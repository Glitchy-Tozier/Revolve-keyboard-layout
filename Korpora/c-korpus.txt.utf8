/*
 base85 codec

 Copyright 2006 Brendan Cully <brendan@kublai.com>

 This software may be used and distributed according to the terms of
 the GNU General Public License, incorporated herein by reference.

 Largely based on git's implementation
*/

#include <Python.h>

#include "util.h"

static const char b85chars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~";
static char b85dec[256];

static void
b85prep(void)
{
	int i;

	memset(b85dec, 0, sizeof(b85dec));
	for (i = 0; i < sizeof(b85chars); i++)
		b85dec[(int)(b85chars[i])] = i + 1;
}

static PyObject *
b85encode(PyObject *self, PyObject *args)
{
	const unsigned char *text;
	PyObject *out;
	char *dst;
	int len, olen, i;
	unsigned int acc, val, ch;
	int pad = 0;

	if (!PyArg_ParseTuple(args, "s#|i", &text, &len, &pad))
		return NULL;

	if (pad)
		olen = ((len + 3) / 4 * 5) - 3;
	else {
		olen = len % 4;
		if (olen)
			olen++;
		olen += len / 4 * 5;
	}
	if (!(out = PyBytes_FromStringAndSize(NULL, olen + 3)))
		return NULL;

	dst = PyBytes_AsString(out);

	while (len) {
		acc = 0;
		for (i = 24; i >= 0; i -= 8) {
			ch = *text++;
			acc |= ch << i;
			if (--len == 0)
				break;
		}
		for (i = 4; i >= 0; i--) {
			val = acc % 85;
			acc /= 85;
			dst[i] = b85chars[val];
		}
		dst += 5;
	}

	if (!pad)
		_PyBytes_Resize(&out, olen);

	return out;
}

static PyObject *
b85decode(PyObject *self, PyObject *args)
{
	PyObject *out;
	const char *text;
	char *dst;
	int len, i, j, olen, c, cap;
	unsigned int acc;

	if (!PyArg_ParseTuple(args, "s#", &text, &len))
		return NULL;

	olen = len / 5 * 4;
	i = len % 5;
	if (i)
		olen += i - 1;
	if (!(out = PyBytes_FromStringAndSize(NULL, olen)))
		return NULL;

	dst = PyBytes_AsString(out);

	i = 0;
	while (i < len)
	{
		acc = 0;
		cap = len - i - 1;
		if (cap > 4)
			cap = 4;
		for (j = 0; j < cap; i++, j++)
		{
			c = b85dec[(int)*text++] - 1;
			if (c < 0)
				return PyErr_Format(
					PyExc_ValueError,
					"Bad base85 character at position %d", i);
			acc = acc * 85 + c;
		}
		if (i++ < len)
		{
			c = b85dec[(int)*text++] - 1;
			if (c < 0)
				return PyErr_Format(
					PyExc_ValueError,
					"Bad base85 character at position %d", i);
			/* overflow detection: 0xffffffff == "|NsC0",
			 * "|NsC" == 0x03030303 */
			if (acc > 0x03030303 || (acc *= 85) > 0xffffffff - c)
				return PyErr_Format(
					PyExc_ValueError,
					"Bad base85 sequence at position %d", i);
			acc += c;
		}

		cap = olen < 4 ? olen : 4;
		olen -= cap;
		for (j = 0; j < 4 - cap; j++)
			acc *= 85;
		if (cap && cap < 4)
			acc += 0xffffff >> (cap - 1) * 8;
		for (j = 0; j < cap; j++)
		{
			acc = (acc << 8) | (acc >> 24);
			*dst++ = acc;
		}
	}

	return out;
}

static char base85_doc[] = "Base85 Data Encoding";

static PyMethodDef methods[] = {
	{"b85encode", b85encode, METH_VARARGS,
	 "Encode text in base85.\n\n"
	 "If the second parameter is true, pad the result to a multiple of "
	 "five characters.\n"},
	{"b85decode", b85decode, METH_VARARGS, "Decode base85 text.\n"},
	{NULL, NULL}
};

#ifdef IS_PY3K
static struct PyModuleDef base85_module = {
	PyModuleDef_HEAD_INIT,
	"base85",
	base85_doc,
	-1,
	methods
};

PyMODINIT_FUNC PyInit_base85(void)
{
	b85prep();

	return PyModule_Create(&base85_module);
}
#else
PyMODINIT_FUNC initbase85(void)
{
	Py_InitModule3("base85", methods, base85_doc);

	b85prep();
}
#endif
/*
 bdiff.c - efficient binary diff extension for Mercurial

 Copyright 2005, 2006 Matt Mackall <mpm@selenic.com>

 This software may be used and distributed according to the terms of
 the GNU General Public License, incorporated herein by reference.

 Based roughly on Python difflib
*/

#include <Python.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if defined __hpux || defined __SUNPRO_C || defined _AIX
#define inline
#endif

#ifdef __linux
#define inline __inline
#endif

#ifdef _WIN32
#ifdef _MSC_VER
#define inline __inline
typedef unsigned long uint32_t;
#else
#include <stdint.h>
#endif
static uint32_t htonl(uint32_t x)
{
	return ((x & 0x000000ffUL) << 24) |
		((x & 0x0000ff00UL) <<  8) |
		((x & 0x00ff0000UL) >>  8) |
		((x & 0xff000000UL) >> 24);
}
#else
#include <sys/types.h>
#if defined __BEOS__ && !defined __HAIKU__
#include <ByteOrder.h>
#else
#include <arpa/inet.h>
#endif
#include <inttypes.h>
#endif

#include "util.h"

struct line {
	int h, len, n, e;
	const char *l;
};

struct pos {
	int pos, len;
};

struct hunk;
struct hunk {
	int a1, a2, b1, b2;
	struct hunk *next;
};

int splitlines(const char *a, int len, struct line **lr)
{
	int h, i;
	const char *p, *b = a;
	const char * const plast = a + len - 1;
	struct line *l;

	/* count the lines */
	i = 1; /* extra line for sentinel */
	for (p = a; p < a + len; p++)
		if (*p == '\n' || p == plast)
			i++;

	*lr = l = (struct line *)malloc(sizeof(struct line) * i);
	if (!l)
		return -1;

	/* build the line array and calculate hashes */
	h = 0;
	for (p = a; p < a + len; p++) {
		/* Leonid Yuriev's hash */
		h = (h * 1664525) + *p + 1013904223;

		if (*p == '\n' || p == plast) {
			l->h = h;
			h = 0;
			l->len = p - b + 1;
			l->l = b;
			l->n = INT_MAX;
			l++;
			b = p + 1;
		}
	}

	/* set up a sentinel */
	l->h = l->len = 0;
	l->l = a + len;
	return i - 1;
}

int inline cmp(struct line *a, struct line *b)
{
	return a->h != b->h || a->len != b->len || memcmp(a->l, b->l, a->len);
}

static int equatelines(struct line *a, int an, struct line *b, int bn)
{
	int i, j, buckets = 1, t, scale;
	struct pos *h = NULL;

	/* build a hash table of the next highest power of 2 */
	while (buckets < bn + 1)
		buckets *= 2;

	/* try to allocate a large hash table to avoid collisions */
	for (scale = 4; scale; scale /= 2) {
		h = (struct pos *)malloc(scale * buckets * sizeof(struct pos));
		if (h)
			break;
	}

	if (!h)
		return 0;

	buckets = buckets * scale - 1;

	/* clear the hash table */
	for (i = 0; i <= buckets; i++) {
		h[i].pos = INT_MAX;
		h[i].len = 0;
	}

	/* add lines to the hash table chains */
	for (i = bn - 1; i >= 0; i--) {
		/* find the equivalence class */
		for (j = b[i].h & buckets; h[j].pos != INT_MAX;
		     j = (j + 1) & buckets)
			if (!cmp(b + i, b + h[j].pos))
				break;

		/* add to the head of the equivalence class */
		b[i].n = h[j].pos;
		b[i].e = j;
		h[j].pos = i;
		h[j].len++; /* keep track of popularity */
	}

	/* compute popularity threshold */
	t = (bn >= 31000) ? bn / 1000 : 1000000 / (bn + 1);

	/* match items in a to their equivalence class in b */
	for (i = 0; i < an; i++) {
		/* find the equivalence class */
		for (j = a[i].h & buckets; h[j].pos != INT_MAX;
		     j = (j + 1) & buckets)
			if (!cmp(a + i, b + h[j].pos))
				break;

		a[i].e = j; /* use equivalence class for quick compare */
		if (h[j].len <= t)
			a[i].n = h[j].pos; /* point to head of match list */
		else
			a[i].n = INT_MAX; /* too popular */
	}

	/* discard hash tables */
	free(h);
	return 1;
}

static int longest_match(struct line *a, struct line *b, struct pos *pos,
			 int a1, int a2, int b1, int b2, int *omi, int *omj)
{
	int mi = a1, mj = b1, mk = 0, mb = 0, i, j, k;

	for (i = a1; i < a2; i++) {
		/* skip things before the current block */
		for (j = a[i].n; j < b1; j = b[j].n)
			;

		/* loop through all lines match a[i] in b */
		for (; j < b2; j = b[j].n) {
			/* does this extend an earlier match? */
			if (i > a1 && j > b1 && pos[j - 1].pos == i - 1)
				k = pos[j - 1].len + 1;
			else
				k = 1;
			pos[j].pos = i;
			pos[j].len = k;

			/* best match so far? */
			if (k > mk) {
				mi = i;
				mj = j;
				mk = k;
			}
		}
	}

	if (mk) {
		mi = mi - mk + 1;
		mj = mj - mk + 1;
	}

	/* expand match to include neighboring popular lines */
	while (mi - mb > a1 && mj - mb > b1 &&
	       a[mi - mb - 1].e == b[mj - mb - 1].e)
		mb++;
	while (mi + mk < a2 && mj + mk < b2 &&
	       a[mi + mk].e == b[mj + mk].e)
		mk++;

	*omi = mi - mb;
	*omj = mj - mb;

	return mk + mb;
}

static struct hunk *recurse(struct line *a, struct line *b, struct pos *pos,
			    int a1, int a2, int b1, int b2, struct hunk *l)
{
	int i, j, k;

	while (1) {
		/* find the longest match in this chunk */
		k = longest_match(a, b, pos, a1, a2, b1, b2, &i, &j);
		if (!k)
			return l;

		/* and recurse on the remaining chunks on either side */
		l = recurse(a, b, pos, a1, i, b1, j, l);
		if (!l)
			return NULL;

		l->next = (struct hunk *)malloc(sizeof(struct hunk));
		if (!l->next)
			return NULL;

		l = l->next;
		l->a1 = i;
		l->a2 = i + k;
		l->b1 = j;
		l->b2 = j + k;
		l->next = NULL;

		/* tail-recursion didn't happen, so do equivalent iteration */
		a1 = i + k;
		b1 = j + k;
	}
}

static int diff(struct line *a, int an, struct line *b, int bn,
		 struct hunk *base)
{
	struct hunk *curr;
	struct pos *pos;
	int t, count = 0;

	/* allocate and fill arrays */
	t = equatelines(a, an, b, bn);
	pos = (struct pos *)calloc(bn ? bn : 1, sizeof(struct pos));

	if (pos && t) {
		/* generate the matching block list */

		curr = recurse(a, b, pos, 0, an, 0, bn, base);
		if (!curr)
			return -1;

		/* sentinel end hunk */
		curr->next = (struct hunk *)malloc(sizeof(struct hunk));
		if (!curr->next)
			return -1;
		curr = curr->next;
		curr->a1 = curr->a2 = an;
		curr->b1 = curr->b2 = bn;
		curr->next = NULL;
	}

	free(pos);

	/* normalize the hunk list, try to push each hunk towards the end */
	for (curr = base->next; curr; curr = curr->next) {
		struct hunk *next = curr->next;
		int shift = 0;

		if (!next)
			break;

		if (curr->a2 == next->a1)
			while (curr->a2 + shift < an && curr->b2 + shift < bn
			       && !cmp(a + curr->a2 + shift,
				       b + curr->b2 + shift))
				shift++;
		else if (curr->b2 == next->b1)
			while (curr->b2 + shift < bn && curr->a2 + shift < an
			       && !cmp(b + curr->b2 + shift,
				       a + curr->a2 + shift))
				shift++;
		if (!shift)
			continue;
		curr->b2 += shift;
		next->b1 += shift;
		curr->a2 += shift;
		next->a1 += shift;
	}

	for (curr = base->next; curr; curr = curr->next)
		count++;
	return count;
}

static void freehunks(struct hunk *l)
{
	struct hunk *n;
	for (; l; l = n) {
		n = l->next;
		free(l);
	}
}

static PyObject *blocks(PyObject *self, PyObject *args)
{
	PyObject *sa, *sb, *rl = NULL, *m;
	struct line *a, *b;
	struct hunk l, *h;
	int an, bn, count, pos = 0;

	if (!PyArg_ParseTuple(args, "SS:bdiff", &sa, &sb))
		return NULL;

	an = splitlines(PyBytes_AsString(sa), PyBytes_Size(sa), &a);
	bn = splitlines(PyBytes_AsString(sb), PyBytes_Size(sb), &b);

	if (!a || !b)
		goto nomem;

	l.next = NULL;
	count = diff(a, an, b, bn, &l);
	if (count < 0)
		goto nomem;

	rl = PyList_New(count);
	if (!rl)
		goto nomem;

	for (h = l.next; h; h = h->next) {
		m = Py_BuildValue("iiii", h->a1, h->a2, h->b1, h->b2);
		PyList_SetItem(rl, pos, m);
		pos++;
	}

nomem:
	free(a);
	free(b);
	freehunks(l.next);
	return rl ? rl : PyErr_NoMemory();
}

static PyObject *bdiff(PyObject *self, PyObject *args)
{
	char *sa, *sb;
	PyObject *result = NULL;
	struct line *al, *bl;
	struct hunk l, *h;
	char encode[12], *rb;
	int an, bn, len = 0, la, lb, count;

	if (!PyArg_ParseTuple(args, "s#s#:bdiff", &sa, &la, &sb, &lb))
		return NULL;

	an = splitlines(sa, la, &al);
	bn = splitlines(sb, lb, &bl);
	if (!al || !bl)
		goto nomem;

	l.next = NULL;
	count = diff(al, an, bl, bn, &l);
	if (count < 0)
		goto nomem;

	/* calculate length of output */
	la = lb = 0;
	for (h = l.next; h; h = h->next) {
		if (h->a1 != la || h->b1 != lb)
			len += 12 + bl[h->b1].l - bl[lb].l;
		la = h->a2;
		lb = h->b2;
	}

	result = PyBytes_FromStringAndSize(NULL, len);

	if (!result)
		goto nomem;

	/* build binary patch */
	rb = PyBytes_AsString(result);
	la = lb = 0;

	for (h = l.next; h; h = h->next) {
		if (h->a1 != la || h->b1 != lb) {
			len = bl[h->b1].l - bl[lb].l;
			*(uint32_t *)(encode)     = htonl(al[la].l - al->l);
			*(uint32_t *)(encode + 4) = htonl(al[h->a1].l - al->l);
			*(uint32_t *)(encode + 8) = htonl(len);
			memcpy(rb, encode, 12);
			memcpy(rb + 12, bl[lb].l, len);
			rb += 12 + len;
		}
		la = h->a2;
		lb = h->b2;
	}

nomem:
	free(al);
	free(bl);
	freehunks(l.next);
	return result ? result : PyErr_NoMemory();
}

static char mdiff_doc[] = "Efficient binary diff.";

static PyMethodDef methods[] = {
	{"bdiff", bdiff, METH_VARARGS, "calculate a binary diff\n"},
	{"blocks", blocks, METH_VARARGS, "find a list of matching lines\n"},
	{NULL, NULL}
};

#ifdef IS_PY3K
static struct PyModuleDef bdiff_module = {
	PyModuleDef_HEAD_INIT,
	"bdiff",
	mdiff_doc,
	-1,
	methods
};

PyMODINIT_FUNC PyInit_bdiff(void)
{
	return PyModule_Create(&bdiff_module);
}
#else
PyMODINIT_FUNC initbdiff(void)
{
	Py_InitModule3("bdiff", methods, mdiff_doc);
}
#endif

/*
 * diffhelpers.c - helper routines for mpatch
 *
 * Copyright 2007 Chris Mason <chris.mason@oracle.com>
 *
 * This software may be used and distributed according to the terms
 * of the GNU General Public License v2, incorporated herein by reference.
 */

#include <Python.h>
#include <stdlib.h>
#include <string.h>

#include "util.h"

static char diffhelpers_doc[] = "Efficient diff parsing";
static PyObject *diffhelpers_Error;


/* fixup the last lines of a and b when the patch has no newline at eof */
static void _fix_newline(PyObject *hunk, PyObject *a, PyObject *b)
{
	int hunksz = PyList_Size(hunk);
	PyObject *s = PyList_GET_ITEM(hunk, hunksz-1);
	char *l = PyBytes_AsString(s);
	int alen = PyList_Size(a);
	int blen = PyList_Size(b);
	char c = l[0];
	PyObject *hline;
	int sz = PyBytes_GET_SIZE(s);

	if (sz > 1 && l[sz-2] == '\r')
		/* tolerate CRLF in last line */
		sz -= 1;

	hline = PyBytes_FromStringAndSize(l, sz-1);

	if (c == ' ' || c == '+') {
		PyObject *rline = PyBytes_FromStringAndSize(l + 1, sz - 2);
		PyList_SetItem(b, blen-1, rline);
	}
	if (c == ' ' || c == '-') {
		Py_INCREF(hline);
		PyList_SetItem(a, alen-1, hline);
	}
	PyList_SetItem(hunk, hunksz-1, hline);
}

/* python callable form of _fix_newline */
static PyObject *
fix_newline(PyObject *self, PyObject *args)
{
	PyObject *hunk, *a, *b;
	if (!PyArg_ParseTuple(args, "OOO", &hunk, &a, &b))
		return NULL;
	_fix_newline(hunk, a, b);
	return Py_BuildValue("l", 0);
}

/*
 * read lines from fp into the hunk.  The hunk is parsed into two arrays
 * a and b.  a gets the old state of the text, b gets the new state
 * The control char from the hunk is saved when inserting into a, but not b
 * (for performance while deleting files)
 */
static PyObject *
addlines(PyObject *self, PyObject *args)
{

	PyObject *fp, *hunk, *a, *b, *x;
	int i;
	int lena, lenb;
	int num;
	int todoa, todob;
	char *s, c;
	PyObject *l;
	if (!PyArg_ParseTuple(args, "OOiiOO", &fp, &hunk, &lena, &lenb, &a, &b))
		return NULL;

	while (1) {
		todoa = lena - PyList_Size(a);
		todob = lenb - PyList_Size(b);
		num = todoa > todob ? todoa : todob;
		if (num == 0)
		    break;
		for (i = 0; i < num; i++) {
			x = PyFile_GetLine(fp, 0);
			s = PyBytes_AsString(x);
			c = *s;
			if (strcmp(s, "\\ No newline at end of file\n") == 0) {
				_fix_newline(hunk, a, b);
				continue;
			}
			if (c == '\n') {
				/* Some patches may be missing the control char
				 * on empty lines. Supply a leading space. */
				Py_DECREF(x);
				x = PyBytes_FromString(" \n");
			}
			PyList_Append(hunk, x);
			if (c == '+') {
				l = PyBytes_FromString(s + 1);
				PyList_Append(b, l);
				Py_DECREF(l);
			} else if (c == '-') {
				PyList_Append(a, x);
			} else {
				l = PyBytes_FromString(s + 1);
				PyList_Append(b, l);
				Py_DECREF(l);
				PyList_Append(a, x);
			}
			Py_DECREF(x);
		}
	}
	return Py_BuildValue("l", 0);
}

/*
 * compare the lines in a with the lines in b.  a is assumed to have
 * a control char at the start of each line, this char is ignored in the
 * compare
 */
static PyObject *
testhunk(PyObject *self, PyObject *args)
{

	PyObject *a, *b;
	long bstart;
	int alen, blen;
	int i;
	char *sa, *sb;

	if (!PyArg_ParseTuple(args, "OOl", &a, &b, &bstart))
		return NULL;
	alen = PyList_Size(a);
	blen = PyList_Size(b);
	if (alen > blen - bstart) {
		return Py_BuildValue("l", -1);
	}
	for (i = 0; i < alen; i++) {
		sa = PyBytes_AsString(PyList_GET_ITEM(a, i));
		sb = PyBytes_AsString(PyList_GET_ITEM(b, i + bstart));
		if (strcmp(sa + 1, sb) != 0)
			return Py_BuildValue("l", -1);
	}
	return Py_BuildValue("l", 0);
}

static PyMethodDef methods[] = {
	{"addlines", addlines, METH_VARARGS, "add lines to a hunk\n"},
	{"fix_newline", fix_newline, METH_VARARGS, "fixup newline counters\n"},
	{"testhunk", testhunk, METH_VARARGS, "test lines in a hunk\n"},
	{NULL, NULL}
};

#ifdef IS_PY3K
static struct PyModuleDef diffhelpers_module = {
	PyModuleDef_HEAD_INIT,
	"diffhelpers",
	diffhelpers_doc,
	-1,
	methods
};

PyMODINIT_FUNC PyInit_diffhelpers(void)
{
	PyObject *m;

	m = PyModule_Create(&diffhelpers_module);
	if (m == NULL)
		return NULL;

	diffhelpers_Error = PyErr_NewException("diffhelpers.diffhelpersError",
											NULL, NULL);
	Py_INCREF(diffhelpers_Error);
	PyModule_AddObject(m, "diffhelpersError", diffhelpers_Error);

	return m;
}
#else
PyMODINIT_FUNC
initdiffhelpers(void)
{
	Py_InitModule3("diffhelpers", methods, diffhelpers_doc);
	diffhelpers_Error = PyErr_NewException("diffhelpers.diffhelpersError",
	                                        NULL, NULL);
}
#endif

/*
 mpatch.c - efficient binary patching for Mercurial

 This implements a patch algorithm that's O(m + nlog n) where m is the
 size of the output and n is the number of patches.

 Given a list of binary patches, it unpacks each into a hunk list,
 then combines the hunk lists with a treewise recursion to form a
 single hunk list. This hunk list is then applied to the original
 text.

 The text (or binary) fragments are copied directly from their source
 Python objects into a preallocated output string to avoid the
 allocation of intermediate Python objects. Working memory is about 2x
 the total number of hunks.

 Copyright 2005, 2006 Matt Mackall <mpm@selenic.com>

 This software may be used and distributed according to the terms
 of the GNU General Public License, incorporated herein by reference.
*/

#include <Python.h>
#include <stdlib.h>
#include <string.h>

#include "util.h"

/* Definitions to get compatibility with python 2.4 and earlier which
   does not have Py_ssize_t. See also PEP 353.
   Note: msvc (8 or earlier) does not have ssize_t, so we use Py_ssize_t.
*/
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
#define PY_SSIZE_T_MAX INT_MAX
#define PY_SSIZE_T_MIN INT_MIN
#endif

#ifdef _WIN32
#ifdef _MSC_VER
/* msvc 6.0 has problems */
#define inline __inline
typedef unsigned long uint32_t;
#else
#include <stdint.h>
#endif
static uint32_t ntohl(uint32_t x)
{
	return ((x & 0x000000ffUL) << 24) |
		((x & 0x0000ff00UL) <<  8) |
		((x & 0x00ff0000UL) >>  8) |
		((x & 0xff000000UL) >> 24);
}
#else
/* not windows */
#include <sys/types.h>
#if defined __BEOS__ && !defined __HAIKU__
#include <ByteOrder.h>
#else
#include <arpa/inet.h>
#endif
#include <inttypes.h>
#endif

static char mpatch_doc[] = "Efficient binary patching.";
static PyObject *mpatch_Error;

struct frag {
	int start, end, len;
	const char *data;
};

struct flist {
	struct frag *base, *head, *tail;
};

static struct flist *lalloc(int size)
{
	struct flist *a = NULL;

	if (size < 1)
		size = 1;

	a = (struct flist *)malloc(sizeof(struct flist));
	if (a) {
		a->base = (struct frag *)malloc(sizeof(struct frag) * size);
		if (a->base) {
			a->head = a->tail = a->base;
			return a;
		}
		free(a);
		a = NULL;
	}
	if (!PyErr_Occurred())
		PyErr_NoMemory();
	return NULL;
}

static void lfree(struct flist *a)
{
	if (a) {
		free(a->base);
		free(a);
	}
}

static int lsize(struct flist *a)
{
	return a->tail - a->head;
}

/* move hunks in source that are less cut to dest, compensating
   for changes in offset. the last hunk may be split if necessary.
*/
static int gather(struct flist *dest, struct flist *src, int cut, int offset)
{
	struct frag *d = dest->tail, *s = src->head;
	int postend, c, l;

	while (s != src->tail) {
		if (s->start + offset >= cut)
			break; /* we've gone far enough */

		postend = offset + s->start + s->len;
		if (postend <= cut) {
			/* save this hunk */
			offset += s->start + s->len - s->end;
			*d++ = *s++;
		}
		else {
			/* break up this hunk */
			c = cut - offset;
			if (s->end < c)
				c = s->end;
			l = cut - offset - s->start;
			if (s->len < l)
				l = s->len;

			offset += s->start + l - c;

			d->start = s->start;
			d->end = c;
			d->len = l;
			d->data = s->data;
			d++;
			s->start = c;
			s->len = s->len - l;
			s->data = s->data + l;

			break;
		}
	}

	dest->tail = d;
	src->head = s;
	return offset;
}

/* like gather, but with no output list */
static int discard(struct flist *src, int cut, int offset)
{
	struct frag *s = src->head;
	int postend, c, l;

	while (s != src->tail) {
		if (s->start + offset >= cut)
			break;

		postend = offset + s->start + s->len;
		if (postend <= cut) {
			offset += s->start + s->len - s->end;
			s++;
		}
		else {
			c = cut - offset;
			if (s->end < c)
				c = s->end;
			l = cut - offset - s->start;
			if (s->len < l)
				l = s->len;

			offset += s->start + l - c;
			s->start = c;
			s->len = s->len - l;
			s->data = s->data + l;

			break;
		}
	}

	src->head = s;
	return offset;
}

/* combine hunk lists a and b, while adjusting b for offset changes in a/
   this deletes a and b and returns the resultant list. */
static struct flist *combine(struct flist *a, struct flist *b)
{
	struct flist *c = NULL;
	struct frag *bh, *ct;
	int offset = 0, post;

	if (a && b)
		c = lalloc((lsize(a) + lsize(b)) * 2);

	if (c) {

		for (bh = b->head; bh != b->tail; bh++) {
			/* save old hunks */
			offset = gather(c, a, bh->start, offset);

			/* discard replaced hunks */
			post = discard(a, bh->end, offset);

			/* insert new hunk */
			ct = c->tail;
			ct->start = bh->start - offset;
			ct->end = bh->end - post;
			ct->len = bh->len;
			ct->data = bh->data;
			c->tail++;
			offset = post;
		}

		/* hold on to tail from a */
		memcpy(c->tail, a->head, sizeof(struct frag) * lsize(a));
		c->tail += lsize(a);
	}

	lfree(a);
	lfree(b);
	return c;
}

/* decode a binary patch into a hunk list */
static struct flist *decode(const char *bin, int len)
{
	struct flist *l;
	struct frag *lt;
	const char *data = bin + 12, *end = bin + len;
	char decode[12]; /* for dealing with alignment issues */

	/* assume worst case size, we won't have many of these lists */
	l = lalloc(len / 12);
	if (!l)
		return NULL;

	lt = l->tail;

	while (data <= end) {
		memcpy(decode, bin, 12);
		lt->start = ntohl(*(uint32_t *)decode);
		lt->end = ntohl(*(uint32_t *)(decode + 4));
		lt->len = ntohl(*(uint32_t *)(decode + 8));
		if (lt->start > lt->end)
			break; /* sanity check */
		bin = data + lt->len;
		if (bin < data)
			break; /* big data + big (bogus) len can wrap around */
		lt->data = data;
		data = bin + 12;
		lt++;
	}

	if (bin != end) {
		if (!PyErr_Occurred())
			PyErr_SetString(mpatch_Error, "patch cannot be decoded");
		lfree(l);
		return NULL;
	}

	l->tail = lt;
	return l;
}

/* calculate the size of resultant text */
static int calcsize(int len, struct flist *l)
{
	int outlen = 0, last = 0;
	struct frag *f = l->head;

	while (f != l->tail) {
		if (f->start < last || f->end > len) {
			if (!PyErr_Occurred())
				PyErr_SetString(mpatch_Error,
				                "invalid patch");
			return -1;
		}
		outlen += f->start - last;
		last = f->end;
		outlen += f->len;
		f++;
	}

	outlen += len - last;
	return outlen;
}

static int apply(char *buf, const char *orig, int len, struct flist *l)
{
	struct frag *f = l->head;
	int last = 0;
	char *p = buf;

	while (f != l->tail) {
		if (f->start < last || f->end > len) {
			if (!PyErr_Occurred())
				PyErr_SetString(mpatch_Error,
				                "invalid patch");
			return 0;
		}
		memcpy(p, orig + last, f->start - last);
		p += f->start - last;
		memcpy(p, f->data, f->len);
		last = f->end;
		p += f->len;
		f++;
	}
	memcpy(p, orig + last, len - last);
	return 1;
}

/* recursively generate a patch of all bins between start and end */
static struct flist *fold(PyObject *bins, int start, int end)
{
	int len;
	Py_ssize_t blen;
	const char *buffer;

	if (start + 1 == end) {
		/* trivial case, output a decoded list */
		PyObject *tmp = PyList_GetItem(bins, start);
		if (!tmp)
			return NULL;
		if (PyObject_AsCharBuffer(tmp, &buffer, &blen))
			return NULL;
		return decode(buffer, blen);
	}

	/* divide and conquer, memory management is elsewhere */
	len = (end - start) / 2;
	return combine(fold(bins, start, start + len),
		       fold(bins, start + len, end));
}

static PyObject *
patches(PyObject *self, PyObject *args)
{
	PyObject *text, *bins, *result;
	struct flist *patch;
	const char *in;
	char *out;
	int len, outlen;
	Py_ssize_t inlen;

	if (!PyArg_ParseTuple(args, "OO:mpatch", &text, &bins))
		return NULL;

	len = PyList_Size(bins);
	if (!len) {
		/* nothing to do */
		Py_INCREF(text);
		return text;
	}

	if (PyObject_AsCharBuffer(text, &in, &inlen))
		return NULL;

	patch = fold(bins, 0, len);
	if (!patch)
		return NULL;

	outlen = calcsize(inlen, patch);
	if (outlen < 0) {
		result = NULL;
		goto cleanup;
	}
	result = PyBytes_FromStringAndSize(NULL, outlen);
	if (!result) {
		result = NULL;
		goto cleanup;
	}
	out = PyBytes_AsString(result);
	if (!apply(out, in, inlen, patch)) {
		Py_DECREF(result);
		result = NULL;
	}
cleanup:
	lfree(patch);
	return result;
}

/* calculate size of a patched file directly */
static PyObject *
patchedsize(PyObject *self, PyObject *args)
{
	long orig, start, end, len, outlen = 0, last = 0;
	int patchlen;
	char *bin, *binend, *data;
	char decode[12]; /* for dealing with alignment issues */

	if (!PyArg_ParseTuple(args, "ls#", &orig, &bin, &patchlen))
		return NULL;

	binend = bin + patchlen;
	data = bin + 12;

	while (data <= binend) {
		memcpy(decode, bin, 12);
		start = ntohl(*(uint32_t *)decode);
		end = ntohl(*(uint32_t *)(decode + 4));
		len = ntohl(*(uint32_t *)(decode + 8));
		if (start > end)
			break; /* sanity check */
		bin = data + len;
		if (bin < data)
			break; /* big data + big (bogus) len can wrap around */
		data = bin + 12;
		outlen += start - last;
		last = end;
		outlen += len;
	}

	if (bin != binend) {
		if (!PyErr_Occurred())
			PyErr_SetString(mpatch_Error, "patch cannot be decoded");
		return NULL;
	}

	outlen += orig - last;
	return Py_BuildValue("l", outlen);
}

static PyMethodDef methods[] = {
	{"patches", patches, METH_VARARGS, "apply a series of patches\n"},
	{"patchedsize", patchedsize, METH_VARARGS, "calculed patched size\n"},
	{NULL, NULL}
};

#ifdef IS_PY3K
static struct PyModuleDef mpatch_module = {
	PyModuleDef_HEAD_INIT,
	"mpatch",
	mpatch_doc,
	-1,
	methods
};

PyMODINIT_FUNC PyInit_mpatch(void)
{
	PyObject *m;

	m = PyModule_Create(&mpatch_module);
	if (m == NULL)
		return NULL;

	mpatch_Error = PyErr_NewException("mpatch.mpatchError", NULL, NULL);
	Py_INCREF(mpatch_Error);
	PyModule_AddObject(m, "mpatchError", mpatch_Error);

	return m;
}
#else
PyMODINIT_FUNC
initmpatch(void)
{
	Py_InitModule3("mpatch", methods, mpatch_doc);
	mpatch_Error = PyErr_NewException("mpatch.mpatchError", NULL, NULL);
}
#endif
/*
 osutil.c - native operating system services

 Copyright 2007 Matt Mackall and others

 This software may be used and distributed according to the terms of
 the GNU General Public License, incorporated herein by reference.
*/

#define _ATFILE_SOURCE
#include <Python.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#include <io.h>
#else
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#endif

#include "util.h"

/* some platforms lack the PATH_MAX definition (eg. GNU/Hurd) */
#ifndef PATH_MAX
#define PATH_MAX 4096
#endif

#ifdef _WIN32
/*
stat struct compatible with hg expectations
Mercurial only uses st_mode, st_size and st_mtime
the rest is kept to minimize changes between implementations
*/
struct hg_stat {
	int st_dev;
	int st_mode;
	int st_nlink;
	__int64 st_size;
	int st_mtime;
	int st_ctime;
};
struct listdir_stat {
	PyObject_HEAD
	struct hg_stat st;
};
#else
struct listdir_stat {
	PyObject_HEAD
	struct stat st;
};
#endif

#define listdir_slot(name) \
	static PyObject *listdir_stat_##name(PyObject *self, void *x) \
	{ \
		return PyInt_FromLong(((struct listdir_stat *)self)->st.name); \
	}

listdir_slot(st_dev)
listdir_slot(st_mode)
listdir_slot(st_nlink)
#ifdef _WIN32
static PyObject *listdir_stat_st_size(PyObject *self, void *x)
{
	return PyLong_FromLongLong(
		(PY_LONG_LONG)((struct listdir_stat *)self)->st.st_size);
}
#else
listdir_slot(st_size)
#endif
listdir_slot(st_mtime)
listdir_slot(st_ctime)

static struct PyGetSetDef listdir_stat_getsets[] = {
	{"st_dev", listdir_stat_st_dev, 0, 0, 0},
	{"st_mode", listdir_stat_st_mode, 0, 0, 0},
	{"st_nlink", listdir_stat_st_nlink, 0, 0, 0},
	{"st_size", listdir_stat_st_size, 0, 0, 0},
	{"st_mtime", listdir_stat_st_mtime, 0, 0, 0},
	{"st_ctime", listdir_stat_st_ctime, 0, 0, 0},
	{0, 0, 0, 0, 0}
};

static PyObject *listdir_stat_new(PyTypeObject *t, PyObject *a, PyObject *k)
{
	return t->tp_alloc(t, 0);
}

static void listdir_stat_dealloc(PyObject *o)
{
	o->ob_type->tp_free(o);
}

static PyTypeObject listdir_stat_type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"osutil.stat",             /*tp_name*/
	sizeof(struct listdir_stat), /*tp_basicsize*/
	0,                         /*tp_itemsize*/
	(destructor)listdir_stat_dealloc, /*tp_dealloc*/
	0,                         /*tp_print*/
	0,                         /*tp_getattr*/
	0,                         /*tp_setattr*/
	0,                         /*tp_compare*/
	0,                         /*tp_repr*/
	0,                         /*tp_as_number*/
	0,                         /*tp_as_sequence*/
	0,                         /*tp_as_mapping*/
	0,                         /*tp_hash */
	0,                         /*tp_call*/
	0,                         /*tp_str*/
	0,                         /*tp_getattro*/
	0,                         /*tp_setattro*/
	0,                         /*tp_as_buffer*/
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
	"stat objects",            /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,                         /* tp_methods */
	0,                         /* tp_members */
	listdir_stat_getsets,      /* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,                         /* tp_init */
	0,                         /* tp_alloc */
	listdir_stat_new,          /* tp_new */
};

#ifdef _WIN32

static int to_python_time(const FILETIME *tm)
{
	/* number of seconds between epoch and January 1 1601 */
	const __int64 a0 = (__int64)134774L * (__int64)24L * (__int64)3600L;
	/* conversion factor from 100ns to 1s */
	const __int64 a1 = 10000000;
	/* explicit (int) cast to suspend compiler warnings */
	return (int)((((__int64)tm->dwHighDateTime << 32)
			+ tm->dwLowDateTime) / a1 - a0);
}

static PyObject *make_item(const WIN32_FIND_DATAA *fd, int wantstat)
{
	PyObject *py_st;
	struct hg_stat *stp;

	int kind = (fd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		? _S_IFDIR : _S_IFREG;

	if (!wantstat)
		return Py_BuildValue("si", fd->cFileName, kind);

	py_st = PyObject_CallObject((PyObject *)&listdir_stat_type, NULL);
	if (!py_st)
		return NULL;

	stp = &((struct listdir_stat *)py_st)->st;
	/*
	use kind as st_mode
	rwx bits on Win32 are meaningless
	and Hg does not use them anyway
	*/
	stp->st_mode  = kind;
	stp->st_mtime = to_python_time(&fd->ftLastWriteTime);
	stp->st_ctime = to_python_time(&fd->ftCreationTime);
	if (kind == _S_IFREG)
		stp->st_size = ((__int64)fd->nFileSizeHigh << 32)
				+ fd->nFileSizeLow;
	return Py_BuildValue("siN", fd->cFileName,
		kind, py_st);
}

static PyObject *_listdir(char *path, int plen, int wantstat, char *skip)
{
	PyObject *rval = NULL; /* initialize - return value */
	PyObject *list;
	HANDLE fh;
	WIN32_FIND_DATAA fd;
	char *pattern;

	/* build the path + \* pattern string */
	pattern = malloc(plen + 3); /* path + \* + \0 */
	if (!pattern) {
		PyErr_NoMemory();
		goto error_nomem;
	}
	strcpy(pattern, path);

	if (plen > 0) {
		char c = path[plen-1];
		if (c != ':' && c != '/' && c != '\\')
			pattern[plen++] = '\\';
	}
	strcpy(pattern + plen, "*");

	fh = FindFirstFileA(pattern, &fd);
	if (fh == INVALID_HANDLE_VALUE) {
		PyErr_SetFromWindowsErrWithFilename(GetLastError(), path);
		goto error_file;
	}

	list = PyList_New(0);
	if (!list)
		goto error_list;

	do {
		PyObject *item;

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			if (!strcmp(fd.cFileName, ".")
			|| !strcmp(fd.cFileName, ".."))
				continue;

			if (skip && !strcmp(fd.cFileName, skip)) {
				rval = PyList_New(0);
				goto error;
			}
		}

		item = make_item(&fd, wantstat);
		if (!item)
			goto error;

		if (PyList_Append(list, item)) {
			Py_XDECREF(item);
			goto error;
		}

		Py_XDECREF(item);
	} while (FindNextFileA(fh, &fd));

	if (GetLastError() != ERROR_NO_MORE_FILES) {
		PyErr_SetFromWindowsErrWithFilename(GetLastError(), path);
		goto error;
	}

	rval = list;
	Py_XINCREF(rval);
error:
	Py_XDECREF(list);
error_list:
	FindClose(fh);
error_file:
	free(pattern);
error_nomem:
	return rval;
}

#else

int entkind(struct dirent *ent)
{
#ifdef DT_REG
	switch (ent->d_type) {
	case DT_REG: return S_IFREG;
	case DT_DIR: return S_IFDIR;
	case DT_LNK: return S_IFLNK;
	case DT_BLK: return S_IFBLK;
	case DT_CHR: return S_IFCHR;
	case DT_FIFO: return S_IFIFO;
	case DT_SOCK: return S_IFSOCK;
	}
#endif
	return -1;
}

static PyObject *_listdir(char *path, int pathlen, int keepstat, char *skip)
{
	PyObject *list, *elem, *stat, *ret = NULL;
	char fullpath[PATH_MAX + 10];
	int kind, err;
	struct stat st;
	struct dirent *ent;
	DIR *dir;
#ifdef AT_SYMLINK_NOFOLLOW
	int dfd = -1;
#endif

	if (pathlen >= PATH_MAX) {
		PyErr_SetString(PyExc_ValueError, "path too long");
		goto error_value;
	}
	strncpy(fullpath, path, PATH_MAX);
	fullpath[pathlen] = '/';

#ifdef AT_SYMLINK_NOFOLLOW
	dfd = open(path, O_RDONLY);
	if (dfd == -1) {
		PyErr_SetFromErrnoWithFilename(PyExc_OSError, path);
		goto error_value;
	}
	dir = fdopendir(dfd);
#else
	dir = opendir(path);
#endif
	if (!dir) {
		PyErr_SetFromErrnoWithFilename(PyExc_OSError, path);
		goto error_dir;
 	}

	list = PyList_New(0);
	if (!list)
		goto error_list;

	while ((ent = readdir(dir))) {
		if (!strcmp(ent->d_name, ".") || !strcmp(ent->d_name, ".."))
			continue;

		kind = entkind(ent);
		if (kind == -1 || keepstat) {
#ifdef AT_SYMLINK_NOFOLLOW
			err = fstatat(dfd, ent->d_name, &st,
				      AT_SYMLINK_NOFOLLOW);
#else
			strncpy(fullpath + pathlen + 1, ent->d_name,
				PATH_MAX - pathlen);
			fullpath[PATH_MAX] = 0;
			err = lstat(fullpath, &st);
#endif
			if (err == -1) {
				strncpy(fullpath + pathlen + 1, ent->d_name,
					PATH_MAX - pathlen);
				fullpath[PATH_MAX] = 0;
				PyErr_SetFromErrnoWithFilename(PyExc_OSError,
							       fullpath);
				goto error;
			}
			kind = st.st_mode & S_IFMT;
		}

		/* quit early? */
		if (skip && kind == S_IFDIR && !strcmp(ent->d_name, skip)) {
			ret = PyList_New(0);
			goto error;
		}

		if (keepstat) {
			stat = PyObject_CallObject((PyObject *)&listdir_stat_type, NULL);
			if (!stat)
				goto error;
			memcpy(&((struct listdir_stat *)stat)->st, &st, sizeof(st));
			elem = Py_BuildValue("siN", ent->d_name, kind, stat);
		} else
			elem = Py_BuildValue("si", ent->d_name, kind);
		if (!elem)
			goto error;

		PyList_Append(list, elem);
		Py_DECREF(elem);
	}

	ret = list;
	Py_INCREF(ret);

error:
	Py_DECREF(list);
error_list:
	closedir(dir);
error_dir:
#ifdef AT_SYMLINK_NOFOLLOW
	close(dfd);
#endif
error_value:
	return ret;
}

#endif /* ndef _WIN32 */

static PyObject *listdir(PyObject *self, PyObject *args, PyObject *kwargs)
{
	PyObject *statobj = NULL; /* initialize - optional arg */
	PyObject *skipobj = NULL; /* initialize - optional arg */
	char *path, *skip = NULL;
	int wantstat, plen;

	static char *kwlist[] = {"path", "stat", "skip", NULL};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#|OO:listdir",
			kwlist, &path, &plen, &statobj, &skipobj))
		return NULL;

	wantstat = statobj && PyObject_IsTrue(statobj);

	if (skipobj && skipobj != Py_None) {
		skip = PyBytes_AsString(skipobj);
		if (!skip)
			return NULL;
	}

	return _listdir(path, plen, wantstat, skip);
}

#ifdef _WIN32
static PyObject *posixfile(PyObject *self, PyObject *args, PyObject *kwds)
{
	static char *kwlist[] = {"name", "mode", "buffering", NULL};
	PyObject *file_obj = NULL;
	char *name = NULL;
	char *mode = "rb";
	DWORD access = 0;
	DWORD creation;
	HANDLE handle;
	int fd, flags = 0;
	int bufsize = -1;
	char m0, m1, m2;
	char fpmode[4];
	int fppos = 0;
	int plus;
	FILE *fp;

	if (!PyArg_ParseTupleAndKeywords(args, kwds, "et|si:posixfile", kwlist,
					 Py_FileSystemDefaultEncoding,
					 &name, &mode, &bufsize))
		return NULL;

	m0 = mode[0];
	m1 = m0 ? mode[1] : '\0';
	m2 = m1 ? mode[2] : '\0';
	plus = m1 == '+' || m2 == '+';

	fpmode[fppos++] = m0;
	if (m1 == 'b' || m2 == 'b') {
		flags = _O_BINARY;
		fpmode[fppos++] = 'b';
	}
	else
		flags = _O_TEXT;
	if (m0 == 'r' && !plus) {
		flags |= _O_RDONLY;
		access = GENERIC_READ;
	} else {
		/*
		work around http://support.microsoft.com/kb/899149 and
		set _O_RDWR for 'w' and 'a', even if mode has no '+'
		*/
		flags |= _O_RDWR;
		access = GENERIC_READ | GENERIC_WRITE;
		fpmode[fppos++] = '+';
	}
	fpmode[fppos++] = '\0';

	switch (m0) {
	case 'r':
		creation = OPEN_EXISTING;
		break;
	case 'w':
		creation = CREATE_ALWAYS;
		break;
	case 'a':
		creation = OPEN_ALWAYS;
		flags |= _O_APPEND;
		break;
	default:
		PyErr_Format(PyExc_ValueError,
			     "mode string must begin with one of 'r', 'w', "
			     "or 'a', not '%c'", m0);
		goto bail;
	}

	handle = CreateFile(name, access,
			    FILE_SHARE_READ | FILE_SHARE_WRITE |
			    FILE_SHARE_DELETE,
			    NULL,
			    creation,
			    FILE_ATTRIBUTE_NORMAL,
			    0);

	if (handle == INVALID_HANDLE_VALUE) {
		PyErr_SetFromWindowsErrWithFilename(GetLastError(), name);
		goto bail;
	}

	fd = _open_osfhandle((intptr_t)handle, flags);

	if (fd == -1) {
		CloseHandle(handle);
		PyErr_SetFromErrnoWithFilename(PyExc_IOError, name);
		goto bail;
	}
#ifndef IS_PY3K
	fp = _fdopen(fd, fpmode);
	if (fp == NULL) {
		_close(fd);
		PyErr_SetFromErrnoWithFilename(PyExc_IOError, name);
		goto bail;
	}

	file_obj = PyFile_FromFile(fp, name, mode, fclose);
	if (file_obj == NULL) {
		fclose(fp);
		goto bail;
	}

	PyFile_SetBufSize(file_obj, bufsize);
#else
	file_obj = PyFile_FromFd(fd, name, mode, bufsize, NULL, NULL, NULL, 1);
	if (file_obj == NULL)
		goto bail;
#endif
bail:
	PyMem_Free(name);
	return file_obj;
}
#endif

static char osutil_doc[] = "Native operating system services.";

static PyMethodDef methods[] = {
	{"listdir", (PyCFunction)listdir, METH_VARARGS | METH_KEYWORDS,
	 "list a directory\n"},
#ifdef _WIN32
	{"posixfile", (PyCFunction)posixfile, METH_VARARGS | METH_KEYWORDS,
	 "Open a file with POSIX-like semantics.\n"
"On error, this function may raise either a WindowsError or an IOError."},
#endif
	{NULL, NULL}
};

#ifdef IS_PY3K
static struct PyModuleDef osutil_module = {
	PyModuleDef_HEAD_INIT,
	"osutil",
	osutil_doc,
	-1,
	methods
};

PyMODINIT_FUNC PyInit_osutil(void)
{
	if (PyType_Ready(&listdir_stat_type) < 0)
		return NULL;

	return PyModule_Create(&osutil_module);
}
#else
PyMODINIT_FUNC initosutil(void)
{
	if (PyType_Ready(&listdir_stat_type) == -1)
		return;

	Py_InitModule3("osutil", methods, osutil_doc);
}
#endif
/*
 parsers.c - efficient content parsing

 Copyright 2008 Matt Mackall <mpm@selenic.com> and others

 This software may be used and distributed according to the terms of
 the GNU General Public License, incorporated herein by reference.
*/

#include <Python.h>
#include <ctype.h>
#include <string.h>

#include "util.h"

static int hexdigit(char c)
{
	if (c >= '0' && c <= '9')
		return c - '0';
	if (c >= 'a' && c <= 'f')
		return c - 'a' + 10;
	if (c >= 'A' && c <= 'F')
		return c - 'A' + 10;

	PyErr_SetString(PyExc_ValueError, "input contains non-hex character");
	return 0;
}

/*
 * Turn a hex-encoded string into binary.
 */
static PyObject *unhexlify(const char *str, int len)
{
	PyObject *ret;
	const char *c;
	char *d;

	ret = PyBytes_FromStringAndSize(NULL, len / 2);

	if (!ret)
		return NULL;

	d = PyBytes_AsString(ret);

	for (c = str; c < str + len;) {
		int hi = hexdigit(*c++);
		int lo = hexdigit(*c++);
		*d++ = (hi << 4) | lo;
	}

	return ret;
}

/*
 * This code assumes that a manifest is stitched together with newline
 * ('\n') characters.
 */
static PyObject *parse_manifest(PyObject *self, PyObject *args)
{
	PyObject *mfdict, *fdict;
	char *str, *cur, *start, *zero;
	int len;

	if (!PyArg_ParseTuple(args, "O!O!s#:parse_manifest",
			      &PyDict_Type, &mfdict,
			      &PyDict_Type, &fdict,
			      &str, &len))
		goto quit;

	for (start = cur = str, zero = NULL; cur < str + len; cur++) {
		PyObject *file = NULL, *node = NULL;
		PyObject *flags = NULL;
		int nlen;

		if (!*cur) {
			zero = cur;
			continue;
		}
		else if (*cur != '\n')
			continue;

		if (!zero) {
			PyErr_SetString(PyExc_ValueError,
					"manifest entry has no separator");
			goto quit;
		}

		file = PyBytes_FromStringAndSize(start, zero - start);

		if (!file)
			goto bail;

		nlen = cur - zero - 1;

		node = unhexlify(zero + 1, nlen > 40 ? 40 : nlen);
		if (!node)
			goto bail;

		if (nlen > 40) {
			flags = PyBytes_FromStringAndSize(zero + 41,
							   nlen - 40);
			if (!flags)
				goto bail;

			if (PyDict_SetItem(fdict, file, flags) == -1)
				goto bail;
		}

		if (PyDict_SetItem(mfdict, file, node) == -1)
			goto bail;

		start = cur + 1;
		zero = NULL;

		Py_XDECREF(flags);
		Py_XDECREF(node);
		Py_XDECREF(file);
		continue;
	bail:
		Py_XDECREF(flags);
		Py_XDECREF(node);
		Py_XDECREF(file);
		goto quit;
	}

	if (len > 0 && *(cur - 1) != '\n') {
		PyErr_SetString(PyExc_ValueError,
				"manifest contains trailing garbage");
		goto quit;
	}

	Py_INCREF(Py_None);
	return Py_None;
quit:
	return NULL;
}

#ifdef _WIN32
#ifdef _MSC_VER
/* msvc 6.0 has problems */
#define inline __inline
typedef unsigned long uint32_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif
static uint32_t ntohl(uint32_t x)
{
	return ((x & 0x000000ffUL) << 24) |
	       ((x & 0x0000ff00UL) <<  8) |
	       ((x & 0x00ff0000UL) >>  8) |
	       ((x & 0xff000000UL) >> 24);
}
#else
/* not windows */
#include <sys/types.h>
#if defined __BEOS__ && !defined __HAIKU__
#include <ByteOrder.h>
#else
#include <arpa/inet.h>
#endif
#include <inttypes.h>
#endif

static PyObject *parse_dirstate(PyObject *self, PyObject *args)
{
	PyObject *dmap, *cmap, *parents = NULL, *ret = NULL;
	PyObject *fname = NULL, *cname = NULL, *entry = NULL;
	char *str, *cur, *end, *cpos;
	int state, mode, size, mtime;
	unsigned int flen;
	int len;
	char decode[16]; /* for alignment */

	if (!PyArg_ParseTuple(args, "O!O!s#:parse_dirstate",
			      &PyDict_Type, &dmap,
			      &PyDict_Type, &cmap,
			      &str, &len))
		goto quit;

	/* read parents */
	if (len < 40)
		goto quit;

	parents = Py_BuildValue("s#s#", str, 20, str + 20, 20);
	if (!parents)
		goto quit;

	/* read filenames */
	cur = str + 40;
	end = str + len;

	while (cur < end - 17) {
		/* unpack header */
		state = *cur;
		memcpy(decode, cur + 1, 16);
		mode = ntohl(*(uint32_t *)(decode));
		size = ntohl(*(uint32_t *)(decode + 4));
		mtime = ntohl(*(uint32_t *)(decode + 8));
		flen = ntohl(*(uint32_t *)(decode + 12));
		cur += 17;
		if (cur + flen > end || cur + flen < cur) {
			PyErr_SetString(PyExc_ValueError, "overflow in dirstate");
			goto quit;
		}

		entry = Py_BuildValue("ciii", state, mode, size, mtime);
		if (!entry)
			goto quit;
		PyObject_GC_UnTrack(entry); /* don't waste time with this */

		cpos = memchr(cur, 0, flen);
		if (cpos) {
			fname = PyBytes_FromStringAndSize(cur, cpos - cur);
			cname = PyBytes_FromStringAndSize(cpos + 1,
							   flen - (cpos - cur) - 1);
			if (!fname || !cname ||
			    PyDict_SetItem(cmap, fname, cname) == -1 ||
			    PyDict_SetItem(dmap, fname, entry) == -1)
				goto quit;
			Py_DECREF(cname);
		} else {
			fname = PyBytes_FromStringAndSize(cur, flen);
			if (!fname ||
			    PyDict_SetItem(dmap, fname, entry) == -1)
				goto quit;
		}
		cur += flen;
		Py_DECREF(fname);
		Py_DECREF(entry);
		fname = cname = entry = NULL;
	}

	ret = parents;
	Py_INCREF(ret);
quit:
	Py_XDECREF(fname);
	Py_XDECREF(cname);
	Py_XDECREF(entry);
	Py_XDECREF(parents);
	return ret;
}

const char nullid[20];
const int nullrev = -1;

/* RevlogNG format (all in big endian, data may be inlined):
 *    6 bytes: offset
 *    2 bytes: flags
 *    4 bytes: compressed length
 *    4 bytes: uncompressed length
 *    4 bytes: base revision
 *    4 bytes: link revision
 *    4 bytes: parent 1 revision
 *    4 bytes: parent 2 revision
 *   32 bytes: nodeid (only 20 bytes used)
 */
static int _parse_index_ng(const char *data, int size, int inlined,
			   PyObject *index)
{
	PyObject *entry;
	int n = 0, err;
	uint64_t offset_flags;
	int comp_len, uncomp_len, base_rev, link_rev, parent_1, parent_2;
	const char *c_node_id;
	const char *end = data + size;
	char decode[64]; /* to enforce alignment with inline data */

	while (data < end) {
		unsigned int step;

		memcpy(decode, data, 64);
		offset_flags = ntohl(*((uint32_t *) (decode + 4)));
		if (n == 0) /* mask out version number for the first entry */
			offset_flags &= 0xFFFF;
		else {
			uint32_t offset_high =  ntohl(*((uint32_t *)decode));
			offset_flags |= ((uint64_t)offset_high) << 32;
		}

		comp_len = ntohl(*((uint32_t *)(decode + 8)));
		uncomp_len = ntohl(*((uint32_t *)(decode + 12)));
		base_rev = ntohl(*((uint32_t *)(decode + 16)));
		link_rev = ntohl(*((uint32_t *)(decode + 20)));
		parent_1 = ntohl(*((uint32_t *)(decode + 24)));
		parent_2 = ntohl(*((uint32_t *)(decode + 28)));
		c_node_id = decode + 32;

		entry = Py_BuildValue("Liiiiiis#", offset_flags, comp_len,
			      uncomp_len, base_rev, link_rev,
			      parent_1, parent_2, c_node_id, 20);

		if (!entry)
			return 0;

		PyObject_GC_UnTrack(entry); /* don't waste time with this */

		if (inlined) {
			err = PyList_Append(index, entry);
			Py_DECREF(entry);
			if (err)
				return 0;
		} else
			PyList_SET_ITEM(index, n, entry); /* steals reference */

		n++;
		step = 64 + (inlined ? comp_len : 0);
		if (data + step > end || data + step < data)
			break;
		data += step;
	}
	if (data != end) {
		if (!PyErr_Occurred())
			PyErr_SetString(PyExc_ValueError, "corrupt index file");
		return 0;
	}

	/* create the magic nullid entry in the index at [-1] */
	entry = Py_BuildValue("Liiiiiis#", (uint64_t)0, 0, 0, -1, -1, -1, -1, nullid, 20);

	if (!entry)
		return 0;

	PyObject_GC_UnTrack(entry); /* don't waste time with this */

	if (inlined) {
		err = PyList_Append(index, entry);
		Py_DECREF(entry);
		if (err)
			return 0;
	} else
		PyList_SET_ITEM(index, n, entry); /* steals reference */

	return 1;
}

/* This function parses a index file and returns a Python tuple of the
 * following format: (index, cache)
 *
 * index: a list of tuples containing the RevlogNG records
 * cache: if data is inlined, a tuple (index_file_content, 0) else None
 */
static PyObject *parse_index2(PyObject *self, PyObject *args)
{
	const char *data;
	int size, inlined;
	PyObject *rval = NULL, *index = NULL, *cache = NULL;
	PyObject *data_obj = NULL, *inlined_obj;

	if (!PyArg_ParseTuple(args, "s#O", &data, &size, &inlined_obj))
		return NULL;
	inlined = inlined_obj && PyObject_IsTrue(inlined_obj);

	/* If no data is inlined, we know the size of the index list in
	 * advance: size divided by the size of one revlog record (64 bytes)
	 * plus one for nullid */
	index = inlined ? PyList_New(0) : PyList_New(size / 64 + 1);
	if (!index)
		goto quit;

	/* set up the cache return value */
	if (inlined) {
		/* Note that the reference to data_obj is only borrowed */
		data_obj = PyTuple_GET_ITEM(args, 0);
		cache = Py_BuildValue("iO", 0, data_obj);
		if (!cache)
			goto quit;
	} else {
		cache = Py_None;
		Py_INCREF(Py_None);
	}

	/* actually populate the index with data */
	if (!_parse_index_ng(data, size, inlined, index))
		goto quit;

	rval = Py_BuildValue("NN", index, cache);
	if (!rval)
		goto quit;
	return rval;

quit:
	Py_XDECREF(index);
	Py_XDECREF(cache);
	Py_XDECREF(rval);
	return NULL;
}


static char parsers_doc[] = "Efficient content parsing.";

static PyMethodDef methods[] = {
	{"parse_manifest", parse_manifest, METH_VARARGS, "parse a manifest\n"},
	{"parse_dirstate", parse_dirstate, METH_VARARGS, "parse a dirstate\n"},
	{"parse_index2", parse_index2, METH_VARARGS, "parse a revlog index\n"},
	{NULL, NULL}
};

#ifdef IS_PY3K
static struct PyModuleDef parsers_module = {
	PyModuleDef_HEAD_INIT,
	"parsers",
	parsers_doc,
	-1,
	methods
};

PyMODINIT_FUNC PyInit_parsers(void)
{
	return PyModule_Create(&parsers_module);
}
#else
PyMODINIT_FUNC initparsers(void)
{
	Py_InitModule3("parsers", methods, parsers_doc);
}
#endif

/*
 * hgsh.c - restricted login shell for mercurial
 *
 * Copyright 2006 Vadim Gelfer <vadim.gelfer@gmail.com>
 *
 * This software may be used and distributed according to the terms of the
 * GNU General Public License, incorporated herein by reference.
 *
 * this program is login shell for dedicated mercurial user account. it
 * only allows few actions:
 *
 * 1. run hg in server mode on specific repository. no other hg commands
 * are allowed. we try to verify that repo to be accessed exists under
 * given top-level directory.
 *
 * 2. (optional) forward ssh connection from firewall/gateway machine to
 * "real" mercurial host, to let users outside intranet pull and push
 * changes through firewall.
 *
 * 3. (optional) run normal shell, to allow to "su" to mercurial user, use
 * "sudo" to run programs as that user, or run cron jobs as that user.
 *
 * only tested on linux yet. patches for non-linux systems welcome.
 */

#ifndef _GNU_SOURCE
#define _GNU_SOURCE /* for asprintf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sysexits.h>
#include <unistd.h>

/*
 * user config.
 *
 * if you see a hostname below, just use first part of hostname. example,
 * if you have host named foo.bar.com, use "foo".
 */

/*
 * HG_GATEWAY: hostname of gateway/firewall machine that people outside your
 * intranet ssh into if they need to ssh to other machines. if you do not
 * have such machine, set to NULL.
 */
#ifndef HG_GATEWAY
#define HG_GATEWAY     "gateway"
#endif

/*
 * HG_HOST: hostname of mercurial server. if any machine is allowed, set to
 * NULL.
 */
#ifndef HG_HOST
#define HG_HOST         "mercurial"
#endif

/*
 * HG_USER: username to log in from HG_GATEWAY to HG_HOST. if gateway and
 * host username are same, set to NULL.
 */
#ifndef HG_USER
#define HG_USER         "hg"
#endif

/*
 * HG_ROOT: root of tree full of mercurial repos. if you do not want to
 * validate location of repo when someone is try to access, set to NULL.
 */
#ifndef HG_ROOT
#define HG_ROOT         "/home/hg/repos"
#endif

/*
 * HG: path to the mercurial executable to run.
 */
#ifndef HG
#define HG              "/home/hg/bin/hg"
#endif

/*
 * HG_SHELL: shell to use for actions like "sudo" and "su" access to
 * mercurial user, and cron jobs. if you want to make these things
 * impossible, set to NULL.
 */
#ifndef HG_SHELL
#define HG_SHELL        NULL
/* #define HG_SHELL        "/bin/bash" */
#endif

/*
 * HG_HELP: some way for users to get support if they have problem. if they
 * should not get helpful message, set to NULL.
 */
#ifndef HG_HELP
#define HG_HELP         "please contact support@example.com for help."
#endif

/*
 * SSH: path to ssh executable to run, if forwarding from HG_GATEWAY to
 * HG_HOST. if you want to use rsh instead (why?), you need to modify
 * arguments it is called with. see forward_through_gateway.
 */
#ifndef SSH
#define SSH             "/usr/bin/ssh"
#endif

/*
 * tell whether to print command that is to be executed. useful for
 * debugging. should not interfere with mercurial operation, since
 * mercurial only cares about stdin and stdout, and this prints to stderr.
 */
static const int debug = 0;

static void print_cmdline(int argc, char **argv)
{
	FILE *fp = stderr;
	int i;

	fputs("command: ", fp);

	for (i = 0; i < argc; i++) {
		char *spc = strpbrk(argv[i], " \t\r\n");
		if (spc) {
			fputc('\'', fp);
		}
		fputs(argv[i], fp);
		if (spc) {
			fputc('\'', fp);
		}
		if (i < argc - 1) {
			fputc(' ', fp);
		}
	}
	fputc('\n', fp);
	fflush(fp);
}

static void usage(const char *reason, int exitcode)
{
	char *hg_help = HG_HELP;

	if (reason) {
		fprintf(stderr, "*** Error: %s.\n", reason);
	}
	fprintf(stderr, "*** This program has been invoked incorrectly.\n");
	if (hg_help) {
		fprintf(stderr, "*** %s\n", hg_help);
	}
	exit(exitcode ? exitcode : EX_USAGE);
}

/*
 * run on gateway host to make another ssh connection, to "real" mercurial
 * server. it sends its command line unmodified to far end.
 *
 * never called if HG_GATEWAY is NULL.
 */
static void forward_through_gateway(int argc, char **argv)
{
	char *ssh = SSH;
	char *hg_host = HG_HOST;
	char *hg_user = HG_USER;
	char **nargv = alloca((10 + argc) * sizeof(char *));
	int i = 0, j;

	nargv[i++] = ssh;
	nargv[i++] = "-q";
	nargv[i++] = "-T";
	nargv[i++] = "-x";
	if (hg_user) {
		nargv[i++] = "-l";
		nargv[i++] = hg_user;
	}
	nargv[i++] = hg_host;

	/*
	 * sshd called us with added "-c", because it thinks we are a shell.
	 * drop it if we find it.
	 */
	j = 1;
	if (j < argc && strcmp(argv[j], "-c") == 0) {
		j++;
	}

	for (; j < argc; i++, j++) {
		nargv[i] = argv[j];
	}
	nargv[i] = NULL;

	if (debug) {
		print_cmdline(i, nargv);
	}

	execv(ssh, nargv);
	perror(ssh);
	exit(EX_UNAVAILABLE);
}

/*
 * run shell. let administrator "su" to mercurial user's account to do
 * administrative works.
 *
 * never called if HG_SHELL is NULL.
 */
static void run_shell(int argc, char **argv)
{
	char *hg_shell = HG_SHELL;
	char **nargv;
	char *c;
	int i;

	nargv = alloca((argc + 3) * sizeof(char *));
	c = strrchr(hg_shell, '/');

	/* tell "real" shell it is login shell, if needed. */

	if (argv[0][0] == '-' && c) {
		nargv[0] = strdup(c);
		if (nargv[0] == NULL) {
			perror("malloc");
			exit(EX_OSERR);
		}
		nargv[0][0] = '-';
	} else {
		nargv[0] = hg_shell;
	}

	for (i = 1; i < argc; i++) {
		nargv[i] = argv[i];
	}
	nargv[i] = NULL;

	if (debug) {
		print_cmdline(i, nargv);
	}

	execv(hg_shell, nargv);
	perror(hg_shell);
	exit(EX_OSFILE);
}

enum cmdline {
	hg_init,
	hg_serve,
};


/*
 * attempt to verify that a directory is really a hg repo, by testing
 * for the existence of a subdirectory.
 */
static int validate_repo(const char *repo_root, const char *subdir)
{
	char *abs_path;
	struct stat st;
	int ret;

	if (asprintf(&abs_path, "%s.hg/%s", repo_root, subdir) == -1) {
		ret = -1;
		goto bail;
	}

	/* verify that we really are looking at valid repo. */

	if (stat(abs_path, &st) == -1) {
		ret = 0;
	} else {
		ret = 1;
	}

bail:
	return ret;
}

/*
 * paranoid wrapper, runs hg executable in server mode.
 */
static void serve_data(int argc, char **argv)
{
	char *hg_root = HG_ROOT;
	char *repo, *repo_root;
	enum cmdline cmd;
	char *nargv[6];
	size_t repolen;
	int i;

	/*
	 * check argv for looking okay. we should be invoked with argv
	 * resembling like this:
	 *
	 *   hgsh
	 *   -c
	 *   hg -R some/path serve --stdio
	 *
	 * the "-c" is added by sshd, because it thinks we are login shell.
	 */

	if (argc != 3) {
		goto badargs;
	}

	if (strcmp(argv[1], "-c") != 0) {
		goto badargs;
	}

	if (sscanf(argv[2], "hg init %as", &repo) == 1) {
		cmd = hg_init;
	}
	else if (sscanf(argv[2], "hg -R %as serve --stdio", &repo) == 1) {
		cmd = hg_serve;
	} else {
		goto badargs;
	}

	repolen = repo ? strlen(repo) : 0;

	if (repolen == 0) {
		goto badargs;
	}

	if (hg_root) {
		if (asprintf(&repo_root, "%s/%s/", hg_root, repo) == -1) {
			goto badargs;
		}

		/*
		 * attempt to stop break out from inside the
		 * repository tree. could do something more clever
		 * here, because e.g. we could traverse a symlink that
		 * looks safe, but really breaks us out of tree.
		 */

		if (strstr(repo_root, "/../") != NULL) {
			goto badargs;
		}

		/* only hg init expects no repo. */

		if (cmd != hg_init) {
			int valid;

			valid = validate_repo(repo_root, "data");

			if (valid == -1) {
				goto badargs;
			}

			if (valid == 0) {
				valid = validate_repo(repo_root, "store");

				if (valid == -1) {
					goto badargs;
				}
			}

			if (valid == 0) {
				perror(repo);
				exit(EX_DATAERR);
			}
		}

		if (chdir(hg_root) == -1) {
			perror(hg_root);
			exit(EX_SOFTWARE);
		}
	}

	i = 0;

	switch (cmd) {
	case hg_serve:
		nargv[i++] = HG;
		nargv[i++] = "-R";
		nargv[i++] = repo;
		nargv[i++] = "serve";
		nargv[i++] = "--stdio";
		break;
	case hg_init:
		nargv[i++] = HG;
		nargv[i++] = "init";
		nargv[i++] = repo;
		break;
	}

	nargv[i] = NULL;

	if (debug) {
		print_cmdline(i, nargv);
	}

	execv(HG, nargv);
	perror(HG);
	exit(EX_UNAVAILABLE);

badargs:
	/* print useless error message. */

	usage("invalid arguments", EX_DATAERR);
}

int main(int argc, char **argv)
{
	char host[1024];
	char *c;

	if (gethostname(host, sizeof(host)) == -1) {
		perror("gethostname");
		exit(EX_OSERR);
	}

	if ((c = strchr(host, '.')) != NULL) {
		*c = '\0';
	}

	if (getenv("SSH_CLIENT")) {
		char *hg_gateway = HG_GATEWAY;
		char *hg_host = HG_HOST;

		if (hg_gateway && strcmp(host, hg_gateway) == 0) {
			forward_through_gateway(argc, argv);
		}

		if (hg_host && strcmp(host, hg_host) != 0) {
			usage("invoked on unexpected host", EX_USAGE);
		}

		serve_data(argc, argv);
	} else if (HG_SHELL) {
		run_shell(argc, argv);
	} else {
		usage("invalid arguments", EX_DATAERR);
	}

	return 0;
}
SET(CMAKE_C_COMPILER "/usr/bin/gcc")
SET(CMAKE_C_COMPILER_ARG1 "")
SET(CMAKE_C_COMPILER_ID "GNU")
SET(CMAKE_C_PLATFORM_ID "Linux")

SET(CMAKE_AR "/usr/bin/ar")
SET(CMAKE_RANLIB "/usr/bin/ranlib")
SET(CMAKE_LINKER "/usr/bin/ld")
SET(CMAKE_COMPILER_IS_GNUCC 1)
SET(CMAKE_C_COMPILER_LOADED 1)
SET(CMAKE_COMPILER_IS_MINGW )
SET(CMAKE_COMPILER_IS_CYGWIN )
IF(CMAKE_COMPILER_IS_CYGWIN)
  SET(CYGWIN 1)
  SET(UNIX 1)
ENDIF(CMAKE_COMPILER_IS_CYGWIN)

SET(CMAKE_C_COMPILER_ENV_VAR "CC")

IF(CMAKE_COMPILER_IS_MINGW)
  SET(MINGW 1)
ENDIF(CMAKE_COMPILER_IS_MINGW)
SET(CMAKE_C_COMPILER_ID_RUN 1)
SET(CMAKE_C_SOURCE_FILE_EXTENSIONS c)
SET(CMAKE_C_IGNORE_EXTENSIONS h;H;o;O;obj;OBJ;def;DEF;rc;RC)
SET(CMAKE_C_LINKER_PREFERENCE 10)

# Save compiler ABI information.
SET(CMAKE_C_SIZEOF_DATA_PTR "8")
SET(CMAKE_C_COMPILER_ABI "ELF")

IF(CMAKE_C_SIZEOF_DATA_PTR)
  SET(CMAKE_SIZEOF_VOID_P "${CMAKE_C_SIZEOF_DATA_PTR}")
ENDIF(CMAKE_C_SIZEOF_DATA_PTR)

IF(CMAKE_C_COMPILER_ABI)
  SET(CMAKE_INTERNAL_PLATFORM_ABI "${CMAKE_C_COMPILER_ABI}")
ENDIF(CMAKE_C_COMPILER_ABI)

SET(CMAKE_C_HAS_ISYSROOT "")


SET(CMAKE_C_IMPLICIT_LINK_LIBRARIES "c")
SET(CMAKE_C_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/x86_64-pc-linux-gnu/4.3.4;/usr/lib64;/lib64;/usr/x86_64-pc-linux-gnu/lib;/usr/lib")
SET(CMAKE_CXX_COMPILER "/usr/bin/c++")
SET(CMAKE_CXX_COMPILER_ARG1 "")
SET(CMAKE_CXX_COMPILER_ID "GNU")
SET(CMAKE_CXX_PLATFORM_ID "Linux")

SET(CMAKE_AR "/usr/bin/ar")
SET(CMAKE_RANLIB "/usr/bin/ranlib")
SET(CMAKE_LINKER "/usr/bin/ld")
SET(CMAKE_COMPILER_IS_GNUCXX 1)
SET(CMAKE_CXX_COMPILER_LOADED 1)
SET(CMAKE_COMPILER_IS_MINGW )
SET(CMAKE_COMPILER_IS_CYGWIN )
IF(CMAKE_COMPILER_IS_CYGWIN)
  SET(CYGWIN 1)
  SET(UNIX 1)
ENDIF(CMAKE_COMPILER_IS_CYGWIN)

SET(CMAKE_CXX_COMPILER_ENV_VAR "CXX")

IF(CMAKE_COMPILER_IS_MINGW)
  SET(MINGW 1)
ENDIF(CMAKE_COMPILER_IS_MINGW)
SET(CMAKE_CXX_COMPILER_ID_RUN 1)
SET(CMAKE_CXX_IGNORE_EXTENSIONS inl;h;H;o;O;obj;OBJ;def;DEF;rc;RC)
SET(CMAKE_CXX_SOURCE_FILE_EXTENSIONS C;M;c++;cc;cpp;cxx;m;mm)
SET(CMAKE_CXX_LINKER_PREFERENCE 30)
SET(CMAKE_CXX_LINKER_PREFERENCE_PROPAGATES 1)

# Save compiler ABI information.
SET(CMAKE_CXX_SIZEOF_DATA_PTR "8")
SET(CMAKE_CXX_COMPILER_ABI "ELF")

IF(CMAKE_CXX_SIZEOF_DATA_PTR)
  SET(CMAKE_SIZEOF_VOID_P "${CMAKE_CXX_SIZEOF_DATA_PTR}")
ENDIF(CMAKE_CXX_SIZEOF_DATA_PTR)

IF(CMAKE_CXX_COMPILER_ABI)
  SET(CMAKE_INTERNAL_PLATFORM_ABI "${CMAKE_CXX_COMPILER_ABI}")
ENDIF(CMAKE_CXX_COMPILER_ABI)

SET(CMAKE_CXX_HAS_ISYSROOT "")


SET(CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "stdc++;m;c")
SET(CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/x86_64-pc-linux-gnu/4.3.4;/usr/lib64;/lib64;/usr/x86_64-pc-linux-gnu/lib;/usr/lib")
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 2.8

# Relative path conversion top directories.
SET(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/arne/Quell/Programme/runner-computerspiele-vorlesung")
SET(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/arne/Quell/Programme/runner-computerspiele-vorlesung")

# Force unix paths in dependencies.
SET(CMAKE_FORCE_UNIX_PATHS 1)

# The C and CXX include file search paths:
SET(CMAKE_C_INCLUDE_PATH
  "/usr/include/OIS"
  "/usr/include/boost-1_41"
  "/usr/include/OGRE"
  "dependencies/tinyxml"
  "dependencies/OgreOggSound/include"
  )
SET(CMAKE_CXX_INCLUDE_PATH ${CMAKE_C_INCLUDE_PATH})
SET(CMAKE_Fortran_INCLUDE_PATH ${CMAKE_C_INCLUDE_PATH})

# The C and CXX include file regular expressions for this directory.
SET(CMAKE_C_INCLUDE_REGEX_SCAN "^.*$")
SET(CMAKE_C_INCLUDE_REGEX_COMPLAIN "^$")
SET(CMAKE_CXX_INCLUDE_REGEX_SCAN ${CMAKE_C_INCLUDE_REGEX_SCAN})
SET(CMAKE_CXX_INCLUDE_REGEX_COMPLAIN ${CMAKE_C_INCLUDE_REGEX_COMPLAIN})


SET(CMAKE_SYSTEM "Linux-2.6.31-gentoo-r6")
SET(CMAKE_SYSTEM_NAME "Linux")
SET(CMAKE_SYSTEM_VERSION "2.6.31-gentoo-r6")
SET(CMAKE_SYSTEM_PROCESSOR "x86_64")

SET(CMAKE_HOST_SYSTEM "Linux-2.6.31-gentoo-r6")
SET(CMAKE_HOST_SYSTEM_NAME "Linux")
SET(CMAKE_HOST_SYSTEM_VERSION "2.6.31-gentoo-r6")
SET(CMAKE_HOST_SYSTEM_PROCESSOR "x86_64")

SET(CMAKE_CROSSCOMPILING "FALSE")

SET(CMAKE_SYSTEM_LOADED 1)
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 2.8

# The generator used is:
SET(CMAKE_DEPENDS_GENERATOR "Unix Makefiles")

# The top level Makefile was generated from the following files:
SET(CMAKE_MAKEFILE_DEPENDS
  "CMakeCache.txt"
  "CMakeFiles/CMakeCCompiler.cmake"
  "CMakeFiles/CMakeCXXCompiler.cmake"
  "CMakeFiles/CMakeSystem.cmake"
  "CMakeLists.txt"
  "dependencies/OgreOggSound/CMakeLists.txt"
  "dependencies/tinyxml/CMakeLists.txt"
  "src/CMakeLists.txt"
  "test/CMakeLists.txt"
  "tools/LevelDataConverter/CMakeLists.txt"
  "/usr/lib/OGRE/cmake/FindOGRE.cmake"
  "/usr/lib/OGRE/cmake/FindOIS.cmake"
  "/usr/lib/OGRE/cmake/FindPkgMacros.cmake"
  "/usr/lib/OGRE/cmake/PreprocessorUtils.cmake"
  "/usr/share/cmake/Modules/CMakeCInformation.cmake"
  "/usr/share/cmake/Modules/CMakeCXXInformation.cmake"
  "/usr/share/cmake/Modules/CMakeCommonLanguageInclude.cmake"
  "/usr/share/cmake/Modules/CMakeGenericSystem.cmake"
  "/usr/share/cmake/Modules/CMakeSystemSpecificInformation.cmake"
  "/usr/share/cmake/Modules/Compiler/GNU-C.cmake"
  "/usr/share/cmake/Modules/Compiler/GNU-CXX.cmake"
  "/usr/share/cmake/Modules/Compiler/GNU.cmake"
  "/usr/share/cmake/Modules/FindBoost.cmake"
  "/usr/share/cmake/Modules/FindPkgConfig.cmake"
  "/usr/share/cmake/Modules/Platform/Linux-GNU-C.cmake"
  "/usr/share/cmake/Modules/Platform/Linux-GNU-CXX.cmake"
  "/usr/share/cmake/Modules/Platform/Linux-GNU.cmake"
  "/usr/share/cmake/Modules/Platform/Linux.cmake"
  "/usr/share/cmake/Modules/Platform/UnixPaths.cmake"
  )

# The corresponding makefile is:
SET(CMAKE_MAKEFILE_OUTPUTS
  "Makefile"
  "CMakeFiles/cmake.check_cache"
  )

# Byproducts of CMake generate step:
SET(CMAKE_MAKEFILE_PRODUCTS
  "CMakeFiles/CMakeDirectoryInformation.cmake"
  "dependencies/tinyxml/CMakeFiles/CMakeDirectoryInformation.cmake"
  "dependencies/OgreOggSound/CMakeFiles/CMakeDirectoryInformation.cmake"
  "src/CMakeFiles/CMakeDirectoryInformation.cmake"
  "test/CMakeFiles/CMakeDirectoryInformation.cmake"
  "tools/LevelDataConverter/CMakeFiles/CMakeDirectoryInformation.cmake"
  )

# Dependency information for all targets:
SET(CMAKE_DEPEND_INFO_FILES
  "dependencies/tinyxml/CMakeFiles/tinyxml.dir/DependInfo.cmake"
  "dependencies/OgreOggSound/CMakeFiles/OgreOggSound.dir/DependInfo.cmake"
  "src/CMakeFiles/Game.dir/DependInfo.cmake"
  "tools/LevelDataConverter/CMakeFiles/LevelDataConverter.dir/DependInfo.cmake"
  )
# This file is generated by cmake for dependency checking of the CMakeCache.txt file
# Install script for directory: /home/arne/Quell/Programme/runner-computerspiele-vorlesung/src

# Set the install prefix
IF(NOT DEFINED CMAKE_INSTALL_PREFIX)
  SET(CMAKE_INSTALL_PREFIX "/usr/local")
ENDIF(NOT DEFINED CMAKE_INSTALL_PREFIX)
STRING(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
IF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  IF(BUILD_TYPE)
    STRING(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  ELSE(BUILD_TYPE)
    SET(CMAKE_INSTALL_CONFIG_NAME "Release")
  ENDIF(BUILD_TYPE)
  MESSAGE(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
ENDIF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)

# Set the component getting installed.
IF(NOT CMAKE_INSTALL_COMPONENT)
  IF(COMPONENT)
    MESSAGE(STATUS "Install component: \"${COMPONENT}\"")
    SET(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  ELSE(COMPONENT)
    SET(CMAKE_INSTALL_COMPONENT)
  ENDIF(COMPONENT)
ENDIF(NOT CMAKE_INSTALL_COMPONENT)

# Install shared libraries without execute permission?
IF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
  SET(CMAKE_INSTALL_SO_NO_EXE "0")
ENDIF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)


#include "OgrePlatform.h"

#include "Core/CTaskManager.h"
#include "Core/CStateManager.h"
#include "Tasks/CTimerTask.h"
#include "Tasks/CInputTask.h"
#include "Tasks/CVideoTask.h"
#include "Tasks/CSoundTask.h"
#include "Tasks/CStateTask.h"
#include "Core/CSettingsManager.h"

#include "Core/IStateFactory.h"
#include "States/CLoadingState.h"
#include "States/CMainMenuState.h"
#include "States/CGameState.h"
#include "States/CEditorState.h"

#include "Core/CLog.h"

using namespace Game;

// one factory for all our states
class StateFactory : public IStateFactory {
public:
	virtual PState CreateState(const std::string& stateType) {
		PState newState;
		if (stateType == "Loading")
			newState = CLoadingState::Create();
		else if (stateType == "MainMenu")
			newState = CMainMenuState::Create();
		else if (stateType == "Game")
			newState = CGameState::Create();
		else if (stateType == "Editor")
			newState = CEditorState::Create();
		return newState;
	}
};


#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32

#define WIN32_LEAN_AND_MEAN
#include "windows.h"

INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT)
#else
int main(int argc, char **argv)
#endif
{

#ifdef DEBUG
	CLog::LogVerbosity = CLog::logDebug;
#endif

	CLog::Get().Write("Starting up...", CLog::logDebug);

	// setup core
	new CTaskManager();
	new CStateManager();
	new CSettingsManager();

	// register state factory
	PStateFactory factory(new StateFactory());
	CStateManager::GetSingleton().RegisterFactory(factory);
	factory.reset();

	// setup tasks
	PTimerTask TimerTask(new CTimerTask());
	PVideoTask VideoTask(new CVideoTask());
	PInputTask InputTask(new CInputTask());
	PStateTask StateTask(new CStateTask());
	PSoundTask SoundTask(new CSoundTask());

	if (!TimerTask->Start()) {
		CLog::Get().Write("TimerTask::Start failed.", CLog::logDebug);
		return 0;
	}

	// setup list of ogre plugins (note: at least one RenderSystem is mandatory)
	// TODO: read from config
	VideoTask->Plugins.push_back("RenderSystem_GL");
	VideoTask->Plugins.push_back("Plugin_CgProgramManager");
	VideoTask->Plugins.push_back("Plugin_OctreeSceneManager");
	VideoTask->Plugins.push_back("Plugin_ParticleFX");
	VideoTask->Plugins.push_back("libOgreOggSound");

	if (!VideoTask->Start()) {
		CLog::Get().Write("VideoTask::Start failed.", CLog::logDebug);
		return 0;
	}

	if (!SoundTask->Start()) {
		CLog::Get().Write("SoundTask::Start failed.", CLog::logDebug);
		return 0;
	}

	// add resource groups
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation("media/main", "FileSystem", "Main", true);
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation("media/editor", "FileSystem", "Editor", true);
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation("media/audio", "FileSystem", "Audio", true);

	// input task needs ogre render window
	InputTask->SetWindow(CVideoTask::ogreRenderWindow);

	if (!InputTask->Start()) {
		CLog::Get().Write("InputTask::Start failed.", CLog::logDebug);
		return 0;
	}

	if (!StateTask->Start()) {
		CLog::Get().Write("StateTask::Start failed.", CLog::logDebug);
		return 0;
	}

	// set StateTask to receive signals from InputTask
	InputTask->addKeyListener(StateTask, "StateTask");
	InputTask->addMouseListener(StateTask, "StateTask");
	InputTask->addJoystickListener(StateTask, "StateTask");

	// switch to loading state
	PLoadingState loadingstate = CLoadingState::Create();
	loadingstate->ResourceGroups.push_back("Editor");

	if (!CStateManager::GetSingleton().ChangeState(loadingstate)) {
		CLog::Get().Write("LoadingState::Start failed.", CLog::logDebug);
		return 0;
	}

	// if no errors occured until now, add tasks to taskmanager and start main loop

	CTaskManager::GetSingleton().AddTask(TimerTask, 10);
	CTaskManager::GetSingleton().AddTask(InputTask, 100);
	CTaskManager::GetSingleton().AddTask(StateTask, 500);
	CTaskManager::GetSingleton().AddTask(SoundTask, 750);
	CTaskManager::GetSingleton().AddTask(VideoTask, 1000);

	CTaskManager::GetSingleton().Run();

	CLog::Get().Write("Main Loop finished.", CLog::logDebug);

	delete CStateManager::GetSingletonPtr();
	delete CTaskManager::GetSingletonPtr();
	delete CSettingsManager::GetSingletonPtr();

	return 0;
}
/*
 * testlog.h
 *
 *  Created on: Sep 30, 2010
 *      Author: crt
 */

#ifndef TESTLOG_H_
#define TESTLOG_H_

#ifdef TESTING
	#ifdef BOOST_TEST
		#include "boost/test/unit_test.hpp"
		#include <sstream>
		#define TEST_LOG(x) \
			{ std::stringstream __tmp; __tmp << __LINE__ << ": " << x; \
			BOOST_MESSAGE( __tmp.str() ); }
	#else
		#define TEST_LOG(x) std::cout << __LINE__ << ": " << x << std::endl ;
	#endif
#else
	#define TEST_LOG(x)
#endif


#endif /* TESTLOG_H_ */
/*
 * CollisionTest.cpp
 *
 *  Created on: Sep 4, 2010
 *      Author: crt
 */

#include "test.h"
#include "../src/GameObjects/CLevelData.h"
#include "../src/GameObjects/LevelObjects.h"
#include "../src/Core/CSettingsManager.h"
#include "Ogre.h"

using namespace Ogre;
using namespace Game::GameObjects;
using namespace std;

BOOST_AUTO_TEST_SUITE(Collision);

BOOST_AUTO_TEST_CASE( collision_test )
{
	new Game::CSettingsManager();

	// create 2x2x2 cube with center in origin
	Vector2 position(0,0);
	Vector2 size(2,2);

	PLevelObject cube = CLevelObject::Create();
	cube->SetPosition(position);
	cube->SetAABBSize(size);

	PMovableObject collider = CMovableObject::Create();

	PLevelData leveldata = CLevelData::Create();
	leveldata->InsertObject(cube, otStatic);

	collider->SetParent(leveldata);

	// move 2x2 rectangle downwards
	collider->SetPosition(Ogre::Vector2(0.0f, 3.0f));
	collider->SetAABBSize(Ogre::Vector2(2.0f, 2.0f));

	collider->Move(Ogre::Vector2::UNIT_Y*(-2.0f));
	Ogre::Vector2 translation = collider->GetPosition() - Ogre::Vector2(0.0f, 3.0f);
	FLOAT_CHECK_EQUAL(translation, Ogre::Vector2(0.0f, -1.0f));


	// move beyond cube
	collider->SetPosition(Ogre::Vector2(0.0f, 3.0f));
	collider->Move(Ogre::Vector2::UNIT_Y*(-10.0f));

	translation = collider->GetPosition() - Ogre::Vector2(0.0f, 3.0f);
	FLOAT_CHECK_EQUAL(translation, Ogre::Vector2(0.0f, -1.0f));

	// move down and right
	collider->SetPosition(Ogre::Vector2(0.0f, 3.0f));
	collider->Move(Ogre::Vector2(1.0f, -2.0f));
	translation = collider->GetPosition() - Ogre::Vector2(0.0f, 3.0f);
	FLOAT_CHECK_EQUAL(translation, Ogre::Vector2(1.0f, -1.0f));

	// initial collision
	// rectangles overlap at [(0,0),(1,1)]
	collider->SetPosition(Ogre::Vector2(1.0f, 1.0f));
	collider->SetAABBSize(Ogre::Vector2(2.0f, 2.0f));
	collider->Move(Ogre::Vector2::UNIT_X);
	translation = collider->GetPosition() - Ogre::Vector2(1.0f, 1.0f);
	FLOAT_CHECK_EQUAL(translation, Ogre::Vector2(-1.0f, 0.0f));

	leveldata->ClearData();
	PLevelObject triangle = CLevelObject::Create();
	Game::Polygon poly;
	poly.AddPoint(Ogre::Vector2(0.0f, -2.0f));
	poly.AddPoint(Ogre::Vector2(4.0f, -2.0f));
	poly.AddPoint(Ogre::Vector2(4.0f,  2.0f));
	triangle->SetCollisionPolygon(poly);
	leveldata->InsertObject(triangle, otStatic);

	collider->SetPosition(Ogre::Vector2(0.5f, 0.5f));
	collider->SetAABBSize(Ogre::Vector2(1.0f, 1.0f));
	collider->Move(Ogre::Vector2::UNIT_X * 5.0f);
	translation = collider->GetPosition() - Ogre::Vector2(0.5f, 0.5f);
	FLOAT_CHECK_EQUAL(translation, Ogre::Vector2(3.0f, 2.0f));

	cube = CLevelObject::Create();
	cube->SetPosition(Ogre::Vector2(3.5f, 1.5f));
	cube->SetAABBSize(Ogre::Vector2::UNIT_SCALE);
	leveldata->InsertObject(cube, otStatic);
	collider->SetPosition(Ogre::Vector2(0.5f, 0.5f));
	collider->Move(Ogre::Vector2::UNIT_X * 5.0f);
	translation = collider->GetPosition() - Ogre::Vector2(0.5f, 0.5f);
	FLOAT_CHECK_EQUAL(translation, Ogre::Vector2(2.0f, 1.0f));

}

BOOST_AUTO_TEST_SUITE_END();
/*
 * GeometryTest.cpp
 *
 *  Created on: Sep 28, 2010
 *      Author: crt
 */

#include "test.h"
#include <math.h>

using namespace Game;

#define sign(x) (( x > 0 ) - ( x < 0 ))


BOOST_AUTO_TEST_SUITE(Geometry);

BOOST_AUTO_TEST_CASE( rectangle_test )
{
	Game::Rectangle r1(-1, -1, 1, 1);
	Game::Rectangle r2(-4, 0, 0, 4);

	BOOST_CHECK_EQUAL( r2.Intersects(r1), true );
}

BOOST_AUTO_TEST_CASE( face_test )
{
	Face emptyFace;
	FLOAT_CHECK_EQUAL(emptyFace.v1, Ogre::Vector2::ZERO);
	FLOAT_CHECK_EQUAL(emptyFace.v2, Ogre::Vector2::ZERO);
	FLOAT_CHECK_EQUAL(emptyFace.normal, Ogre::Vector2::ZERO);

	Face normalTest(Ogre::Vector2::UNIT_X, Ogre::Vector2::ZERO);
	FLOAT_CHECK_EQUAL(normalTest.v1, Ogre::Vector2::UNIT_X);
	FLOAT_CHECK_EQUAL(normalTest.v2, Ogre::Vector2::ZERO);
	FLOAT_CHECK_EQUAL(normalTest.normal, Ogre::Vector2::UNIT_Y);

	normalTest = Face(Ogre::Vector2::ZERO, Ogre::Vector2::UNIT_X);
	FLOAT_CHECK_EQUAL(normalTest.v2, Ogre::Vector2::UNIT_X);
	FLOAT_CHECK_EQUAL(normalTest.v1, Ogre::Vector2::ZERO);
	FLOAT_CHECK_EQUAL(normalTest.normal, Ogre::Vector2::NEGATIVE_UNIT_Y);

	BOOST_CHECK_NE(normalTest, emptyFace);

	emptyFace = Face(Ogre::Vector2::ZERO, Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(normalTest, emptyFace);

	emptyFace.normal = Ogre::Vector2(10, 5);
	BOOST_CHECK_EQUAL(normalTest, emptyFace);
}

BOOST_AUTO_TEST_CASE( polygon_constructor_test )
{
	Game::Polygon polygon;

	BOOST_CHECK_EQUAL(polygon.FaceCount(), 0);
	BOOST_CHECK_EQUAL(polygon.GetFaces().size(), 0);

	Face face(Ogre::Vector2::ZERO, Ogre::Vector2::UNIT_X);
	polygon = Game::Polygon(face);

	BOOST_CHECK_EQUAL(polygon.FaceCount(), 1);

	std::vector<Face> faces = polygon.GetFaces();
	BOOST_REQUIRE_EQUAL(faces.size(), 1);

	FLOAT_CHECK_EQUAL(faces[0].v1, Ogre::Vector2::ZERO);
	FLOAT_CHECK_EQUAL(faces[0].v2, Ogre::Vector2::UNIT_X);

	Game::Rectangle rect(-1, -1, 1, 1);
	polygon = Game::Polygon(rect);

	BOOST_CHECK_EQUAL(polygon.FaceCount(), 4);

	faces = polygon.GetFaces(false);
	BOOST_REQUIRE_EQUAL(faces.size(), 4);

	FLOAT_CHECK_EQUAL(faces[0].v2, faces[1].v1);
	FLOAT_CHECK_EQUAL(faces[1].v2, faces[2].v1);
	FLOAT_CHECK_EQUAL(faces[2].v2, faces[3].v1);
	FLOAT_CHECK_EQUAL(faces[3].v2, faces[0].v1);

	FLOAT_CHECK_EQUAL(faces[0].v1, Ogre::Vector2(-1, -1));
	FLOAT_CHECK_EQUAL(faces[1].v1, Ogre::Vector2(1, -1));
	FLOAT_CHECK_EQUAL(faces[2].v1, Ogre::Vector2(1, 1));
	FLOAT_CHECK_EQUAL(faces[3].v1, Ogre::Vector2(-1, 1));

	FLOAT_CHECK_EQUAL(faces[0].normal, Ogre::Vector2(0.0f, -1.0f));
	FLOAT_CHECK_EQUAL(faces[1].normal, Ogre::Vector2(1.0f,  0.0f));
	FLOAT_CHECK_EQUAL(faces[2].normal, Ogre::Vector2(0.0f,  1.0f));
	FLOAT_CHECK_EQUAL(faces[3].normal, Ogre::Vector2(-1.0f,  0.0f));
}

BOOST_AUTO_TEST_CASE( polygon_modifier_test )
{
	Game::Polygon polygon;

	polygon.AddPoint(Ogre::Vector2::ZERO);
	BOOST_CHECK_EQUAL(polygon.FaceCount(), 0);
	BOOST_CHECK_NE(polygon, Game::Polygon());

	polygon.AddPoint(Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(polygon.FaceCount(), 1);

	polygon.AddPoint(Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(polygon.FaceCount(), 1);

	polygon.AddPoint(Ogre::Vector2::UNIT_Y);
	BOOST_CHECK_EQUAL(polygon.FaceCount(), 3);

	polygon.RemovePoint(Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(polygon.FaceCount(), 1);

	polygon.Clear();
	BOOST_CHECK_EQUAL(polygon.FaceCount(), 0);

	BOOST_CHECK_EQUAL(polygon, Game::Polygon());

	polygon.AddPoint(Ogre::Vector2::UNIT_X);
	polygon.AddPoint(Ogre::Vector2::UNIT_Y);

	Game::Polygon polygon2(Face(Ogre::Vector2::UNIT_Y, Ogre::Vector2::UNIT_X));

	BOOST_CHECK_EQUAL(polygon, polygon2);

	polygon2.RemovePoint(Ogre::Vector2::UNIT_Y);

	BOOST_CHECK_NE(polygon, polygon2);

	polygon.Translate(Ogre::Vector2::UNIT_X);
	std::vector<Face> faces = polygon.GetFaces();

	BOOST_CHECK_EQUAL(faces[0], Face(Ogre::Vector2(2.0f, 0.0f), Ogre::Vector2(1.0f, 1.0f)));
}

BOOST_AUTO_TEST_CASE( polygon_intersection_test )
{
	Game::Rectangle rect(-1, -1, 1, 1);

	Game::Polygon poly1(rect);
	Game::Polygon poly2 = poly1;

	SATResult result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_Y);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	std::pair<bool, Ogre::Vector2> result2 = poly1.SeparatingAxesTest(poly2);
	BOOST_CHECK_EQUAL(result2.first, false);
	FLOAT_CHECK_EQUAL(result2.second.length(), 2.0f);

	poly1.Translate(result2.second * (1.0f + TOLERANCE));
	result2 = poly1.SeparatingAxesTest(poly2);
	BOOST_CHECK_EQUAL(result2.first, true);

	poly1 = Game::Polygon(rect);

	poly1.Translate(Ogre::Vector2::UNIT_Y * (result.MinimumOverlap*(1.0f+TOLERANCE)));
	result2 = poly1.SeparatingAxesTest(poly2);
	BOOST_CHECK_EQUAL(result2.first, true);

	poly1 = Game::Polygon(rect);
	poly1.Translate(Ogre::Vector2::UNIT_Y * (result.MaximumOverlap*(1.0f+TOLERANCE)));
	result2 = poly1.SeparatingAxesTest(poly2);
	BOOST_CHECK_EQUAL(result2.first, true);

	poly1 = Game::Polygon(rect);
	poly2.Translate(Ogre::Vector2(3.0f, 0.0f));

	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_Y);
	BOOST_CHECK_EQUAL(result.IsSeparating, true);
	result2 = poly1.SeparatingAxesTest(poly2);
	BOOST_CHECK_EQUAL(result2.first, true);

	poly2 = Game::Polygon();
	poly2.AddPoint(Ogre::Vector2(0.0f, -4.0f));
	poly2.AddPoint(Ogre::Vector2(3.0f, -4.0f));
	poly2.AddPoint(Ogre::Vector2(3.0f, 2.0f));

	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_Y);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2(3.0f, 6.0f));
	BOOST_CHECK_EQUAL(result.IsSeparating, true);
	result2 = poly1.SeparatingAxesTest(poly2);
	BOOST_CHECK_EQUAL(result2.first, true);

	// translate triangle; should intersect now and MTV should have length of approx. 0.447
	poly2.Translate(Ogre::Vector2(-1.0f, 0.0f));
	result2 = poly1.SeparatingAxesTest(poly2);
	BOOST_CHECK_EQUAL(result2.first, false);
	FLOAT_CHECK_EQUAL( result2.second.length(), 0.447f );

	// create two 2x2 rectangles which overlap at (0.5,0),(1,1)

	poly1 = Game::Polygon(rect);
	poly2 = Game::Polygon(Game::Rectangle(0.5f, 0.0f, 2.5f, 2.0f));

	result2 = poly2.SeparatingAxesTest(poly1);
	BOOST_CHECK_EQUAL(result2.first, false);
	FLOAT_CHECK_EQUAL(result2.second, Ogre::Vector2::UNIT_X*0.5f);


	//202: ResolveCollision: (286.962, -5.5, 289.962, -14.5) Vector2(0.880605, -0.07865)
	//337: 1, -0 Face( Vector2(290, -14.5); Vector2(280, -14.5); Vector2(0, 1) )

	poly1 = Game::Polygon(Game::Rectangle(286.583f, -14.5f, 289.583f, -5.5f));
	Game::Face fc(Ogre::Vector2(290.0f, -14.5f), Ogre::Vector2(280.0f, -14.5f), Ogre::Vector2(0,1));
	poly2 = Game::Polygon(fc);

	// both axes should not be separating, but minimum overlap should be near zero
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_X);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	FLOAT_CHECK_EQUAL(result.MinimumOverlap, 0.0f);
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::UNIT_Y);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::NEGATIVE_UNIT_X);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
	FLOAT_CHECK_EQUAL(result.MinimumOverlap, 0.0f);
	result = poly1.IsSeparatingAxis(poly2, Ogre::Vector2::NEGATIVE_UNIT_Y);
	BOOST_CHECK_EQUAL(result.IsSeparating, false);
}

BOOST_AUTO_TEST_CASE( polygon_intersection_test2 )
{
	Game::Polygon poly1, poly2;
	poly1.AddPoint(Ogre::Vector2( 0.0f, 0.0f));
	poly1.AddPoint(Ogre::Vector2( 0.0f, 2.0f));
	poly1.AddPoint(Ogre::Vector2(-2.0f, 0.0f));

	poly2.AddPoint(Ogre::Vector2( 1.0f, 0.0f));
	poly2.AddPoint(Ogre::Vector2( 3.0f, 0.0f));
	poly2.AddPoint(Ogre::Vector2( 3.0f, 2.0f));

	std::pair<bool, float> result = poly2.TranslationIntersect(poly1, Ogre::Vector2(-2.0f, 0.0f));
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 0.5f );

	result = poly2.TranslationIntersect(poly1, Ogre::Vector2(-2.0f, 2.0f));
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 0.5f );
}

BOOST_AUTO_TEST_CASE( polygon_misc_test ) {
	Game::Rectangle rect(-1, -1, 1, 1);
	Game::Polygon poly(rect);

	FLOAT_CHECK_EQUAL( poly.CalculateArea(), 4.0f);
	FLOAT_CHECK_EQUAL( poly.CalculateCenter(), 0.5f*(rect.GetMinimum() + rect.GetMaximum()) );

	rect = Game::Rectangle(1, 1, 5, 4);
	poly = Game::Polygon(rect);
	FLOAT_CHECK_EQUAL( poly.CalculateArea(), 12.0f);
	FLOAT_CHECK_EQUAL( poly.CalculateCenter(), 0.5f*(rect.GetMinimum() + rect.GetMaximum()) );

	rect = Game::Rectangle(-1, -1, 1, 1);
	poly = Game::Polygon(rect);

	FLOAT_CHECK_EQUAL(poly.CalculateCenter(), Ogre::Vector2::ZERO);

	poly.Rotate(M_PI / 2.0f);
	std::vector<Ogre::Vector2> points = poly.GetPoints();

	FLOAT_CHECK_EQUAL(poly.CalculateCenter(), Ogre::Vector2::ZERO);

	FLOAT_CHECK_EQUAL(points[0], Ogre::Vector2( 1.0f, -1.0f));
	FLOAT_CHECK_EQUAL(points[1], Ogre::Vector2( 1.0f,  1.0f));
	FLOAT_CHECK_EQUAL(points[2], Ogre::Vector2(-1.0f,  1.0f));
	FLOAT_CHECK_EQUAL(points[3], Ogre::Vector2(-1.0f, -1.0f));

	poly = Game::Polygon(rect);
	poly.Rotate(M_PI / 4.0f);
	points = poly.GetPoints();
	FLOAT_CHECK_EQUAL(points[0], sqrt(2.0f) * Ogre::Vector2::NEGATIVE_UNIT_Y);
	FLOAT_CHECK_EQUAL(points[1], sqrt(2.0f) * Ogre::Vector2::UNIT_X);
	FLOAT_CHECK_EQUAL(points[2], sqrt(2.0f) * Ogre::Vector2::UNIT_Y);
	FLOAT_CHECK_EQUAL(points[3], sqrt(2.0f) * Ogre::Vector2::NEGATIVE_UNIT_X);
}

BOOST_AUTO_TEST_CASE( ray_ray_intersection_test )
{
	Game::Ray ray1( Ogre::Vector2::ZERO, Ogre::Vector2::UNIT_Y );
	Game::Ray ray2( Ogre::Vector2(1.0f, 1.0f), Ogre::Vector2::NEGATIVE_UNIT_X );

	// intersection point should be at (0, 1)
	std::pair<bool, float> result = ray1.Intersects(ray2);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 1.0f );

	result = ray2.Intersects(ray1);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 1.0f );

	// testing identical rays should return no intersection
	ray2 = ray1;
	result = ray1.Intersects(ray2);
	BOOST_CHECK_EQUAL(result.first, false);

	// rays are now parallel; rare case of no intersection
	ray2 = Game::Ray( Ogre::Vector2(1.0f, 0.0f), Ogre::Vector2::UNIT_Y );
	result = ray1.Intersects(ray2);
	BOOST_CHECK_EQUAL(result.first, false);
	result = ray2.Intersects(ray1);
	BOOST_CHECK_EQUAL(result.first, false);

	// rays share same origin
	ray1 = Game::Ray( Ogre::Vector2(2.0f, 5.0f), Ogre::Vector2(1.0f, 1.0f) );
	ray2 = Game::Ray( Ogre::Vector2(2.0f, 5.0f), Ogre::Vector2(-1.0f, 3.0f) );
	result = ray1.Intersects(ray2);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 0.0f );
	result = ray2.Intersects(ray1);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 0.0f );

	// rays will intersect at (1, 4) which is origin of ray2
	ray2.SetOrigin(Ogre::Vector2(1.0f, 4.0f));
	result = ray1.Intersects(ray2);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, -1.0f );
	result = ray2.Intersects(ray1);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 0.0f );
}

BOOST_AUTO_TEST_CASE( ray_face_intersection_test )
{
	Game::Ray ray(Ogre::Vector2::ZERO, Ogre::Vector2::UNIT_X);
	Game::Face face(Ogre::Vector2(1.0f, 0.0f), Ogre::Vector2(1.0f, 1.0f));

	// ray intersects at (1, 0)
	std::pair<bool, float> result = ray.Intersects(face);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 1.0f );

	// no intersection
	ray.SetOrigin(Ogre::Vector2(0.0f, 2.0f));
	result = ray.Intersects(face);
	BOOST_CHECK_EQUAL(result.first, false);

	// ray intersects at (1, 2)
	face = Game::Face(Ogre::Vector2(0.0f, 3.0f), Ogre::Vector2(1.0f, 2.0f));
	result = ray.Intersects(face);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 1.0f );

	// ray intersects at (0.5, 2.5)
	ray.SetDirection(Ogre::Vector2(1.0f, 1.0f));
	result = ray.Intersects(face);
	BOOST_CHECK_EQUAL(result.first, true);
	FLOAT_CHECK_EQUAL( result.second, 0.5f );
}

BOOST_AUTO_TEST_SUITE_END();
/*
 * SettingsManagerTest.cpp
 *
 *  Created on: Aug 19, 2010
 *      Author: crt
 */

#include "../src/Core/CSettingsManager.h"
#include "boost/test/unit_test.hpp"

using namespace Game;

BOOST_AUTO_TEST_SUITE(SettingsManagerTest);

BOOST_AUTO_TEST_CASE( constructor_test )
{
	BOOST_REQUIRE_NO_THROW( new CSettingsManager() );

	BOOST_CHECK( CSettingsManager::GetSingletonPtr() != NULL );

	BOOST_REQUIRE_NO_THROW( delete CSettingsManager::GetSingletonPtr() );
}

/** Read test/test_config.cfg and check for errors */
BOOST_AUTO_TEST_CASE( read_config_test )
{
	BOOST_REQUIRE_NO_THROW( new CSettingsManager() );

	CSettingsManager& sm = CSettingsManager::GetSingleton();

	BOOST_CHECK_NO_THROW( sm.readConfig("test/test_config.cfg") );

	// check conversion
	BOOST_CHECK_EQUAL( sm.get<int>("Section2", "intValue", -1), 1337 );
	BOOST_CHECK_EQUAL( sm.get<bool>("Section2", "boolValue", true), false );
	BOOST_CHECK_EQUAL( sm.get<bool>("Section2", "boolValue2", false), true );
	BOOST_CHECK_EQUAL( sm.get<float>("Section2", "floatValue", -1.0f), 31.337f );
	BOOST_CHECK_EQUAL( sm.get<std::string>("Section2", "strValue", "fail"), "test string" );

	// check invalid conversion (should return default values)
	BOOST_CHECK_EQUAL( sm.get<int>("Section2", "strValue", -1), -1 );
	BOOST_CHECK_EQUAL( sm.get<std::string>("Section2", "intValue", "fail"), "fail" );

	// commentValue should return default
	BOOST_CHECK_EQUAL( sm.get<std::string>("Section2", "commentValue", "fail"), "fail" );

	// check section with a lot of whitespaces
	BOOST_CHECK_EQUAL( sm.get<int>("WhitespaceTestSection", "intValue", -1), 42 );
	BOOST_CHECK_EQUAL( sm.get<std::string>("WhitespaceTestSection", "strValue", "fail"), "test string" );

	// check invalid section (should always return default)
	BOOST_CHECK_EQUAL( sm.get<int>("InvalidValues", "intValue", -1), -1 );
	BOOST_CHECK_EQUAL( sm.get<int>("InvalidValues", "intValue1", -1), -1 );
	BOOST_CHECK_EQUAL( sm.get<int>("InvalidValues", "intValue2", -1), -1 );
	BOOST_CHECK_EQUAL( sm.get<float>("InvalidValues", "floatValue", -1.0f), -1.0f );
	BOOST_CHECK_EQUAL( sm.get<std::string>("InvalidValues", "strValue", "fail"), "fail" );
	BOOST_CHECK_EQUAL( sm.get<std::string>("InvalidValues", "noValue", "fail"), "fail" );


	BOOST_REQUIRE_NO_THROW( delete CSettingsManager::GetSingletonPtr() );
}

BOOST_AUTO_TEST_SUITE_END();
/*
 * StateManagerTest.cpp
 *
 *  Created on: Aug 3, 2010
 *      Author: crt
 */

#include "../src/Core/CStateManager.h"
#include "TestState.h"
#include "TestStateFactory.h"
#include "boost/test/unit_test.hpp"

using namespace Game;
using namespace Test;

BOOST_AUTO_TEST_SUITE(StateManager);

BOOST_AUTO_TEST_CASE( constructor_test )
{
	BOOST_REQUIRE_NO_THROW( new CStateManager() );

	BOOST_CHECK( CStateManager::GetSingletonPtr() != NULL );

	BOOST_REQUIRE_NO_THROW( delete CStateManager::GetSingletonPtr() );
}

/** Test state manager to state interaction.
 *
 * Test if the state management from the state manager
 * is correctly forwarded to the states.
 */

BOOST_AUTO_TEST_CASE( push_pop_test )
{
	BOOST_REQUIRE_NO_THROW( new CStateManager() );

	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PopAll() );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == NULL );

	PTestState teststate1(new TestState());
	PTestState teststate2(new TestState());

	// Adding a new state
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PushState(teststate1) );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == teststate1);
	BOOST_CHECK_EQUAL( teststate1->bStart, true );
	teststate1->Reset();

	// pushing a new state pauses the current state. 
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PushState(teststate2) );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == teststate2);
	BOOST_CHECK_EQUAL( teststate2->bStart, true );
	BOOST_CHECK_EQUAL( teststate1->bPause, true );
	teststate1->Reset(); teststate2->Reset();

	// popping a state stops the popped state. 
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PopState() );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == teststate1);
	BOOST_CHECK_EQUAL( teststate2->bStop, true );
	BOOST_CHECK_EQUAL( teststate1->bResume, true );
	teststate1->Reset(); teststate2->Reset();

	// popping all states stops all states. 
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PushState(teststate2) );
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PopAll() );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == NULL);
	BOOST_CHECK_EQUAL( teststate1->bStop, true );
	BOOST_CHECK_EQUAL( teststate2->bStop, true );

	BOOST_REQUIRE_NO_THROW( delete CStateManager::GetSingletonPtr() );
}

/** Test State Manager Change State function
 * */
BOOST_AUTO_TEST_CASE( change_state_test )
{
	BOOST_REQUIRE_NO_THROW( new CStateManager() );

	PTestState teststate1(new TestState());
	PTestState teststate2(new TestState());
	PTestState teststate3(new TestState());

	// test with empty stack
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().ChangeState(teststate1) );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == teststate1 );
	BOOST_CHECK_EQUAL( teststate1->bStart, true );
	teststate1->Reset();

	// test with one state on stack
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().ChangeState(teststate2) );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == teststate2 );
	BOOST_CHECK_EQUAL( teststate1->bStop, true );
	BOOST_CHECK_EQUAL( teststate2->bStart, true );
	teststate1->Reset(); teststate2->Reset();

	// test with multiple states on stack

	// push another state
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PushState(teststate3) );
	teststate2->Reset(); teststate3->Reset();

	// change to teststate3
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().ChangeState(teststate1) );
	BOOST_CHECK( CStateManager::GetSingleton().GetCurrentState() == teststate1 );
	BOOST_CHECK_EQUAL( teststate1->bStart, true );
	BOOST_CHECK_EQUAL( teststate2->bStop, true );
	BOOST_CHECK_EQUAL( teststate3->bStop, true );

	BOOST_REQUIRE_NO_THROW( delete CStateManager::GetSingletonPtr() );
}

/** Test Factory Methods */
BOOST_AUTO_TEST_CASE( factory_test )
{
	BOOST_REQUIRE_NO_THROW( new CStateManager() );

	// create and register test factory
	PTestStateFactory factory(new CTestStateFactory());
	factory->TypeList.push_back("type1");
	factory->TypeList.push_back("type2");
	BOOST_REQUIRE_NO_THROW( CStateManager::GetSingleton().RegisterFactory(boost::static_pointer_cast<IStateFactory>(factory)) );

	// make states using factory methods
	PState state;
	PTestState testState;

	// create instance of "type1"
	BOOST_CHECK_NO_THROW( state = CStateManager::GetSingleton().CreateState("type1") );
	testState = boost::dynamic_pointer_cast<TestState>(state);
	BOOST_REQUIRE( testState != NULL );
	BOOST_CHECK( testState->Tag == "type1");

	// create instance of unknown type
	BOOST_CHECK_NO_THROW( state = CStateManager::GetSingleton().CreateState("unknown") );
	BOOST_CHECK( state == NULL);

	// add another factory
	factory = PTestStateFactory(new CTestStateFactory());
	factory->TypeList.push_back("new type");
	BOOST_REQUIRE_NO_THROW( CStateManager::GetSingleton().RegisterFactory(boost::static_pointer_cast<IStateFactory>(factory)) );

	// create instance of "new type"
	BOOST_CHECK_NO_THROW( state = CStateManager::GetSingleton().CreateState("new type") );
	testState = boost::dynamic_pointer_cast<TestState>(state);
	BOOST_REQUIRE( testState != NULL );
	BOOST_CHECK( testState->Tag == "new type");

	// test ChangeState(string) and PushState(string)
	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().PushState("type1") );
	testState = boost::dynamic_pointer_cast<TestState>(CStateManager::GetSingleton().GetCurrentState());
	BOOST_REQUIRE( testState != NULL );
	BOOST_CHECK( testState->Tag == "type1" );
	BOOST_CHECK_EQUAL( testState->bStart, true );
	testState->Reset();

	BOOST_CHECK_NO_THROW( CStateManager::GetSingleton().ChangeState("new type") );
	BOOST_CHECK_EQUAL( testState->bStop, true );

	testState = boost::dynamic_pointer_cast<TestState>(CStateManager::GetSingleton().GetCurrentState());
	BOOST_REQUIRE( testState != NULL );
	BOOST_CHECK( testState->Tag == "new type" );
	BOOST_CHECK_EQUAL( testState->bStart, true );


	BOOST_REQUIRE_NO_THROW( delete CStateManager::GetSingletonPtr() );
}

BOOST_AUTO_TEST_SUITE_END();
/*
 * TestState.h
 *
 *  Created on: Aug 3, 2010
 *      Author: crt
 */

#ifndef TESTSTATE_H_
#define TESTSTATE_H_

#include "../src/Core/IState.h"
#include "boost/smart_ptr.hpp"
#include <string>

namespace Test {

/** test implementation of IState
 *  sets flags when each function is called
 *  make sure to call Reset a lot */
class TestState: public Game::IState {
public:
	TestState() { Reset(); }
	virtual ~TestState() {}
	virtual bool Start() { bStart = true; return true; }
	virtual void Stop() { bStop = true; }
	virtual void Pause() { bPause = true; }
	virtual void Resume() { bResume = true; }
	virtual void Update() { bUpdate = true; }

	bool bStart, bStop, bPause, bResume, bUpdate;
	std::string Tag;

	void Reset() {
		bStart = bStop = bPause = bResume = bUpdate = false;
	}
};
typedef boost::shared_ptr<TestState> PTestState;

}

#endif /* TESTSTATE_H_ */
/*
 * TestStateFactory.h
 *
 *  Created on: Aug 7, 2010
 *      Author: crt
 */

#ifndef TESTSTATEFACTORY_H_
#define TESTSTATEFACTORY_H_

#include "../src/Core/IStateFactory.h"
#include "TestState.h"
#include "boost/smart_ptr.hpp"
#include <string>
#include <vector>

namespace Test {

/** Test State Factory; creates TestStates and sets Tag to type
 *  creates all types in TypeList */
class CTestStateFactory : public Game::IStateFactory {
public:
	std::vector< std::string > TypeList;

	virtual Game::PState CreateState(const std::string& stateType) {
		if (std::find(TypeList.begin(), TypeList.end(), stateType) != TypeList.end()) {
			PTestState newState(new TestState());
			newState->Tag = stateType;
			return newState;
		} else {
			return Game::PState();
		}
	}
};

typedef boost::shared_ptr<CTestStateFactory> PTestStateFactory;

}

#endif /* TESTSTATEFACTORY_H_ */
# Install script for directory: /home/arne/Quell/Programme/runner-computerspiele-vorlesung/test

# Set the install prefix
IF(NOT DEFINED CMAKE_INSTALL_PREFIX)
  SET(CMAKE_INSTALL_PREFIX "/usr/local")
ENDIF(NOT DEFINED CMAKE_INSTALL_PREFIX)
STRING(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
IF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  IF(BUILD_TYPE)
    STRING(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  ELSE(BUILD_TYPE)
    SET(CMAKE_INSTALL_CONFIG_NAME "Release")
  ENDIF(BUILD_TYPE)
  MESSAGE(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
ENDIF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)

# Set the component getting installed.
IF(NOT CMAKE_INSTALL_COMPONENT)
  IF(COMPONENT)
    MESSAGE(STATUS "Install component: \"${COMPONENT}\"")
    SET(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  ELSE(COMPONENT)
    SET(CMAKE_INSTALL_COMPONENT)
  ENDIF(COMPONENT)
ENDIF(NOT CMAKE_INSTALL_COMPONENT)

# Install shared libraries without execute permission?
IF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
  SET(CMAKE_INSTALL_SO_NO_EXE "0")
ENDIF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)

/*
 * test.h
 *
 *  Created on: Sep 30, 2010
 *      Author: crt
 */

#ifndef TEST_H_
#define TEST_H_

#include "../src/GameObjects/Geometry.h"
#include "boost/test/unit_test.hpp"

namespace Test {

struct check_float_equality {
    boost::test_tools::predicate_result operator() (float A, float B) const {
        boost::test_tools::predicate_result result = Game::approximatelyEqual(A, B);
        if (!result) result.message() << " (approx.)";
        return result;
    }

    boost::test_tools::predicate_result operator() (const Ogre::Vector2& A, const Ogre::Vector2& B) const {
        boost::test_tools::predicate_result result = Game::approximatelyEqual(A.x, B.x) && Game::approximatelyEqual(A.y, B.y);
        if (!result) result.message() << " (approx.)";
        return result;
    }

    boost::test_tools::predicate_result operator() (const Ogre::Vector3& A, const Ogre::Vector3& B) const {
        boost::test_tools::predicate_result result = Game::approximatelyEqual(A.x, B.x) &&
        		Game::approximatelyEqual(A.y, B.y) && Game::approximatelyEqual(A.z, B.z);
        if (!result) result.message() << " (approx.)";
        return result;
    }
};

#define FLOAT_WARN_EQUAL(A, B) \
	BOOST_CHECK_WITH_ARGS_IMPL(::Test::check_float_equality(), \
        "", WARN, CHECK_EQUAL, (A)(B));

#define FLOAT_CHECK_EQUAL(A, B) \
    BOOST_CHECK_WITH_ARGS_IMPL(::Test::check_float_equality(), \
        "", CHECK, CHECK_EQUAL, (A)(B));

#define FLOAT_REQUIRE_EQUAL(A, B) \
	BOOST_CHECK_WITH_ARGS_IMPL(::Test::check_float_equality(), \
        "", REQUIRE, CHECK_EQUAL, (A)(B));

}

#endif /* TEST_H_ */
#######################################
# Config File for SettingsManagerTest #
#######################################

[EmptySection]

[Section2]
intValue = 1337
boolValue = false
boolValue2 = true
floatValue = 31.337
strValue = "test string"
#commentValue = "comment"

		  [WhitespaceTestSection]
		  
		 			  intValue		  = 	 42
		 			  
		 	strValue 	   = 			"test string"
		 	
		 	
[InvalidSection

[InvalidValues]
int Value = 42
intValue1 = 4 2
intValue2 = 4.2
floatValue = 127.0.0.1
strValue = "test string
noValue = invalid
/*
 * test_main.cpp
 *
 *  Created on: Aug 3, 2010
 *      Author: crt
 */

#define BOOST_TEST_MODULE game test
#include <boost/test/included/unit_test.hpp>
#ifdef __cplusplus
# error "A C++ compiler has been selected for C."
#endif

#if defined(__18CXX)
# define ID_VOID_MAIN
#endif

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"

#elif defined(__WATCOMC__)
# define COMPILER_ID "Watcom"

#elif defined(__SUNPRO_C)
# define COMPILER_ID "SunPro"

#elif defined(__HP_cc)
# define COMPILER_ID "HP"

#elif defined(__DECC)
# define COMPILER_ID "Compaq"

#elif defined(__IBMC__)
# if defined(__COMPILER_VER__)
#  define COMPILER_ID "zOS"
# elif __IBMC__ >= 800
#  define COMPILER_ID "XL"
# else
#  define COMPILER_ID "VisualAge"
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"

#elif defined(__PATHSCALE__)
# define COMPILER_ID "PathScale"

#elif defined(__GNUC__)
# define COMPILER_ID "GNU"

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"

#elif defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)
/* Analog Devices C++ compiler for Blackfin, TigerSHARC and
   SHARC (21000) DSPs */
# define COMPILER_ID "ADSP"

/* IAR Systems compiler for embedded systems.
   http://www.iar.com
   Not supported yet by CMake
#elif defined(__IAR_SYSTEMS_ICC__)
# define COMPILER_ID "IAR" */

/* sdcc, the small devices C compiler for embedded systems,
   http://sdcc.sourceforge.net  */
#elif defined(SDCC)
# define COMPILER_ID "SDCC"

#elif defined(_SGI_COMPILER_VERSION) || defined(_COMPILER_VERSION)
# define COMPILER_ID "MIPSpro"

/* This compiler is either not known or is too old to define an
   identification macro.  Try to identify the platform and guess that
   it is the native compiler.  */
#elif defined(__sgi)
# define COMPILER_ID "MIPSpro"

#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""

#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__sgi) || defined(__sgi__) || defined(_SGI)
# define PLATFORM_ID "IRIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU) || defined(__HAIKU__) || defined(_HAIKU)
# define PLATFORM_ID "Haiku"
/* Haiku also defines __BEOS__ so we must 
   put it prior to the check for __BEOS__
*/

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#else /* unknown platform */
# define PLATFORM_ID ""

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is becase
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64" 

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



/*--------------------------------------------------------------------------*/

#ifdef ID_VOID_MAIN
void main() {}
#else
int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
  (void)argv;
  return require;
}
#endif
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if defined(__COMO__)
# define COMPILER_ID "Comeau"

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"

#elif defined(__WATCOMC__)
# define COMPILER_ID "Watcom"

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"

#elif defined(__IBMCPP__)
# if defined(__COMPILER_VER__)
#  define COMPILER_ID "zOS"
# elif __IBMCPP__ >= 800
#  define COMPILER_ID "XL"
# else
#  define COMPILER_ID "VisualAge"
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"

#elif defined(__PATHSCALE__)
# define COMPILER_ID "PathScale"

#elif defined(__GNUC__)
# define COMPILER_ID "GNU"

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"

#elif defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)
/* Analog Devices C++ compiler for Blackfin, TigerSHARC and
   SHARC (21000) DSPs */
# define COMPILER_ID "ADSP"

#elif defined(_SGI_COMPILER_VERSION) || defined(_COMPILER_VERSION)
# define COMPILER_ID "MIPSpro"

/* This compiler is either not known or is too old to define an
   identification macro.  Try to identify the platform and guess that
   it is the native compiler.  */
#elif defined(__sgi)
# define COMPILER_ID "MIPSpro"

#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""

#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__sgi) || defined(__sgi__) || defined(_SGI)
# define PLATFORM_ID "IRIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU) || defined(__HAIKU__) || defined(_HAIKU)
# define PLATFORM_ID "Haiku"
/* Haiku also defines __BEOS__ so we must 
   put it prior to the check for __BEOS__
*/

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#else /* unknown platform */
# define PLATFORM_ID ""

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is becase
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64" 

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  (void)argv;
  return require;
}
# This file is generated by cmake for dependency checking of the CMakeCache.txt file
# Install script for directory: /home/arne/Quell/Programme/runner-computerspiele-vorlesung/dependencies/OgreOggSound

# Set the install prefix
IF(NOT DEFINED CMAKE_INSTALL_PREFIX)
  SET(CMAKE_INSTALL_PREFIX "/usr/local")
ENDIF(NOT DEFINED CMAKE_INSTALL_PREFIX)
STRING(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
IF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  IF(BUILD_TYPE)
    STRING(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  ELSE(BUILD_TYPE)
    SET(CMAKE_INSTALL_CONFIG_NAME "Release")
  ENDIF(BUILD_TYPE)
  MESSAGE(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
ENDIF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)

# Set the component getting installed.
IF(NOT CMAKE_INSTALL_COMPONENT)
  IF(COMPONENT)
    MESSAGE(STATUS "Install component: \"${COMPONENT}\"")
    SET(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  ELSE(COMPONENT)
    SET(CMAKE_INSTALL_COMPONENT)
  ENDIF(COMPONENT)
ENDIF(NOT CMAKE_INSTALL_COMPONENT)

# Install shared libraries without execute permission?
IF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
  SET(CMAKE_INSTALL_SO_NO_EXE "0")
ENDIF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)

# Install script for directory: /home/arne/Quell/Programme/runner-computerspiele-vorlesung/dependencies/tinyxml

# Set the install prefix
IF(NOT DEFINED CMAKE_INSTALL_PREFIX)
  SET(CMAKE_INSTALL_PREFIX "/usr/local")
ENDIF(NOT DEFINED CMAKE_INSTALL_PREFIX)
STRING(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
IF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  IF(BUILD_TYPE)
    STRING(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  ELSE(BUILD_TYPE)
    SET(CMAKE_INSTALL_CONFIG_NAME "Release")
  ENDIF(BUILD_TYPE)
  MESSAGE(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
ENDIF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)

# Set the component getting installed.
IF(NOT CMAKE_INSTALL_COMPONENT)
  IF(COMPONENT)
    MESSAGE(STATUS "Install component: \"${COMPONENT}\"")
    SET(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  ELSE(COMPONENT)
    SET(CMAKE_INSTALL_COMPONENT)
  ENDIF(COMPONENT)
ENDIF(NOT CMAKE_INSTALL_COMPONENT)

# Install shared libraries without execute permission?
IF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
  SET(CMAKE_INSTALL_SO_NO_EXE "0")
ENDIF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)

/*
http://code.google.com/p/ticpp/
Copyright (c) 2006 Ryan Pusztai, Ryan Mulder

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifdef TIXML_USE_TICPP

#include "ticpp.h"
#include "ticpprc.h"
#include "tinyxml.h"
#include <sstream>

using namespace ticpp;

// In the following Visitor functions, casting away const should be safe, as the object can only be referred to by a const &
bool Visitor::VisitEnter( const TiXmlDocument& doc )
{
	return VisitEnter( Document( const_cast< TiXmlDocument* >( &doc ) ) );
}

bool Visitor::VisitExit( const TiXmlDocument& doc )
{
	return VisitEnter( Document( const_cast< TiXmlDocument* >( &doc ) ) );
}

bool Visitor::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
{
	if ( 0 != firstAttribute )
	{
		Attribute attribute( const_cast< TiXmlAttribute* >( firstAttribute ) );
		return VisitEnter( Element( const_cast< TiXmlElement* >( &element ) ), &attribute );
	}
	else
	{
		return VisitEnter( Element( const_cast< TiXmlElement* >( &element ) ), 0 );
	}
}

bool Visitor::VisitExit( const TiXmlElement& element )
{
	return VisitExit( Element( const_cast< TiXmlElement* >( &element ) ) );
}

bool Visitor::Visit( const TiXmlDeclaration& declaration )
{
	return Visit( Declaration( const_cast< TiXmlDeclaration* >( &declaration ) ) );
}

bool Visitor::Visit( const TiXmlStylesheetReference& stylesheet )
{
	return Visit( StylesheetReference( const_cast< TiXmlStylesheetReference* >( &stylesheet ) ) );
}

bool Visitor::Visit( const TiXmlText& text )
{
	return Visit( Text( const_cast< TiXmlText* >( &text ) ) );
}

bool Visitor::Visit( const TiXmlComment& comment )
{
	return Visit( Comment( const_cast< TiXmlComment* >( &comment ) ) );
}

Attribute::Attribute()
{
	SetTiXmlPointer( new TiXmlAttribute() );
	m_impRC->InitRef();
}

Attribute::Attribute( TiXmlAttribute* attribute )
{
	SetTiXmlPointer( attribute );
	m_impRC->IncRef();
}

Attribute::Attribute( const std::string& name, const std::string& value )
{
	SetTiXmlPointer( new TiXmlAttribute( name, value ) );
	m_impRC->InitRef();
}

void Attribute::operator=( const Attribute& copy )
{
	// Dropping the reference to the old object
	this->m_impRC->DecRef();

	// Pointing to the new Object
	SetTiXmlPointer( copy.m_tiXmlPointer );

	// The internal tixml pointer changed in the above line
	this->m_impRC->IncRef();
}

Attribute::Attribute( const Attribute& copy ) : Base()
{
	// Dropping the reference to the old object
	this->m_impRC->DecRef();

	// Pointing to the new Object
	SetTiXmlPointer( copy.m_tiXmlPointer );

	// The internal tixml pointer changed in the above line
	this->m_impRC->IncRef();
}

Attribute::~Attribute()
{
	m_impRC->DecRef();
}

std::string Attribute::Value() const
{
	ValidatePointer();
	return m_tiXmlPointer->ValueStr();
}

std::string Attribute::Name() const
{
	ValidatePointer();
	return m_tiXmlPointer->Name();
}

Attribute* Attribute::Next( bool throwIfNoAttribute ) const
{
	ValidatePointer();
	TiXmlAttribute* attribute = m_tiXmlPointer->Next();
	if ( 0 == attribute )
	{
		if ( throwIfNoAttribute )
		{
			TICPPTHROW( "No more attributes found" )
		}
		else
		{
			return 0;
		}
	}

	Attribute* temp = new Attribute( attribute );
	attribute->m_spawnedWrappers.push_back( temp );

	return temp;
}

Attribute* Attribute::Previous( bool throwIfNoAttribute ) const
{
	ValidatePointer();
	TiXmlAttribute* attribute = m_tiXmlPointer->Previous();
	if ( 0 == attribute )
	{
		if ( throwIfNoAttribute )
		{
			TICPPTHROW( "No more attributes found" )
		}
		else
		{
			return 0;
		}
	}

	Attribute* temp = new Attribute( attribute );
	attribute->m_spawnedWrappers.push_back( temp );

	return temp;
}

void Attribute::IterateNext( const std::string&, Attribute** next ) const
{
	*next = Next( false );
}

void Attribute::IteratePrevious( const std::string&, Attribute** previous ) const
{
	*previous = Previous( false );
}

void Attribute::Print( FILE* file, int depth ) const
{
	ValidatePointer();
	m_tiXmlPointer->Print( file, depth );
}

void Attribute::SetTiXmlPointer( TiXmlAttribute* newPointer )
{
	m_tiXmlPointer = newPointer;
	SetImpRC( newPointer );
}

//*****************************************************************************

Node* Node::NodeFactory( TiXmlNode* tiXmlNode, bool throwIfNull, bool rememberSpawnedWrapper ) const
{
	if ( 0 == tiXmlNode )
	{
		if ( throwIfNull )
		{
			TICPPTHROW( "tiXmlNode is NULL" )
		}
		else
		{
			return 0;
		}
	}

	Node* temp;
	switch ( tiXmlNode->Type() )
	{
		case TiXmlNode::DOCUMENT:
			temp = new Document( tiXmlNode->ToDocument() );
			break;

		case TiXmlNode::ELEMENT:
			temp = new Element( tiXmlNode->ToElement() );
			break;

		case TiXmlNode::COMMENT:
			temp = new Comment( tiXmlNode->ToComment() );
			break;

		case TiXmlNode::TEXT:
			temp = new Text( tiXmlNode->ToText() );
			break;

		case TiXmlNode::DECLARATION:
			temp = new Declaration( tiXmlNode->ToDeclaration() );
			break;

		case TiXmlNode::STYLESHEETREFERENCE:
			temp = new StylesheetReference( tiXmlNode->ToStylesheetReference() );
			break;

		default:
			TICPPTHROW( "Type is unsupported" )
	}

	if ( rememberSpawnedWrapper )
	{
		tiXmlNode->m_spawnedWrappers.push_back( temp );
	}
	return temp;
}


std::string Node::Value() const
{
	return GetTiXmlPointer()->ValueStr();
}

void Node::Clear()
{
	GetTiXmlPointer()->Clear();
}

Node* Node::Parent( bool throwIfNoParent ) const
{
	TiXmlNode* parent = GetTiXmlPointer()->Parent();
	if ( ( 0 == parent ) && throwIfNoParent )
	{
		TICPPTHROW( "No parent exists" );
	}

	return NodeFactory( parent, false );
}

Node* Node::FirstChild( bool throwIfNoChildren ) const
{
	return FirstChild( "", throwIfNoChildren );
}

Node* Node::FirstChild( const std::string& value, bool throwIfNoChildren ) const
{
	return FirstChild( value.c_str(), throwIfNoChildren );
}

Node* Node::FirstChild( const char* value, bool throwIfNoChildren ) const
{
	TiXmlNode* childNode;
	if ( 0 == strlen( value ) )
	{
		childNode = GetTiXmlPointer()->FirstChild();
	}
	else
	{
		childNode = GetTiXmlPointer()->FirstChild( value );
	}

	if ( ( 0 == childNode ) && throwIfNoChildren )
	{
		TICPPTHROW( "Child with the value of \"" << value << "\" not found" );
	}

	return NodeFactory( childNode, false );
}

Node* Node::LastChild( bool throwIfNoChildren ) const
{
	return LastChild( "", throwIfNoChildren );
}

Node* Node::LastChild( const std::string& value, bool throwIfNoChildren ) const
{
	return LastChild( value.c_str(), throwIfNoChildren );
}

Node* Node::LastChild( const char* value, bool throwIfNoChildren ) const
{
	TiXmlNode* childNode;
	if ( 0 == strlen( value ) )
	{
		childNode = GetTiXmlPointer()->LastChild();
	}
	else
	{
		childNode = GetTiXmlPointer()->LastChild( value );
	}

	if ( ( 0 == childNode ) && throwIfNoChildren )
	{
		TICPPTHROW( "Child with the value of \"" << value << "\" not found" );
	}

	return NodeFactory( childNode, false );
}

Node* Node::IterateChildren ( Node* previous ) const
{
	TiXmlNode* pointer;
	if ( 0 == previous )
	{
		pointer = GetTiXmlPointer()->IterateChildren( 0 );
	}
	else
	{
		pointer = GetTiXmlPointer()->IterateChildren( previous->GetTiXmlPointer() );
	}

	return NodeFactory( pointer, false );
}

Node* Node::IterateChildren( const std::string& value, Node* previous ) const
{
	TiXmlNode* pointer;
	if ( 0 == previous )
	{
		pointer = GetTiXmlPointer()->IterateChildren( value, 0 );
	}
	else
	{
		pointer = GetTiXmlPointer()->IterateChildren( value, previous->GetTiXmlPointer() );
	}

	return NodeFactory( pointer, false );
}

Node* Node::InsertEndChild( const Node& addThis )
{
	if ( addThis.Type() == TiXmlNode::DOCUMENT )
	{
		TICPPTHROW( "Node is a Document and can't be inserted" );
	}

	TiXmlNode* pointer = GetTiXmlPointer()->InsertEndChild( *addThis.GetTiXmlPointer() );
	if ( 0 == pointer )
	{
		TICPPTHROW( "Node can't be inserted" );
	}

	return NodeFactory( pointer );
}

Node* Node::LinkEndChild( Node* childNode )
{
	if ( childNode->Type() == TiXmlNode::DOCUMENT )
	{
		TICPPTHROW( "Node is a Document and can't be linked" );
	}

	// Increment reference count when adding to the tree
	childNode->m_impRC->IncRef();

	if ( 0 == GetTiXmlPointer()->LinkEndChild( childNode->GetTiXmlPointer() ) )
	{
		TICPPTHROW( "Node can't be linked" );
	}

	return childNode;
}

Node* Node::InsertBeforeChild( Node* beforeThis, const Node& addThis )
{
	if ( addThis.Type() == TiXmlNode::DOCUMENT )
	{
		TICPPTHROW( "Node is a Document and can't be inserted" );
	}

	// Increment reference count when adding to the tree
	addThis.m_impRC->IncRef();

	TiXmlNode* pointer = GetTiXmlPointer()->InsertBeforeChild( beforeThis->GetTiXmlPointer(), *addThis.GetTiXmlPointer() );
	if ( 0 == pointer )
	{
		TICPPTHROW( "Node can't be inserted" );
	}

	return NodeFactory( pointer );
}

Node* Node::InsertAfterChild( Node* afterThis, const Node& addThis )
{
	if ( addThis.Type() == TiXmlNode::DOCUMENT )
	{
		TICPPTHROW( "Node is a Document and can't be inserted" );
	}

	// Increment reference count when adding to the tree
	addThis.m_impRC->IncRef();

	TiXmlNode* pointer = GetTiXmlPointer()->InsertAfterChild( afterThis->GetTiXmlPointer(), *addThis.GetTiXmlPointer() );
	if ( 0 == pointer )
	{
		TICPPTHROW( "Node can't be inserted" );
	}

	return NodeFactory( pointer );
}

Node* Node::ReplaceChild( Node* replaceThis, const Node& withThis )
{
	if ( withThis.Type() == TiXmlNode::DOCUMENT )
	{
		TICPPTHROW( "Node is a Document and can't be inserted" );
	}

	// Increment reference count when adding to the tree
	withThis.m_impRC->IncRef();

	TiXmlNode* pointer = GetTiXmlPointer()->ReplaceChild( replaceThis->GetTiXmlPointer(), *withThis.GetTiXmlPointer() );
	if ( 0 == pointer )
	{
		TICPPTHROW( "Node can't be inserted" );
	}

	return NodeFactory( pointer );
}

void Node::RemoveChild( Node* removeThis )
{
	if  ( !GetTiXmlPointer()->RemoveChild( removeThis->GetTiXmlPointer() ) )
	{
		TICPPTHROW( "Node to remove (" << removeThis->Value() << ") is not a child of this Node (" << Value() << ")" )
	}
}

Node* Node::PreviousSibling( bool throwIfNoSiblings ) const
{
	return PreviousSibling( "", throwIfNoSiblings );
}

Node* Node::PreviousSibling( const std::string& value, bool throwIfNoSiblings ) const
{
	return PreviousSibling( value.c_str(), throwIfNoSiblings );
}

Node* Node::PreviousSibling( const char* value, bool throwIfNoSiblings ) const
{
	TiXmlNode* sibling;
	if ( 0 == strlen( value ) )
	{
		sibling = GetTiXmlPointer()->PreviousSibling();
	}
	else
	{
		sibling = GetTiXmlPointer()->PreviousSibling( value );
	}

	if ( ( 0 == sibling ) && throwIfNoSiblings )
	{
		TICPPTHROW( "No Siblings found with value, '" << value << "', Prior to this Node (" << Value() << ")" )
	}

	return NodeFactory( sibling, false );
}

Node* Node::NextSibling( bool throwIfNoSiblings ) const
{
	return NextSibling( "", throwIfNoSiblings );
}

Node* Node::NextSibling( const std::string& value, bool throwIfNoSiblings ) const
{
	return NextSibling( value.c_str(), throwIfNoSiblings );
}

Node* Node::NextSibling( const char* value, bool throwIfNoSiblings ) const
{
	TiXmlNode* sibling;
	if ( 0 == strlen( value ) )
	{
		sibling = GetTiXmlPointer()->NextSibling();
	}
	else
	{
		sibling = GetTiXmlPointer()->NextSibling( value );
	}

	if ( ( 0 == sibling ) && throwIfNoSiblings )
	{
		TICPPTHROW( "No Siblings found with value, '" << value << "', After this Node (" << Value() << ")" )
	}

	return NodeFactory( sibling, false );
}

Element* Node::NextSiblingElement( bool throwIfNoSiblings ) const
{
	return NextSiblingElement( "", throwIfNoSiblings );
}

Element* Node::NextSiblingElement( const std::string& value, bool throwIfNoSiblings ) const
{
	return NextSiblingElement( value.c_str(), throwIfNoSiblings );
}

Element* Node::NextSiblingElement( const char* value, bool throwIfNoSiblings ) const
{
	TiXmlElement* sibling;
	if ( 0 == strlen( value ) )
	{
		sibling = GetTiXmlPointer()->NextSiblingElement();
	}
	else
	{
		sibling = GetTiXmlPointer()->NextSiblingElement( value );
	}

	if ( 0 == sibling )
	{
		if ( throwIfNoSiblings )
		{
			TICPPTHROW( "No Element Siblings found with value, '" << value << "', After this Node (" << Value() << ")" )
		}
		else
		{
			return 0;
		}
	}

	Element* temp = new Element( sibling );
	sibling->m_spawnedWrappers.push_back( temp );

	return temp;
}

Element* Node::FirstChildElement( bool throwIfNoChildren ) const
{
	return FirstChildElement( "", throwIfNoChildren );
}

Element* Node::FirstChildElement( const std::string& value, bool throwIfNoChildren ) const
{
	return FirstChildElement( value.c_str(), throwIfNoChildren );
}

Element* Node::FirstChildElement( const char* value, bool throwIfNoChildren ) const
{
	TiXmlElement* element;
	if ( 0 == strlen( value ) )
	{
		element = GetTiXmlPointer()->FirstChildElement();
	}
	else
	{
		element = GetTiXmlPointer()->FirstChildElement( value );
	}

	if ( 0 == element )
	{
		if( throwIfNoChildren )
		{
			TICPPTHROW( "Element (" << Value() << ") does NOT contain a child with the value of '" << value << "'" )
		}
		else
		{
			return 0;
		}
	}

	Element* temp = new Element( element );
	element->m_spawnedWrappers.push_back( temp );

	return temp;
}

int Node::Type() const
{
	return GetTiXmlPointer()->Type();
}

Document* Node::GetDocument( bool throwIfNoDocument ) const
{
	TiXmlDocument* doc = GetTiXmlPointer()->GetDocument();
	if ( 0 == doc )
	{
		if( throwIfNoDocument )
		{
			TICPPTHROW( "This node (" << Value() << ") is not linked under a document" )
		}
		else
		{
			return 0;
		}
	}
	Document* temp = new Document( doc );
	doc->m_spawnedWrappers.push_back( temp );

	return temp;
}

bool Node::NoChildren() const
{
	return GetTiXmlPointer()->NoChildren();
}

Document* Node::ToDocument() const
{
	TiXmlDocument* doc = GetTiXmlPointer()->ToDocument();
	if ( 0 == doc )
	{
		TICPPTHROW( "This node (" << Value() << ") is not a Document" )
	}
	Document* temp = new Document( doc );
	doc->m_spawnedWrappers.push_back( temp );

	return temp;
}

Element* Node::ToElement() const
{
	TiXmlElement* doc = GetTiXmlPointer()->ToElement();
	if ( 0 == doc )
	{
		TICPPTHROW( "This node (" << Value() << ") is not a Element" )
	}
	Element* temp = new Element( doc );
	doc->m_spawnedWrappers.push_back( temp );

	return temp;
}

Comment* Node::ToComment() const
{
	TiXmlComment* doc = GetTiXmlPointer()->ToComment();
	if ( 0 == doc )
	{
		TICPPTHROW( "This node (" << Value() << ") is not a Comment" )
	}
	Comment* temp = new Comment( doc );
	doc->m_spawnedWrappers.push_back( temp );

	return temp;
}

Text* Node::ToText() const
{
	TiXmlText* doc = GetTiXmlPointer()->ToText();
	if ( 0 == doc )
	{
		TICPPTHROW( "This node (" << Value() << ") is not a Text" )
	}
	Text* temp = new Text( doc );
	doc->m_spawnedWrappers.push_back( temp );

	return temp;
}

Declaration* Node::ToDeclaration() const
{
	TiXmlDeclaration* doc = GetTiXmlPointer()->ToDeclaration();
	if ( 0 == doc )
	{
		TICPPTHROW( "This node (" << Value() << ") is not a Declaration" )
	}
	Declaration* temp = new Declaration( doc );
	doc->m_spawnedWrappers.push_back( temp );

	return temp;
}

StylesheetReference* Node::ToStylesheetReference() const
{
	TiXmlStylesheetReference* doc = GetTiXmlPointer()->ToStylesheetReference();
	if ( 0 == doc )
	{
		TICPPTHROW( "This node (" << Value() << ") is not a StylesheetReference" )
	}
	StylesheetReference* temp = new StylesheetReference( doc );
	doc->m_spawnedWrappers.push_back( temp );

	return temp;
}

std::auto_ptr< Node > Node::Clone() const
{
	TiXmlNode* node = GetTiXmlPointer()->Clone();
	if ( 0 == node )
	{
		TICPPTHROW( "Node could not be cloned" );
	}
	std::auto_ptr< Node > temp( NodeFactory( node, false, false ) );

	// Take ownership of the memory from TiXml
	temp->m_impRC->InitRef();

	return temp;
}

bool Node::Accept( TiXmlVisitor* visitor ) const
{
	return GetTiXmlPointer()->Accept( visitor );
}

//*****************************************************************************

Comment::Comment()
: NodeImp< TiXmlComment >( new TiXmlComment() )
{
	m_impRC->InitRef();
}

Comment::Comment( TiXmlComment* comment )
: NodeImp< TiXmlComment >( comment )
{
}

Comment::Comment( const std::string& comment )
: NodeImp< TiXmlComment >( new TiXmlComment() )
{
	m_impRC->InitRef();
	m_tiXmlPointer->SetValue( comment );
}

//*****************************************************************************

Text::Text()
: NodeImp< TiXmlText >( new TiXmlText("") )
{
	m_impRC->InitRef();
}


Text::Text( const std::string& value )
: NodeImp< TiXmlText >( new TiXmlText( value ) )
{
	m_impRC->InitRef();
}

Text::Text( TiXmlText* text )
: NodeImp< TiXmlText >( text )
{
}


//*****************************************************************************

Document::Document()
: NodeImp< TiXmlDocument >( new TiXmlDocument() )
{
	m_impRC->InitRef();
}

Document::Document( TiXmlDocument* document )
: NodeImp< TiXmlDocument >( document )
{
}

Document::Document( const char* documentName )
: NodeImp< TiXmlDocument >( new TiXmlDocument( documentName ) )
{
	m_impRC->InitRef();
}

Document::Document( const std::string& documentName )
: NodeImp< TiXmlDocument >( new TiXmlDocument( documentName ) )
{
	m_impRC->InitRef();
}

void Document::LoadFile( TiXmlEncoding encoding )
{
	if ( !m_tiXmlPointer->LoadFile( encoding ) )
	{
		TICPPTHROW( "Couldn't load " << m_tiXmlPointer->Value() );
	}
}

void Document::SaveFile( void ) const
{
	if ( !m_tiXmlPointer->SaveFile() )
	{
		TICPPTHROW( "Couldn't save " << m_tiXmlPointer->Value() );
	}
}

void Document::LoadFile( const std::string& filename, TiXmlEncoding encoding )
{
	if ( !m_tiXmlPointer->LoadFile( filename.c_str(), encoding ) )
	{
		TICPPTHROW( "Couldn't load " << filename );
	}
}

void Document::LoadFile( const char* filename, TiXmlEncoding encoding )
{
	if ( !m_tiXmlPointer->LoadFile( filename, encoding ) )
	{
		TICPPTHROW( "Couldn't load " << filename );
	}
}

void Document::SaveFile( const std::string& filename ) const
{
	if ( !m_tiXmlPointer->SaveFile( filename.c_str() ) )
	{
		TICPPTHROW( "Couldn't save " << filename );
	}
}

void Document::Parse( const std::string& xml, bool throwIfParseError, TiXmlEncoding encoding )
{
	m_tiXmlPointer->Parse( xml.c_str(), 0, encoding );
	if( throwIfParseError && m_tiXmlPointer->Error() )
	{
		TICPPTHROW( "Error parsing xml." );
	}
}

//*****************************************************************************

Element::Element()
: NodeImp< TiXmlElement >( new TiXmlElement( "DefaultValueCausedByCreatingAnElementWithNoParameters" ) )
{
	m_impRC->InitRef();
}

Element::Element( const std::string& value )
: NodeImp< TiXmlElement >( new TiXmlElement( value ) )
{
	m_impRC->InitRef();
}

Element::Element( const char* value )
: NodeImp< TiXmlElement >( new TiXmlElement( value ) )
{
	m_impRC->InitRef();
}

Element::Element( TiXmlElement* element )
: NodeImp< TiXmlElement >( element )
{
}

Attribute* Element::FirstAttribute( bool throwIfNoAttributes ) const
{
	ValidatePointer();
	TiXmlAttribute* attribute = m_tiXmlPointer->FirstAttribute();
	if ( ( 0 == attribute ) && throwIfNoAttributes )
	{
		TICPPTHROW( "This Element (" << Value() << ") has no attributes" )
	}

	if ( 0 == attribute )
	{
		if( throwIfNoAttributes )
		{
			TICPPTHROW( "Element (" << Value() << ") has no attributes" )
		}
		else
		{
			return 0;
		}
	}

	Attribute* temp = new Attribute( attribute );
	attribute->m_spawnedWrappers.push_back( temp );

	return temp;
}

Attribute* Element::LastAttribute( bool throwIfNoAttributes ) const
{
	ValidatePointer();
	TiXmlAttribute* attribute = m_tiXmlPointer->LastAttribute();
	if ( ( 0 == attribute ) && throwIfNoAttributes )
	{
		TICPPTHROW( "This Element (" << Value() << ") has no attributes" )
	}

	if ( 0 == attribute )
	{
		if( throwIfNoAttributes )
		{
			TICPPTHROW( "Element (" << Value() << ") has no attributes" )
		}
		else
		{
			return 0;
		}
	}

	Attribute* temp = new Attribute( attribute );
	attribute->m_spawnedWrappers.push_back( temp );

	return temp;
}

std::string Element::GetAttributeOrDefault( const std::string& name, const std::string& defaultValue ) const
{
	std::string value;
	if ( !GetAttributeImp( name, &value ) )
	{
		return defaultValue;
	}
	return value;
}

std::string Element::GetAttribute( const std::string& name ) const
{
	return GetAttributeOrDefault( name, std::string() );
}

bool Element::HasAttribute( const std::string& name ) const
{
	ValidatePointer();
	return ( 0 != m_tiXmlPointer->Attribute( name.c_str() ) );
}

void Element::RemoveAttribute( const std::string& name )
{
	ValidatePointer();
	m_tiXmlPointer->RemoveAttribute( name.c_str() );
}

bool Element::GetAttributeImp( const std::string& name, std::string* value ) const
{
	ValidatePointer();

	// Get value from TinyXML, if the attribute exists
	const char* retVal = m_tiXmlPointer->Attribute( name.c_str() );

	// TinyXML returns NULL if the attribute doesn't exist
	if ( 0 == retVal )
	{
		return false;
	}
	else
	{
		*value = retVal;
		return true;
	}
}

bool Element::GetTextImp( std::string* value ) const
{
	ValidatePointer();

	// Get value from TinyXML, if the attribute exists
	const char* retVal = m_tiXmlPointer->GetText();

	// TinyXML returns NULL if the attribute doesn't exist
	if ( 0 == retVal )
	{
		return false;
	}
	else
	{
		*value = retVal;
		return true;
	}
}

//*****************************************************************************

Declaration::Declaration()
: NodeImp< TiXmlDeclaration >( new TiXmlDeclaration() )
{
	m_impRC->InitRef();
}

Declaration::Declaration( TiXmlDeclaration* declaration )
: NodeImp< TiXmlDeclaration >( declaration )
{
}

Declaration::Declaration( const std::string& version, const std::string& encoding, const std::string& standalone )
: NodeImp< TiXmlDeclaration >( new TiXmlDeclaration( version, encoding, standalone ) )
{
	m_impRC->InitRef();
}

std::string Declaration::Version() const
{
	return m_tiXmlPointer->Version();
}

std::string Declaration::Encoding() const
{
	return m_tiXmlPointer->Encoding();
}

std::string Declaration::Standalone() const
{
	return m_tiXmlPointer->Standalone();
}

//*****************************************************************************

StylesheetReference::StylesheetReference()
: NodeImp< TiXmlStylesheetReference >( new TiXmlStylesheetReference() )
{
	m_impRC->InitRef();
}

StylesheetReference::StylesheetReference( TiXmlStylesheetReference* stylesheetReference )
: NodeImp< TiXmlStylesheetReference >( stylesheetReference )
{
}

StylesheetReference::StylesheetReference( const std::string& type, const std::string& href )
: NodeImp< TiXmlStylesheetReference >( new TiXmlStylesheetReference( type, href ) )
{
	m_impRC->InitRef();
}

std::string StylesheetReference::Type() const
{
	return m_tiXmlPointer->Type();
}

std::string StylesheetReference::Href() const
{
	return m_tiXmlPointer->Href();
}

//*****************************************************************************

Exception::Exception(const std::string &details)
:
m_details( details )
{

}

Exception::~Exception() throw()
{
}

const char* Exception::what() const throw()
{
	return m_details.c_str();
}

//*****************************************************************************

TiCppRC::TiCppRC()
{
	// Spawn reference counter for this object
	m_tiRC = new TiCppRCImp( this );
}

void TiCppRC::DeleteSpawnedWrappers()
{
	std::vector< Base* >::reverse_iterator wrapper;
	for ( wrapper = m_spawnedWrappers.rbegin(); wrapper != m_spawnedWrappers.rend(); ++wrapper )
	{
		delete *wrapper;
	}
	m_spawnedWrappers.clear();
}
		
TiCppRC::~TiCppRC()
{	
	DeleteSpawnedWrappers();
	
	// Set pointer held by reference counter to NULL
	this->m_tiRC->Nullify();

	// Decrement reference - so reference counter will delete itself if necessary
	this->m_tiRC->DecRef();
}

//*****************************************************************************

TiCppRCImp::TiCppRCImp( TiCppRC* tiCppRC )
	: m_count( 1 ), m_tiCppRC ( tiCppRC )
{
}

void TiCppRCImp::IncRef()
{
	m_count++;
}

void TiCppRCImp::DecRef()
{
	m_count--;
	if ( 0 == m_count )
	{
		delete m_tiCppRC;
		delete this;
	}
}

void TiCppRCImp::InitRef()
{
	m_count = 1;
}

void TiCppRCImp::Nullify()
{
	m_tiCppRC = 0;
}

TiCppRC* TiCppRCImp::Get()
{
	return m_tiCppRC;
}

bool TiCppRCImp::IsNull()
{
	return 0 == m_tiCppRC;
}

#endif // TIXML_USE_TICPP
/*
http://code.google.com/p/ticpp/
Copyright (c) 2006 Ryan Pusztai, Ryan Mulder

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/**
@copydoc ticpp
@file
@author		Ryan Pusztai
@author		Ryan Mulder
@date		04/11/2006

@version	0.04a by edam@waxworlds.org: based Exception based on std::exception; added stream
					<< and >> support; added Document::Parse(); bug fix; improved THROW() macro.
@version	0.04 Added NodeImp class. Also made all the classes inherit from NodeImp.
@version	0.03 Added Declaration class
@version	0.02 Added Element class
@version	0.01 Added Exception class, Document class

@todo add UNKNOWN support. See ticpp::NodeFactory.
@todo add TYPECOUNT support. See ticpp::NodeFactory.
@todo Add a quick reference
*/
#ifdef TIXML_USE_TICPP

#ifndef TICPP_INCLUDED
#define TICPP_INCLUDED

#include "tinyxml.h"
#include <sstream>
#include <vector>
#include <memory>
#include <exception>
#include <typeinfo>

/**
@subpage ticpp is a TinyXML wrapper that uses a lot more C++ ideals.
It throws exceptions, uses templates, is in its own name space, and
<b>requires</b> STL (Standard Template Library). This is done to ease the use
of getting values in and out of the xml.

If you don't perfer to use some of the concepts just don't use it.
It is just a wrapper that extends TinyXML. It doesn't actually change
any of TinyXML.
*/
namespace ticpp
{
    /**
	This is a ticpp exception class
	*/
	class Exception : public std::exception
	{
	public:
		/**
		Construct an exception with a message
		*/
		Exception( const std::string& details );
		~Exception() throw();

		/// Override std::exception::what() to return m_details
		const char* what() const throw();

		std::string m_details; /**< Exception Details */
	};

	/**
	This allows you to stream your exceptions in.
	It will take care of the conversion	and throwing the exception.
	*/
	#define TICPPTHROW( message ) 											\
	{																		\
		std::ostringstream full_message;									\
		std::string file( __FILE__ );										\
		file = file.substr( file.find_last_of( "\\/" ) + 1 );				\
		full_message << message << " <" << file << "@" << __LINE__ << ">";	\
		full_message << BuildDetailedErrorString();							\
		throw Exception( full_message.str() );								\
	}

	// Forward Declarations for Visitor, and others.
	class Document;
	class Element;
	class Declaration;
	class StylesheetReference;
	class Text;
	class Comment;
	class Attribute;

	/** Wrapper around TiXmlVisitor */
	class Visitor : public TiXmlVisitor
	{
	public:
		// Overload the TiXmlVisitor functions, wrap objects, call ticpp::Visitor functions
		/// @internal
		virtual bool VisitEnter( const TiXmlDocument& doc );
		/// @internal
		virtual bool VisitExit( const TiXmlDocument& doc );
		/// @internal
		virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
		/// @internal
		virtual bool VisitExit( const TiXmlElement& element );
		/// @internal
		virtual bool Visit( const TiXmlDeclaration& declaration );
		/// @internal
		virtual bool Visit( const TiXmlStylesheetReference& stylesheet );
		/// @internal
		virtual bool Visit( const TiXmlText& text );
		/// @internal
		virtual bool Visit( const TiXmlComment& comment );

	public:
		/// Visit a document.
		virtual bool VisitEnter( const Document& /*doc*/ )			{ return true; }
		/// Visit a document.
		virtual bool VisitExit( const Document& /*doc*/ )			{ return true; }

		/// Visit an element.
		virtual bool VisitEnter( const Element& /*element*/, const Attribute* /*firstAttribute*/ )	{ return true; }
		/// Visit an element.
		virtual bool VisitExit( const Element& /*element*/ )		{ return true; }

		/// Visit a declaration
		virtual bool Visit( const Declaration& /*declaration*/ )	{ return true; }
		/// Visit a stylesheet reference
		virtual bool Visit( const StylesheetReference& /*stylesheet*/ )	{ return true; }
		/// Visit a text node
		virtual bool Visit( const Text& /*text*/ )					{ return true; }
		/// Visit a comment node
		virtual bool Visit( const Comment& /*comment*/ )			{ return true; }
	};

	/** Wrapper around TiXmlBase */
	class Base
	{
	public:

		/**
		Converts any class with a proper overload of the << opertor to a std::string
		@param value The value to be converted
		@throws Exception When value cannot be converted to a std::string
		*/
		template < class T >
			std::string ToString( const T& value ) const
		{
			std::stringstream convert;
			convert << value;
			if ( convert.fail() )
			{
				TICPPTHROW( "Could not convert value to text" );
			}
			return convert.str();
		}

		std::string ToString( const std::string& value ) const
		{
			return value;
		}

		/**
		Converts a std::string to any class with a proper overload of the >> opertor
		@param temp			The string to be converted
		@param out	[OUT]	The container for the returned value
		@throws Exception When temp cannot be converted to the target type
		*/
		template < class T >
			void FromString( const std::string& temp, T* out ) const
		{
			std::istringstream val( temp );
			val >> *out;

			if ( val.fail() )
			{
				TICPPTHROW( "Could not convert \"" << temp << "\" to target type" );
			}
		}

		/**
		Specialization for std::string
		*/
		void FromString( const std::string& temp, std::string* out ) const
		{
			*out = temp;
		}

		/**
		Return the position, in the original source file, of this node or attribute.
		Wrapper around TiXmlBase::Row()
		*/
		int Row() const
		{
			return GetBasePointer()->Row();
		}

		/**
		Return the position, in the original source file, of this node or attribute.
		Wrapper around TiXmlBase::Row()
		*/
		int Column() const
		{
			return GetBasePointer()->Column();
		}

		/**
		Compare internal TiXml pointers to determine is both are wrappers around the same node
		*/
		bool operator == ( const Base& rhs ) const
		{
			return ( GetBasePointer() == rhs.GetBasePointer() );
		}
		
		/**
		Compare internal TiXml pointers to determine is both are wrappers around the same node
		*/
		bool operator != ( const Base& rhs ) const
		{
			return ( GetBasePointer() != rhs.GetBasePointer() );
		}
		
		/**
		Builds detailed error string using TiXmlDocument::Error() and others
		*/
		std::string BuildDetailedErrorString() const
		{
			std::ostringstream full_message;
			#ifndef TICPP_NO_RTTI
			TiXmlNode* node = dynamic_cast< TiXmlNode* >( GetBasePointer() );
			if ( node != 0 )
			{
				TiXmlDocument* doc = node->GetDocument();
				if ( doc != 0 )
				{
					if ( doc->Error() )
					{
						full_message 	<< "\nDescription: " << doc->ErrorDesc()
										<< "\nFile: " << (strlen( doc->Value() ) > 0 ? doc->Value() : "<unnamed-file>") 
										<< "\nLine: " << doc->ErrorRow() 
										<< "\nColumn: " << doc->ErrorCol();
					}
				}
			}
			#endif
			return full_message.str();
		}

		/**
		Destructor
		*/
		virtual ~Base()
		{
		}

	protected:
		mutable TiCppRCImp* m_impRC;	/**< Holds status of internal TiXmlPointer - use this to determine if object has been deleted already */

		/**
		@internal
		Updates the pointer to the reference counter to point at the counter in the new node.

		@param node TiXmlBase containing the new reference counter
		*/
		void SetImpRC( TiXmlBase* node )
		{
			m_impRC = node->m_tiRC;
		}

		void ValidatePointer() const
		{
			if ( m_impRC->IsNull() )
			{
				TICPPTHROW( "Internal TiXml Pointer is NULL" );
			}
		}		

		/**
		@internal
		Get internal TiXmlBase*
		*/
		virtual TiXmlBase* GetBasePointer() const = 0;
	};

	/**
	Wrapper around TiXmlAttribute
	*/
	class Attribute : public Base
	{
	private:
		TiXmlAttribute* m_tiXmlPointer;
		TiXmlBase* GetBasePointer() const
		{
			ValidatePointer();
			return m_tiXmlPointer;
		}

	public:
		/**
		Construct an empty attribute.
		*/
		Attribute();

		/**
		Construct an attribute with @a name and @a value

		@param name The name of the attribute
		@param value The value of the attribute
		*/
		Attribute( const std::string& name, const std::string& value );

		/**
		@internal
		Construct an attribute with the internal pointer

		@param attribute The internal pointer
		*/
		Attribute( TiXmlAttribute* attribute );

		/**
		Get the value of this attribute
		Uses Base::FromString to convert TiXmlAttribute::ValueStr from a std::string,
		and puts it in the passed pointer.

		@param value [OUT] A pointer to fill with the value
		*/
		template < class T >
			void GetValue( T* value ) const
		{
			ValidatePointer();
			FromString( m_tiXmlPointer->ValueStr(), value );
		}

		/**
		Get the value of this attribute.
		Simple wrapper for TiXmlAttribute::ValueStr.

		@see GetValue
		*/
		std::string Value() const;

		/**
		Set the value of this node.
		Uses Base::ToString to convert value to a std::string, then calls TiXmlAttribute::SetValue.

		@param value The value to set
		*/
		template < class T >
			void SetValue( const T& value )
		{
			ValidatePointer();
			m_tiXmlPointer->SetValue( ToString( value ) );
		}

		/**
		Get the value of this attribute
		Uses Base::FromString to convert TiXmlAttribute::Name from a std::string,
		and puts it in the passed pointer.

		@param name [OUT] A pointer to fill with the name
		*/
		template < class T >
			void GetName( T* name ) const
		{
			ValidatePointer();
			FromString( m_tiXmlPointer->Name(), name );
		}

		/**
		Get the value of this attribute.
		Simple wrapper for TiXmlAttribute::Name.

		@see GetName
		*/
		std::string Name() const;

		/**
		Set the value of this attribute.
		Uses Base::ToString to convert @a name to a std::string, then calls TiXmlAttribute::SetName.

		@param name The name to set
		*/
		template < class T >
			void SetName( const T& name )
		{
			ValidatePointer();
			m_tiXmlPointer->SetName( ToString( name ) );
		}

		/**
		@internal
		Updates the reference count for the old and new pointers.
		*/
		void operator=( const Attribute& copy );

		/**
		@internal
		Updates the reference count for the old and new pointers.
		*/
		Attribute( const Attribute& copy );

		/*
		Decrements reference count.
		*/
		~Attribute();

		/**
		Get the next sibling attribute in the DOM.
		*/
		Attribute* Next( bool throwIfNoAttribute = true ) const;

		/**
		Get the previous sibling attribute in the DOM.
		*/
		Attribute* Previous( bool throwIfNoAttribute = true ) const;

		/**
		@internal
		Just for Iterator<>

		@param next [OUT] The pointer to the next valid attribute
		@return true if there is a next attribute, false if not
		*/
		void IterateNext( const std::string&, Attribute** next ) const;

		/**
		@internal
		Just for Iterator<>

		@param previous [OUT] The pointer to the previous valid attribute
		@return true if there is a previous attribute, false if not
		*/
		void IteratePrevious( const std::string&, Attribute** previous ) const;

		/**
		All TinyXml classes can print themselves to a filestream.
		*/
		virtual void Print( FILE* file, int depth ) const;

	private:

		/**
		@internal
		Sets the internal pointer.
		Saves a copy of the pointer to the RC object.

		@param newPointer TiXmlAttribute* to set.
		*/
		void SetTiXmlPointer( TiXmlAttribute* newPointer );
	};

	/**
	Wrapper around TiXmlNode
	*/
	class Node : public Base
	{
	public:

		/**
		Get the value of this node
		Uses Base::FromString to convert TiXmlNode::ValueStr from a std::string,
		and puts it in the passed pointer.

		@param value [OUT] A pointer to fill with the value
		*/
		template < class T >
			void GetValue( T* value) const
		{
			FromString( GetTiXmlPointer()->ValueStr(), value );
		}

		/**
		Get the value of this node.
		Simple wrapper for TiXmlNode::ValueStr.

		@see GetValue
		*/
		std::string Value() const;

		/**
		Set the value of this node.
		Uses Base::ToString to convert value to a std::string, then calls TiXmlNode::SetValue.

		@param value The value to set
		*/
		template < class T >
			void SetValue( const T& value )
		{
			GetTiXmlPointer()->SetValue( ToString( value ) );
		}

		/**
		Clear all Nodes below this.
		Simple wrapper for TiXmlNode::Clear.
		*/
		void Clear();

		/**
		The Parent of this Node.
		Simple wrapper for TiXmlNode::Parent.

		@param throwIfNoParent [DEF] If true, throws when Parent = NULL.
		@return The parent of this node, NULL if there is no Parent.
		@throws Exception When throwIfNoParent is true, and TiXmlNode::Parent returns Null.
		*/
		Node* Parent( bool throwIfNoParent = true ) const;

		/**
		The first child of this node.

		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no children.
		@return Pointer to child, Null if no children and 'throwIfNoChildren' is false.
		@throws Exception When throwIfNoChildren is true, and TiXmlNode::FirstChild returns Null.

		@see TiXmlNode::FirstChild
		*/
		Node* FirstChild( bool throwIfNoChildren = true ) const;

		/**
		@internal
		The first child of this node with the matching @a value.

		@overload
		@param value				Value to match.
		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.

		@see FirstChild( bool throwIfNoChildren = true )
		*/
		Node* FirstChild( const char* value, bool throwIfNoChildren = true ) const;

		/**
		The first child of this node with the matching @a value.

		@overload
		@param value				Value to match.
		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.

		@see FirstChild( const char* value, bool throwIfNoChildren = true )
		*/
		Node* FirstChild( const std::string& value, bool throwIfNoChildren = true ) const;

		/**
		The last child of this node.

		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no children.
		@return Pointer to child, Null if no children and 'throwIfNoChildren' is false.
		@throws Exception When throwIfNoChildren is true, and TiXmlNode::LastChild returns Null.

		@see TiXmlNode::LastChild
		*/
		Node* LastChild( bool throwIfNoChildren = true ) const;

		/**
		@internal
		The last child of this node with the matching @a value.

		@overload
		@param value				Value to match.
		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.

		@see LastChild( bool throwIfNoChildren = true )
		*/
		Node* LastChild( const char* value, bool throwIfNoChildren = true ) const;

		/**
		The last child of this node with the matching @a value.

		@overload
		@param value				Value to match.
		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.

		@see LastChild( const char* value, bool throwIfNoChildren = true )
		*/
		Node* LastChild( const std::string& value, bool throwIfNoChildren = true ) const;

		/**
		An alternate way to walk the children of a node.
		Simple wrapper for TiXmlNode::IterateChildren.

		@param previous The previous Node* that was returned from IterateChildren.
		@return NULL When there are no more children.
		*/
		Node* IterateChildren( Node* previous ) const;

		/**
		This flavor of IterateChildren searches for children with a particular @a value.
		Simple wrapper for TiXmlNode::IterateChildren.

		@param value	The value you want to search for.
		@param previous The previous Node* that was returned from IterateChildren.
		@return NULL When there are no more children.
		*/
		Node* IterateChildren( const std::string& value, Node* previous ) const;

		/**
		Adds a child past the LastChild.
		Throws if you try to insert a document.

		@note This takes a copy of @a addThis so it is not as efficiant as LinkEndChild.
		@param addThis Node to insert.
		@throws Exception When TiXmlNode::InsertEndChild returns Null

		@see LinkEndChild
		@see TiXmlNode::InsertEndChild
		*/
		Node* InsertEndChild( const Node& addThis );

		/**
		Adds a child past the LastChild.
		Throws if you try to link a document.

		@param childNode Node to link.
		@throws Exception When TiXmlNode::LinkEndChild returns Null.

		@see InsertEndChild
		@see TiXmlNode::LinkEndChild
		*/
		Node* LinkEndChild( Node* childNode );

		/**
		Adds a child before the specified child.
		Throws if you try to insert a document.

		@param beforeThis	Node that will have @a addThis linked before.
		@param addThis		Node to insert before.
		@throws Exception When TiXmlNode::InsertBeforeChild returns Null.

		@see InsertAfterChild
		@see TiXmlNode::InsertBeforeChild
		*/
		Node* InsertBeforeChild( Node* beforeThis, const Node& addThis );

		/**
		Adds a child after the specified child.
		Throws if you try to insert a document.

		@param afterThis	Node that will have @a addThis linked after.
		@param addThis		Node to insert after.
		@throws Exception When TiXmlNode::InsertAfterChild returns Null.

		@see InsertBeforeChild
		@see TiXmlNode::InsertAfterChild
		*/
		Node* InsertAfterChild( Node* afterThis, const Node& addThis );

		/**
		Replace a child of this node.
		Throws if you try to replace with a document.

		@param replaceThis	Node to replace.
		@param withThis		Node that is replacing @a replaceThis.
		@throws Exception When TiXmlNode::ReplaceChild returns Null.

		@see TiXmlNode::ReplaceChild
		*/
		Node* ReplaceChild( Node* replaceThis, const Node& withThis );

		/**
		Delete a child of this node.

		@param removeThis Node to delete.
		@throws Exception When removeThis is not a child of this Node.

		@see TiXmlNode::RemoveChild
		*/
		void RemoveChild( Node* removeThis );

		/**
		Navigate to a sibling node.
		Wrapper around TiXmlNode::PreviousSibling.

		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
		@return Pointer to sibling, Null if no siblings and 'throwIfNoSiblings' is false.
		@throws Exception When TiXmlNode::PreviousSibling returns Null and 'throwIfNoSiblings' is true.
		*/
		Node* PreviousSibling( bool throwIfNoSiblings = true ) const;

		/**
		Navigate to a sibling node with the given @a value.

		@overload
		@param value The value of the node to look for.
		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.

		@see PreviousSibling( bool throwIfNoSiblings )
		*/
		Node* PreviousSibling( const std::string& value, bool throwIfNoSiblings = true ) const;

		/**
		@internal
		Navigate to a sibling node with the given @a value.

		@overload
		@param value The value of the node to look for.
		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.

		@see PreviousSibling( const std::string& value, bool throwIfNoSiblings )
		*/
		Node* PreviousSibling( const char* value, bool throwIfNoSiblings = true ) const;

		/**
		Navigate to a sibling node.
		Wrapper around TiXmlNode::NextSibling.

		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
		@return Pointer to sibling, Null if no siblings and 'throwIfNoSiblings' is false.
		@throws Exception When TiXmlNode::NextSibling returns Null and 'throwIfNoSiblings' is true.
		*/
		Node* NextSibling( bool throwIfNoSiblings = true ) const;

		/**
		Navigate to a sibling node with the given @a value.

		@overload
		@param value The value of the node to look for.
		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.

		@see NextSibling( bool throwIfNoSiblings )
		*/
		Node* NextSibling( const std::string& value, bool throwIfNoSiblings = true ) const;

		/**
		@internal
		Navigate to a sibling node with the given @a value.

		@overload
		@param value The value of the node to look for.
		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.

		@see NextSibling( const std::string& value, bool throwIfNoSiblings )
		*/
		Node* NextSibling( const char* value, bool throwIfNoSiblings = true ) const;

		/**
		@internal
		Just for Iterator<>

		@param value The value of nodes to iterate through
		@param next [OUT] The pointer to the first valid node
		*/
		template < class T >
			void IterateFirst( const std::string& value, T** first ) const
		{
			*first = 0;
			for( Node* child = FirstChild( value, false ); child; child = child->NextSibling( value, false ) )
			{
				*first = dynamic_cast< T* >( child );
				if ( 0 != *first )
				{
					return;
				}
			}
		}

		virtual	void IterateFirst( const std::string&, Attribute** ) const
		{
			TICPPTHROW( "Attributes can only be iterated with Elements." )
		}

		/**
		@internal
		Just for Iterator<>

		@param value The value of nodes to iterate through
		@param next [OUT] The pointer to the next valid node
		*/
		template < class T >
			void IterateNext( const std::string& value, T** next ) const
		{
			Node* sibling = NextSibling( value, false );
			*next = dynamic_cast< T* >( sibling );

			while ( ( 0 != sibling ) && ( 0 == *next ) )
			{
				sibling = sibling->NextSibling( value, false );
				*next = dynamic_cast< T* >( sibling );
			}
		}

		/**
		@internal
		Just for Iterator<>

		@param value The value of nodes to iterate through
		@param previous [OUT] The pointer to the previous valid node
		*/
		template < class T >
			void IteratePrevious( const std::string& value, T** previous  ) const
		{
			Node* sibling = PreviousSibling( value, false );
			*previous = dynamic_cast< T* >( sibling );

			while ( ( 0 != sibling ) && ( 0 == *previous ) )
			{
				sibling = sibling->PreviousSibling( value, false );
				*previous = dynamic_cast< T* >( sibling );
			}
		}

		/**
		Navigate to a sibling element.
		Wrapper around TiXmlNode::NextSibling.

		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no sibling element.
		@return Pointer to sibling, Null if no siblings and 'throwIfNoSiblings' is false.
		@throws Exception When TiXmlNode::NextSibling returns Null and 'throwIfNoSiblings' is true.
		*/
		Element* NextSiblingElement( bool throwIfNoSiblings = true ) const;

		/**
		Navigate to a sibling element with the given @a value.

		@overload
		@param value The value of the element to look for.
		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no sibling elements.
		@see NextSiblingElement( bool throwIfNoSiblings )
		*/
		Element* NextSiblingElement( const std::string& value, bool throwIfNoSiblings = true ) const;

		/**
		@internal
		Navigate to a sibling element with the given @a value.

		@overload
		@param value The value of the element to look for.
		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no sibling elements.

		@see NextSiblingElement( const std::string& value, bool throwIfNoSiblings )
		*/
		Element* NextSiblingElement( const char* value, bool throwIfNoSiblings = true ) const;

		/**
		The first child element of this node.

		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no element children.
		@return Pointer to child, Null if no element children and 'throwIfNoChildren' is false.
		@throws Exception When throwIfNoChildren is true, and TiXmlNode::FirstChildElement returns Null.

		@see TiXmlNode::FirstChildElement
		*/
		Element* FirstChildElement( bool throwIfNoChildren = true ) const;

		/**
		@internal
		The first child element of this node with the matching @a value.

		@overload
		@param value Value to match.
		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no element children.

		@see FirstChildElement( bool throwIfNoChildren = true )
		*/
		Element* FirstChildElement( const char* value, bool throwIfNoChildren = true ) const;

		/**
		The first child element of this node with the matching @a value.

		@overload
		@param value Value to match.
		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no element children.

		@see FirstChildElement( const char* value, bool throwIfNoChildren = true )
		*/
		Element* FirstChildElement( const std::string& value, bool throwIfNoChildren = true ) const;

		/**
		Query the type (as TiXmlNode::NodeType ) of this node.
		*/
		int Type() const;

		/**
		Return a pointer to the Document this node lives in.

		@param throwIfNoDocument [DEF] If true, will throw an exception if this node is not linked under a Document.
		@return A pointer to the Document this node lives in, NULL if not linked under a Document, and 'throwIfNoDocument' is false.
		@throws Exception When this node is not linked under a Document and 'throwIfNoDocument' is true.
		*/
		Document* GetDocument( bool throwIfNoDocument = true ) const;

		/**
		Check if this node has no children.

		@return true if this node has no children.
		*/
		bool NoChildren() const;

		#ifndef TICPP_NO_RTTI
		/**
		Pointer conversion ( NOT OBJECT CONVERSION ) - replaces TiXmlNode::ToElement, TiXmlNode::ToDocument, TiXmlNode::ToComment, etc.

		@throws Exception When the target is not an object of class T
		@warning Some ancient compilers do not support explicit specification of member template arguments, which this depends on ( e.g. VC6 ).
		*/
		template < class T >
			T* To() const
		{
			T* pointer = dynamic_cast< T* >( this );
			if ( 0 == pointer )
			{
				std::string thisType = typeid( this ).name();
				std::string targetType = typeid( T ).name();
				std::string thatType = typeid( *this ).name();
				TICPPTHROW( "The " << thisType.substr( 6 ) << " could not be casted to a " << targetType.substr( 6 )
					<< " *, because the target object is not a " << targetType.substr( 6 ) << ". (It is a " << thatType.substr( 6 ) << ")" );
			}
			return pointer;
		}
		#endif

		/**
		Pointer conversion - replaces TiXmlNode::ToDocument.

		@throws Exception When this node is not a Document.
		*/
		Document* ToDocument() const;

		/**
		Pointer conversion - replaces TiXmlNode::ToElement.

		@throws Exception When this node is not a Element.
		*/
		Element* ToElement() const;

		/**
		Pointer conversion - replaces TiXmlNode::ToComment.

		@throws Exception When this node is not a Comment.
		*/
		Comment* ToComment() const;

		/**
		Pointer conversion - replaces TiXmlNode::ToText.

		@throws Exception When this node is not a Text.
		*/
		Text* ToText() const;

		/**
		Pointer conversion - replaces TiXmlNode::ToDeclaration.

		@throws Exception When this node is not a Declaration.
		*/
		Declaration* ToDeclaration() const;

		/**
		Pointer conversion - replaces TiXmlNode::ToStylesheetReference.

		@throws Exception When this node is not a StylesheetReference.
		*/
		StylesheetReference* ToStylesheetReference() const;

		/**
		Create an exact duplicate of this node and return it.

		@note Using auto_ptr to manage the memory declared on the heap by TiXmlNode::Clone.
		@code
		// Now using clone
		ticpp::Document doc( "C:\\Test.xml" );
		ticpp::Node* sectionToClone;
		sectionToClone = doc.FirstChild( "settings" );
		std::auto_ptr< ticpp::Node > clonedNode = sectionToClone->Clone();
		// Now you can use the clone.
		ticpp::Node* node2 = clonedNode->FirstChildElement()->FirstChild();
		...
		// After the variable clonedNode goes out of scope it will automatically be cleaned up.
		@endcode
		@return Pointer the duplicate node.
		*/
		std::auto_ptr< Node > Clone() const;

		/**
		Accept a hierchical visit the nodes in the TinyXML DOM.
		@return The boolean returned by the visitor.
		*/
		bool Accept( TiXmlVisitor* visitor ) const;

		/**
 		Stream input operator.
 		*/
 		friend std::istream& operator >>( std::istream& in, Node& base )
 		{
 			in >> *base.GetTiXmlPointer();
 			return in;
 		}

 		/**
 		Stream output operator.
 		*/
 		friend std::ostream& operator <<( std::ostream& out, const Node& base )
 		{
 			out << *base.GetTiXmlPointer();
 			return out;
 		}

	protected:
		/**
		@internal
		Allows NodeImp to use Node*'s.
		*/
		virtual TiXmlNode* GetTiXmlPointer() const = 0;

		TiXmlBase* GetBasePointer() const
		{
			return GetTiXmlPointer();
		}

		/**
		@internal
		Constructs the correct child of Node, based on the Type of the TiXmlNode*.
		*/
		Node* NodeFactory( TiXmlNode* tiXmlNode, bool throwIfNull = true, bool rememberSpawnedWrapper = true ) const;

	};

	/** Iterator for conveniently stepping through Nodes and Attributes.
	TinyXML++ introduces iterators:
	@code
	ticpp::Iterator< ticpp::Node > child;
	for ( child = child.begin( parent ); child != child.end(); child++ )
	@endcode

	Iterators have the added advantage of filtering by type:
	@code
	// Only iterates through Comment nodes
	ticpp::Iterator< ticpp::Comment > child;
	for ( child = child.begin( parent ); child != child.end(); child++ )
	@endcode

	@code
	// Only iterates through Element nodes with value "ElementValue"
	ticpp::Iterator< ticpp::Element > child( "ElementValue" );
	for ( child = child.begin( parent ); child != child.end(); child++ )
	@endcode

	Finally, Iterators also work with Attributes
	@code
	ticpp::Iterator< ticpp::Attribute > attribute;
	for ( attribute = attribute.begin( element ); attribute != attribute.end(); attribute++ )
	@endcode
	*/
	template < class T = Node >
		class Iterator
	{
	private:
		T* m_p;					/**< Internal Pointer */
		std::string m_value;	/**< Value for NextSibling  calls */

	public:

		/**
		For for loop comparisons.
		@param parent The parent of the nodes to iterate.
		@return The first child of type T.
		@code
		ticpp::Iterator< ticpp::Node > child;
		for ( child = child.begin( parent ); child != child.end(); child++ )
		@endcode
		*/
		T* begin( const Node* parent ) const
		{
			T* pointer;
			parent->IterateFirst( m_value, &pointer );
			return pointer;
		}

		/**
		For for loop comparisons.
		@return NULL
		@code
		ticpp::Iterator< ticpp::Node > child;
		for ( child = child.begin( parent ); child != child.end(); child++ )
		@endcode
		*/
		T* end() const
		{
			return 0;
		}

		/** Constructor.
		@param value If not empty, this iterator will only visit nodes with matching value.
		@code
		// Only iterates through Element nodes with value "ElementValue"
		ticpp::Iterator< ticpp::Element > child( "ElementValue" );
		for ( child = child.begin( parent ); child != child.end(); child++ )
		@endcode
		*/
		Iterator( const std::string& value = "" )
			: m_p( 0 ), m_value( value )
		{
		}

		/// Constructor
		Iterator( T* node, const std::string& value = "" )
			: m_p( node ), m_value( value )
		{
		}

		/// Constructor
		Iterator( const Iterator& it )
			: m_p( it.m_p ), m_value( it.m_value )
		{
		}

		/**
		Gets internal pointer.
		@return The internal pointer.
		*/
		T* Get() const
		{
			return m_p;
		}

		/** Sets internal pointer */
		Iterator& operator=( const Iterator& it )
		{
			m_p = it.m_p;
			m_value = it.m_value;
			return *this;
		}

		/** Sets internal pointer */
		Iterator& operator=( T* p )
		{
			m_p = p;
			return *this;
		}

		/** Sets internal pointer to the Next Sibling, or Iterator::END, if there are no more siblings */
		Iterator& operator++()
		{
			m_p->IterateNext( m_value, &m_p );
			return *this;
		}

		/** Sets internal pointer to the Next Sibling, or Iterator::END, if there are no more siblings */
		Iterator operator++(int)
		{
			Iterator tmp(*this);
			++(*this);
			return tmp;
		}

		/** Sets internal pointer to the Previous Sibling, or Iterator::END, if there are no prior siblings */
		Iterator& operator--()
		{
			m_p->IteratePrevious( m_value, &m_p );
			return *this;
		}

		/** Sets internal pointer to the Previous Sibling, or Iterator::END, if there are no prior siblings */
		Iterator operator--(int)
		{			
			Iterator tmp(*this);
			--(*this);
			return tmp;
		}

		/** Compares internal pointer */
		bool operator!=( const T* p ) const
		{
			if ( m_p == p )
			{
				return false;
			}
			if ( 0 == m_p || 0 == p )
			{
				return true;
			}
			return *m_p != *p;
		}

		/** Compares internal pointer */
		bool operator!=( const Iterator& it ) const
		{
			return operator!=( it.m_p );
		}

		/** Compares internal pointer* */
		bool operator==( T* p ) const
		{
			if ( m_p == p )
			{
				return true;
			}
			if ( 0 == m_p || 0 == p )
			{
				return false;
			}
			return *m_p == *p;
		}

		/** Compares internal pointer */
		bool operator==( const Iterator& it ) const
		{
			return operator==( it.m_p );
		}

		/** So Iterator behaves like a STL iterator */
		T* operator->() const
		{
			return m_p;
		}

		/** So Iterator behaves like a STL iterator */
		T& operator*() const
		{
			return *m_p;
		}
	};

	/** Implementation of Node wrapper */
	template < class T >
		class NodeImp : public Node
	{
	protected:

		T* m_tiXmlPointer;		/**< Internal pointer to the TiXml Class which is being wrapped */

		/**
		@internal
		Gets the internal TinyXML pointer.

		@returns The internal TiXmlNode*.
		*/
		TiXmlNode* GetTiXmlPointer() const
		{
			ValidatePointer();
			return m_tiXmlPointer;
		}

		/**
		@internal
		Sets the internal pointer.
		Saves a copy of the pointer to the RC object.

		@param newPointer TiXmlNode* to set.
		*/
		void SetTiXmlPointer( T* newPointer )
		{
			m_tiXmlPointer = newPointer;
			SetImpRC( newPointer );
		}

		/**
		@internal
		Constructor used by child classes.
		*/
		NodeImp( T* tiXmlPointer )
		{
			// Check for NULL pointers
			if ( 0 == tiXmlPointer )
			{
				#ifdef TICPP_NO_RTTI
					TICPPTHROW( "Can not create TinyXML objext" );
				#else
					TICPPTHROW( "Can not create a " << typeid( T ).name() );
				#endif
			}
			SetTiXmlPointer( tiXmlPointer );
			m_impRC->IncRef();
		}

		/**
		@internal
		Updates the reference count for the old and new pointers.
		In addition, the spawnedWrappers must be cleared out before a new TiXml object is loaded in.
		*/
		virtual void operator=( const NodeImp<T>& copy )
		{
			// Dropping the reference to the old object
			this->m_impRC->DecRef();

			// Pointing to the new Object
			SetTiXmlPointer( copy.m_tiXmlPointer );

			// The internal tixml pointer changed in the above line
			this->m_impRC->IncRef();
		}

		/**
		@internal
		Updates the reference count for the old and new pointers.
		In addition, the spawnedWrappers must be cleared out before a new TiXml object is loaded in
		*/
		NodeImp( const NodeImp<T>& copy ) : Node( copy )
		{
			// Pointing to the new Object
			SetTiXmlPointer( copy.m_tiXmlPointer );

			// The internal tixml pointer changed in the above line
			this->m_impRC->IncRef();
		}

	public:

		/*
		Deletes the spawned wrapper objects.
		Decrements reference count.
		*/
		virtual ~NodeImp()
		{
			m_impRC->DecRef();
		}
	};

	/** Wrapper around TiXmlComment */
	class Comment : public NodeImp< TiXmlComment >
	{
	public:

		/**
		Constructor.
		*/
		Comment();

		/**
		Constructor.
		*/
		Comment( TiXmlComment* comment );

		/**
		Constructor.
		*/
		Comment( const std::string& comment );
	};

	/** Wrapper around TiXmlText */
	class Text : public NodeImp< TiXmlText >
	{
	public:

		/**
		Constructor.
		*/
		Text();

		/**
		Constructor.
		@overload
		*/
		Text( TiXmlText* text );

		/**
		Constructor.
		@overload
		*/
		Text( const std::string& value );

		/**
		Streams value into a string and creates a Text with it.
		Uses ToString to covert the parameter to a string.

		@param value The value of the Text node.
		@throws Exception

		@see TiXmlText
        */
		template < class T >
			Text( const T& value )
				: NodeImp< TiXmlText >( new TiXmlText( ToString( value ) ) )
		{
			m_impRC->InitRef();
		}
	};

	/** Wrapper around TiXmlDocument */
	class Document : public NodeImp< TiXmlDocument >
	{
	public:
		/**
		Default	Constructor.
		Create an empty document, that has no name.
		*/
		Document();

		/**
		Constructor.
		*/
		Document( TiXmlDocument* document );

		/**
		Constructor.
		*/
		Document( const char* documentName );

		/**
		 * Constructor.
		 * Create a document with a name. The name of the document is also the filename of the xml.
		 * @param documentName Name to set in the Document.
		 * @note LoadFile() needs to be called to actually load the data from the file specified by documentName
		 * 		 SaveFile() needs to be called to save data to file specified by documentName.
		 */
		Document( const std::string& documentName );

		/**
		Load a file using the current document value. Throws if load is unsuccessful.

		@param encoding Sets the documents encoding.
		@see TiXmlEncoding
		@throws Exception
		*/
		void LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

		/**
		Save a file using the current document value. Throws if it can't save the file.

		@throws Exception
		*/
		void SaveFile() const;

		/**
		Load a file using the given filename. Throws if load is unsuccessful.

		@param filename File to load.
		@param encoding Sets the documents encoding.
		@see TiXmlEncoding
		@throws Exception
		*/
		void LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

		/**
		@copydoc Document::LoadFile( const std::string&, TiXmlEncoding )
		*/
		void LoadFile( const char* filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

		/**
		Save a file using the given filename. Throws if it can't save the file.

		@param filename File to save.
		@throws Exception
		*/
		void SaveFile( const std::string& filename ) const;

		/**
		Parse the given xml data.

		@param xml Xml to parse.
		@param throwIfParseError [DEF] If true, throws when there is a parse error.
		@param encoding Sets the documents encoding.
		@throws Exception
		*/
		void Parse( const std::string& xml, bool throwIfParseError = true, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	};

	/** Wrapper around TiXmlElement */
	class Element : public NodeImp< TiXmlElement >
	{
	public:
		/**
		Default Constructor.
		*/
		Element();

		/**
		Default	Constructor. Initializes all the variables.
		@param value The value of the element.
		*/
		Element( const std::string& value );

		/**
		Default	Constructor. Initializes all the variables.
		@param value The value of the element.
		*/
		Element( const char* value );

		/**
		Constructor.
		*/
		Element( TiXmlElement* element );

		/**
		Constructor that allows you to set the element text
		@param value The value of the element.
		@param text The text to set.
		*/
		template < class T >
			Element( const std::string& value, const T& text )
			: NodeImp< TiXmlElement >( new TiXmlElement( value ) )
		{
			m_impRC->InitRef();
			SetText( text );
		}

		/**
		Access the first attribute in this element.

		@param throwIfNoAttributes [DEF] If true, throws when there are no attributes
		@return The first attribute, NULL if there are none and @a throwIfNoAttributes is true
		*/
		Attribute* FirstAttribute( bool throwIfNoAttributes = true ) const;

		/**
		Access the last attribute in this element.

		@param throwIfNoAttributes [DEF] If true, throws when there are no attributes
		@return The last attribute, NULL if there are none and @a throwIfNoAttributes is true
		*/
		Attribute* LastAttribute( bool throwIfNoAttributes = true ) const;

		/**
		@internal
		Just for Iterator<>

		@param value The value of nodes to iterate through
		@param next [OUT] The pointer to the first valid node
		*/
		void IterateFirst( const std::string&, Attribute** first ) const
		{
			*first = 0;
			for( Attribute* child = FirstAttribute( false ); child; child = child->Next( false ) )
			{
				*first = dynamic_cast< Attribute* >( child );
				if ( 0 != *first )
				{
					return;
				}
			}
		}

		/**
		Sets an attribute of name to a given value.
		The attribute will be created if it does not exist, or changed if it does.
		Uses ToString to convert the @a value to a string, so there is no need to use any other SetAttribute methods.

		@see GetAttribute
		*/
		template < class T >
			void SetAttribute ( const std::string& name, const T& value )
		{
			ValidatePointer();
			m_tiXmlPointer->SetAttribute( name, ToString( value ) );
		}

		/**
		Gets the text of an Element.

		@param throwIfNotFound	[DEF]	If true, will throw an exception if there is no text in this element
		@note This only works if the Text is the FirstChild node
		@throws Exception When there is no text and throwIfNotFound is true

		@see GetText( T* value, bool throwIfNotFound = false )
		@see GetTextOrDefault
		@see GetTextOrDefault( T* value, const DefaultT& defaultValue )
		@see TiXmlElement::GetText
		*/
		std::string GetText( bool throwIfNotFound = true ) const
		{
			// Get the element's text value as a std::string
			std::string temp;
			if ( !GetTextImp( &temp ) )
			{
				if ( throwIfNotFound )
				{
					TICPPTHROW( "Text does not exists in the current element" );
				}
			}

			return temp;
		}

		/**
		Gets the text of an Element, if it doesn't exist it will return the defaultValue.

		@param defaultValue			What to put in 'value' if there is no text in this element
		@note This only works if the Text is the FirstChild node

		@see GetText
		@see GetText( T* value, bool throwIfNotFound = false )
		@see GetTextOrDefault( T* value, const DefaultT& defaultValue )
		@see TiXmlElement::GetText
		*/
		std::string GetTextOrDefault( const std::string& defaultValue ) const
		{
			// Get the element's text value as a std::string
			std::string temp;
			if ( !GetTextImp( &temp ) )
			{
				return defaultValue;
			}

			return temp;
		}

		/**
		Gets the text value of an Element, if it doesn't exist it will return the defaultValue.
		Uses FromString to convert the string to the type of choice

		@param value		[OUT]	The container for the returned value
		@param defaultValue			What to put in 'value' if there is no text in this element
		@note This is different than GetText() in that it will covert the text to what ever type you want.
		@note This only works if the Text is the FirstChild node

		@see GetText
		@see GetText( T* value, bool throwIfNotFound = false )
		@see GetTextOrDefault( const std::string& defaultValue )
		@see TiXmlElement::GetText
		*/
		template < class T, class DefaultT >
			void GetTextOrDefault( T* value, const DefaultT& defaultValue ) const
		{
			// Get the element's text value as a std::string
			std::string temp;
			if ( !GetTextImp( &temp ) )
			{
				// The text value does not exist - set value to the default
				*value = defaultValue;
				return;
			}

			// Stream the value from the string to T
			FromString( temp, value );
		}

		/**
		Gets the text of an Element.
		Uses FromString to convert the string to the type of choice.

		@param value			[OUT]	The container for the returned value
		@param throwIfNotFound	[DEF]	If true, will throw an exception if there is no text in this element
		@note This is different than GetText() in that it will covert the text to what ever type you want
		@note This only works if the Text is the FirstChild node
		@throws Exception When there is no text and throwIfNotFound is true

		@see GetText
		@see GetTextOrDefault
		@see GetTextOrDefault( T* value, const DefaultT& defaultValue )
		@see TiXmlElement::GetText
		*/
		template< class T >
			void GetText( T* value, bool throwIfNotFound = true ) const
		{
			// Get the element's text value as a std::string
			std::string temp;
			if ( !GetTextImp( &temp ) )
			{
				if ( throwIfNotFound )
				{
					TICPPTHROW( "Text does not exists in the current element" );
				}
				else
				{
					return;
				}
			}

			// Stream the value from the string to T
			FromString( temp, value );
		}

		/**
		Convenience function to set the text of an element.
		Creates a Text node and inserts it as the first child.
		Uses ToString to convert the parameter to a string.

		@param value The text to set.
		*/
		template < class T >
			void SetText( const T& value )
		{
			ValidatePointer();
			std::string temp = ToString( value );

			if ( m_tiXmlPointer->NoChildren() )
			{
				m_tiXmlPointer->LinkEndChild( new TiXmlText( temp ) );
			}
			else
			{
				if ( 0 == m_tiXmlPointer->GetText() )
				{
					m_tiXmlPointer->InsertBeforeChild( m_tiXmlPointer->FirstChild(), TiXmlText( temp ) );
				}
				else
				{
					// There already is text, so change it
					m_tiXmlPointer->FirstChild()->SetValue( temp );
				}
			}
		}

		/**
		Gets an attribute of @a name from an element, if it doesn't exist it will return the defaultValue.
		Uses FromString to convert the string to the type of choice.

		@param name			The name of the attribute you are querying.
		@param value		[OUT] The container for the returned value.
		@param defaultValue	What to put in @a value if there is no attribute in this element.
		@throws Exception

		@see GetAttribute
		*/
		template < class T, class DefaulT >
			void GetAttributeOrDefault( const std::string& name, T* value, const DefaulT& defaultValue ) const
		{
			// Get the attribute's value as a std::string
			std::string temp;
			if ( !GetAttributeImp( name, &temp ) )
			{
				// The attribute does not exist - set value to the default
				*value = defaultValue;
				return;
			}

			// Stream the value from the string to T
			FromString( temp, value );
		}

		/**
		Gets an attribute of @a name from an element, if it doesn't exist it will return the defaultValue.

		@param name			The name of the attribute you are querying.
		@param defaultValue	What to put in @a value if there is no attribute in this element.

		@see GetAttribute
		*/
		std::string GetAttributeOrDefault( const std::string& name, const std::string& defaultValue ) const;

		/**
		Returns an attribute of @a name from an element.
		Uses FromString to convert the string to the type of choice.

		@param name				The name of the attribute you are querying.
		@param throwIfNotFound	[DEF]	If true, will throw an exception if the attribute doesn't exist
		@throws Exception When the attribute doesn't exist and throwIfNotFound is true
		@see GetAttributeOrDefault
		*/
		template < class T >
			T GetAttribute( const std::string& name, bool throwIfNotFound = true ) const
		{
			// Get the attribute's value as a std::string
			std::string temp;
			T value;
			if ( !GetAttributeImp( name, &temp ) )
			{
				if ( throwIfNotFound )
				{
					const std::string error( std::string( "Attribute '" ) + name + std::string( "' does not exist" ) );
					TICPPTHROW( error );
				}
			}
			else
			{
				// Stream the value from the string to T
				FromString( temp, &value );
			}

			return value;
		}

		/**
		Gets an attribute of @a name from an element.
		Uses FromString to convert the string to the type of choice.

		@param name				The name of the attribute you are querying.
		@param value			[OUT]	The container for the returned value
		@param throwIfNotFound	[DEF]	If true, will throw an exception if the attribute doesn't exist
		@throws Exception When the attribute doesn't exist and throwIfNotFound is true

		@see GetAttributeOrDefault
		*/
		template< class T >
			void GetAttribute( const std::string& name, T* value, bool throwIfNotFound = true ) const
		{
			// Get the attribute's value as a std::string
			std::string temp;
			if ( !GetAttributeImp( name, &temp ) )
			{
				if ( throwIfNotFound )
				{
					const std::string error( std::string( "Attribute '" ) + name + std::string( "' does not exist" ) );
					TICPPTHROW( error );
				}
				else
				{
					return;
				}
			}

			// Stream the value from the string to T
			FromString( temp, value );
		}

		/**
		Gets an attribute of @a name from an element.
		Returns an empty string if the attribute does not exist.

		@param name	The name of the attribute you are querying.
		@return The value of the attribute, or an empty string if it does not exist.

		@see GetAttributeOrDefault
		*/
		std::string GetAttribute( const std::string& name ) const;

		/**
		Returns true, if attribute exists

		@param name The name of the attribute you are checking.
		@return Existence of attribute
		*/
		bool HasAttribute( const std::string& name ) const;

		/**
		Removes attribute from element.

		@param name The name of the attribute to remove.
		*/
		void RemoveAttribute( const std::string& name );

	private:

		/**
		@internal
		Implimentation of the GetAttribute and GetAttributeOrDefault template methods.
		*/
		bool GetAttributeImp( const std::string& name, std::string* value ) const;

		/**
		@internal
		Implimentation of the GetText, GetTextOrDefault, GetTextValue, and GetTextValueOrDefault template methods.
		*/
		bool GetTextImp( std::string* value ) const;
	};

	/** Wrapper around TiXmlDeclaration */
	class Declaration : public NodeImp< TiXmlDeclaration >
	{
	public:
		/**
		Default	Constructor. Construct an empty declaration.
		*/
		Declaration();

		/**
		Constructor.
		*/
		Declaration( TiXmlDeclaration* declaration );

		/**
		Constructor.
		*/
		Declaration( const std::string& version, const std::string& encoding, const std::string& standalone );

		/**
		Version. Will return an empty string if none was found.
		*/
		std::string Version() const;

		/**
		Encoding. Will return an empty string if none was found.
		*/
		std::string Encoding() const;

		/**
		StandAlone. Is this a standalone document?
		*/
		std::string Standalone() const;
	};

	/** Wrapper around TiXmlStylesheetReference */
	class StylesheetReference : public NodeImp< TiXmlStylesheetReference >
	{
	public:
		/**
		Default	Constructor. Construct an empty declaration.
		*/
		StylesheetReference();

		/**
		Constructor.
		*/
		StylesheetReference( TiXmlStylesheetReference* stylesheetReference );

		/**
		Constructor.
		*/
		StylesheetReference( const std::string& type, const std::string& href );

		/**
		Type. Will return an empty string if none was found.
		*/
		std::string Type() const;

		/**
		Href. Will return an empty string if none was found.
		*/
		std::string Href() const;
	};
}

#endif	// TICPP_INCLUDED

#endif // TIXML_USE_TICPP
/*
http://code.google.com/p/ticpp/
Copyright (c) 2006 Ryan Pusztai, Ryan Mulder

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifdef TIXML_USE_TICPP

#ifndef TICPPRC_INCLUDED
#define TICPPRC_INCLUDED

#include <vector>

// Forward declare ticpp::Node, so it can be made a friend of TiCppRC
namespace ticpp
{
	class Base;
}

// Forward declare TiCppRCImp so TiCppRC can hold a pointer to it
class TiCppRCImp;

/**
Base class for reference counting functionality
*/
class TiCppRC
{
	// Allow ticpp::Node to directly modify reference count
	friend class ticpp::Base;

private:

	TiCppRCImp* m_tiRC; /**< Pointer to reference counter */

public:

	/**
	Constructor
	Spawns new reference counter with a pointer to this
	*/
	TiCppRC();

	/**
	Destructor
	Nullifies the pointer to this held by the reference counter
	Decrements reference count
	*/
	virtual ~TiCppRC();
	
	std::vector< ticpp::Base* > m_spawnedWrappers; /**< Remember all wrappers that we've created with 'new' - ( e.g. NodeFactory, FirstChildElement, etc. )*/

	/**
	Delete all container objects we've spawned with 'new'.
	*/
	void DeleteSpawnedWrappers();
};

class TiCppRCImp
{
private:

	int m_count;		/**< Holds reference count to me, and to the node I point to */

	TiCppRC* m_tiCppRC;	/**< Holds pointer to an object inheriting TiCppRC */

public:

	/**
	Initializes m_tiCppRC pointer, and set reference count to 1
	*/
	TiCppRCImp( TiCppRC* tiCppRC );

	/**
	Allows the TiCppRC object to set the pointer to itself ( m_tiCppRc ) to NULL when the TiCppRC object is deleted
	*/
	void Nullify();

	/**
	Increment Reference Count
	*/
	void IncRef();

	/**
	Decrement Reference Count
	*/
	void DecRef();

	/**
	Set Reference Count to 1 - dangerous! - Use only if you are sure of the consequences
	*/
	void InitRef();

	/**
	Get internal pointer to the TiCppRC object - not reference counted, use at your own risk
	*/
	TiCppRC* Get();

	/**
	Returns state of internal pointer - will be null if the object was deleted
	*/
	bool IsNull();
};

#endif // TICPP_INCLUDED

#endif // TIXML_USE_TICPP
/*
www.sourceforge.net/projects/tinyxml
Original file by Yves Berquin.

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

/*
 * THIS FILE WAS ALTERED BY Tyge Lvset, 7. April 2005.
 */


#ifndef TIXML_USE_STL

#include "tinystr.h"

// Error value for find primitive
const TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);


// Null rep.
TiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, { '\0' } };


void TiXmlString::reserve (size_type cap)
{
	if (cap > capacity())
	{
		TiXmlString tmp;
		tmp.init(length(), cap);
		memcpy(tmp.start(), data(), length());
		swap(tmp);
	}
}


TiXmlString& TiXmlString::assign(const char* str, size_type len)
{
	size_type cap = capacity();
	if (len > cap || cap > 3*(len + 8))
	{
		TiXmlString tmp;
		tmp.init(len);
		memcpy(tmp.start(), str, len);
		swap(tmp);
	}
	else
	{
		memmove(start(), str, len);
		set_size(len);
	}
	return *this;
}


TiXmlString& TiXmlString::append(const char* str, size_type len)
{
	size_type newsize = length() + len;
	if (newsize > capacity())
	{
		reserve (newsize + capacity());
	}
	memmove(finish(), str, len);
	set_size(newsize);
	return *this;
}


TiXmlString operator + (const TiXmlString & a, const TiXmlString & b)
{
	TiXmlString tmp;
	tmp.reserve(a.length() + b.length());
	tmp += a;
	tmp += b;
	return tmp;
}

TiXmlString operator + (const TiXmlString & a, const char* b)
{
	TiXmlString tmp;
	TiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );
	tmp.reserve(a.length() + b_len);
	tmp += a;
	tmp.append(b, b_len);
	return tmp;
}

TiXmlString operator + (const char* a, const TiXmlString & b)
{
	TiXmlString tmp;
	TiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );
	tmp.reserve(a_len + b.length());
	tmp.append(a, a_len);
	tmp += b;
	return tmp;
}


#endif	// TIXML_USE_STL
/*
www.sourceforge.net/projects/tinyxml
Original file by Yves Berquin.

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

/*
 * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.
 *
 * - completely rewritten. compact, clean, and fast implementation.
 * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)
 * - fixed reserve() to work as per specification.
 * - fixed buggy compares operator==(), operator<(), and operator>()
 * - fixed operator+=() to take a const ref argument, following spec.
 * - added "copy" constructor with length, and most compare operators.
 * - added swap(), clear(), size(), capacity(), operator+().
 */

#ifndef TIXML_USE_STL

#ifndef TIXML_STRING_INCLUDED
#define TIXML_STRING_INCLUDED

#include <assert.h>
#include <string.h>

/*	The support for explicit isn't that universal, and it isn't really
	required - it is used to check that the TiXmlString class isn't incorrectly
	used. Be nice to old compilers and macro it here:
*/
#if defined(_MSC_VER) && (_MSC_VER >= 1200 )
	// Microsoft visual studio, version 6 and higher.
	#define TIXML_EXPLICIT explicit
#elif defined(__GNUC__) && (__GNUC__ >= 3 )
	// GCC version 3 and higher.s
	#define TIXML_EXPLICIT explicit
#else
	#define TIXML_EXPLICIT
#endif


/*
   TiXmlString is an emulation of a subset of the std::string template.
   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
   Only the member functions relevant to the TinyXML project have been implemented.
   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
   a string and there's no more room, we allocate a buffer twice as big as we need.
*/
class TiXmlString
{
  public :
	// The size type used
  	typedef size_t size_type;

	// Error value for find primitive
	static const size_type npos; // = -1;


	// TiXmlString empty constructor
	TiXmlString () : rep_(&nullrep_)
	{
	}

	// TiXmlString copy constructor
	TiXmlString ( const TiXmlString & copy) : rep_(0)
	{
		init(copy.length());
		memcpy(start(), copy.data(), length());
	}

	// TiXmlString constructor, based on a string
	TIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)
	{
		init( static_cast<size_type>( strlen(copy) ));
		memcpy(start(), copy, length());
	}

	// TiXmlString constructor, based on a string
	TIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)
	{
		init(len);
		memcpy(start(), str, len);
	}

	// TiXmlString destructor
	~TiXmlString ()
	{
		quit();
	}

	// = operator
	TiXmlString& operator = (const char * copy)
	{
		return assign( copy, (size_type)strlen(copy));
	}

	// = operator
	TiXmlString& operator = (const TiXmlString & copy)
	{
		return assign(copy.start(), copy.length());
	}


	// += operator. Maps to append
	TiXmlString& operator += (const char * suffix)
	{
		return append(suffix, static_cast<size_type>( strlen(suffix) ));
	}

	// += operator. Maps to append
	TiXmlString& operator += (char single)
	{
		return append(&single, 1);
	}

	// += operator. Maps to append
	TiXmlString& operator += (const TiXmlString & suffix)
	{
		return append(suffix.data(), suffix.length());
	}


	// Convert a TiXmlString into a null-terminated char *
	const char * c_str () const { return rep_->str; }

	// Convert a TiXmlString into a char * (need not be null terminated).
	const char * data () const { return rep_->str; }

	// Return the length of a TiXmlString
	size_type length () const { return rep_->size; }

	// Alias for length()
	size_type size () const { return rep_->size; }

	// Checks if a TiXmlString is empty
	bool empty () const { return rep_->size == 0; }

	// Return capacity of string
	size_type capacity () const { return rep_->capacity; }


	// single char extraction
	const char& at (size_type index) const
	{
		assert( index < length() );
		return rep_->str[ index ];
	}

	// [] operator
	char& operator [] (size_type index) const
	{
		assert( index < length() );
		return rep_->str[ index ];
	}

	// find a char in a string. Return TiXmlString::npos if not found
	size_type find (char lookup) const
	{
		return find(lookup, 0);
	}

	// find a char in a string from an offset. Return TiXmlString::npos if not found
	size_type find (char tofind, size_type offset) const
	{
		if (offset >= length()) return npos;

		for (const char* p = c_str() + offset; *p != '\0'; ++p)
		{
		   if (*p == tofind) return static_cast< size_type >( p - c_str() );
		}
		return npos;
	}

	void clear ()
	{
		//Lee:
		//The original was just too strange, though correct:
		//	TiXmlString().swap(*this);
		//Instead use the quit & re-init:
		quit();
		init(0,0);
	}

	/*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
		function DOES NOT clear the content of the TiXmlString if any exists.
	*/
	void reserve (size_type cap);

	TiXmlString& assign (const char* str, size_type len);

	TiXmlString& append (const char* str, size_type len);

	void swap (TiXmlString& other)
	{
		Rep* r = rep_;
		rep_ = other.rep_;
		other.rep_ = r;
	}

  private:

	void init(size_type sz) { init(sz, sz); }
	void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
	char* start() const { return rep_->str; }
	char* finish() const { return rep_->str + rep_->size; }

	struct Rep
	{
		size_type size, capacity;
		char str[1];
	};

	void init(size_type sz, size_type cap)
	{
		if (cap)
		{
			// Lee: the original form:
			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
			// doesn't work in some cases of new being overloaded. Switching
			// to the normal allocation, although use an 'int' for systems
			// that are overly picky about structure alignment.
			const size_type bytesNeeded = sizeof(Rep) + cap;
			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 
			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );

			rep_->str[ rep_->size = sz ] = '\0';
			rep_->capacity = cap;
		}
		else
		{
			rep_ = &nullrep_;
		}
	}

	void quit()
	{
		if (rep_ != &nullrep_)
		{
			// The rep_ is really an array of ints. (see the allocator, above).
			// Cast it back before delete, so the compiler won't incorrectly call destructors.
			delete [] ( reinterpret_cast<int*>( rep_ ) );
		}
	}

	Rep * rep_;
	static Rep nullrep_;

} ;


inline bool operator == (const TiXmlString & a, const TiXmlString & b)
{
	return    ( a.length() == b.length() )				// optimization on some platforms
	       && ( strcmp(a.c_str(), b.c_str()) == 0 );	// actual compare
}
inline bool operator < (const TiXmlString & a, const TiXmlString & b)
{
	return strcmp(a.c_str(), b.c_str()) < 0;
}

inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
inline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }
inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }

inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }

TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
TiXmlString operator + (const TiXmlString & a, const char* b);
TiXmlString operator + (const char* a, const TiXmlString & b);


/*
   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
   Only the operators that we need for TinyXML have been developped.
*/
class TiXmlOutStream : public TiXmlString
{
public :

	// TiXmlOutStream << operator.
	TiXmlOutStream & operator << (const TiXmlString & in)
	{
		*this += in;
		return *this;
	}

	// TiXmlOutStream << operator.
	TiXmlOutStream & operator << (const char * in)
	{
		*this += in;
		return *this;
	}

} ;

#endif	// TIXML_STRING_INCLUDED
#endif	// TIXML_USE_STL
/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/
#include "tinyxml.h"

#include <ctype.h>

#ifdef TIXML_USE_STL
#include <sstream>
#include <iostream>
#endif


bool TiXmlBase::condenseWhiteSpace = true;

// Microsoft compiler security
FILE* TiXmlFOpen( const char* filename, const char* mode )
{
	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
		FILE* fp = 0;
		errno_t err = fopen_s( &fp, filename, mode );
		if ( !err && fp )
			return fp;
		return 0;
	#else
		return fopen( filename, mode );
	#endif
}

void TiXmlBase::EncodeString( const TIXML_STRING& str, TIXML_STRING* outString )
{
	int i=0;

	while( i<(int)str.length() )
	{
		unsigned char c = (unsigned char) str[i];

		if (    c == '&'
		     && i < ( (int)str.length() - 2 )
			 && str[i+1] == '#'
			 && str[i+2] == 'x' )
		{
			// Hexadecimal character reference.
			// Pass through unchanged.
			// &#xA9;	-- copyright symbol, for example.
			//
			// The -1 is a bug fix from Rob Laveaux. It keeps
			// an overflow from happening if there is no ';'.
			// There are actually 2 ways to exit this loop -
			// while fails (error case) and break (semicolon found).
			// However, there is no mechanism (currently) for
			// this function to return an error.
			while ( i<(int)str.length()-1 )
			{
				outString->append( str.c_str() + i, 1 );
				++i;
				if ( str[i] == ';' )
					break;
			}
		}
		else if ( c == '&' )
		{
			outString->append( entity[0].str, entity[0].strLength );
			++i;
		}
		else if ( c == '<' )
		{
			outString->append( entity[1].str, entity[1].strLength );
			++i;
		}
		else if ( c == '>' )
		{
			outString->append( entity[2].str, entity[2].strLength );
			++i;
		}
		else if ( c == '\"' )
		{
			outString->append( entity[3].str, entity[3].strLength );
			++i;
		}
		else if ( c == '\'' )
		{
			outString->append( entity[4].str, entity[4].strLength );
			++i;
		}
		else if ( c < 32 )
		{
			// Easy pass at non-alpha/numeric/symbol
			// Below 32 is symbolic.
			char buf[ 32 ];

			#if defined(TIXML_SNPRINTF)
				TIXML_SNPRINTF( buf, sizeof(buf), "&#x%02X;", (unsigned) ( c & 0xff ) );
			#else
				sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
			#endif

			//*ME:	warning C4267: convert 'size_t' to 'int'
			//*ME:	Int-Cast to make compiler happy ...
			outString->append( buf, (int)strlen( buf ) );
			++i;
		}
		else
		{
			//char realc = (char) c;
			//outString->append( &realc, 1 );
			*outString += (char) c;	// somewhat more efficient function call.
			++i;
		}
	}
}


TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
{
	parent = 0;
	type = _type;
	firstChild = 0;
	lastChild = 0;
	prev = 0;
	next = 0;
}


TiXmlNode::~TiXmlNode()
{
	TiXmlNode* node = firstChild;
	TiXmlNode* temp = 0;

	while ( node )
	{
		temp = node;
		node = node->next;
		delete temp;
	}
}


void TiXmlNode::CopyTo( TiXmlNode* target ) const
{
	target->SetValue (value.c_str() );
	target->userData = userData;
}


void TiXmlNode::Clear()
{
	TiXmlNode* node = firstChild;
	TiXmlNode* temp = 0;

	while ( node )
	{
		temp = node;
		node = node->next;
		delete temp;
	}

	firstChild = 0;
	lastChild = 0;
}


TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
{
	assert( node->parent == 0 || node->parent == this );
	assert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );

	if ( node->Type() == TiXmlNode::DOCUMENT )
	{
		delete node;
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	node->parent = this;

	node->prev = lastChild;
	node->next = 0;

	if ( lastChild )
		lastChild->next = node;
	else
		firstChild = node;			// it was an empty list.

	lastChild = node;
	return node;
}


TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
{
	if ( addThis.Type() == TiXmlNode::DOCUMENT )
	{
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}
	TiXmlNode* node = addThis.Clone();
	if ( !node )
		return 0;

	return LinkEndChild( node );
}


TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
{
	if ( !beforeThis || beforeThis->parent != this ) {
		return 0;
	}
	if ( addThis.Type() == TiXmlNode::DOCUMENT )
	{
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	TiXmlNode* node = addThis.Clone();
	if ( !node )
		return 0;
	node->parent = this;

	node->next = beforeThis;
	node->prev = beforeThis->prev;
	if ( beforeThis->prev )
	{
		beforeThis->prev->next = node;
	}
	else
	{
		assert( firstChild == beforeThis );
		firstChild = node;
	}
	beforeThis->prev = node;
	return node;
}


TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
{
	if ( !afterThis || afterThis->parent != this ) {
		return 0;
	}
	if ( addThis.Type() == TiXmlNode::DOCUMENT )
	{
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	TiXmlNode* node = addThis.Clone();
	if ( !node )
		return 0;
	node->parent = this;

	node->prev = afterThis;
	node->next = afterThis->next;
	if ( afterThis->next )
	{
		afterThis->next->prev = node;
	}
	else
	{
		assert( lastChild == afterThis );
		lastChild = node;
	}
	afterThis->next = node;
	return node;
}


TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
{
	if ( replaceThis->parent != this )
		return 0;

	TiXmlNode* node = withThis.Clone();
	if ( !node )
		return 0;

	node->next = replaceThis->next;
	node->prev = replaceThis->prev;

	if ( replaceThis->next )
		replaceThis->next->prev = node;
	else
		lastChild = node;

	if ( replaceThis->prev )
		replaceThis->prev->next = node;
	else
		firstChild = node;

	delete replaceThis;
	node->parent = this;
	return node;
}


bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
{
	if ( removeThis->parent != this )
	{
		assert( 0 );
		return false;
	}

	if ( removeThis->next )
		removeThis->next->prev = removeThis->prev;
	else
		lastChild = removeThis->prev;

	if ( removeThis->prev )
		removeThis->prev->next = removeThis->next;
	else
		firstChild = removeThis->next;

	delete removeThis;
	return true;
}

const TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
{
	const TiXmlNode* node;
	for ( node = firstChild; node; node = node->next )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


const TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
{
	const TiXmlNode* node;
	for ( node = lastChild; node; node = node->prev )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


const TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const
{
	if ( !previous )
	{
		return FirstChild();
	}
	else
	{
		assert( previous->parent == this );
		return previous->NextSibling();
	}
}


const TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const
{
	if ( !previous )
	{
		return FirstChild( val );
	}
	else
	{
		assert( previous->parent == this );
		return previous->NextSibling( val );
	}
}


const TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const
{
	const TiXmlNode* node;
	for ( node = next; node; node = node->next )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


const TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
{
	const TiXmlNode* node;
	for ( node = prev; node; node = node->prev )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


void TiXmlElement::RemoveAttribute( const char * name )
{
    #ifdef TIXML_USE_STL
	TIXML_STRING str( name );
	TiXmlAttribute* node = attributeSet.Find( str );
	#else
	TiXmlAttribute* node = attributeSet.Find( name );
	#endif
	if ( node )
	{
		attributeSet.Remove( node );
		delete node;
	}
}

const TiXmlElement* TiXmlNode::FirstChildElement() const
{
	const TiXmlNode* node;

	for (	node = FirstChild();
			node;
			node = node->NextSibling() )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
{
	const TiXmlNode* node;

	for (	node = FirstChild( _value );
			node;
			node = node->NextSibling( _value ) )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlElement* TiXmlNode::NextSiblingElement() const
{
	const TiXmlNode* node;

	for (	node = NextSibling();
			node;
			node = node->NextSibling() )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
{
	const TiXmlNode* node;

	for (	node = NextSibling( _value );
			node;
			node = node->NextSibling( _value ) )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlDocument* TiXmlNode::GetDocument() const
{
	const TiXmlNode* node;

	for( node = this; node; node = node->parent )
	{
		if ( node->ToDocument() )
			return node->ToDocument();
	}
	return 0;
}


TiXmlElement::TiXmlElement (const char * _value)
	: TiXmlNode( TiXmlNode::ELEMENT )
{
	firstChild = lastChild = 0;
	value = _value;
}


#ifdef TIXML_USE_STL
TiXmlElement::TiXmlElement( const std::string& _value )
	: TiXmlNode( TiXmlNode::ELEMENT )
{
	firstChild = lastChild = 0;
	value = _value;
}
#endif


TiXmlElement::TiXmlElement( const TiXmlElement& copy)
	: TiXmlNode( TiXmlNode::ELEMENT )
{
	firstChild = lastChild = 0;
	copy.CopyTo( this );
}


void TiXmlElement::operator=( const TiXmlElement& base )
{
	ClearThis();
	base.CopyTo( this );
}


TiXmlElement::~TiXmlElement()
{
	ClearThis();
}


void TiXmlElement::ClearThis()
{
	Clear();
	while( attributeSet.First() )
	{
		TiXmlAttribute* node = attributeSet.First();
		attributeSet.Remove( node );
		delete node;
	}
}


const char* TiXmlElement::Attribute( const char* name ) const
{
	const TiXmlAttribute* node = attributeSet.Find( name );
	if ( node )
		return node->Value();
	return 0;
}


#ifdef TIXML_USE_STL
const std::string* TiXmlElement::Attribute( const std::string& name ) const
{
	const TiXmlAttribute* node = attributeSet.Find( name );
	if ( node )
		return &node->ValueStr();
	return 0;
}
#endif


const char* TiXmlElement::Attribute( const char* name, int* i ) const
{
	const char* s = Attribute( name );
	if ( i )
	{
		if ( s ) {
			*i = atoi( s );
		}
		else {
			*i = 0;
		}
	}
	return s;
}


#ifdef TIXML_USE_STL
const std::string* TiXmlElement::Attribute( const std::string& name, int* i ) const
{
	const std::string* s = Attribute( name );
	if ( i )
	{
		if ( s ) {
			*i = atoi( s->c_str() );
		}
		else {
			*i = 0;
		}
	}
	return s;
}
#endif


const char* TiXmlElement::Attribute( const char* name, double* d ) const
{
	const char* s = Attribute( name );
	if ( d )
	{
		if ( s ) {
			*d = atof( s );
		}
		else {
			*d = 0;
		}
	}
	return s;
}


#ifdef TIXML_USE_STL
const std::string* TiXmlElement::Attribute( const std::string& name, double* d ) const
{
	const std::string* s = Attribute( name );
	if ( d )
	{
		if ( s ) {
			*d = atof( s->c_str() );
		}
		else {
			*d = 0;
		}
	}
	return s;
}
#endif


int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
{
	const TiXmlAttribute* node = attributeSet.Find( name );
	if ( !node )
		return TIXML_NO_ATTRIBUTE;
	return node->QueryIntValue( ival );
}


#ifdef TIXML_USE_STL
int TiXmlElement::QueryIntAttribute( const std::string& name, int* ival ) const
{
	const TiXmlAttribute* node = attributeSet.Find( name );
	if ( !node )
		return TIXML_NO_ATTRIBUTE;
	return node->QueryIntValue( ival );
}
#endif


int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
{
	const TiXmlAttribute* node = attributeSet.Find( name );
	if ( !node )
		return TIXML_NO_ATTRIBUTE;
	return node->QueryDoubleValue( dval );
}


#ifdef TIXML_USE_STL
int TiXmlElement::QueryDoubleAttribute( const std::string& name, double* dval ) const
{
	const TiXmlAttribute* node = attributeSet.Find( name );
	if ( !node )
		return TIXML_NO_ATTRIBUTE;
	return node->QueryDoubleValue( dval );
}
#endif


void TiXmlElement::SetAttribute( const char * name, int val )
{
	char buf[64];
	#if defined(TIXML_SNPRINTF)
		TIXML_SNPRINTF( buf, sizeof(buf), "%d", val );
	#else
		sprintf( buf, "%d", val );
	#endif
	SetAttribute( name, buf );
}


#ifdef TIXML_USE_STL
void TiXmlElement::SetAttribute( const std::string& name, int val )
{
   std::ostringstream oss;
   oss << val;
   SetAttribute( name, oss.str() );
}
#endif


void TiXmlElement::SetDoubleAttribute( const char * name, double val )
{
	char buf[256];
	#if defined(TIXML_SNPRINTF)
		TIXML_SNPRINTF( buf, sizeof(buf), "%f", val );
	#else
		sprintf( buf, "%f", val );
	#endif
	SetAttribute( name, buf );
}


void TiXmlElement::SetAttribute( const char * cname, const char * cvalue )
{
    #ifdef TIXML_USE_STL
	TIXML_STRING _name( cname );
	TIXML_STRING _value( cvalue );
	#else
	const char* _name = cname;
	const char* _value = cvalue;
	#endif

	TiXmlAttribute* node = attributeSet.Find( _name );
	if ( node )
	{
		node->SetValue( _value );
		return;
	}

	TiXmlAttribute* attrib = new TiXmlAttribute( cname, cvalue );
	if ( attrib )
	{
		attributeSet.Add( attrib );
	}
	else
	{
		TiXmlDocument* document = GetDocument();
		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
	}
}


#ifdef TIXML_USE_STL
void TiXmlElement::SetAttribute( const std::string& name, const std::string& _value )
{
	TiXmlAttribute* node = attributeSet.Find( name );
	if ( node )
	{
		node->SetValue( _value );
		return;
	}

	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
	if ( attrib )
	{
		attributeSet.Add( attrib );
	}
	else
	{
		TiXmlDocument* document = GetDocument();
		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
	}
}
#endif


void TiXmlElement::Print( FILE* cfile, int depth ) const
{
	int i;
	assert( cfile );
	for ( i=0; i<depth; i++ ) {
		fprintf( cfile, "    " );
	}

	fprintf( cfile, "<%s", value.c_str() );

	const TiXmlAttribute* attrib;
	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
	{
		fprintf( cfile, " " );
		attrib->Print( cfile, depth );
	}

	// There are 3 different formatting approaches:
	// 1) An element without children is printed as a <foo /> node
	// 2) An element with only a text child is printed as <foo> text </foo>
	// 3) An element with children is printed on multiple lines.
	TiXmlNode* node;
	if ( !firstChild )
	{
		fprintf( cfile, " />" );
	}
	else if ( firstChild == lastChild && firstChild->ToText() )
	{
		fprintf( cfile, ">" );
		firstChild->Print( cfile, depth + 1 );
		fprintf( cfile, "</%s>", value.c_str() );
	}
	else
	{
		fprintf( cfile, ">" );

		for ( node = firstChild; node; node=node->NextSibling() )
		{
			if ( !node->ToText() )
			{
				fprintf( cfile, "\n" );
			}
			node->Print( cfile, depth+1 );
		}
		fprintf( cfile, "\n" );
		for( i=0; i<depth; ++i ) {
			fprintf( cfile, "    " );
		}
		fprintf( cfile, "</%s>", value.c_str() );
	}
}


void TiXmlElement::CopyTo( TiXmlElement* target ) const
{
	// superclass:
	TiXmlNode::CopyTo( target );

	// Element class:
	// Clone the attributes, then clone the children.
	const TiXmlAttribute* attribute = 0;
	for(	attribute = attributeSet.First();
	attribute;
	attribute = attribute->Next() )
	{
		target->SetAttribute( attribute->Name(), attribute->Value() );
	}

	TiXmlNode* node = 0;
	for ( node = firstChild; node; node = node->NextSibling() )
	{
		target->LinkEndChild( node->Clone() );
	}
}

bool TiXmlElement::Accept( TiXmlVisitor* visitor ) const
{
	if ( visitor->VisitEnter( *this, attributeSet.First() ) )
	{
		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
		{
			if ( !node->Accept( visitor ) )
				break;
		}
	}
	return visitor->VisitExit( *this );
}


TiXmlNode* TiXmlElement::Clone() const
{
	TiXmlElement* clone = new TiXmlElement( Value() );
	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


const char* TiXmlElement::GetText() const
{
	const TiXmlNode* child = this->FirstChild();
	if ( child ) {
		const TiXmlText* childText = child->ToText();
		if ( childText ) {
			return childText->Value();
		}
	}
	return 0;
}


TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
{
	tabsize = 4;
	useMicrosoftBOM = false;
	ClearError();
}

TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
{
	tabsize = 4;
	useMicrosoftBOM = false;
	value = documentName;
	ClearError();
}


#ifdef TIXML_USE_STL
TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
{
	tabsize = 4;
	useMicrosoftBOM = false;
    value = documentName;
	ClearError();
}
#endif


TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::DOCUMENT )
{
	copy.CopyTo( this );
}


void TiXmlDocument::operator=( const TiXmlDocument& copy )
{
	Clear();
	copy.CopyTo( this );
}


bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
{
	// See STL_STRING_BUG below.
	//StringToBuffer buf( value );

	return LoadFile( Value(), encoding );
}


bool TiXmlDocument::SaveFile() const
{
	// See STL_STRING_BUG below.
//	StringToBuffer buf( value );
//
//	if ( buf.buffer && SaveFile( buf.buffer ) )
//		return true;
//
//	return false;
	return SaveFile( Value() );
}

bool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )
{
	// There was a really terrifying little bug here. The code:
	//		value = filename
	// in the STL case, cause the assignment method of the std::string to
	// be called. What is strange, is that the std::string had the same
	// address as it's c_str() method, and so bad things happen. Looks
	// like a bug in the Microsoft STL implementation.
	// Add an extra string to avoid the crash.
	TIXML_STRING filename( _filename );
	value = filename;

	// reading in binary mode so that tinyxml can normalize the EOL
	FILE* file = TiXmlFOpen( value.c_str (), "rb" );

	if ( file )
	{
		bool result = LoadFile( file, encoding );
		fclose( file );
		return result;
	}
	else
	{
		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}
}

bool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )
{
	if ( !file )
	{
		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}

	// Delete the existing data:
	Clear();
	location.Clear();

	// Get the file size, so we can pre-allocate the string. HUGE speed impact.
	long length = 0;
	fseek( file, 0, SEEK_END );
	length = ftell( file );
	fseek( file, 0, SEEK_SET );

	// Strange case, but good to handle up front.
	if ( length <= 0 )
	{
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}

	// If we have a file, assume it is all one big XML file, and read it in.
	// The document parser may decide the document ends sooner than the entire file, however.
	TIXML_STRING data;
	data.reserve( length );

	// Subtle bug here. TinyXml did use fgets. But from the XML spec:
	// 2.11 End-of-Line Handling
	// <snip>
	// <quote>
	// ...the XML processor MUST behave as if it normalized all line breaks in external
	// parsed entities (including the document entity) on input, before parsing, by translating
	// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to
	// a single #xA character.
	// </quote>
	//
	// It is not clear fgets does that, and certainly isn't clear it works cross platform.
	// Generally, you expect fgets to translate from the convention of the OS to the c/unix
	// convention, and not work generally.

	/*
	while( fgets( buf, sizeof(buf), file ) )
	{
		data += buf;
	}
	*/

	char* buf = new char[ length+1 ];
	buf[0] = 0;

	if ( fread( buf, length, 1, file ) != 1 ) {
		delete [] buf;
		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}

	const char* lastPos = buf;
	const char* p = buf;

	buf[length] = 0;
	while( *p ) {
		assert( p < (buf+length) );
		if ( *p == 0xa ) {
			// Newline character. No special rules for this. Append all the characters
			// since the last string, and include the newline.
			data.append( lastPos, (p-lastPos+1) );	// append, include the newline
			++p;									// move past the newline
			lastPos = p;							// and point to the new buffer (may be 0)
			assert( p <= (buf+length) );
		}
		else if ( *p == 0xd ) {
			// Carriage return. Append what we have so far, then
			// handle moving forward in the buffer.
			if ( (p-lastPos) > 0 ) {
				data.append( lastPos, p-lastPos );	// do not add the CR
			}
			data += (char)0xa;						// a proper newline

			if ( *(p+1) == 0xa ) {
				// Carriage return - new line sequence
				p += 2;
				lastPos = p;
				assert( p <= (buf+length) );
			}
			else {
				// it was followed by something else...that is presumably characters again.
				++p;
				lastPos = p;
				assert( p <= (buf+length) );
			}
		}
		else {
			++p;
		}
	}
	// Handle any left over characters.
	if ( p-lastPos ) {
		data.append( lastPos, p-lastPos );
	}
	delete [] buf;
	buf = 0;

	Parse( data.c_str(), 0, encoding );

	if (  Error() )
        return false;
    else
		return true;
}


bool TiXmlDocument::SaveFile( const char * filename ) const
{
	// The old c stuff lives on...
	FILE* fp = TiXmlFOpen( filename, "w" );
	if ( fp )
	{
		bool result = SaveFile( fp );
		fclose( fp );
		return result;
	}
	return false;
}


bool TiXmlDocument::SaveFile( FILE* fp ) const
{
	if ( useMicrosoftBOM )
	{
		const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
		const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
		const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;

		fputc( TIXML_UTF_LEAD_0, fp );
		fputc( TIXML_UTF_LEAD_1, fp );
		fputc( TIXML_UTF_LEAD_2, fp );
	}
	Print( fp, 0 );
	return (ferror(fp) == 0);
}


void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
{
	TiXmlNode::CopyTo( target );

	target->error = error;
	target->errorId = errorId;
	target->errorDesc = errorDesc;
	target->tabsize = tabsize;
	target->errorLocation = errorLocation;
	target->useMicrosoftBOM = useMicrosoftBOM;

	TiXmlNode* node = 0;
	for ( node = firstChild; node; node = node->NextSibling() )
	{
		target->LinkEndChild( node->Clone() );
	}
}


TiXmlNode* TiXmlDocument::Clone() const
{
	TiXmlDocument* clone = new TiXmlDocument();
	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


void TiXmlDocument::Print( FILE* cfile, int depth ) const
{
	assert( cfile );
	for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
	{
		node->Print( cfile, depth );
		fprintf( cfile, "\n" );
	}
}


bool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const
{
	if ( visitor->VisitEnter( *this ) )
	{
		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
		{
			if ( !node->Accept( visitor ) )
				break;
		}
	}
	return visitor->VisitExit( *this );
}


const TiXmlAttribute* TiXmlAttribute::Next() const
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( next->value.empty() && next->name.empty() )
		return 0;
	return next;
}

/*
TiXmlAttribute* TiXmlAttribute::Next()
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( next->value.empty() && next->name.empty() )
		return 0;
	return next;
}
*/

const TiXmlAttribute* TiXmlAttribute::Previous() const
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( prev->value.empty() && prev->name.empty() )
		return 0;
	return prev;
}

/*
TiXmlAttribute* TiXmlAttribute::Previous()
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( prev->value.empty() && prev->name.empty() )
		return 0;
	return prev;
}
*/

void TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
{
	TIXML_STRING n, v;

	EncodeString( name, &n );
	EncodeString( value, &v );

	if (value.find ('\"') == TIXML_STRING::npos) {
		if ( cfile ) {
		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
		}
		if ( str ) {
			(*str) += n; (*str) += "=\""; (*str) += v; (*str) += "\"";
		}
	}
	else {
		if ( cfile ) {
		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
		}
		if ( str ) {
			(*str) += n; (*str) += "='"; (*str) += v; (*str) += "'";
		}
	}
}


int TiXmlAttribute::QueryIntValue( int* ival ) const
{
	if ( TIXML_SSCANF( value.c_str(), "%d", ival ) == 1 )
		return TIXML_SUCCESS;
	return TIXML_WRONG_TYPE;
}

int TiXmlAttribute::QueryDoubleValue( double* dval ) const
{
	if ( TIXML_SSCANF( value.c_str(), "%lf", dval ) == 1 )
		return TIXML_SUCCESS;
	return TIXML_WRONG_TYPE;
}

void TiXmlAttribute::SetIntValue( int _value )
{
	char buf [64];
	#if defined(TIXML_SNPRINTF)
		TIXML_SNPRINTF(buf, sizeof(buf), "%d", _value);
	#else
		sprintf (buf, "%d", _value);
	#endif
	SetValue (buf);
}

void TiXmlAttribute::SetDoubleValue( double _value )
{
	char buf [256];
	#if defined(TIXML_SNPRINTF)
		TIXML_SNPRINTF( buf, sizeof(buf), "%lf", _value);
	#else
		sprintf (buf, "%lf", _value);
	#endif
	SetValue (buf);
}

int TiXmlAttribute::IntValue() const
{
	return atoi (value.c_str ());
}

double  TiXmlAttribute::DoubleValue() const
{
	return atof (value.c_str ());
}


TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::COMMENT )
{
	copy.CopyTo( this );
}


void TiXmlComment::operator=( const TiXmlComment& base )
{
	Clear();
	base.CopyTo( this );
}


void TiXmlComment::Print( FILE* cfile, int depth ) const
{
	assert( cfile );
	for ( int i=0; i<depth; i++ )
	{
		fprintf( cfile,  "    " );
	}
	fprintf( cfile, "<!--%s-->", value.c_str() );
}


void TiXmlComment::CopyTo( TiXmlComment* target ) const
{
	TiXmlNode::CopyTo( target );
}


bool TiXmlComment::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlComment::Clone() const
{
	TiXmlComment* clone = new TiXmlComment();

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


void TiXmlText::Print( FILE* cfile, int depth ) const
{
	assert( cfile );
	if ( cdata )
	{
		int i;
		fprintf( cfile, "\n" );
		for ( i=0; i<depth; i++ ) {
			fprintf( cfile, "    " );
		}
		fprintf( cfile, "<![CDATA[%s]]>\n", value.c_str() );	// unformatted output
	}
	else
	{
		TIXML_STRING buffer;
		EncodeString( value, &buffer );
		fprintf( cfile, "%s", buffer.c_str() );
	}
}


void TiXmlText::CopyTo( TiXmlText* target ) const
{
	TiXmlNode::CopyTo( target );
	target->cdata = cdata;
}


bool TiXmlText::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlText::Clone() const
{
	TiXmlText* clone = 0;
	clone = new TiXmlText( "" );

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


TiXmlDeclaration::TiXmlDeclaration( const char * _version,
									const char * _encoding,
									const char * _standalone )
	: TiXmlNode( TiXmlNode::DECLARATION )
{
	version = _version;
	encoding = _encoding;
	standalone = _standalone;
}


#ifdef TIXML_USE_STL
TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
									const std::string& _encoding,
									const std::string& _standalone )
	: TiXmlNode( TiXmlNode::DECLARATION )
{
	version = _version;
	encoding = _encoding;
	standalone = _standalone;
}
#endif


TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
	: TiXmlNode( TiXmlNode::DECLARATION )
{
	copy.CopyTo( this );
}


void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
{
	Clear();
	copy.CopyTo( this );
}


void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
{
	if ( cfile ) fprintf( cfile, "<?xml " );
	if ( str )	 (*str) += "<?xml ";

	if ( !version.empty() ) {
		if ( cfile ) fprintf (cfile, "version=\"%s\" ", version.c_str ());
		if ( str ) { (*str) += "version=\""; (*str) += version; (*str) += "\" "; }
	}
	if ( !encoding.empty() ) {
		if ( cfile ) fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
		if ( str ) { (*str) += "encoding=\""; (*str) += encoding; (*str) += "\" "; }
	}
	if ( !standalone.empty() ) {
		if ( cfile ) fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
		if ( str ) { (*str) += "standalone=\""; (*str) += standalone; (*str) += "\" "; }
	}
	if ( cfile ) fprintf( cfile, "?>" );
	if ( str )	 (*str) += "?>";
}


void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
{
	TiXmlNode::CopyTo( target );

	target->version = version;
	target->encoding = encoding;
	target->standalone = standalone;
}


bool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlDeclaration::Clone() const
{
	TiXmlDeclaration* clone = new TiXmlDeclaration();

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}

TiXmlStylesheetReference::TiXmlStylesheetReference( const char * _type,
													const char * _href )
	: TiXmlNode( TiXmlNode::STYLESHEETREFERENCE )
{
	type = _type;
	href = _href;
}


#ifdef TIXML_USE_STL
TiXmlStylesheetReference::TiXmlStylesheetReference(	const std::string& _type,
													const std::string& _href )
	: TiXmlNode( TiXmlNode::STYLESHEETREFERENCE )
{
	type = _type;
	href = _href;
}
#endif


TiXmlStylesheetReference::TiXmlStylesheetReference( const TiXmlStylesheetReference& copy )
	: TiXmlNode( TiXmlNode::STYLESHEETREFERENCE )
{
	copy.CopyTo( this );
}


void TiXmlStylesheetReference::operator=( const TiXmlStylesheetReference& copy )
{
	Clear();
	copy.CopyTo( this );
}


void TiXmlStylesheetReference::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
{
	if ( cfile ) fprintf( cfile, "<?xml-stylesheet " );
	if ( str )	 (*str) += "<?xml-stylesheet ";

	if ( !type.empty() ) {
		if ( cfile ) fprintf (cfile, "type=\"%s\" ", type.c_str ());
		if ( str ) { (*str) += "type=\""; (*str) += type; (*str) += "\" "; }
	}
	if ( !href.empty() ) {
		if ( cfile ) fprintf (cfile, "href=\"%s\" ", href.c_str ());
		if ( str ) { (*str) += "href=\""; (*str) += href; (*str) += "\" "; }
	}
	if ( cfile ) fprintf (cfile, "?>");
	if ( str )	 (*str) += "?>";
}

void TiXmlStylesheetReference::CopyTo( TiXmlStylesheetReference* target ) const
{
	TiXmlNode::CopyTo( target );

	target->type = type;
	target->href = href;
}

bool TiXmlStylesheetReference::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}

TiXmlNode* TiXmlStylesheetReference::Clone() const
{
	TiXmlStylesheetReference* clone = new TiXmlStylesheetReference();

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


void TiXmlUnknown::Print( FILE* cfile, int depth ) const
{
	for ( int i=0; i<depth; i++ )
		fprintf( cfile, "    " );
	fprintf( cfile, "<%s>", value.c_str() );
}


void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
{
	TiXmlNode::CopyTo( target );
}


bool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlUnknown::Clone() const
{
	TiXmlUnknown* clone = new TiXmlUnknown();

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


TiXmlAttributeSet::TiXmlAttributeSet()
{
	sentinel.next = &sentinel;
	sentinel.prev = &sentinel;
}


TiXmlAttributeSet::~TiXmlAttributeSet()
{
	assert( sentinel.next == &sentinel );
	assert( sentinel.prev == &sentinel );
}


void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
{
    #ifdef TIXML_USE_STL
	assert( !Find( TIXML_STRING( addMe->Name() ) ) );	// Shouldn't be multiply adding to the set.
	#else
	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
	#endif

	addMe->next = &sentinel;
	addMe->prev = sentinel.prev;

	sentinel.prev->next = addMe;
	sentinel.prev      = addMe;
}

void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
{
	TiXmlAttribute* node;

	for( node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( node == removeMe )
		{
			node->prev->next = node->next;
			node->next->prev = node->prev;
			node->next = 0;
			node->prev = 0;
			return;
		}
	}
	assert( 0 );		// we tried to remove a non-linked attribute.
}


#ifdef TIXML_USE_STL
const TiXmlAttribute* TiXmlAttributeSet::Find( const std::string& name ) const
{
	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( node->name == name )
			return node;
	}
	return 0;
}

/*
TiXmlAttribute*	TiXmlAttributeSet::Find( const std::string& name )
{
	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( node->name == name )
			return node;
	}
	return 0;
}
*/
#endif


const TiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const
{
	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( strcmp( node->name.c_str(), name ) == 0 )
			return node;
	}
	return 0;
}

/*
TiXmlAttribute*	TiXmlAttributeSet::Find( const char* name )
{
	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( strcmp( node->name.c_str(), name ) == 0 )
			return node;
	}
	return 0;
}
*/

#ifdef TIXML_USE_STL
std::istream& operator>> (std::istream & in, TiXmlNode & base)
{
	TIXML_STRING tag;
	tag.reserve( 8 * 1000 );
	base.StreamIn( &in, &tag );

	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
	return in;
}
#endif


#ifdef TIXML_USE_STL
std::ostream& operator<< (std::ostream & out, const TiXmlNode & base)
{
	TiXmlPrinter printer;
	printer.SetStreamPrinting();
	base.Accept( &printer );
	out << printer.Str();

	return out;
}


std::string& operator<< (std::string& out, const TiXmlNode& base )
{
	TiXmlPrinter printer;
	printer.SetStreamPrinting();
	base.Accept( &printer );
	out.append( printer.Str() );

	return out;
}
#endif


TiXmlHandle TiXmlHandle::FirstChild() const
{
	if ( node )
	{
		TiXmlNode* child = node->FirstChild();
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
{
	if ( node )
	{
		TiXmlNode* child = node->FirstChild( value );
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::FirstChildElement() const
{
	if ( node )
	{
		TiXmlElement* child = node->FirstChildElement();
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
{
	if ( node )
	{
		TiXmlElement* child = node->FirstChildElement( value );
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::Child( int count ) const
{
	if ( node )
	{
		int i;
		TiXmlNode* child = node->FirstChild();
		for (	i=0;
				child && i<count;
				child = child->NextSibling(), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
{
	if ( node )
	{
		int i;
		TiXmlNode* child = node->FirstChild( value );
		for (	i=0;
				child && i<count;
				child = child->NextSibling( value ), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::ChildElement( int count ) const
{
	if ( node )
	{
		int i;
		TiXmlElement* child = node->FirstChildElement();
		for (	i=0;
				child && i<count;
				child = child->NextSiblingElement(), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
{
	if ( node )
	{
		int i;
		TiXmlElement* child = node->FirstChildElement( value );
		for (	i=0;
				child && i<count;
				child = child->NextSiblingElement( value ), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


bool TiXmlPrinter::VisitEnter( const TiXmlDocument& )
{
	return true;
}

bool TiXmlPrinter::VisitExit( const TiXmlDocument& )
{
	return true;
}

bool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
{
	DoIndent();
	buffer += "<";
	buffer += element.Value();

	for( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )
	{
		buffer += " ";
		attrib->Print( 0, 0, &buffer );
	}

	if ( !element.FirstChild() )
	{
		buffer += " />";
		DoLineBreak();
	}
	else
	{
		buffer += ">";
		if (    element.FirstChild()->ToText()
			  && element.LastChild() == element.FirstChild()
			  && element.FirstChild()->ToText()->CDATA() == false )
		{
			simpleTextPrint = true;
			// no DoLineBreak()!
		}
		else
		{
			DoLineBreak();
		}
	}
	++depth;
	return true;
}


bool TiXmlPrinter::VisitExit( const TiXmlElement& element )
{
	--depth;
	if ( !element.FirstChild() )
	{
		// nothing.
	}
	else
	{
		if ( simpleTextPrint )
		{
			simpleTextPrint = false;
		}
		else
		{
			DoIndent();
		}
		buffer += "</";
		buffer += element.Value();
		buffer += ">";
		DoLineBreak();
	}
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlText& text )
{
	if ( text.CDATA() )
	{
		DoIndent();
		buffer += "<![CDATA[";
		buffer += text.Value();
		buffer += "]]>";
		DoLineBreak();
	}
	else if ( simpleTextPrint )
	{
		TIXML_STRING str;
		TiXmlBase::EncodeString( text.ValueTStr(), &str );
		buffer += str;
	}
	else
	{
		DoIndent();
		TIXML_STRING str;
		TiXmlBase::EncodeString( text.ValueTStr(), &str );
		buffer += str;
		DoLineBreak();
	}
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )
{
	DoIndent();
	declaration.Print( 0, 0, &buffer );
	DoLineBreak();
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlComment& comment )
{
	DoIndent();
	buffer += "<!--";
	buffer += comment.Value();
	buffer += "-->";
	DoLineBreak();
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )
{
	DoIndent();
	buffer += "<";
	buffer += unknown.Value();
	buffer += ">";
	DoLineBreak();
	return true;
}

bool TiXmlPrinter::Visit( const TiXmlStylesheetReference& stylesheet )
{
	    DoIndent();
	    stylesheet.Print( 0, 0, &buffer );
	    DoLineBreak();
	    return true;
}
/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/


#ifndef TINYXML_INCLUDED
#define TINYXML_INCLUDED

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable : 4530 )
#pragma warning( disable : 4786 )
#endif

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// Help out windows:
#if defined( _DEBUG ) && !defined( DEBUG )
#define DEBUG
#endif

#ifdef TIXML_USE_TICPP
	#ifndef TIXML_USE_STL
		#define TIXML_USE_STL
	#endif
#endif

#ifdef TIXML_USE_STL
	#include <string>
 	#include <iostream>
	#include <sstream>
	#define TIXML_STRING		std::string
#else
	#include "tinystr.h"
	#define TIXML_STRING		TiXmlString
#endif

// Deprecated library function hell. Compilers want to use the
// new safe versions. This probably doesn't fully address the problem,
// but it gets closer. There are too many compilers for me to fully
// test. If you get compilation troubles, undefine TIXML_SAFE
#define TIXML_SAFE

#ifdef TIXML_SAFE
	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
		// Microsoft visual studio, version 2005 and higher.
		#define TIXML_SNPRINTF _snprintf_s
		#define TIXML_SNSCANF  _snscanf_s
		#define TIXML_SSCANF   sscanf_s
	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
		// Microsoft visual studio, version 6 and higher.
		//#pragma message( "Using _sn* functions." )
		#define TIXML_SNPRINTF _snprintf
		#define TIXML_SNSCANF  _snscanf
		#define TIXML_SSCANF   sscanf
	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
		// GCC version 3 and higher.s
		//#warning( "Using sn* functions." )
		#define TIXML_SNPRINTF snprintf
		#define TIXML_SNSCANF  snscanf
		#define TIXML_SSCANF   sscanf
	#else
		#define TIXML_SSCANF   sscanf
	#endif
#endif

class TiXmlDocument;
class TiXmlElement;
class TiXmlComment;
class TiXmlUnknown;
class TiXmlAttribute;
class TiXmlText;
class TiXmlDeclaration;
class TiXmlStylesheetReference;
class TiXmlParsingData;

const int TIXML_MAJOR_VERSION = 2;
const int TIXML_MINOR_VERSION = 5;
const int TIXML_PATCH_VERSION = 3;

/*	Internal structure for tracking location of items
	in the XML file.
*/
struct TiXmlCursor
{
	TiXmlCursor()		{ Clear(); }
	void Clear()		{ row = col = -1; }

	int row;	// 0 based.
	int col;	// 0 based.
};


/**
	If you call the Accept() method, it requires being passed a TiXmlVisitor
	class to handle callbacks. For nodes that contain other nodes (Document, Element)
	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
	are simple called with Visit().

	If you return 'true' from a Visit method, recursive parsing will continue. If you return
	false, <b>no children of this node or its sibilings</b> will be Visited.

	All flavors of Visit methods have a default implementation that returns 'true' (continue
	visiting). You need to only override methods that are interesting to you.

	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.

	You should never change the document from a callback.

	@sa TiXmlNode::Accept()
*/
class TiXmlVisitor
{
public:
	virtual ~TiXmlVisitor() {}

	/// Visit a document.
	virtual bool VisitEnter( const TiXmlDocument& /*doc*/ )			{ return true; }
	/// Visit a document.
	virtual bool VisitExit( const TiXmlDocument& /*doc*/ )			{ return true; }

	/// Visit an element.
	virtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )	{ return true; }
	/// Visit an element.
	virtual bool VisitExit( const TiXmlElement& /*element*/ )		{ return true; }

	/// Visit a declaration
	virtual bool Visit( const TiXmlDeclaration& /*declaration*/ )	{ return true; }
	/// Visit a stylesheet reference
	virtual bool Visit( const TiXmlStylesheetReference& /*stylesheet*/ )	{ return true; }
	/// Visit a text node
	virtual bool Visit( const TiXmlText& /*text*/ )					{ return true; }
	/// Visit a comment node
	virtual bool Visit( const TiXmlComment& /*comment*/ )			{ return true; }
	/// Visit an unknow node
	virtual bool Visit( const TiXmlUnknown& /*unknown*/ )			{ return true; }
};

// Only used by Attribute::Query functions
enum
{
	TIXML_SUCCESS,
	TIXML_NO_ATTRIBUTE,
	TIXML_WRONG_TYPE
};


// Used by the parsing routines.
enum TiXmlEncoding
{
	TIXML_ENCODING_UNKNOWN,
	TIXML_ENCODING_UTF8,
	TIXML_ENCODING_LEGACY
};

const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;

/** TiXmlBase is a base class for every class in TinyXml.
	It does little except to establish that TinyXml classes
	can be printed and provide some utility functions.

	In XML, the document and elements can contain
	other elements and other types of nodes.

	@verbatim
	A Document can contain:	Element	(container or leaf)
							Comment (leaf)
							Unknown (leaf)
							Declaration( leaf )

	An Element can contain:	Element (container or leaf)
							Text	(leaf)
							Attributes (not on tree)
							Comment (leaf)
							Unknown (leaf)

	A Decleration contains: Attributes (not on tree)
	@endverbatim
*/
#ifdef TIXML_USE_TICPP
#include "ticpprc.h"
class TiXmlBase : public TiCppRC
#else
class TiXmlBase
#endif
{
	friend class TiXmlNode;
	friend class TiXmlElement;
	friend class TiXmlDocument;

public:
	TiXmlBase()	:	userData(0)		{}
	virtual ~TiXmlBase()			{}

	/**	All TinyXml classes can print themselves to a filestream
		or the string class (TiXmlString in non-STL mode, std::string
		in STL mode.) Either or both cfile and str can be null.

		This is a formatted print, and will insert
		tabs and newlines.

		(For an unformatted stream, use the << operator.)
	*/
	virtual void Print( FILE* cfile, int depth ) const = 0;

	/**	The world does not agree on whether white space should be kept or
		not. In order to make everyone happy, these global, static functions
		are provided to set whether or not TinyXml will condense all white space
		into a single space or not. The default is to condense. Note changing this
		value is not thread safe.
	*/
	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }

	/// Return the current white space setting.
	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }

	/** Return the position, in the original source file, of this node or attribute.
		The row and column are 1-based. (That is the first row and first column is
		1,1). If the returns values are 0 or less, then the parser does not have
		a row and column value.

		Generally, the row and column value will be set when the TiXmlDocument::Load(),
		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
		when the DOM was created from operator>>.

		The values reflect the initial load. Once the DOM is modified programmatically
		(by adding or changing nodes and attributes) the new values will NOT update to
		reflect changes in the document.

		There is a minor performance cost to computing the row and column. Computation
		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.

		@sa TiXmlDocument::SetTabSize()
	*/
	int Row() const			{ return location.row + 1; }
	int Column() const		{ return location.col + 1; }	///< See Row()

	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.

	// Table that returs, for a given lead byte, the total number of bytes
	// in the UTF-8 sequence.
	static const int utf8ByteTable[256];

	virtual const char* Parse(	const char* p,
								TiXmlParsingData* data,
								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;

	/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc,
		or they will be transformed into entities!
	*/
	static void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );

	enum
	{
		TIXML_NO_ERROR = 0,
		TIXML_ERROR,
		TIXML_ERROR_OPENING_FILE,
		TIXML_ERROR_OUT_OF_MEMORY,
		TIXML_ERROR_PARSING_ELEMENT,
		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
		TIXML_ERROR_READING_ELEMENT_VALUE,
		TIXML_ERROR_READING_ATTRIBUTES,
		TIXML_ERROR_PARSING_EMPTY,
		TIXML_ERROR_READING_END_TAG,
		TIXML_ERROR_PARSING_UNKNOWN,
		TIXML_ERROR_PARSING_COMMENT,
		TIXML_ERROR_PARSING_DECLARATION,
		TIXML_ERROR_DOCUMENT_EMPTY,
		TIXML_ERROR_EMBEDDED_NULL,
		TIXML_ERROR_PARSING_CDATA,
		TIXML_ERROR_DOCUMENT_TOP_ONLY,

		TIXML_ERROR_STRING_COUNT
	};

protected:

	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );
	inline static bool IsWhiteSpace( char c )
	{
		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' );
	}
	inline static bool IsWhiteSpace( int c )
	{
		if ( c < 256 )
			return IsWhiteSpace( (char) c );
		return false;	// Again, only truly correct for English/Latin...but usually works.
	}

	#ifdef TIXML_USE_STL
	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
	#endif

	/*	Reads an XML name into the string provided. Returns
		a pointer just past the last character of the name,
		or 0 if the function has an error.
	*/
	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );

	/*	Reads text. Returns a pointer past the given end tag.
		Wickedly complex options, but it keeps the (sensitive) code in one place.
	*/
	static const char* ReadText(	const char* in,				// where to start
									TIXML_STRING* text,			// the string read
									bool ignoreWhiteSpace,		// whether to keep the white space
									const char* endTag,			// what ends this text
									bool ignoreCase,			// whether to ignore case in the end tag
									TiXmlEncoding encoding );	// the current encoding

	// If an entity has been found, transform it into a character.
	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );

	// Get a character, while interpreting entities.
	// The length can be from 0 to 4 bytes.
	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
	{
		assert( p );
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			*length = utf8ByteTable[ *((const unsigned char*)p) ];
			assert( *length >= 0 && *length < 5 );
		}
		else
		{
			*length = 1;
		}

		if ( *length == 1 )
		{
			if ( *p == '&' )
				return GetEntity( p, _value, length, encoding );
			*_value = *p;
			return p+1;
		}
		else if ( *length )
		{
			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
												// and the null terminator isn't needed
			for( int i=0; p[i] && i<*length; ++i ) {
				_value[i] = p[i];
			}
			return p + (*length);
		}
		else
		{
			// Not valid text.
			return 0;
		}
	}

	// Return true if the next characters in the stream are any of the endTag sequences.
	// Ignore case only works for english, and should only be relied on when comparing
	// to English words: StringEqual( p, "version", true ) is fine.
	static bool StringEqual(	const char* p,
								const char* endTag,
								bool ignoreCase,
								TiXmlEncoding encoding );

	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];

	TiXmlCursor location;

    /// Field containing a generic user pointer
	void*			userData;

	// None of these methods are reliable for any language except English.
	// Good for approximation, not great for accuracy.
	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
	inline static int ToLower( int v, TiXmlEncoding encoding )
	{
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			if ( v < 128 ) return tolower( v );
			return v;
		}
		else
		{
			return tolower( v );
		}
	}
	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );

private:
	TiXmlBase( const TiXmlBase& );				// not implemented.
	void operator=( const TiXmlBase& base );	// not allowed.

	struct Entity
	{
		const char*     str;
		unsigned int	strLength;
		char		    chr;
	};
	enum
	{
		NUM_ENTITY = 5,
		MAX_ENTITY_LENGTH = 6

	};
	static Entity entity[ NUM_ENTITY ];
	static bool condenseWhiteSpace;
};


/** The parent class for everything in the Document Object Model.
	(Except for attributes).
	Nodes have siblings, a parent, and children. A node can be
	in a document, or stand on its own. The type of a TiXmlNode
	can be queried, and it can be cast to its more defined type.
*/
class TiXmlNode : public TiXmlBase
{
	friend class TiXmlDocument;
	friend class TiXmlElement;

public:
	#ifdef TIXML_USE_STL

	    /** An input stream operator, for every class. Tolerant of newlines and
		    formatting, but doesn't expect them.
	    */
	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);

	    /** An output stream operator, for every class. Note that this outputs
		    without any newlines or formatting, as opposed to Print(), which
		    includes tabs and new lines.

		    The operator<< and operator>> are not completely symmetric. Writing
		    a node to a stream is very well defined. You'll get a nice stream
		    of output, without any extra whitespace or newlines.

		    But reading is not as well defined. (As it always is.) If you create
		    a TiXmlElement (for example) and read that from an input stream,
		    the text needs to define an element or junk will result. This is
		    true of all input streams, but it's worth keeping in mind.

		    A TiXmlDocument will read nodes until it reads a root element, and
			all the children of that root element.
	    */
	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);

		/// Appends the XML node or attribute to a std::string.
		friend std::string& operator<< (std::string& out, const TiXmlNode& base );

	#endif

	/** The types of XML nodes supported by TinyXml. (All the
			unsupported types are picked up by UNKNOWN.)
	*/
	enum NodeType
	{
		DOCUMENT,
		ELEMENT,
		COMMENT,
		UNKNOWN,
		TEXT,
		DECLARATION,
		STYLESHEETREFERENCE,
		TYPECOUNT
	};

	virtual ~TiXmlNode();

	/** The meaning of 'value' changes for the specific type of
		TiXmlNode.
		@verbatim
		Document:	filename of the xml file
		Element:	name of the element
		Comment:	the comment text
		Unknown:	the tag contents
		Text:		the text string
		@endverbatim

		The subclasses will wrap this function.
	*/
	const char *Value() const { return value.c_str (); }

    #ifdef TIXML_USE_STL
	/** Return Value() as a std::string. If you only use STL,
	    this is more efficient than calling Value().
		Only available in STL mode.
	*/
	const std::string& ValueStr() const { return value; }
	#endif

	const TIXML_STRING& ValueTStr() const { return value; }

	/** Changes the value of the node. Defined as:
		@verbatim
		Document:	filename of the xml file
		Element:	name of the element
		Comment:	the comment text
		Unknown:	the tag contents
		Text:		the text string
		@endverbatim
	*/
	void SetValue(const char * _value) { value = _value;}

    #ifdef TIXML_USE_STL
	/// STL std::string form.
	void SetValue( const std::string& _value )	{ value = _value; }
	#endif

	/// Delete all the children of this node. Does not affect 'this'.
	void Clear();

	/// One step up the DOM.
	TiXmlNode* Parent()							{ return parent; }
	const TiXmlNode* Parent() const				{ return parent; }

	const TiXmlNode* FirstChild()	const		{ return firstChild; }	///< The first child of this node. Will be null if there are no children.
	TiXmlNode* FirstChild()						{ return firstChild; }
	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
	/// The first child of this node with the matching 'value'. Will be null if none found.
	TiXmlNode* FirstChild( const char * _value ) {
		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
		// call the method, cast the return back to non-const.
		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
	}
	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
	TiXmlNode* LastChild()	{ return lastChild; }

	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
	TiXmlNode* LastChild( const char * _value ) {
		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
	#endif

	/** An alternate way to walk the children of a node.
		One way to iterate over nodes is:
		@verbatim
			for( child = parent->FirstChild(); child; child = child->NextSibling() )
		@endverbatim

		IterateChildren does the same thing with the syntax:
		@verbatim
			child = 0;
			while( child = parent->IterateChildren( child ) )
		@endverbatim

		IterateChildren takes the previous child as input and finds
		the next one. If the previous child is null, it returns the
		first. IterateChildren will return null when done.
	*/
	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
	}

	/// This flavor of IterateChildren searches for children with a particular 'value'
	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
	#endif

	/** Add a new node related to this. Adds a child past the LastChild.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );


	/** Add a new node related to this. Adds a child past the LastChild.

		NOTE: the node to be added is passed by pointer, and will be
		henceforth owned (and deleted) by tinyXml. This method is efficient
		and avoids an extra copy, but should be used with care as it
		uses a different memory model than the other insert functions.

		@sa InsertEndChild
	*/
	TiXmlNode* LinkEndChild( TiXmlNode* addThis );

	/** Add a new node related to this. Adds a child before the specified child.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );

	/** Add a new node related to this. Adds a child after the specified child.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );

	/** Replace a child of this node.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );

	/// Delete a child of this node.
	bool RemoveChild( TiXmlNode* removeThis );

	/// Navigate to a sibling node.
	const TiXmlNode* PreviousSibling() const			{ return prev; }
	TiXmlNode* PreviousSibling()						{ return prev; }

	/// Navigate to a sibling node.
	const TiXmlNode* PreviousSibling( const char * ) const;
	TiXmlNode* PreviousSibling( const char *_prev ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
	#endif

	/// Navigate to a sibling node.
	const TiXmlNode* NextSibling() const				{ return next; }
	TiXmlNode* NextSibling()							{ return next; }

	/// Navigate to a sibling node with the given 'value'.
	const TiXmlNode* NextSibling( const char * ) const;
	TiXmlNode* NextSibling( const char* _next ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
	}

	/** Convenience function to get through elements.
		Calls NextSibling and ToElement. Will skip all non-Element
		nodes. Returns 0 if there is not another element.
	*/
	const TiXmlElement* NextSiblingElement() const;
	TiXmlElement* NextSiblingElement() {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
	}

	/** Convenience function to get through elements.
		Calls NextSibling and ToElement. Will skip all non-Element
		nodes. Returns 0 if there is not another element.
	*/
	const TiXmlElement* NextSiblingElement( const char * ) const;
	TiXmlElement* NextSiblingElement( const char *_next ) {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
	#endif

	/// Convenience function to get through elements.
	const TiXmlElement* FirstChildElement()	const;
	TiXmlElement* FirstChildElement() {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
	}

	/// Convenience function to get through elements.
	const TiXmlElement* FirstChildElement( const char * _value ) const;
	TiXmlElement* FirstChildElement( const char * _value ) {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
	#endif

	/** Query the type (as an enumerated value, above) of this node.
		The possible types are: DOCUMENT, ELEMENT, COMMENT,
								UNKNOWN, TEXT, and DECLARATION.
	*/
	int Type() const	{ return type; }

	/** Return a pointer to the Document this node lives in.
		Returns null if not in a document.
	*/
	const TiXmlDocument* GetDocument() const;
	TiXmlDocument* GetDocument() {
		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
	}

	/// Returns true if this node has no children.
	bool NoChildren() const						{ return !firstChild; }

	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlStylesheetReference* ToStylesheetReference() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlStylesheetReference*       ToStylesheetReference() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	/** Create an exact duplicate of this node and return it. The memory must be deleted
		by the caller.
	*/
	virtual TiXmlNode* Clone() const = 0;

	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the
		XML tree will be conditionally visited and the host will be called back
		via the TiXmlVisitor interface.

		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
		interface versus any other.)

		The interface has been based on ideas from:

		- http://www.saxproject.org/
		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern

		Which are both good references for "visiting".

		An example of using Accept():
		@verbatim
		TiXmlPrinter printer;
		tinyxmlDoc.Accept( &printer );
		const char* xmlcstr = printer.CStr();
		@endverbatim
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;

protected:
	TiXmlNode( NodeType _type );

	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
	// and the assignment operator.
	void CopyTo( TiXmlNode* target ) const;

	#ifdef TIXML_USE_STL
	    // The real work of the input operator.
	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
	#endif

	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );

	TiXmlNode*		parent;
	NodeType		type;

	TiXmlNode*		firstChild;
	TiXmlNode*		lastChild;

	TIXML_STRING	value;

	TiXmlNode*		prev;
	TiXmlNode*		next;

private:
	TiXmlNode( const TiXmlNode& );				// not implemented.
	void operator=( const TiXmlNode& base );	// not allowed.
};


/** An attribute is a name-value pair. Elements have an arbitrary
	number of attributes, each with a unique name.

	@note The attributes are not TiXmlNodes, since they are not
		  part of the tinyXML document object model. There are other
		  suggested ways to look at this problem.
*/
class TiXmlAttribute : public TiXmlBase
{
	friend class TiXmlAttributeSet;

public:
	/// Construct an empty attribute.
	TiXmlAttribute() : TiXmlBase()
	{
		document = 0;
		prev = next = 0;
	}

	#ifdef TIXML_USE_STL
	/// std::string constructor.
	TiXmlAttribute( const std::string& _name, const std::string& _value )
	{
		name = _name;
		value = _value;
		document = 0;
		prev = next = 0;
	}
	#endif

	/// Construct an attribute with a name and value.
	TiXmlAttribute( const char * _name, const char * _value )
	{
		name = _name;
		value = _value;
		document = 0;
		prev = next = 0;
	}

	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
	#ifdef TIXML_USE_STL
	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
	#endif
	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.

	// Get the tinyxml string representation
	const TIXML_STRING& NameTStr() const { return name; }

	/** QueryIntValue examines the value string. It is an alternative to the
		IntValue() method with richer error checking.
		If the value is an integer, it is stored in 'value' and
		the call returns TIXML_SUCCESS. If it is not
		an integer, it returns TIXML_WRONG_TYPE.

		A specialized but useful call. Note that for success it returns 0,
		which is the opposite of almost all other TinyXml calls.
	*/
	int QueryIntValue( int* _value ) const;
	/// QueryDoubleValue examines the value string. See QueryIntValue().
	int QueryDoubleValue( double* _value ) const;

	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.

	void SetIntValue( int _value );										///< Set the value from an integer.
	void SetDoubleValue( double _value );								///< Set the value from a double.

    #ifdef TIXML_USE_STL
	/// STL std::string form.
	void SetName( const std::string& _name )	{ name = _name; }
	/// STL std::string form.
	void SetValue( const std::string& _value )	{ value = _value; }
	#endif

	/// Get the next sibling attribute in the DOM. Returns null at end.
	const TiXmlAttribute* Next() const;
	TiXmlAttribute* Next() {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() );
	}

	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
	const TiXmlAttribute* Previous() const;
	TiXmlAttribute* Previous() {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() );
	}

	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }

	/*	Attribute parsing starts: first letter of the name
						 returns: the next char after the value end quote
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	// Prints this Attribute to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const {
		Print( cfile, depth, 0 );
	}
	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;

	// [internal use]
	// Set the document pointer so the attribute can report errors.
	void SetDocument( TiXmlDocument* doc )	{ document = doc; }

private:
	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
	void operator=( const TiXmlAttribute& base );	// not allowed.

	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
	TIXML_STRING name;
	TIXML_STRING value;
	TiXmlAttribute*	prev;
	TiXmlAttribute*	next;
};


/*	A class used to manage a group of attributes.
	It is only used internally, both by the ELEMENT and the DECLARATION.

	The set can be changed transparent to the Element and Declaration
	classes that use it, but NOT transparent to the Attribute
	which has to implement a next() and previous() method. Which makes
	it a bit problematic and prevents the use of STL.

	This version is implemented with circular lists because:
		- I like circular lists
		- it demonstrates some independence from the (typical) doubly linked list.
*/
class TiXmlAttributeSet
{
public:
	TiXmlAttributeSet();
	~TiXmlAttributeSet();

	void Add( TiXmlAttribute* attribute );
	void Remove( TiXmlAttribute* attribute );

	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }

	const TiXmlAttribute*	Find( const char* _name ) const;
	TiXmlAttribute*	Find( const char* _name ) {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
	}
	#ifdef TIXML_USE_STL
	const TiXmlAttribute*	Find( const std::string& _name ) const;
	TiXmlAttribute*	Find( const std::string& _name ) {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
	}

	#endif

private:
	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)

	TiXmlAttribute sentinel;
};


/** The element is a container class. It has a value, the element name,
	and can contain other elements, text, comments, and unknowns.
	Elements also contain an arbitrary number of attributes.
*/
class TiXmlElement : public TiXmlNode
{
public:
	/// Construct an element.
	TiXmlElement (const char * in_value);

	#ifdef TIXML_USE_STL
	/// std::string constructor.
	TiXmlElement( const std::string& _value );
	#endif

	TiXmlElement( const TiXmlElement& );

	void operator=( const TiXmlElement& base );

	virtual ~TiXmlElement();

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
	*/
	const char* Attribute( const char* name ) const;

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
		If the attribute exists and can be converted to an integer,
		the integer value will be put in the return 'i', if 'i'
		is non-null.
	*/
	const char* Attribute( const char* name, int* i ) const;

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
		If the attribute exists and can be converted to an double,
		the double value will be put in the return 'd', if 'd'
		is non-null.
	*/
	const char* Attribute( const char* name, double* d ) const;

	/** QueryIntAttribute examines the attribute - it is an alternative to the
		Attribute() method with richer error checking.
		If the attribute is an integer, it is stored in 'value' and
		the call returns TIXML_SUCCESS. If it is not
		an integer, it returns TIXML_WRONG_TYPE. If the attribute
		does not exist, then TIXML_NO_ATTRIBUTE is returned.
	*/
	int QueryIntAttribute( const char* name, int* _value ) const;
	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
	int QueryDoubleAttribute( const char* name, double* _value ) const;
	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
	int QueryFloatAttribute( const char* name, float* _value ) const {
		double d;
		int result = QueryDoubleAttribute( name, &d );
		if ( result == TIXML_SUCCESS ) {
			*_value = (float)d;
		}
		return result;
	}

    #ifdef TIXML_USE_STL
	/** Template form of the attribute query which will try to read the
		attribute into the specified type. Very easy, very powerful, but
		be careful to make sure to call this with the correct type.

		NOTE: This method doesn't work correctly for 'string' types.

		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
	*/
	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
	{
		const TiXmlAttribute* node = attributeSet.Find( name );
		if ( !node )
			return TIXML_NO_ATTRIBUTE;

		std::stringstream sstream( node->ValueStr() );
		sstream >> *outValue;
		if ( !sstream.fail() )
			return TIXML_SUCCESS;
		return TIXML_WRONG_TYPE;
	}
	/*
	 This is - in theory - a bug fix for "QueryValueAtribute returns truncated std::string"
	 but template specialization is hard to get working cross-compiler. Leaving the bug for now.

	// The above will fail for std::string because the space character is used as a seperator.
	// Specialize for strings. Bug [ 1695429 ] QueryValueAtribute returns truncated std::string
	template<> int QueryValueAttribute( const std::string& name, std::string* outValue ) const
	{
		const TiXmlAttribute* node = attributeSet.Find( name );
		if ( !node )
			return TIXML_NO_ATTRIBUTE;
		*outValue = node->ValueStr();
		return TIXML_SUCCESS;
	}
	*/
	#endif

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetAttribute( const char* name, const char * _value );

    #ifdef TIXML_USE_STL
	const std::string* Attribute( const std::string& name ) const;
	const std::string* Attribute( const std::string& name, int* i ) const;
	const std::string* Attribute( const std::string& name, double* d ) const;
	int QueryIntAttribute( const std::string& name, int* _value ) const;
	int QueryDoubleAttribute( const std::string& name, double* _value ) const;

	/// STL std::string form.
	void SetAttribute( const std::string& name, const std::string& _value );
	///< STL std::string form.
	void SetAttribute( const std::string& name, int _value );
	#endif

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetAttribute( const char * name, int value );

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetDoubleAttribute( const char * name, double value );

	/** Deletes an attribute with the given name.
	*/
	void RemoveAttribute( const char * name );
    #ifdef TIXML_USE_STL
	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
	#endif

	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }

	/** Convenience function for easy access to the text inside an element. Although easy
		and concise, GetText() is limited compared to getting the TiXmlText child
		and accessing it directly.

		If the first child of 'this' is a TiXmlText, the GetText()
		returns the character string of the Text node, else null is returned.

		This is a convenient method for getting the text of simple contained text:
		@verbatim
		<foo>This is text</foo>
		const char* str = fooElement->GetText();
		@endverbatim

		'str' will be a pointer to "This is text".

		Note that this function can be misleading. If the element foo was created from
		this XML:
		@verbatim
		<foo><b>This is text</b></foo>
		@endverbatim

		then the value of str would be null. The first child node isn't a text node, it is
		another element. From this XML:
		@verbatim
		<foo>This is <b>text</b></foo>
		@endverbatim
		GetText() will return "This is ".

		WARNING: GetText() accesses a child node - don't become confused with the
				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are
				 safe type casts on the referenced node.
	*/
	const char* GetText() const;

	/// Creates a new Element and returns it - the returned element is a copy.
	virtual TiXmlNode* Clone() const;
	// Print the Element to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/*	Attribtue parsing starts: next char past '<'
						 returns: next char past '>'
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children.
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:

	void CopyTo( TiXmlElement* target ) const;
	void ClearThis();	// like clear, but initializes 'this' object as well

	// Used to be public [internal use]
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif
	/*	[internal use]
		Reads the "value" of the element -- another element, or text.
		This should terminate with the current end tag.
	*/
	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );

private:

	TiXmlAttributeSet attributeSet;
};


/**	An XML comment.
*/
class TiXmlComment : public TiXmlNode
{
public:
	/// Constructs an empty comment.
	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
	/// Construct a comment from text.
	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::COMMENT ) {
		SetValue( _value );
	}
	TiXmlComment( const TiXmlComment& );
	void operator=( const TiXmlComment& base );

	virtual ~TiXmlComment()	{}

	/// Returns a copy of this Comment.
	virtual TiXmlNode* Clone() const;
	// Write this Comment to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/*	Attribtue parsing starts: at the ! of the !--
						 returns: next char past '>'
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children.
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
	void CopyTo( TiXmlComment* target ) const;

	// used to be public
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif
//	virtual void StreamOut( TIXML_OSTREAM * out ) const;

private:

};


/** XML text. A text node can have 2 ways to output the next. "normal" output
	and CDATA. It will default to the mode it was parsed from the XML file and
	you generally want to leave it alone, but you can change the output mode with
	SetCDATA() and query it with CDATA().
*/
class TiXmlText : public TiXmlNode
{
	friend class TiXmlElement;
public:
	/** Constructor for text element. By default, it is treated as
		normal, encoded text. If you want it be output as a CDATA text
		element, set the parameter _cdata to 'true'
	*/
	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TEXT)
	{
		SetValue( initValue );
		cdata = false;
	}
	virtual ~TiXmlText() {}

	#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
	{
		SetValue( initValue );
		cdata = false;
	}
	#endif

	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }

	// Write this text object to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/// Queries whether this represents text using a CDATA section.
	bool CDATA() const				{ return cdata; }
	/// Turns on or off a CDATA representation of text.
	void SetCDATA( bool _cdata )	{ cdata = _cdata; }

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children.
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected :
	///  [internal use] Creates a new Element and returns it.
	virtual TiXmlNode* Clone() const;
	void CopyTo( TiXmlText* target ) const;

	bool Blank() const;	// returns true if all white space and new lines
	// [internal use]
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:
	bool cdata;			// true if this should be input and output as a CDATA style text element
};


/** In correct XML the declaration is the first entry in the file.
	@verbatim
		<?xml version="1.0" standalone="yes"?>
	@endverbatim

	TinyXml will happily read or write files without a declaration,
	however. There are 3 possible attributes to the declaration:
	version, encoding, and standalone.

	Note: In this version of the code, the attributes are
	handled as special cases, not generic attributes, simply
	because there can only be at most 3 and they are always the same.
*/
class TiXmlDeclaration : public TiXmlNode
{
public:
	/// Construct an empty declaration.
	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}

#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlDeclaration(	const std::string& _version,
						const std::string& _encoding,
						const std::string& _standalone );
#endif

	/// Construct.
	TiXmlDeclaration(	const char* _version,
						const char* _encoding,
						const char* _standalone );

	TiXmlDeclaration( const TiXmlDeclaration& copy );
	void operator=( const TiXmlDeclaration& copy );

	virtual ~TiXmlDeclaration()	{}

	/// Version. Will return an empty string if none was found.
	const char *Version() const			{ return version.c_str (); }
	/// Encoding. Will return an empty string if none was found.
	const char *Encoding() const		{ return encoding.c_str (); }
	/// Is this a standalone document?
	const char *Standalone() const		{ return standalone.c_str (); }

	/// Creates a copy of this Declaration and returns it.
	virtual TiXmlNode* Clone() const;
	// Print this declaration to a FILE stream.
	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
	virtual void Print( FILE* cfile, int depth ) const {
		Print( cfile, depth, 0 );
	}

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children.
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
	void CopyTo( TiXmlDeclaration* target ) const;
	// used to be public
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:

	TIXML_STRING version;
	TIXML_STRING encoding;
	TIXML_STRING standalone;
};

/** A stylesheet reference looks like this:
	@verbatim
		<?xml-stylesheet type="text/xsl" href="style.xsl"?>
	@endverbatim

	Note: In this version of the code, the attributes are
	handled as special cases, not generic attributes, simply
	because there can only be at most 2 and they are always the same.
*/
class TiXmlStylesheetReference : public TiXmlNode
{
public:
	/// Construct an empty declaration.
	TiXmlStylesheetReference()   : TiXmlNode( TiXmlNode::STYLESHEETREFERENCE ) {}

#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlStylesheetReference(	const std::string& _type,
								const std::string& _href );
#endif

	/// Construct.
	TiXmlStylesheetReference(	const char* _type,
								const char* _href );

	TiXmlStylesheetReference( const TiXmlStylesheetReference& copy );
	void operator=( const TiXmlStylesheetReference& copy );

	virtual ~TiXmlStylesheetReference()	{}

	/// Type. Will return an empty string if none was found.
	const char *Type() const { return type.c_str (); }
	/// Href. Will return an empty string if none was found.
	const char *Href() const		{ return href.c_str (); }

	/// Creates a copy of this StylesheetReference and returns it.
	virtual TiXmlNode* Clone() const;
	// Print this declaration to a FILE stream.
	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
	virtual void Print( FILE* cfile, int depth ) const {
		Print( cfile, depth, 0 );
	}

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlStylesheetReference* ToStylesheetReference() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlStylesheetReference*       ToStylesheetReference()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children.
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
	void CopyTo( TiXmlStylesheetReference* target ) const;
	// used to be public
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:

	TIXML_STRING type;
	TIXML_STRING href;
};

/** Any tag that tinyXml doesn't recognize is saved as an
	unknown. It is a tag of text, but should not be modified.
	It will be written back to the XML, unchanged, when the file
	is saved.

	DTD tags get thrown into TiXmlUnknowns.
*/
class TiXmlUnknown : public TiXmlNode
{
public:
	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
	virtual ~TiXmlUnknown() {}

	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }

	/// Creates a copy of this Unknown and returns it.
	virtual TiXmlNode* Clone() const;
	// Print this Unknown to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children.
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected:
	void CopyTo( TiXmlUnknown* target ) const;

	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:

};


/** Always the top level node. A document binds together all the
	XML pieces. It can be saved, loaded, and printed to the screen.
	The 'value' of a document node is the xml file name.
*/
class TiXmlDocument : public TiXmlNode
{
public:
	/// Create an empty document, that has no name.
	TiXmlDocument();
	/// Create a document with a name. The name of the document is also the filename of the xml.
	TiXmlDocument( const char * documentName );

	#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlDocument( const std::string& documentName );
	#endif

	TiXmlDocument( const TiXmlDocument& copy );
	void operator=( const TiXmlDocument& copy );

	virtual ~TiXmlDocument() {}

	/** Load a file using the current document value.
		Returns true if successful. Will delete any existing
		document data before loading.
	*/
	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the current document value. Returns true if successful.
	bool SaveFile() const;
	/// Load a file using the given filename. Returns true if successful.
	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the given filename. Returns true if successful.
	bool SaveFile( const char * filename ) const;
	/** Load a file using the given FILE*. Returns true if successful. Note that this method
		doesn't stream - the entire object pointed at by the FILE*
		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
		file location. Streaming may be added in the future.
	*/
	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the given FILE*. Returns true if successful.
	bool SaveFile( FILE* ) const;

	#ifdef TIXML_USE_STL
	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
	{
//		StringToBuffer f( filename );
//		return ( f.buffer && LoadFile( f.buffer, encoding ));
		return LoadFile( filename.c_str(), encoding );
	}
	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
	{
//		StringToBuffer f( filename );
//		return ( f.buffer && SaveFile( f.buffer ));
		return SaveFile( filename.c_str() );
	}
	#endif

	/** Parse the given null terminated block of xml data. Passing in an encoding to this
		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
		to use that encoding, regardless of what TinyXml might otherwise try to detect.
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

	/** Get the root element -- the only top level element -- of the document.
		In well formed XML, there should only be one. TinyXml is tolerant of
		multiple elements at the document level.
	*/
	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
	TiXmlElement* RootElement()					{ return FirstChildElement(); }

	/** If an error occurs, Error will be set to true. Also,
		- The ErrorId() will contain the integer identifier of the error (not generally useful)
		- The ErrorDesc() method will return the name of the error. (very useful)
		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
	*/
	bool Error() const						{ return error; }

	/// Contains a textual (english) description of the error if one occurs.
	const char * ErrorDesc() const	{ return errorDesc.c_str (); }

	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
		prefer the ErrorId, this function will fetch it.
	*/
	int ErrorId()	const				{ return errorId; }

	/** Returns the location (if known) of the error. The first column is column 1,
		and the first row is row 1. A value of 0 means the row and column wasn't applicable
		(memory errors, for example, have no row/column) or the parser lost the error. (An
		error in the error reporting, in that case.)

		@sa SetTabSize, Row, Column
	*/
	int ErrorRow() const	{ return errorLocation.row+1; }
	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()

	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
		to report the correct values for row and column. It does not change the output
		or input in any way.

		By calling this method, with a tab size
		greater than 0, the row and column of each node and attribute is stored
		when the file is loaded. Very useful for tracking the DOM back in to
		the source file.

		The tab size is required for calculating the location of nodes. If not
		set, the default of 4 is used. The tabsize is set per document. Setting
		the tabsize to 0 disables row/column tracking.

		Note that row and column tracking is not supported when using operator>>.

		The tab size needs to be enabled before the parse or load. Correct usage:
		@verbatim
		TiXmlDocument doc;
		doc.SetTabSize( 8 );
		doc.Load( "myfile.xml" );
		@endverbatim

		@sa Row, Column
	*/
	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }

	int TabSize() const	{ return tabsize; }

	/** If you have handled the error, it can be reset with this call. The error
		state is automatically cleared if you Parse a new XML block.
	*/
	void ClearError()						{	error = false;
												errorId = 0;
												errorDesc = "";
												errorLocation.row = errorLocation.col = 0;
												//errorLocation.last = 0;
											}

	/** Write the document to standard out using formatted printing ("pretty print"). */
	void Print() const						{ Print( stdout, 0 ); }

	/* Write the document to a string using formatted printing ("pretty print"). This
		will allocate a character array (new char[]) and return it as a pointer. The
		calling code pust call delete[] on the return char* to avoid a memory leak.
	*/
	//char* PrintToMemory() const;

	/// Print this Document to a FILE stream.
	virtual void Print( FILE* cfile, int depth = 0 ) const;
	// [internal use]
	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );

	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children.
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected :
	// [internal use]
	virtual TiXmlNode* Clone() const;
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:
	void CopyTo( TiXmlDocument* target ) const;

	bool error;
	int  errorId;
	TIXML_STRING errorDesc;
	int tabsize;
	TiXmlCursor errorLocation;
	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
};


/**
	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
	DOM structure. It is a separate utility class.

	Take an example:
	@verbatim
	<Document>
		<Element attributeA = "valueA">
			<Child attributeB = "value1" />
			<Child attributeB = "value2" />
		</Element>
	<Document>
	@endverbatim

	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
	easy to write a *lot* of code that looks like:

	@verbatim
	TiXmlElement* root = document.FirstChildElement( "Document" );
	if ( root )
	{
		TiXmlElement* element = root->FirstChildElement( "Element" );
		if ( element )
		{
			TiXmlElement* child = element->FirstChildElement( "Child" );
			if ( child )
			{
				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
				if ( child2 )
				{
					// Finally do something useful.
	@endverbatim

	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe
	and correct to use:

	@verbatim
	TiXmlHandle docHandle( &document );
	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
	if ( child2 )
	{
		// do something useful
	@endverbatim

	Which is MUCH more concise and useful.

	It is also safe to copy handles - internally they are nothing more than node pointers.
	@verbatim
	TiXmlHandle handleCopy = handle;
	@endverbatim

	What they should not be used for is iteration:

	@verbatim
	int i=0;
	while ( true )
	{
		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
		if ( !child )
			break;
		// do something
		++i;
	}
	@endverbatim

	It seems reasonable, but it is in fact two embedded while loops. The Child method is
	a linear walk to find the element, so this code would iterate much more than it needs
	to. Instead, prefer:

	@verbatim
	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();

	for( child; child; child=child->NextSiblingElement() )
	{
		// do something
	}
	@endverbatim
*/
class TiXmlHandle
{
public:
	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
	/// Copy constructor
	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }

	/// Return a handle to the first child node.
	TiXmlHandle FirstChild() const;
	/// Return a handle to the first child node with the given name.
	TiXmlHandle FirstChild( const char * value ) const;
	/// Return a handle to the first child element.
	TiXmlHandle FirstChildElement() const;
	/// Return a handle to the first child element with the given name.
	TiXmlHandle FirstChildElement( const char * value ) const;

	/** Return a handle to the "index" child with the given name.
		The first child is 0, the second 1, etc.
	*/
	TiXmlHandle Child( const char* value, int index ) const;
	/** Return a handle to the "index" child.
		The first child is 0, the second 1, etc.
	*/
	TiXmlHandle Child( int index ) const;
	/** Return a handle to the "index" child element with the given name.
		The first child element is 0, the second 1, etc. Note that only TiXmlElements
		are indexed: other types are not counted.
	*/
	TiXmlHandle ChildElement( const char* value, int index ) const;
	/** Return a handle to the "index" child element.
		The first child element is 0, the second 1, etc. Note that only TiXmlElements
		are indexed: other types are not counted.
	*/
	TiXmlHandle ChildElement( int index ) const;

	#ifdef TIXML_USE_STL
	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }

	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
	#endif

	/** Return the handle as a TiXmlNode. This may return null.
	*/
	TiXmlNode* ToNode() const			{ return node; }
	/** Return the handle as a TiXmlElement. This may return null.
	*/
	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
	/**	Return the handle as a TiXmlText. This may return null.
	*/
	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
	/** Return the handle as a TiXmlUnknown. This may return null.
	*/
	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }

	/** @deprecated use ToNode.
		Return the handle as a TiXmlNode. This may return null.
	*/
	TiXmlNode* Node() const			{ return ToNode(); }
	/** @deprecated use ToElement.
		Return the handle as a TiXmlElement. This may return null.
	*/
	TiXmlElement* Element() const	{ return ToElement(); }
	/**	@deprecated use ToText()
		Return the handle as a TiXmlText. This may return null.
	*/
	TiXmlText* Text() const			{ return ToText(); }
	/** @deprecated use ToUnknown()
		Return the handle as a TiXmlUnknown. This may return null.
	*/
	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }

private:
	TiXmlNode* node;
};


/** Print to memory functionality. The TiXmlPrinter is useful when you need to:

	-# Print to memory (especially in non-STL mode)
	-# Control formatting (line endings, etc.)

	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
	Before calling Accept() you can call methods to control the printing
	of the XML document. After TiXmlNode::Accept() is called, the printed document can
	be accessed via the CStr(), Str(), and Size() methods.

	TiXmlPrinter uses the Visitor API.
	@verbatim
	TiXmlPrinter printer;
	printer.SetIndent( "\t" );

	doc.Accept( &printer );
	fprintf( stdout, "%s", printer.CStr() );
	@endverbatim
*/
class TiXmlPrinter : public TiXmlVisitor
{
public:
	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
					 buffer(), indent( "    " ), lineBreak( "\n" ) {}

	virtual bool VisitEnter( const TiXmlDocument& doc );
	virtual bool VisitExit( const TiXmlDocument& doc );

	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
	virtual bool VisitExit( const TiXmlElement& element );

	virtual bool Visit( const TiXmlDeclaration& declaration );
	virtual bool Visit( const TiXmlText& text );
	virtual bool Visit( const TiXmlComment& comment );
	virtual bool Visit( const TiXmlUnknown& unknown );
	virtual bool Visit( const TiXmlStylesheetReference& stylesheet );

	/** Set the indent characters for printing. By default 4 spaces
		but tab (\t) is also useful, or null/empty string for no indentation.
	*/
	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
	/// Query the indention string.
	const char* Indent()							{ return indent.c_str(); }
	/** Set the line breaking string. By default set to newline (\n).
		Some operating systems prefer other characters, or can be
		set to the null/empty string for no indenation.
	*/
	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
	/// Query the current line breaking string.
	const char* LineBreak()							{ return lineBreak.c_str(); }

	/** Switch over to "stream printing" which is the most dense formatting without
		linebreaks. Common when the XML is needed for network transmission.
	*/
	void SetStreamPrinting()						{ indent = "";
													  lineBreak = "";
													}
	/// Return the result.
	const char* CStr()								{ return buffer.c_str(); }
	/// Return the length of the result string.
	size_t Size()									{ return buffer.size(); }

	#ifdef TIXML_USE_STL
	/// Return the result.
	const std::string& Str()						{ return buffer; }
	#endif

private:
	void DoIndent()	{
		for( int i=0; i<depth; ++i )
			buffer += indent;
	}
	void DoLineBreak() {
		buffer += lineBreak;
	}

	int depth;
	bool simpleTextPrint;
	TIXML_STRING buffer;
	TIXML_STRING indent;
	TIXML_STRING lineBreak;
};


#ifdef _MSC_VER
#pragma warning( pop )
#endif

#endif

/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied 
warranty. In no event will the authors be held liable for any 
damages arising from the use of this software.

Permission is granted to anyone to use this software for any 
purpose, including commercial applications, and to alter it and 
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

#include "tinyxml.h"

// The goal of the seperate error file is to make the first
// step towards localization. tinyxml (currently) only supports
// english error messages, but the could now be translated.
//
// It also cleans up the code a bit.
//

const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
{
	"No error",
	"Error",
	"Failed to open file",
	"Memory allocation failed.",
	"Error parsing Element.",
	"Failed to read Element name",
	"Error reading Element value.",
	"Error reading Attributes.",
	"Error: empty tag.",
	"Error reading end tag.",
	"Error parsing Unknown.",
	"Error parsing Comment.",
	"Error parsing Declaration.",
	"Error document empty.",
	"Error null (0) or unexpected EOF found in input stream.",
	"Error parsing CDATA.",
	"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.",
};
/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

#include <ctype.h>
#include <stddef.h>

#include "tinyxml.h"

//#define DEBUG_PARSER
#if defined( DEBUG_PARSER )
#	if defined( DEBUG ) && defined( _MSC_VER )
#		include <windows.h>
#		define TIXML_LOG OutputDebugString
#	else
#		define TIXML_LOG printf
#	endif
#endif

// Note tha "PutString" hardcodes the same list. This
// is less flexible than it appears. Changing the entries
// or order will break putstring.
TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] =
{
	{ "&amp;",  5, '&' },
	{ "&lt;",   4, '<' },
	{ "&gt;",   4, '>' },
	{ "&quot;", 6, '\"' },
	{ "&apos;", 6, '\'' }
};

// Bunch of unicode info at:
//		http://www.unicode.org/faq/utf_bom.html
// Including the basic of this table, which determines the #bytes in the
// sequence from the lead byte. 1 placed for invalid sequences --
// although the result will be junk, pass it through as much as possible.
// Beware of the non-characters in UTF-8:
//				ef bb bf (Microsoft "lead bytes")
//				ef bf be
//				ef bf bf

const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;

const int TiXmlBase::utf8ByteTable[256] =
{
	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0
		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
};


void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
{
	const unsigned long BYTE_MASK = 0xBF;
	const unsigned long BYTE_MARK = 0x80;
	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

	if (input < 0x80)
		*length = 1;
	else if ( input < 0x800 )
		*length = 2;
	else if ( input < 0x10000 )
		*length = 3;
	else if ( input < 0x200000 )
		*length = 4;
	else
		{ *length = 0; return; }	// This code won't covert this correctly anyway.

	output += *length;

	// Scary scary fall throughs.
	switch (*length)
	{
		case 4:
			--output;
			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
			input >>= 6;
		case 3:
			--output;
			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
			input >>= 6;
		case 2:
			--output;
			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
			input >>= 6;
		case 1:
			--output;
			*output = (char)(input | FIRST_BYTE_MARK[*length]);
	}
}


/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
{
	// This will only work for low-ascii, everything else is assumed to be a valid
	// letter. I'm not sure this is the best approach, but it is quite tricky trying
	// to figure out alhabetical vs. not across encoding. So take a very
	// conservative approach.

//	if ( encoding == TIXML_ENCODING_UTF8 )
//	{
		if ( anyByte < 127 )
			return isalpha( anyByte );
		else
			return 1;	// What else to do? The unicode set is huge...get the english ones right.
//	}
//	else
//	{
//		return isalpha( anyByte );
//	}
}


/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
{
	// This will only work for low-ascii, everything else is assumed to be a valid
	// letter. I'm not sure this is the best approach, but it is quite tricky trying
	// to figure out alhabetical vs. not across encoding. So take a very
	// conservative approach.

//	if ( encoding == TIXML_ENCODING_UTF8 )
//	{
		if ( anyByte < 127 )
			return isalnum( anyByte );
		else
			return 1;	// What else to do? The unicode set is huge...get the english ones right.
//	}
//	else
//	{
//		return isalnum( anyByte );
//	}
}


class TiXmlParsingData
{
	friend class TiXmlDocument;
  public:
	void Stamp( const char* now, TiXmlEncoding encoding );

	const TiXmlCursor& Cursor()	{ return cursor; }

  private:
	// Only used by the document!
	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
	{
		assert( start );
		stamp = start;
		tabsize = _tabsize;
		cursor.row = row;
		cursor.col = col;
	}

	TiXmlCursor		cursor;
	const char*		stamp;
	int				tabsize;
};


void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
{
	assert( now );

	// Do nothing if the tabsize is 0.
	if ( tabsize < 1 )
	{
		return;
	}

	// Get the current row, column.
	int row = cursor.row;
	int col = cursor.col;
	const char* p = stamp;
	assert( p );

	while ( p < now )
	{
		// Treat p as unsigned, so we have a happy compiler.
		const unsigned char* pU = (const unsigned char*)p;

		// Code contributed by Fletcher Dunn: (modified by lee)
		switch (*pU) {
			case 0:
				// We *should* never get here, but in case we do, don't
				// advance past the terminating null character, ever
				return;

			case '\r':
				// bump down to the next line
				++row;
				col = 0;
				// Eat the character
				++p;

				// Check for \r\n sequence, and treat this as a single character
				if (*p == '\n') {
					++p;
				}
				break;

			case '\n':
				// bump down to the next line
				++row;
				col = 0;

				// Eat the character
				++p;

				// Check for \n\r sequence, and treat this as a single
				// character.  (Yes, this bizarre thing does occur still
				// on some arcane platforms...)
				if (*p == '\r') {
					++p;
				}
				break;

			case '\t':
				// Eat the character
				++p;

				// Skip to next tab stop
				col = (col / tabsize + 1) * tabsize;
				break;

			case TIXML_UTF_LEAD_0:
				if ( encoding == TIXML_ENCODING_UTF8 )
				{
					if ( *(p+1) && *(p+2) )
					{
						// In these cases, don't advance the column. These are
						// 0-width spaces.
						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )
							p += 3;
						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )
							p += 3;
						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )
							p += 3;
						else
							{ p +=3; ++col; }	// A normal character.
					}
				}
				else
				{
					++p;
					++col;
				}
				break;

			default:
				if ( encoding == TIXML_ENCODING_UTF8 )
				{
					// Eat the 1 to 4 byte utf8 character.
					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];
					if ( step == 0 )
						step = 1;		// Error case from bad encoding, but handle gracefully.
					p += step;

					// Just advance one column, of course.
					++col;
				}
				else
				{
					++p;
					++col;
				}
				break;
		}
	}
	cursor.row = row;
	cursor.col = col;
	assert( cursor.row >= -1 );
	assert( cursor.col >= -1 );
	stamp = p;
	assert( stamp );
}


const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
{
	if ( !p || !*p )
	{
		return 0;
	}
	if ( encoding == TIXML_ENCODING_UTF8 )
	{
		while ( *p )
		{
			const unsigned char* pU = (const unsigned char*)p;

			// Skip the stupid Microsoft UTF-8 Byte order marks
			if (	*(pU+0)==TIXML_UTF_LEAD_0
				 && *(pU+1)==TIXML_UTF_LEAD_1
				 && *(pU+2)==TIXML_UTF_LEAD_2 )
			{
				p += 3;
				continue;
			}
			else if(*(pU+0)==TIXML_UTF_LEAD_0
				 && *(pU+1)==0xbfU
				 && *(pU+2)==0xbeU )
			{
				p += 3;
				continue;
			}
			else if(*(pU+0)==TIXML_UTF_LEAD_0
				 && *(pU+1)==0xbfU
				 && *(pU+2)==0xbfU )
			{
				p += 3;
				continue;
			}

			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.
				++p;
			else
				break;
		}
	}
	else
	{
		while ( ( *p && IsWhiteSpace( *p ) ) || *p == '\n' || *p =='\r' )
			++p;
	}

	return p;
}

#ifdef TIXML_USE_STL
/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )
{
	for( ;; )
	{
		if ( !in->good() ) return false;

		int c = in->peek();
		// At this scope, we can't get to a document. So fail silently.
		if ( !IsWhiteSpace( c ) || c <= 0 )
			return true;

		*tag += (char) in->get();
	}
}

/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )
{
	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
	while ( in->good() )
	{
		int c = in->peek();
		if ( c == character )
			return true;
		if ( c <= 0 )		// Silent failure: can't get document at this scope
			return false;

		in->get();
		*tag += (char) c;
	}
	return false;
}
#endif

// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The
// "assign" optimization removes over 10% of the execution time.
//
const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
{
	// Oddly, not supported on some comilers,
	//name->clear();
	// So use this:
	*name = "";
	assert( p );

	// Names start with letters or underscores.
	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
	// algorithm is generous.
	//
	// After that, they can be letters, underscores, numbers,
	// hyphens, or colons. (Colons are valid ony for namespaces,
	// but tinyxml can't tell namespaces from names.)
	if (    p && *p
		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
	{
		const char* start = p;
		while(		p && *p
				&&	(		IsAlphaNum( (unsigned char ) *p, encoding )
						 || *p == '_'
						 || *p == '-'
						 || *p == '.'
						 || *p == ':' ) )
		{
			//(*name) += *p; // expensive
			++p;
		}
		if ( p-start > 0 ) {
			name->assign( start, p-start );
		}
		return p;
	}
	return 0;
}

const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
{
	// Presume an entity, and pull it out.
    TIXML_STRING ent;
	int i;
	*length = 0;

	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
	{
		unsigned long ucs = 0;
		ptrdiff_t delta = 0;
		unsigned mult = 1;

		if ( *(p+2) == 'x' )
		{
			// Hexadecimal.
			if ( !*(p+3) ) return 0;

			const char* q = p+3;
			q = strchr( q, ';' );

			if ( !q || !*q ) return 0;

			delta = q-p;
			--q;

			while ( *q != 'x' )
			{
				if ( *q >= '0' && *q <= '9' )
					ucs += mult * (*q - '0');
				else if ( *q >= 'a' && *q <= 'f' )
					ucs += mult * (*q - 'a' + 10);
				else if ( *q >= 'A' && *q <= 'F' )
					ucs += mult * (*q - 'A' + 10 );
				else
					return 0;
				mult *= 16;
				--q;
			}
		}
		else
		{
			// Decimal.
			if ( !*(p+2) ) return 0;

			const char* q = p+2;
			q = strchr( q, ';' );

			if ( !q || !*q ) return 0;

			delta = q-p;
			--q;

			while ( *q != '#' )
			{
				if ( *q >= '0' && *q <= '9' )
					ucs += mult * (*q - '0');
				else
					return 0;
				mult *= 10;
				--q;
			}
		}
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			// convert the UCS to UTF-8
			ConvertUTF32ToUTF8( ucs, value, length );
		}
		else
		{
			*value = (char)ucs;
			*length = 1;
		}
		return p + delta + 1;
	}

	// Now try to match it.
	for( i=0; i<NUM_ENTITY; ++i )
	{
		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
		{
			assert( strlen( entity[i].str ) == entity[i].strLength );
			*value = entity[i].chr;
			*length = 1;
			return ( p + entity[i].strLength );
		}
	}

	// So it wasn't an entity, its unrecognized, or something like that.
	*value = *p;	// Don't put back the last one, since we return it!
	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
					// Just writes strange XML.
	return p+1;
}


bool TiXmlBase::StringEqual( const char* p,
							 const char* tag,
							 bool ignoreCase,
							 TiXmlEncoding encoding )
{
	assert( p );
	assert( tag );
	if ( !p || !*p )
	{
		assert( 0 );
		return false;
	}

	const char* q = p;

	if ( ignoreCase )
	{
		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
		{
			++q;
			++tag;
		}

		if ( *tag == 0 )
			return true;
	}
	else
	{
		while ( *q && *tag && *q == *tag )
		{
			++q;
			++tag;
		}

		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
			return true;
	}
	return false;
}

const char* TiXmlBase::ReadText(	const char* p,
									TIXML_STRING * text,
									bool trimWhiteSpace,
									const char* endTag,
									bool caseInsensitive,
									TiXmlEncoding encoding )
{
    *text = "";
	if (    !trimWhiteSpace			// certain tags always keep whitespace
		 || !condenseWhiteSpace )	// if true, whitespace is always kept
	{
		// Keep all the white space.
		while (	   p && *p
				&& !StringEqual( p, endTag, caseInsensitive, encoding )
			  )
		{
			int len;
			char cArr[4] = { 0, 0, 0, 0 };
			p = GetChar( p, cArr, &len, encoding );
			text->append( cArr, len );
		}
	}
	else
	{
		bool whitespace = false;

		// Remove leading white space:
		p = SkipWhiteSpace( p, encoding );
		while (	   p && *p
				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
		{
			if ( *p == '\r' || *p == '\n' )
			{
				whitespace = true;
				++p;
			}
			else if ( IsWhiteSpace( *p ) )
			{
				whitespace = true;
				++p;
			}
			else
			{
				// If we've found whitespace, add it before the
				// new character. Any whitespace just becomes a space.
				if ( whitespace )
				{
					(*text) += ' ';
					whitespace = false;
				}
				int len;
				char cArr[4] = { 0, 0, 0, 0 };
				p = GetChar( p, cArr, &len, encoding );
				if ( len == 1 )
					(*text) += cArr[0];	// more efficient
				else
					text->append( cArr, len );
			}
		}
	}
	if ( p )
		p += strlen( endTag );
	return p;
}

#ifdef TIXML_USE_STL

void TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	// The basic issue with a document is that we don't know what we're
	// streaming. Read something presumed to be a tag (and hope), then
	// identify it, and call the appropriate stream method on the tag.
	//
	// This "pre-streaming" will never read the closing ">" so the
	// sub-tag can orient itself.

	if ( !StreamTo( in, '<', tag ) )
	{
		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return;
	}

	while ( in->good() )
	{
		int tagIndex = (int) tag->length();
		while ( in->good() && in->peek() != '>' )
		{
			int c = in->get();
			if ( c <= 0 )
			{
				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
				break;
			}
			(*tag) += (char) c;
		}

		if ( in->good() )
		{
			// We now have something we presume to be a node of
			// some sort. Identify it, and call the node to
			// continue streaming.
			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );

			if ( node )
			{
				node->StreamIn( in, tag );
				bool isElement = node->ToElement() != 0;
				delete node;
				node = 0;

				// If this is the root element, we're done. Parsing will be
				// done by the >> operator.
				if ( isElement )
				{
					return;
				}
			}
			else
			{
				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
				return;
			}
		}
	}
	// We should have returned sooner.
	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
}

#endif

const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
{
	ClearError();

	// Parse away, at the document level. Since a document
	// contains nothing but other tags, most of what happens
	// here is skipping white space.
	if ( !p || !*p )
	{
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	// Note that, for a document, this needs to come
	// before the while space skip, so that parsing
	// starts from the pointer we are given.
	location.Clear();
	if ( prevData )
	{
		location.row = prevData->cursor.row;
		location.col = prevData->cursor.col;
	}
	else
	{
		location.row = 0;
		location.col = 0;
	}
	TiXmlParsingData data( p, TabSize(), location.row, location.col );
	location = data.Cursor();

	if ( encoding == TIXML_ENCODING_UNKNOWN )
	{
		// Check for the Microsoft UTF-8 lead bytes.
		const unsigned char* pU = (const unsigned char*)p;
		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )
		{
			encoding = TIXML_ENCODING_UTF8;
			useMicrosoftBOM = true;
		}
	}

    p = SkipWhiteSpace( p, encoding );
	if ( !p )
	{
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	while ( p && *p )
	{
		TiXmlNode* node = Identify( p, encoding );
		if ( node )
		{
			p = node->Parse( p, &data, encoding );
			LinkEndChild( node );
		}
		else
		{
			break;
		}

		// Did we get encoding info?
		if (    encoding == TIXML_ENCODING_UNKNOWN
			 && node->ToDeclaration() )
		{
			TiXmlDeclaration* dec = node->ToDeclaration();
			const char* enc = dec->Encoding();
			assert( enc );

			if ( *enc == 0 )
				encoding = TIXML_ENCODING_UTF8;
			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
				encoding = TIXML_ENCODING_UTF8;
			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
			else
				encoding = TIXML_ENCODING_LEGACY;
		}

		p = SkipWhiteSpace( p, encoding );
	}

	// Was this empty?
	if ( !firstChild ) {
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );
		return 0;
	}

	// All is well.
	return p;
}

void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	// The first error in a chain is more accurate - don't set again!
	if ( error )
		return;

	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
	error   = true;
	errorId = err;
	errorDesc = errorString[ errorId ];

	errorLocation.Clear();
	if ( pError && data )
	{
		data->Stamp( pError, encoding );
		errorLocation = data->Cursor();
	}
}


TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
{
	TiXmlNode* returnNode = 0;

	p = SkipWhiteSpace( p, encoding );
	if( !p || !*p || *p != '<' )
	{
		return 0;
	}

	TiXmlDocument* doc = GetDocument();
	p = SkipWhiteSpace( p, encoding );

	if ( !p || !*p )
	{
		return 0;
	}

	// What is this thing?
	// - Elements start with a letter or underscore, but xml is reserved.
	// - Comments: <!--
	// - Decleration: <?xml
	// - StylesheetReference <?xml-stylesheet
	// - Everthing else is unknown to tinyxml.
	//

	const char* xmlHeader = { "<?xml" };
	const char* xmlSSHeader = { "<?xml-stylesheet" };
	const char* commentHeader = { "<!--" };
	const char* dtdHeader = { "<!" };
	const char* cdataHeader = { "<![CDATA[" };

	if ( StringEqual( p, xmlSSHeader, true, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Stylesheet Reference\n" );
		#endif
		returnNode = new TiXmlStylesheetReference();
	}
	else if ( StringEqual( p, xmlHeader, true, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Declaration\n" );
		#endif
		returnNode = new TiXmlDeclaration();
	}
	else if ( StringEqual( p, commentHeader, false, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Comment\n" );
		#endif
		returnNode = new TiXmlComment();
	}
	else if ( StringEqual( p, cdataHeader, false, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing CDATA\n" );
		#endif
		TiXmlText* text = new TiXmlText( "" );
		text->SetCDATA( true );
		returnNode = text;
	}
	else if ( StringEqual( p, dtdHeader, false, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Unknown(1)\n" );
		#endif
		returnNode = new TiXmlUnknown();
	}
	else if (    IsAlpha( *(p+1), encoding )
			  || *(p+1) == '_' )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Element\n" );
		#endif
		returnNode = new TiXmlElement( "" );
	}
	else
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Unknown(2)\n" );
		#endif
		returnNode = new TiXmlUnknown();
	}

	if ( returnNode )
	{
		// Set the parent, so it can report errors
		returnNode->parent = this;
	}
	else
	{
		if ( doc )
			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
	}
	return returnNode;
}

#ifdef TIXML_USE_STL

void TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)
{
	// We're called with some amount of pre-parsing. That is, some of "this"
	// element is in "tag". Go ahead and stream to the closing ">"
	while( in->good() )
	{
		int c = in->get();
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}
		(*tag) += (char) c ;

		if ( c == '>' )
			break;
	}

	if ( tag->length() < 3 ) return;

	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
	// If not, identify and stream.

	if (    tag->at( tag->length() - 1 ) == '>'
		 && tag->at( tag->length() - 2 ) == '/' )
	{
		// All good!
		return;
	}
	else if ( tag->at( tag->length() - 1 ) == '>' )
	{
		// There is more. Could be:
		//		text
		//		cdata text (which looks like another node)
		//		closing tag
		//		another node.
		for ( ;; )
		{
			StreamWhiteSpace( in, tag );

			// Do we have text?
			if ( in->good() && in->peek() != '<' )
			{
				// Yep, text.
				TiXmlText text( "" );
				text.StreamIn( in, tag );

				// What follows text is a closing tag or another node.
				// Go around again and figure it out.
				continue;
			}

			// We now have either a closing tag...or another node.
			// We should be at a "<", regardless.
			if ( !in->good() ) return;
			assert( in->peek() == '<' );
			int tagIndex = (int) tag->length();

			bool closingTag = false;
			bool firstCharFound = false;

			for( ;; )
			{
				if ( !in->good() )
					return;

				int c = in->peek();
				if ( c <= 0 )
				{
					TiXmlDocument* document = GetDocument();
					if ( document )
						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
					return;
				}

				if ( c == '>' )
					break;

				*tag += (char) c;
				in->get();

				// Early out if we find the CDATA id.
				if ( c == '[' && tag->size() >= 9 )
				{
					size_t len = tag->size();
					const char* start = tag->c_str() + len - 9;
					if ( strcmp( start, "<![CDATA[" ) == 0 ) {
						assert( !closingTag );
						break;
					}
				}

				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
				{
					firstCharFound = true;
					if ( c == '/' )
						closingTag = true;
				}
			}
			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
			// If it was not, the streaming will be done by the tag.
			if ( closingTag )
			{
				if ( !in->good() )
					return;

				int c = in->get();
				if ( c <= 0 )
				{
					TiXmlDocument* document = GetDocument();
					if ( document )
						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
					return;
				}
				assert( c == '>' );
				*tag += (char) c;

				// We are done, once we've found our closing tag.
				return;
			}
			else
			{
				// If not a closing tag, id it, and stream.
				const char* tagloc = tag->c_str() + tagIndex;
				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
				if ( !node )
					return;
				node->StreamIn( in, tag );
				delete node;
				node = 0;

				// No return: go around from the beginning: text, closing tag, or node.
			}
		}
	}
}
#endif

const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	p = SkipWhiteSpace( p, encoding );
	TiXmlDocument* document = GetDocument();

	if ( !p || !*p )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
		return 0;
	}

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}

	if ( *p != '<' )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
		return 0;
	}

	p = SkipWhiteSpace( p+1, encoding );

	// Read the name.
	const char* pErr = p;

    p = ReadName( p, &value, encoding );
	if ( !p || !*p )
	{
		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
		return 0;
	}

    TIXML_STRING endTag ("</");
	endTag += value;
	endTag += ">";

	// Check for and read attributes. Also look for an empty
	// tag or an end tag.
	while ( p && *p )
	{
		pErr = p;
		p = SkipWhiteSpace( p, encoding );
		if ( !p || !*p )
		{
			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
			return 0;
		}
		if ( *p == '/' )
		{
			++p;
			// Empty tag.
			if ( *p  != '>' )
			{
				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );
				return 0;
			}
			return (p+1);
		}
		else if ( *p == '>' )
		{
			// Done with attributes (if there were any.)
			// Read the value -- which can include other
			// elements -- read the end tag, and return.
			++p;
			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
			if ( !p || !*p ) {
				// We were looking for the end tag, but found nothing.
				// Fix for [ 1663758 ] Failure to report error on bad XML
				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
				return 0;
			}

			// We should find the end tag now
			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
			{
				p += endTag.length();
				return p;
			}
			else
			{
				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
				return 0;
			}
		}
		else
		{
			// Try to read an attribute:
			TiXmlAttribute* attrib = new TiXmlAttribute();
			if ( !attrib )
			{
				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );
				return 0;
			}

			attrib->SetDocument( document );
			pErr = p;
			p = attrib->Parse( p, data, encoding );

			if ( !p || !*p )
			{
				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
				delete attrib;
				return 0;
			}

			// Handle the strange case of double attributes:
			#ifdef TIXML_USE_STL
			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
			#else
			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
			#endif
			if ( node )
			{
				node->SetValue( attrib->Value() );
				delete attrib;
				return 0;
			}

			attributeSet.Add( attrib );
		}
	}
	return p;
}


const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	TiXmlDocument* document = GetDocument();

	// Read in text and elements in any order.
	const char* pWithWhiteSpace = p;
	p = SkipWhiteSpace( p, encoding );

	while ( p && *p )
	{
		if ( *p != '<' )
		{
			// Take what we have, make a text element.
			TiXmlText* textNode = new TiXmlText( "" );

			if ( !textNode )
			{
				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );
				    return 0;
			}

			if ( TiXmlBase::IsWhiteSpaceCondensed() )
			{
				p = textNode->Parse( p, data, encoding );
			}
			else
			{
				// Special case: we want to keep the white space
				// so that leading spaces aren't removed.
				p = textNode->Parse( pWithWhiteSpace, data, encoding );
			}

			if ( !textNode->Blank() )
				LinkEndChild( textNode );
			else
				delete textNode;
		}
		else
		{
			// We hit a '<'
			// Have we hit a new element or an end tag? This could also be
			// a TiXmlText in the "CDATA" style.
			if ( StringEqual( p, "</", false, encoding ) )
			{
				return p;
			}
			else
			{
				TiXmlNode* node = Identify( p, encoding );
				if ( node )
				{
					p = node->Parse( p, data, encoding );
					LinkEndChild( node );
				}
				else
				{
					return 0;
				}
			}
		}
		pWithWhiteSpace = p;
		p = SkipWhiteSpace( p, encoding );
	}

	if ( !p )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
	}
	return p;
}


#ifdef TIXML_USE_STL
void TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->get();
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}
		(*tag) += (char) c;

		if ( c == '>' )
		{
			// All is well.
			return;
		}
	}
}
#endif


const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	TiXmlDocument* document = GetDocument();
	p = SkipWhiteSpace( p, encoding );

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}
	if ( !p || !*p || *p != '<' )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
		return 0;
	}
	++p;
    value = "";

	while ( p && *p && *p != '>' )
	{
		value += *p;
		++p;
	}

	if ( !p )
	{
		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
	}
	if ( *p == '>' )
		return p+1;
	return p;
}

#ifdef TIXML_USE_STL
void TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->get();
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}

		(*tag) += (char) c;

		if ( c == '>'
			 && tag->at( tag->length() - 2 ) == '-'
			 && tag->at( tag->length() - 3 ) == '-' )
		{
			// All is well.
			return;
		}
	}
}
#endif


const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	TiXmlDocument* document = GetDocument();
	value = "";

	p = SkipWhiteSpace( p, encoding );

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}
	const char* startTag = "<!--";
	const char* endTag   = "-->";

	if ( !StringEqual( p, startTag, false, encoding ) )
	{
		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
		return 0;
	}
	p += strlen( startTag );

	// [ 1475201 ] TinyXML parses entities in comments
	// Oops - ReadText doesn't work, because we don't want to parse the entities.
	// p = ReadText( p, &value, false, endTag, false, encoding );
	//
	// from the XML spec:
	/*
	 [Definition: Comments may appear anywhere in a document outside other markup; in addition,
	              they may appear within the document type declaration at places allowed by the grammar.
				  They are not part of the document's character data; an XML processor MAY, but need not,
				  make it possible for an application to retrieve the text of comments. For compatibility,
				  the string "--" (double-hyphen) MUST NOT occur within comments.] Parameter entity
				  references MUST NOT be recognized within comments.

				  An example of a comment:

				  <!-- declarations for <head> & <body> -->
	*/

    value = "";
	// Keep all the white space.
	while (	p && *p && !StringEqual( p, endTag, false, encoding ) )
	{
		value.append( p, 1 );
		++p;
	}
	if ( p )
		p += strlen( endTag );

	return p;
}


const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	p = SkipWhiteSpace( p, encoding );
	if ( !p || !*p ) return 0;

//	int tabsize = 4;
//	if ( document )
//		tabsize = document->TabSize();

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}
	// Read the name, the '=' and the value.
	const char* pErr = p;
	p = ReadName( p, &name, encoding );
	if ( !p || !*p )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
		return 0;
	}
	p = SkipWhiteSpace( p, encoding );
	if ( !p || !*p || *p != '=' )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
		return 0;
	}

	++p;	// skip '='
	p = SkipWhiteSpace( p, encoding );
	if ( !p || !*p )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
		return 0;
	}

	const char* end;
	const char SINGLE_QUOTE = '\'';
	const char DOUBLE_QUOTE = '\"';

	if ( *p == SINGLE_QUOTE )
	{
		++p;
		end = "\'";		// single quote in string
		p = ReadText( p, &value, false, end, false, encoding );
	}
	else if ( *p == DOUBLE_QUOTE )
	{
		++p;
		end = "\"";		// double quote in string
		p = ReadText( p, &value, false, end, false, encoding );
	}
	else
	{
		// All attribute values should be in single or double quotes.
		// But this is such a common error that the parser will try
		// its best, even without them.
		value = "";
		while (    p && *p											// existence
				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
				&& *p != '/' && *p != '>' )							// tag end
		{
			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {
				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
				// We did not have an opening quote but seem to have a
				// closing one. Give up and throw an error.
				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
				return 0;
			}
			value += *p;
			++p;
		}
	}
	return p;
}

#ifdef TIXML_USE_STL
void TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->peek();
		if ( !cdata && (c == '<' ) )
		{
			return;
		}
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}

		(*tag) += (char) c;
		in->get();	// "commits" the peek made above

		if ( cdata && c == '>' && tag->size() >= 3 ) {
			size_t len = tag->size();
			if ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {
				// terminator of cdata.
				return;
			}
		}
	}
}
#endif

const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	value = "";
	TiXmlDocument* document = GetDocument();

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}

	const char* const startTag = "<![CDATA[";
	const char* const endTag   = "]]>";

	if ( cdata || StringEqual( p, startTag, false, encoding ) )
	{
		cdata = true;

		if ( !StringEqual( p, startTag, false, encoding ) )
		{
			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );
			return 0;
		}
		p += strlen( startTag );

		// Keep all the white space, ignore the encoding, etc.
		while (	   p && *p
				&& !StringEqual( p, endTag, false, encoding )
			  )
		{
			value += *p;
			++p;
		}

		TIXML_STRING dummy;
		p = ReadText( p, &dummy, false, endTag, false, encoding );
		return p;
	}
	else
	{
		bool ignoreWhite = true;

		const char* end = "<";
		p = ReadText( p, &value, ignoreWhite, end, false, encoding );
		if ( p )
			return p-1;	// don't truncate the '<'
		return 0;
	}
}

#ifdef TIXML_USE_STL
void TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->get();
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}
		(*tag) += (char) c;

		if ( c == '>' )
		{
			// All is well.
			return;
		}
	}
}
#endif

const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
{
	p = SkipWhiteSpace( p, _encoding );
	// Find the beginning, find the end, and look for
	// the stuff in-between.
	TiXmlDocument* document = GetDocument();
	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
		return 0;
	}
	if ( data )
	{
		data->Stamp( p, _encoding );
		location = data->Cursor();
	}
	p += 5;

	version = "";
	encoding = "";
	standalone = "";

	while ( p && *p )
	{
		if ( *p == '>' )
		{
			++p;
			return p;
		}

		p = SkipWhiteSpace( p, _encoding );
		if ( StringEqual( p, "version", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );
			version = attrib.Value();
		}
		else if ( StringEqual( p, "encoding", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );
			encoding = attrib.Value();
		}
		else if ( StringEqual( p, "standalone", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );
			standalone = attrib.Value();
		}
		else
		{
			// Read over whatever it is.
			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
				++p;
		}
	}
	return 0;
}

bool TiXmlText::Blank() const
{
	for ( unsigned i=0; i<value.length(); i++ )
		if ( !IsWhiteSpace( value[i] ) )
			return false;
	return true;
}

#ifdef TIXML_USE_STL
void TiXmlStylesheetReference::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->get();
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}
		(*tag) += (char) c;

		if ( c == '>' )
		{
			// All is well.
			return;
		}
	}
}
#endif

const char* TiXmlStylesheetReference::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
{
	p = SkipWhiteSpace( p, _encoding );
	// Find the beginning, find the end, and look for
	// the stuff in-between.
	TiXmlDocument* document = GetDocument();
	if ( !p || !*p || !StringEqual( p, "<?xml-stylesheet", true, _encoding ) )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
		return 0;
	}
	if ( data )
	{
		data->Stamp( p, _encoding );
		location = data->Cursor();
	}
	p += 5;

	type = "";
	href = "";

	while ( p && *p )
	{
		if ( *p == '>' )
		{
			++p;
			return p;
		}

		p = SkipWhiteSpace( p, _encoding );
		if ( StringEqual( p, "type", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );
			type = attrib.Value();
		}
		else if ( StringEqual( p, "href", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );
			href = attrib.Value();
		}
		else
		{
			// Read over whatever it is.
			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
				++p;
		}
	}
	return 0;
}
# Config File for Audio Initialization process

[PreloadAudio]
# Specify here which audio files to preload
# Format: [AudioName] = "[FileName]"
# optional settings:
# [AudioName].stream = ([true]/false)
# [AudioName].loop = (true/[false])
# [AudioName].prebuffer = (true/[false])
# [AudioName].volume = [volume]
# volume has to be float between 0.0 and 1.0, default is 1.0

bgmusic = "rain.ogg"
bgmusic.stream = false
bgmusic.loop = true
bgmusic.prebuffer = true
bgmusic.volume = 1.0

thunder = "thunder.wav"
thunder.stream = false
thunder.loop = false
thunder.prebuffer = true
thunder.volume = 0.75

thunder2 = "thunder2_.wav"
thunder2.stream = false
thunder2.loop = false
thunder2.prebuffer = true
thunder2.volume = 0.75# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 2.8

# Relative path conversion top directories.
SET(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/arne/Quell/Programme/runner-computerspiele-vorlesung")
SET(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/arne/Quell/Programme/runner-computerspiele-vorlesung")

# Force unix paths in dependencies.
SET(CMAKE_FORCE_UNIX_PATHS 1)

# The C and CXX include file search paths:
SET(CMAKE_C_INCLUDE_PATH
  "/usr/include/OIS"
  "/usr/include/boost-1_41"
  "/usr/include/OGRE"
  "dependencies/tinyxml"
  "dependencies/OgreOggSound/include"
  )
SET(CMAKE_CXX_INCLUDE_PATH ${CMAKE_C_INCLUDE_PATH})
SET(CMAKE_Fortran_INCLUDE_PATH ${CMAKE_C_INCLUDE_PATH})

# The C and CXX include file regular expressions for this directory.
SET(CMAKE_C_INCLUDE_REGEX_SCAN "^.*$")
SET(CMAKE_C_INCLUDE_REGEX_COMPLAIN "^$")
SET(CMAKE_CXX_INCLUDE_REGEX_SCAN ${CMAKE_C_INCLUDE_REGEX_SCAN})
SET(CMAKE_CXX_INCLUDE_REGEX_COMPLAIN ${CMAKE_C_INCLUDE_REGEX_COMPLAIN})
/*
 * CLog.cpp
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#include "CLog.h"

namespace Game {

CLog::ELogVerbosity CLog::LogVerbosity = logRelease;
std::string CLog::LogFileName = "game.log";

CLog::CLog() {
}

CLog::~CLog() {
}

CLog CLog::Get()
{
	// create new instance and return
	CLog log;
	return log;
}

std::string CLog::MakeTimePrefix() {
	//Find the current time
	time_t curtime = time(0);

	//convert it to tm
	tm now = *localtime(&curtime);

	//BUFSIZ is standard macro that expands to a integer constant expression
	//that is greater then or equal to 256. It is the size of the stream buffer
	//used by setbuf()
	char dest[BUFSIZ]={0};

	//Format string determines the conversion specification's behaviour
	const char format[] = "%X";

	//strftime - converts date and time to a string
	if (strftime(dest, sizeof(dest)-1, format, &now) > 0)
		return "[" + std::string(dest) + "] ";
	else
		return "";
}

void CLog::Write(std::string message, ELogVerbosity messageLevel)
{
	// dont log messages below verbosity level
	if (LogVerbosity < messageLevel) return;

	// write timestamp and message
	std::ofstream outfile(LogFileName.c_str(), std::ofstream::app);
	outfile << MakeTimePrefix();
	outfile << message;

	// append newline
	if (message[message.length()-1] != '\n')
		outfile << std::endl;

	outfile.close();
}

}
/*
 * CLog.h
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#ifndef CLOG_H_
#define CLOG_H_

#include <string>
#include <fstream>
#include <ctime>

namespace Game {

/** Simple class for logging
@remarks always use CLog::Get()*/
class CLog {
private:
	// helper function which returns current timestamp
	std::string MakeTimePrefix();

	CLog();
public:
	/** Logging levels, self-explanitory*/
	enum ELogVerbosity {logNothing = 0, logRelease = 1, logDebug = 4};

	virtual ~CLog();

	/** Only messages with MessageLevel below or equal LogVerbosity will be written */
	static ELogVerbosity LogVerbosity;

	/** The Log File, default is game.log */
	static std::string LogFileName;

	/** Factory method, returns an instance of CLog */
	static CLog Get();

	/** Write message to log file
	@param message The Message
	@param messageLevel The Message Level; see LogVerbosity*/
	void Write(std::string message, ELogVerbosity messageLevel);
};

}

#endif /* CLOG_H_ */
/*
 * CSettingsManager.cpp
 *
 *  Created on: 04.07.2010
 *      Author: untor
 */

#include "CSettingsManager.h"
#include "sstream"
//added directories boost/algorithm and boost/concept to ogre/boost_1_42/
#include "boost/algorithm/string.hpp"
#include <vector>
#include <exception>


namespace Game {

CSettingsManager::CSettingsManager(){
}

CSettingsManager::~CSettingsManager(){
}

void CSettingsManager::readConfig(char* filename) {

	std::fstream config;
	config.open(filename, std::ios::in);

	std::string line;
	std::string group = "default";
	std::string key;
	std::string svalue;
	boost::any avalue;
	size_t found;
	size_t found_end;

	while( getline(config,line) ){
		boost::trim(line);

		if(line[0] != '#') { // # Kommentarfunktion

			// search for groups
			if ( (line.find("[") != std::string::npos) && (line.find("]") != std::string::npos) ) {
				boost::erase_all(line,"[");
				boost::erase_all(line,"]");

				group = line;
			}

			// search for key = value
			else if (line.find("=") != std::string::npos ){

				// splits line ("=")
				std::vector<std::string> split_vector;

				boost::split( split_vector, line, boost::is_any_of("=") );

				boost::trim(split_vector[0]);
				boost::trim(split_vector[1]);

				key = split_vector[0];
				svalue = split_vector[1];

				avalue = this->identifyType(svalue);

				this->writeSettings(group,key,avalue);
			}

			else {
				boost::trim(line);
				this->writeSettings(group,line,true);
			}
		}
	}

	config.close();
}

template <typename T>T CSettingsManager::castFromString(std::string input) {
	T output;
	std::stringstream sstr;

	try {
	sstr << input;
	sstr >> output;
	}
    catch (std::exception& e)
    {
     	TEST_LOG("Standard exception: " << e.what() );
    }

	return output;
};

boost::any CSettingsManager::identifyType(std::string input){
	boost::any output;

	//Typunterscheidung - string erkennen
	if (input.find_first_of("\"") != std::string::npos) {

		std::string soutput;

		int i = input.find_first_of("\"");
		i++;
		while( (i < input.size()) && (input[i] != '\"') ) {
			i++;
		}
		// soutput is identified string
		soutput = input.substr(input.find_first_of("\"")+1,i-1);

		output = soutput;

		return output;
		}

	else if(input.find_first_not_of("1234567890") == std::string::npos){
		output = castFromString<int>(input);

		return output;
	}

	//Typunterscheidung - float erkennen
	else if ( (input.find_first_of(".") != std::string::npos)
		&& ( input.find_first_not_of("1234567890.")) == std::string::npos ){
		output = castFromString<float>(input);

		return output;
	}

	// boolean value
	else if (boost::algorithm::to_lower_copy(input) == "true") {
		output = (bool)true;
	} else if (boost::algorithm::to_lower_copy(input) == "false") {
		output = (bool)false;
	}

	return output;

}

void CSettingsManager::writeSettings(std::string group, std::string key, boost::any value){
		this->settings[group][key] = value;
	}

void CSettingsManager::extractSettings(char* filename) {

	std::fstream configCheck;
	configCheck.open(filename, std::ios::out);

	for(std::map<std::string, std::map<std::string, boost::any> >::iterator i = this->settings.begin();
			i != this->settings.end(); ++i) {

		configCheck << "[" << i->first << "]" << std::endl;

		for(std::map<std::string, boost::any>::iterator j = i->second.begin();
				j != i->second.end(); j++){

			configCheck << j->first << " " << std::endl;

		}
	}

}

std::vector<std::string> CSettingsManager::EnumerateSection(const std::string& SectionName) {
	// find section, return empty container if not exists
	if (settings.find(SectionName) == settings.end())
		return std::vector<std::string>();

	// return all keys in section
	std::vector<std::string> results;
	std::map<std::string, boost::any>& section = settings[SectionName];
	std::map<std::string, boost::any>::iterator it;
	for (it = section.begin(); it != section.end(); ++it) {
		results.push_back(it->first);
	}

	return results;
}

Ogre::NameValuePairList CSettingsManager::getVideoOptions(){
	return this->videoOptions;
}
}

/*
 * CSettingsManager.h
 *
 *  Created on: 04.07.2010
 *      Author: untor
 */

#ifndef CSETTINGSMANAGER_H_
#define CSETTINGSMANAGER_H_

#include "../testlog.h"
#include "Ogre.h"

#include "Singleton.h"
#include "string.h"
#include <map>
#include "boost/any.hpp"

namespace Game {

/** Manages all settings */
class CSettingsManager : public Singleton<CSettingsManager> {

private:
	std::map<std::string, std::map<std::string, boost::any> > settings;
	Ogre::NameValuePairList videoOptions;

	template <typename T>T castFromString(std::string input);
	boost::any identifyType(std::string input);

public:
	CSettingsManager();
	virtual ~CSettingsManager();

	void readConfig(char* filename);

	void writeSettings(std::string group, std::string key, boost::any value);
	void extractSettings(char* filename);
	boost::any convert(std::string value);

	template <typename T>T get(std::string group, std::string key, T defaultValue) {
		boost::any temp;
			T output;

			temp = this->settings[group][key];

			try {
				output = boost::any_cast<T>(temp);
			}
			catch (std::exception& e){
			      TEST_LOG( "Standard exception: " << e.what() );
			      output = defaultValue;
			}

			return output;
	}

	std::string getString(std::string group, std::string key, std::string defaultValue);
	int getInt(std::string group, std::string key, int defaultValue);
	float getFloat(std::string group, std::string key, float defaultValue);
	bool getBool(std::string group, std::string key, bool defaultValue);

	std::vector<std::string> EnumerateSection(const std::string& SectionName);

	Ogre::NameValuePairList getVideoOptions();

};
}

#endif /* CSETTINGSMANAGER_H_ */

/*
 * CStateManager.cpp
 *
 *  Created on: Jun 22, 2010
 *      Author: crt
 */

#include "CStateManager.h"

namespace Game {

CStateManager::CStateManager() : lFactories(), lStates()
{
}

CStateManager::~CStateManager() {
}

bool CStateManager::PushState(PState newState) {
	// pause current state
	if (GetCurrentState() != NULL)
		GetCurrentState()->Pause();

	if (!newState->Start()) {
		// resume previous state if new state won't start
		if (GetCurrentState() != NULL)
			GetCurrentState()->Resume();

		return false;
	} else {
		lStates.push_back(newState);
		return true;
	}
}

bool CStateManager::PushState(const std::string& newState) {
	// create and push new state
	PState state = this->CreateState(newState);
	if (state == NULL)
		return false;
	else
		return PushState(state);
}

bool CStateManager::ChangeState(PState newState) {
	// remove all states
	PopAll();

	// start and push new state
	if (newState->Start()) {
		lStates.push_back(newState);
		return true;
	}  else {
		return false;
	}
}

bool CStateManager::ChangeState(const std::string& newState) {
	// create new state and change to it
	PState state = this->CreateState(newState);
	if (state == NULL)
		return false;
	else
		return ChangeState(state);
}

void CStateManager::PopState() {
	// stop current state and remove
	if (GetCurrentState() != NULL) {
		GetCurrentState()->Stop();
		lStates.pop_back();
	}

	if (GetCurrentState() != NULL)
		GetCurrentState()->Resume();
}

void CStateManager::PopAll() {
	// pop all states
	while (lStates.size() > 0) {
		PopState();
	}
}

PState CStateManager::GetCurrentState() {
	// return state on top of the stack
	if (lStates.empty())
		return PState();
	return lStates.back();
}

PState CStateManager::CreateState(const std::string& stateType) {
	FactoryListItor it = lFactories.begin();
	PState newState;

	// loop through all factories and create new state
	while (it != lFactories.end() && newState == NULL) {
		newState = (*it)->CreateState(stateType);
		++it;
	}
	return newState;
}

void CStateManager::RegisterFactory(PStateFactory factory) {
	assert(factory != NULL);
	// add new factory if not already exists
	if (std::find(lFactories.begin(), lFactories.end(), factory) == lFactories.end())
		lFactories.push_back(factory);
}

}
/*
 * CStateManager.h
 *
 *  Created on: Jun 22, 2010
 *      Author: crt
 */

#ifndef CSTATEMANAGER_H_
#define CSTATEMANAGER_H_

#include "Singleton.h"
#include "IState.h"
#include "IStateFactory.h"

#include <string>
#include <vector>

namespace Game {

/** Manages a stack of IState */
class CStateManager : public Singleton<CStateManager> {
public:
	CStateManager();
	virtual ~CStateManager();

	/** Create and Push State on top
	@param newState Type Name of the new state
	@return false if new state can't be created or started*/
	bool PushState(const std::string& newState);

	/** Push State on top
	@param newState Pointer to new state
	@return false if new state can't be started*/
	bool PushState(PState newState);

	/** Pop All States, create and push new state
	@see PushState*/
	bool ChangeState(const std::string& newState);

	/** Pop All States and push new state
	@see PushState*/
	bool ChangeState(PState newState);

	/** Pop one State*/
	void PopState();

	/** Pop all States*/
	void PopAll();

	/** Returns current State; might return NULL*/
	PState GetCurrentState();

	/** Create new State by Name using one of the State Factories
	@param stateType Type Name of the State
	@remarks returns NULL if given type can't be created*/
	PState CreateState(const std::string& stateType);

	/** Adds a new factory to factory list
	@param factory Pointer to the new factory*/
	void RegisterFactory(PStateFactory factory);
private:
	typedef std::vector<PState> StateList;
	typedef std::vector<PState>::iterator StateListItor;

	typedef std::vector<PStateFactory> FactoryList;
	typedef std::vector<PStateFactory>::iterator FactoryListItor;

	FactoryList lFactories;
	StateList lStates;
};

}

#endif /* CSTATEMANAGER_H_ */

/*
 * CTaskManager.cpp
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#include "CTaskManager.h"

namespace Game {

CTaskManager::CTaskManager() : taskList()
{
}

CTaskManager::~CTaskManager()
{
}

void CTaskManager::Run()
{
	// loop through states while list is not empty
	while (!taskList.empty()) {
		// update all tasks
		for (TaskListItor it = taskList.begin(); it != taskList.end(); ) {
			PTask task(*it);
			++it;

			// remove dead tasks
			if (!task->running())
				taskList.remove(task);
			else
				task->Update();
		}

		// stop tasks flagged as "canKill"
		// note: tasks are removed next cycle if running flag is unset (should usually happen)
		for (TaskListItor it = taskList.begin(); it != taskList.end(); ) {
			PTask task(*it);
			++it;
			if (task->canKill()) {
				task->Stop();
			}
		}
	}
}

void CTaskManager::AddTask(PTask task)
{
	assert(task != NULL);

	// Task has to be started first
	if (!task->running())
		return;

	// find insert position
	TaskListItor it;
	for (it = taskList.begin(); it != taskList.end(); ++it)
	{
		PTask aTask(*it);
		if (aTask->GetPriority() > task->GetPriority()) break;
	}

	// insert new task
	taskList.insert(it, task);
}


void CTaskManager::AddTask(PTask task, int priority)
{
	assert(task != NULL);
	assert(priority > 0);

	task->SetPriority(priority);
	AddTask(task);
}



void CTaskManager::KillAll()
{
	// Stop all Tasks
	for (TaskListItor it = taskList.begin(); it != taskList.end(); ++it) {
		PTask task(*it);
		task->Kill();
	}
	// Note: Tasks are removed from List on next cycle
}

}
/*
 * CTaskManager.h
 *
 *  Created on: Jun 13, 2010
 *      Author: crt
 */

#ifndef CTASKMANAGER_H_
#define CTASKMANAGER_H_

#include "Singleton.h"
#include "ITask.h"
#include <list>

namespace Game {

/** Handles a list of Tasks
 @remarks
	 Add Tasks first, then call Run().
 */
class CTaskManager : public Singleton<CTaskManager> {
public:
	typedef std::list<PTask> TaskList;
	typedef std::list<PTask>::iterator TaskListItor;

private:
	TaskList taskList;

public:
	CTaskManager();
	virtual ~CTaskManager();

	/** Add Task to taskList
	@param task The Task to add
	@remarks Make sure to have task->priority set.
	*/
	void AddTask(PTask task);

	/** Add Task and set its priority
	@param task The Task
	@param priority its priority
	*/
	void AddTask(PTask task, int priority);

	/** Runs main loop; loops until taskList is empty. */
	void Run();

	/** Terminates all Tasks on next cycle */
	void KillAll();
};

}

#endif /* CTASKMANAGER_H_ */
/*
 * IState.h
 *
 *  Created on: Jun 19, 2010
 *      Author: crt
 */

#ifndef ISTATE_H_
#define ISTATE_H_

#include "OISMouse.h"
#include "OISKeyboard.h"
#include "OISJoyStick.h"

#include "boost/smart_ptr.hpp"

namespace Game {

class IState {
public:
	IState() {}
	virtual ~IState() {}

	/** Called once when State is pushed */
	virtual bool Start() = 0;

	/** Called once when State is popped */
	virtual void Stop() = 0;

	/* Called every time another state gets pushed on top this one */
	virtual void Pause() = 0;

	/* Called every time the state on top this one gets popped */
	virtual void Resume() = 0;

	/** Called on every frame */
	virtual void Update() = 0;

	// OIS::KeyListener
	virtual void keyPressed( const OIS::KeyEvent &e ) { }
	virtual void keyReleased( const OIS::KeyEvent &e ) { }

    // OIS::MouseListener
	virtual void mouseMoved( const OIS::MouseEvent &e ) { }
	virtual void mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id ) { }
	virtual void mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id ) { }

    // OIS::JoyStickListener
	virtual void povMoved( const OIS::JoyStickEvent &e, int pov ) { }
	virtual void axisMoved( const OIS::JoyStickEvent &e, int axis ) { }
	virtual void sliderMoved( const OIS::JoyStickEvent &e, int sliderID ) { }
	virtual void buttonPressed( const OIS::JoyStickEvent &e, int button ) { }
	virtual void buttonReleased( const OIS::JoyStickEvent &e, int button ) { }
};

typedef boost::shared_ptr<IState> PState;

}

#endif /* ISTATE_H_ */
/*
 * IStateFactory.h
 *
 *  Created on: Jun 22, 2010
 *      Author: crt
 */

#ifndef ISTATEFACTORY_H_
#define ISTATEFACTORY_H_

#include "IState.h"
#include "boost/smart_ptr.hpp"
#include <string>

namespace Game {

/** Abstract IState Factory class.
 */
class IStateFactory {
public:
	/** Returns an instance of the state, returns NULL if factory can't
	    create a state of the desired type
	 */
	virtual PState CreateState(const std::string& stateType) = 0;
};

typedef boost::shared_ptr<IStateFactory> PStateFactory;

}

#endif /* ISTATEFACTORY_H_ */
/*
 * ITask.h
 *
 *  Created on: Jun 13, 2010
 *      Author: crt
 */

#ifndef ITASK_H_
#define ITASK_H_

#include "boost/smart_ptr.hpp"

namespace Game {

class ITask {
protected:
	bool bRunning;
	bool bCanKill;
	int iPriority;
public:
	/** returns "running" flag */
	inline bool running() { return bRunning; }

	/** canKill flag, used by TaskManager to stop Tasks */
	inline bool canKill() { return bCanKill; }

	inline void SetPriority(int priority) { iPriority = priority; }
	inline int GetPriority() { return iPriority; }

    ITask() : bRunning(false),
    		  bCanKill(false),
    		  iPriority(0)
	{
	}

    /** Called when Task is started
    @remarks if successfully started, make sure the running flag is set
    @return true if successful */
	virtual bool Start()
	{
		this->bRunning = true;
		return true;
	}

	/** Called every frame */
	virtual void Update() = 0;

	/** Kill Task; Task is stopped on next cycle
	@remarks Use this to stop task instead of Stop()*/
	virtual void Kill()
	{
		this->bCanKill = true;
	}

	/** Called when stopping the task
	@remarks Do not use this; should only be called by TaskManager*/
	virtual void Stop()
	{
		this->bRunning = false;
	}
};

typedef boost::shared_ptr<ITask> PTask;

}

#endif /* ITASK_H_ */
/*
 * Singleton.h
 *
 *  Created on: Jun 13, 2010
 *      Author: crt
 */

#ifndef SINGLETON_H_
#define SINGLETON_H_

#include <assert.h>

namespace Game {

/** Generic Singleton
@author Scott Bilas, Game Programming Gems
 */
template<typename T>
class Singleton
{
	static T* ms_singleton;
	public:
		Singleton()
		{
			assert(!ms_singleton);
			//use a cunning trick to get the singleton pointing to the start of the whole, rather than
			//the start of the Singleton part of the object
#ifdef __i386__
			int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
			ms_singleton = (T*)((int)this + offset);
#else
			long offset = (long)(T*)1 - (long)(Singleton <T>*)(T*)1;
			ms_singleton = (T*)((long)this + offset);
#endif
		}

		~Singleton()
		{
			assert(ms_singleton);
			ms_singleton=0;
		}

		static inline T& GetSingleton()
		{
			assert(ms_singleton);
			return *ms_singleton;
		}

		static inline T* GetSingletonPtr()
		{
			assert(ms_singleton);
			return ms_singleton;
		}
};

template <typename T> T* Singleton <T>::ms_singleton = 0;

}

#endif /* SINGLETON_H_ */
/*
 * CLevelData.cpp
 *
 *  Created on: Aug 8, 2010
 *      Author: crt
 */

#include "CLevelData.h"

namespace Game {
namespace GameObjects {

CLevelData::CLevelData() {
	player = CPlayerModel::Create();
	playerView = CPlayerOgreView::Create(player);

	player->SetPosition(Ogre::Vector2::UNIT_Y * 5);
	player->SetSpeedLimits(CSettingsManager::GetSingleton().get<float>("Game", "speedMin", 50.0f),
						   CSettingsManager::GetSingleton().get<float>("Game", "speedMax", 100.0f),
						   CSettingsManager::GetSingleton().get<float>("Game", "acceleration", 1.0f));

	player->SetGravity(CSettingsManager::GetSingleton().get<float>("Game", "gravity", 90.0f));
	player->SetJumpAcceleration(CSettingsManager::GetSingleton().get<float>("Game", "jump", 30.0f));
	player->SetMaxJumpTime(CSettingsManager::GetSingleton().get<float>("Game", "jumpTime", 1.0f));
}

CLevelData::~CLevelData() {
}

void CLevelData::ClearData() {
	staticLevelData.clear();
	dynamicLevelData.clear();
	backgroundLevelData.clear();
}

void CLevelData::InsertObject(PLevelObject object, ObjectType type) {
	object->SetParent(self.lock());
	switch (type) {
	case otStatic:
		staticLevelData.push_back(object);
		break;
	case otDynamic:
		dynamicLevelData.push_back(object);
		break;
	case otBackground:
		backgroundLevelData.push_back(object);
		break;
	}
}

void CLevelData::InsertView(POgreView view, ObjectType type) {
	if (view->IsUpdateable())
		ogreUpdateableViews.push_back(view);
	else
		ogreViews.push_back(view);
}

Ogre::SceneNode* CLevelData::Draw(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode) {
	Ogre::SceneNode* node = NULL;
	if (ogreNode == NULL)
		node = ogreScene->getRootSceneNode()->createChildSceneNode(Ogre::Vector3::ZERO);
	else
		node = ogreNode->createChildSceneNode(Ogre::Vector3::ZERO);

	for (OgreViewList::iterator it = ogreViews.begin(); it != ogreViews.end(); ++it) {
		(*it)->SetOgreScene(ogreScene, node);
	}
	for (OgreViewList::iterator it = ogreUpdateableViews.begin(); it != ogreUpdateableViews.end(); ++it) {
		(*it)->SetOgreScene(ogreScene, node);
	}
	playerView->SetOgreScene(ogreScene, node);

	return node;
}

void CLevelData::Update(float deltaTime) {
	for (OgreViewList::iterator it = ogreUpdateableViews.begin(); it != ogreUpdateableViews.end(); ++it) {
		(*it)->Update(deltaTime);
	}
	playerView->Update(deltaTime);
	player->Update(deltaTime);
}

typedef ILevelObjectManager::LevelObjectList LevelObjectList;

ILevelObjectManager::LevelObjectList CLevelData::GetObjectRectangle(const Game::Rectangle& rect, ILevelObjectManager::LevelObjectList& list) {
	LevelObjectList results;
	for (LevelObjectList::iterator it = list.begin(); it != list.end(); ++it) {
		const PLevelObject& obj = *it;
		if (obj->GetBoundingBox().Intersects(rect))
			results.push_back(obj);
	}
	return results;
}

ILevelObjectManager::LevelObjectList CLevelData::GetObjectRectangle(const Game::Rectangle& rect) {
	// TODO: use space partitioning here
	LevelObjectList results = GetObjectRectangle(rect, this->staticLevelData);
	LevelObjectList temp = GetObjectRectangle(rect, this->dynamicLevelData);
	results.insert(results.end(), temp.begin(), temp.end());
	return results;
}

}
}
/*
 * CLevelData.h
 *
 *  Created on: Aug 8, 2010
 *      Author: crt
 */

#ifndef LEVELDATA_H_
#define LEVELDATA_H_

#include "Geometry.h"
#include "LevelObjects.h"
#include "LevelDataReader.h"
#include "LevelObjectManager.h"
#include "PlayerModel.h"
#include "PlayerView.h"
#include "../testlog.h"
#include "../Core/CLog.h"
#include "../Core/CSettingsManager.h"

#include "Ogre.h"

#include "boost/smart_ptr.hpp"

namespace Game {
namespace GameObjects {

class CLevelData;
typedef boost::shared_ptr<CLevelData> PLevelData;
typedef boost::weak_ptr<CLevelData> WLevelData;

class CLevelData : public CXMLReader::Listener, public ILevelObjectManager {
public:
	virtual ~CLevelData();

	/** Draw level in given ogre scene manager
	@param ogreScene scene manager to use
	@param ogreNode specify Node at which scene is drawn; NULL for root
	@return newly created scene node */
	Ogre::SceneNode* Draw(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode = NULL);

	/** Removes all objects */
	void ClearData();

	/** Insert object as specified type
	@param object The object
	@param type Specify where to insert (static, dynamic, background) */
	virtual void InsertObject(PLevelObject object, ObjectType type);

	/** Insert view as specified type
	@param object The object
	@param type Specify where to insert (static, dynamic, background) */
	virtual void InsertView(POgreView view, ObjectType type);

	static PLevelData Create() {
		CLevelData* leveldata = new CLevelData();
		PLevelData leveldataPtr(leveldata);
		leveldata->self = leveldataPtr;
		leveldata->player->SetParent(leveldataPtr);
		return leveldataPtr;
	}

	/** Implementation of CXMLReader::Listener */
	virtual void ReadLevelObject(PLevelObject object, ObjectType layer) {
		InsertObject(object, static_cast<ObjectType>(layer) );
	}

	/** Implementation of CXMLReader::Listener */
	virtual void ReadOgreView(POgreView view, ObjectType layer) {
		InsertView(view, layer);
	}

	/** Implementation of ILevelObjectManager */
	virtual ILevelObjectManager::LevelObjectList GetObjectRectangle(const Game::Rectangle& rect);

	void Update(float deltaTime);

	PPlayerModel GetPlayer() { return player; }
	PPlayerOgreView GetPlayerView() { return playerView; }
private:
	CLevelData();

	typedef std::vector<POgreView> OgreViewList;

	ILevelObjectManager::LevelObjectList GetObjectRectangle(const Game::Rectangle& rect, ILevelObjectManager::LevelObjectList& list);

	ILevelObjectManager::LevelObjectList staticLevelData;
	ILevelObjectManager::LevelObjectList backgroundLevelData;
	ILevelObjectManager::LevelObjectList dynamicLevelData;
	OgreViewList ogreViews;
	OgreViewList ogreUpdateableViews;

	PPlayerModel player;
	PPlayerOgreView playerView;

	WLevelData self;
};

}
}

#endif /* LEVELDATA_H_ */
/*
 * COverlay.cpp
 *
 *  Created on: Jul 6, 2010
 *      Author: crt
 */

#include "COverlay.h"

namespace Game {
namespace GameObjects {

COverlay::COverlay(std::string ogreOverlayTemplate, std::string ogreOverlayName, int zOrder)
	: ogrePanel(NULL),
	  ogreOverlay(NULL),
	  rootName(ogreOverlayName)
{
	// create ogre overlay
	ogrePanel = Ogre::OverlayManager::getSingleton().create(ogreOverlayName+"_panel");
	ogrePanel->setZOrder(zOrder);

	ogreOverlay = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate
		(ogreOverlayTemplate, "Panel", ogreOverlayName);

	Ogre::OverlayContainer* container = dynamic_cast<Ogre::OverlayContainer*>(ogreOverlay);

	//TODO: throw exception if container is NULL

	ogrePanel->add2D(container);
	ogrePanel->show();

	childTable.clear();
	MakeTable(container);
}

COverlay::~COverlay() {
	// remove ogre overlay element
	nukeOverlayElement(ogreOverlay);
	ogreOverlay = NULL;

	// remove overlay
	Ogre::OverlayManager::getSingleton().destroy(ogrePanel);
}

void COverlay::MakeTable(Ogre::OverlayContainer* element) {
	if (element == NULL) return;

	// loop childs
	Ogre::OverlayContainer::ChildIterator it = element->getChildIterator();
	while (it.hasMoreElements()) {
		Ogre::OverlayElement* pElement = it.getNext();
		if (pElement == NULL) continue;

		childTable[pElement->getName()] = pElement;

		// check if Element is also a Container and recurse
		Ogre::OverlayContainer* pContainer = dynamic_cast<Ogre::OverlayContainer*>(pElement);
		if (pContainer != NULL)
			MakeTable(pContainer);
	}
}

POverlay COverlay::Create(std::string ogreOverlayTemplate, std::string ogreOverlayName, int zOrder) {
	COverlay* overlay = new COverlay(ogreOverlayTemplate, ogreOverlayName, zOrder);
	POverlay overlayPtr(overlay);
	overlay->self = overlayPtr;
	return overlayPtr;
}

void COverlay::Show() {
	if (ogrePanel != NULL)
		ogrePanel->show();
}

void COverlay::Hide() {
	if (ogrePanel != NULL)
		ogrePanel->hide();
}

void COverlay::Show(const std::string& target) {
	std::string node = rootName+"/"+target;
	if (childTable[node] != NULL) {
		Ogre::OverlayElement* element = childTable[node];
		element->show();
	}
}

void COverlay::Hide(const std::string& target) {
	std::string node = rootName+"/"+target;
	if (childTable[node] != NULL) {
		Ogre::OverlayElement* element = childTable[node];
		element->hide();
	}
}

void COverlay::SetColor(std::string target, Ogre::ColourValue value) {
	std::string node = rootName+"/"+target;
	if (childTable[node] != NULL) {
		Ogre::OverlayElement* element = childTable[node];
		element->setColour(value);
	}
}

void COverlay::SetText(std::string target, std::string value) {
	std::string node = rootName+"/"+target;
	if (childTable[node] != NULL) {
		Ogre::OverlayElement* element = childTable[node];
		element->setCaption(value);
	}
}

void COverlay::nukeOverlayElement(Ogre::OverlayElement* element)
{
	// check if element is also a container
	Ogre::OverlayContainer* container = dynamic_cast<Ogre::OverlayContainer*>(element);
	if (container)
	{
		std::vector<Ogre::OverlayElement*> toDelete;

		// enumerate childs
		Ogre::OverlayContainer::ChildIterator children = container->getChildIterator();
		while (children.hasMoreElements())
		{
			toDelete.push_back(children.getNext());
		}

		// recursively delete childs
		for (unsigned int i = 0; i < toDelete.size(); i++)
		{
			nukeOverlayElement(toDelete[i]);
		}
	}
	if (element)
	{
		// if element is a child, remove from parent
		Ogre::OverlayContainer* parent = element->getParent();
		if (parent) parent->removeChild(element->getName());

		// delete overlay element
		Ogre::OverlayManager::getSingleton().destroyOverlayElement(element);
	}
}

}
}
/*
 * COverlay.h
 *
 *  Created on: Jul 6, 2010
 *      Author: crt
 */

#ifndef COVERLAY_H_
#define COVERLAY_H_

#include "../Core/CLog.h"
#include "Ogre.h"
#include <string>
#include <sstream>
#include <map>
#include <vector>
#include "boost/smart_ptr.hpp"

namespace Game {
namespace GameObjects {

class COverlay;
typedef boost::shared_ptr<COverlay> POverlay;
typedef boost::weak_ptr<COverlay> WPOverlay;

/** Wrapper for Ogre Overlay; provides additional functionality to easily display Text*/
class COverlay {
public:
	/** Factory method to create new object
	@param ogreOverlayTemplate Ogre Template Name
	@param ogreOverlayName Ogre Overlay Name; also creates new Overlay named [ogerOverlayName]_panel
	@param zOrder Z Position of overlay*/
	static POverlay Create(std::string ogreOverlayTemplate, std::string ogreOverlayName, int zOrder);
	virtual ~COverlay();

	/** Show Overlay */
	void Show();
	void Show(const std::string& target);

	/** Hide Overlay*/
	void Hide();
	void Hide(const std::string& target);

	inline Ogre::OverlayElement* GetElement(const std::string& name) { return childTable[rootName+"/"+name]; }

	inline Ogre::Overlay* GetOverlay() { return ogrePanel; }

	/** Set Color of Overlay Element
	@param target Ogre Name of the Overlay Element
	@param value Color*/
	void SetColor(std::string target, Ogre::ColourValue value);

	/** Set Caption of Overlay Element
	@param target Ogre Name of the Overlay Element
	@param value Caption*/
	void SetText(std::string target, std::string value);

	/** See SetText; uses stringstream to convert value to string */
	template <typename T>
	void SetValue(std::string target, T value);

	/** Helper function to delete Ogre Overlay Elements and all its childs recursively
	 *  Borrowed from Ogre Samples */
	static void nukeOverlayElement(Ogre::OverlayElement* element);

private:
	typedef std::map<std::string, Ogre::OverlayElement*> OverlayMap;
	typedef std::map<std::string, Ogre::OverlayElement*>::iterator OverlayMapItor;

	/** See ::Create(...)*/
	COverlay(std::string ogreOverlayTemplate, std::string ogreOverlayName, int zOrder);

	WPOverlay self;

	Ogre::Overlay* ogrePanel;
	Ogre::OverlayElement* ogreOverlay;

	OverlayMap childTable;

	std::string rootName;

	void MakeTable(Ogre::OverlayContainer* element);
};

template <typename T> void COverlay::SetValue(std::string target, T value) {
	std::stringstream sstream;
	sstream << value;
	SetText(target, sstream.str());
}

}
}

#endif /* COVERLAY_H_ */
/*
 * CPivotCamera.cpp
 *
 *  Created on: Jul 3, 2010
 *      Author: crt
 */

#include "CPivotCamera.h"

namespace Game {
namespace GameObjects {

CPivotCamera::CPivotCamera(Ogre::Camera* camera, float distance)
	: snCameraPivot(NULL),
	  snCameraGoal(NULL),
	  snCameraNode(NULL),
	  fSpeed(9.0f)
{
	// create a pivot at roughly the character's shoulder
	snCameraPivot = camera->getSceneManager()->getRootSceneNode()->createChildSceneNode();

	// this is where the camera should be soon, and it spins around the pivot
	snCameraGoal = snCameraPivot->createChildSceneNode(Ogre::Vector3(0, 0, distance));

	// this is where the camera actually is
	snCameraNode = camera->getSceneManager()->getRootSceneNode()->createChildSceneNode();
	snCameraNode->setPosition(snCameraPivot->getPosition() + snCameraGoal->getPosition());

	snCameraPivot->setFixedYawAxis(true);
	snCameraGoal->setFixedYawAxis(true);
	snCameraNode->setFixedYawAxis(true);

	snCameraNode->attachObject(camera);
}

CPivotCamera::~CPivotCamera() {
}

PPivotCamera CPivotCamera::Create(Ogre::Camera* camera, float distance) {
	CPivotCamera* pivotcamera = new CPivotCamera(camera, distance);
	PPivotCamera cameraPtr(pivotcamera);
	pivotcamera->self = cameraPtr;
	return cameraPtr;
}

void CPivotCamera::Update(float deltaTime) {
	// move the camera smoothly to the goal
	Ogre::Vector3 goalOffset = snCameraGoal->_getDerivedPosition() - snCameraNode->getPosition();
	snCameraNode->translate(goalOffset * deltaTime * fSpeed);

	// always look at the pivot
	snCameraNode->lookAt(snCameraPivot->_getDerivedPosition(), Ogre::Node::TS_WORLD);
}

void CPivotCamera::MoveToGoal() {
	snCameraNode->setPosition(snCameraGoal->_getDerivedPosition());
}

void CPivotCamera::Yaw(float angle) {
	snCameraPivot->yaw(Ogre::Degree(angle), Ogre::Node::TS_WORLD);
}

void CPivotCamera::Pitch(float angle) {
	snCameraPivot->pitch(Ogre::Degree(angle), Ogre::Node::TS_LOCAL);
}

void CPivotCamera::Zoom(float factor) {
	// get distance Goal to Pivot
	Ogre::Real distance = snCameraGoal->_getDerivedPosition().distance(snCameraPivot->_getDerivedPosition());

	Ogre::Real distChange = factor * distance;

	snCameraGoal->translate(0, 0, distChange, Ogre::Node::TS_LOCAL);
}

}
}
/*
 * CPivotCamera.h
 *
 *  Created on: Jul 3, 2010
 *      Author: crt
 */

#ifndef CPIVOTCAMERA_H_
#define CPIVOTCAMERA_H_

#include "Ogre.h"
#include "boost/smart_ptr.hpp"

namespace Game {
namespace GameObjects {

class CPivotCamera;
typedef boost::shared_ptr<CPivotCamera> PPivotCamera;
typedef boost::weak_ptr<CPivotCamera> WPPivotCamera;

/** A pivoted Camera  */
class CPivotCamera {
public:
	/** Factory Method; creates a new object
	 @param camera Ogre Camera to use
	 @param distance initial distance to pivot
	 @remarks zero distance might lead to unexpected behaviour*/
	static PPivotCamera Create(Ogre::Camera* camera, float distance);
	virtual ~CPivotCamera();

	/** Set Point to look at */
	inline void SetPivot(Ogre::Vector3 pivot) { snCameraPivot->setPosition(pivot); }

	inline Ogre::Vector3 GetPosition() { return snCameraNode->getPosition(); }

	/** Set Camera speed (used for zoom) */
	inline void SetSpeed(float speed) { fSpeed = speed; }

	// self-explanitory
	void Yaw(float angle);
	void Pitch(float angle);
	void Zoom(float factor);

	/** Skip animation */
	void MoveToGoal();

	void Update(float deltaTime);

	inline Ogre::SceneNode* GetCameraNode() { return snCameraNode; }

private:
	WPPivotCamera self;
	Ogre::SceneNode* snCameraPivot;
	Ogre::SceneNode* snCameraGoal;
	Ogre::SceneNode* snCameraNode;
	float fSpeed;

	CPivotCamera(Ogre::Camera* camera, float distance);
};

}
}

#endif /* CPIVOTCAMERA_H_ */
/*
 * CProgressBar.cpp
 *
 *  Created on: Aug 6, 2010
 *      Author: crt
 */

#include "CProgressBar.h"

namespace Game {
namespace GameObjects {

CProgressBar::CProgressBar(std::string overlayTemplate, std::string overlayName) {
	mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate
		(overlayTemplate, "BorderPanel", overlayName);

	// parse overlay elements to be able to make changes

	OverlayContainer = dynamic_cast<Ogre::OverlayContainer*>(mElement);
	mTextArea = dynamic_cast<Ogre::TextAreaOverlayElement*>(OverlayContainer->getChild(mElement->getName() + "/ProgressCaption"));
	commentBox = dynamic_cast<Ogre::OverlayContainer*>(OverlayContainer->getChild(mElement->getName() + "/ProgressCommentBox"));
	mCommentTextArea = dynamic_cast<Ogre::TextAreaOverlayElement*>(commentBox->getChild(commentBox->getName() + "/ProgressCommentText"));
	mMeter = OverlayContainer->getChild(mElement->getName() + "/ProgressMeter");
	mFill = (dynamic_cast<Ogre::OverlayContainer*>(mMeter))->getChild(mMeter->getName() + "/ProgressFill");
	mTextArea->setCaption("Loading");
}

CProgressBar::~CProgressBar() {
	// destroy ogre overlay elements
	COverlay::nukeOverlayElement(mElement);
	mElement = NULL;
}

PProgressBar CProgressBar::Create(std::string overlayTemplate, std::string overlayName) {
	PProgressBar newBar(new CProgressBar(overlayTemplate, overlayName));
	return newBar;
}

void CProgressBar::SetCaption(std::string caption) {
	mTextArea->setCaption(caption);
}

void CProgressBar::SetComment(std::string comment) {
	mCommentTextArea->setCaption(comment);
}

void CProgressBar::SetProgress(float progress) {
	mProgress = progress;
	mFill->setWidth(mProgress*(mMeter->getWidth() - 2.0f*mFill->getLeft()));
}

void CProgressBar::Setup(unsigned int numGroupsInit, unsigned int numGroupsLoad, float initProportion) {
	bLoadingEnded = false;

	// calculate weights; borrowed from ogre samples
	if (numGroupsInit == 0 && numGroupsLoad != 0)
	{
		mGroupInitProportion = 0;
		mGroupLoadProportion = 1;
	}
	else if (numGroupsLoad == 0 && numGroupsInit != 0)
	{
		mGroupLoadProportion = 0;
		if (numGroupsInit != 0)
			mGroupInitProportion = 1;
	}
	else if (numGroupsInit == 0 && numGroupsLoad == 0)
	{
		mGroupInitProportion = 0;
		mGroupLoadProportion = 0;
	}
	else
	{
		mGroupInitProportion = initProportion / numGroupsInit;
		mGroupLoadProportion = (1 - initProportion) / numGroupsLoad;
	}
}

/*
 * Ogre::ResourceGroupListener
 * self-explanitory; update progress bar when stuff happens
 */

void CProgressBar::resourceGroupScriptingStarted(const Ogre::String& groupName, size_t scriptCount)
{
	mLoadInc = mGroupInitProportion / (float)scriptCount;
	SetCaption("Parsing...");
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::scriptParseStarted(const Ogre::String& scriptName, bool& skipThisScript)
{
	SetComment(scriptName);
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::scriptParseEnded(const Ogre::String& scriptName, bool skipped)
{
	SetProgress(GetProgress() + mLoadInc);
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::resourceGroupScriptingEnded(const Ogre::String& groupName)
{
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::resourceGroupLoadStarted(const Ogre::String& groupName, size_t resourceCount)
{
	mLoadInc = mGroupLoadProportion / (float)resourceCount;
	SetCaption("Loading...");
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::resourceLoadStarted(const Ogre::ResourcePtr& resource)
{
	SetComment(resource->getName());
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::resourceLoadEnded()
{
	SetProgress(GetProgress() + mLoadInc);
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::worldGeometryStageStarted(const Ogre::String& description)
{
	SetComment(description);
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::worldGeometryStageEnded()
{
	SetProgress(GetProgress() + mLoadInc);
	CVideoTask::ogreRenderWindow->update();
}

void CProgressBar::resourceGroupLoadEnded(const Ogre::String& groupName) {
	bLoadingEnded = true;
	CVideoTask::ogreRenderWindow->update();
}


}
}
/*
 * CProgressBar.h
 *
 *  Created on: Aug 6, 2010
 *      Author: crt
 */

#ifndef CPROGRESSBAR_H_
#define CPROGRESSBAR_H_

#include "../Tasks/CVideoTask.h"
#include "COverlay.h"

#include "Ogre.h"
#include "OgreFontManager.h"
#include "OgreBorderPanelOverlayElement.h"
#include "OgreTextAreaOverlayElement.h"
#include "boost/smart_ptr.hpp"

namespace Game {
namespace GameObjects {

class CProgressBar;
typedef boost::shared_ptr<CProgressBar> PProgressBar;

/** ProgressBar using Ogre Overlay (hardcoded overlay names)
@remarks Use as ResourceGroupListener; call Setup before loading is started */
class CProgressBar : public Ogre::ResourceGroupListener {
public:
	virtual ~CProgressBar();

	/** Factory method
	@param overlayTemplate Ogre Overlay Template Name
	@param overlayName Ogre Overlay Name*/
	static PProgressBar Create(std::string overlayTemplate, std::string overlayName);

	/** Ogre Overlay Container which contains all Elements */
	Ogre::OverlayContainer* OverlayContainer;

	/** Set Progress Bar Caption*/
	void SetCaption(std::string caption);

	/** Set Progress Bar Comment */
	void SetComment(std::string comment);

	/** Set Progress; Value between 0 and 1 */
	void SetProgress(float progress);
	inline float GetProgress() { return mProgress; }

	/** Indicates end of loading; rest by calling Setup */
	inline bool LoadingEnded() { return bLoadingEnded; }

	/** Sets progress weights */
	void Setup(unsigned int numGroupsInit, unsigned int numGroupsLoad, float initProportion);


	// Ogre::ResourceGroupListener
	void resourceGroupScriptingStarted(const Ogre::String& groupName, size_t scriptCount);
	void scriptParseStarted(const Ogre::String& scriptName, bool& skipThisScript);
	void scriptParseEnded(const Ogre::String& scriptName, bool skipped);
	void resourceGroupScriptingEnded(const Ogre::String& groupName);
	void resourceGroupLoadStarted(const Ogre::String& groupName, size_t resourceCount);
	void resourceLoadStarted(const Ogre::ResourcePtr& resource);
	void resourceLoadEnded();
	void worldGeometryStageStarted(const Ogre::String& description);
	void worldGeometryStageEnded();
	void resourceGroupLoadEnded(const Ogre::String& groupName);

private:
	CProgressBar(std::string overlayTemplate, std::string overlayName);

	Ogre::TextAreaOverlayElement* mTextArea;
	Ogre::TextAreaOverlayElement* mCommentTextArea;
	Ogre::OverlayElement* mMeter;
	Ogre::OverlayElement* mFill;
	float mProgress;
	Ogre::OverlayElement* mElement;
	Ogre::OverlayContainer* commentBox;

	float mGroupLoadProportion;
	float mGroupInitProportion;
	float mLoadInc;

	bool bLoadingEnded;

	void setProgress(float progress);

	void SetupLoadingBar(unsigned int numGroupsInit = 1, unsigned int numGroupsLoad = 1,
			float initProportion = 0.7f);
};



}
}

#endif /* CPROGRESSBAR_H_ */
/*
 * Geometry.cpp
 *
 *  Created on: Sep 28, 2010
 *      Author: crt
 */

#include "Geometry.h"

namespace Game {

/*------------------
 * Rectangle
 *------------------*/

Rectangle::Rectangle()
	: left(0.0f), bottom(0.0f), right(0.0f), top(0.0f)
{ }

Rectangle::Rectangle(float fLeft, float fBottom, float fRight, float fTop)
{
	SetExtends(fLeft, fBottom, fRight, fTop);
}

Rectangle::Rectangle(const Ogre::Vector2& vMin, const Ogre::Vector2& vMax)
{
	SetExtends(vMin, vMax);
}

void Rectangle::SetExtends(const Ogre::Vector2& vMin, const Ogre::Vector2& vMax) {
	left = vMin.x; bottom = vMin.y;
	right = vMax.x; top = vMax.y;
	assert(left <= right);
	assert(bottom <= top);
}

void Rectangle::SetExtends(float fLeft, float fBottom, float fRight, float fTop) {
	left = fLeft; bottom = fBottom;
	right = fRight; top = fTop;
	assert(left <= right);
	assert(bottom <= top);
}

void Rectangle::Translate(const Ogre::Vector2& translate) {
	left += translate.x; right += translate.x;
	top += translate.y; bottom += translate.y;
}

void Rectangle::SetLeft(float fLeft) {
	assert(fLeft <= right);
	left = fLeft;
}
void Rectangle::SetBottom(float fBottom) {
	assert(fBottom <= top);
	bottom = fBottom;
}
void Rectangle::SetRight(float fRight) {
	assert(fRight >= left);
	right = fRight;
}
void Rectangle::SetTop(float fTop) {
	assert(fTop >= bottom);
	top = fTop;
}

std::ostream& operator<< (std::ostream& os, const Rectangle &rect) {
	os << "Rectangle( " << rect.Left() << ", " << rect.Bottom() << "; " << rect.Right() << ", " << rect.Top() << " )";
	return os;
}

/*------------------
 * Face
 *------------------*/

Face::Face() : v1(0.0f, 0.0f), v2(0.0f, 0.0f), normal(0.0f, 0.0f)
{ }

Face::Face(const Ogre::Vector2& vector1, const Ogre::Vector2& vector2)
	: v1(vector1), v2(vector2)
{
	normal = RightHandNormal(v2-v1);
}

Face::Face(const Ogre::Vector2& vector1, const Ogre::Vector2& vector2, const Ogre::Vector2& normal)
	: v1(vector1), v2(vector2), normal(normal)
{
	this->normal.normalise();
}

bool Face::operator==(const Face& face2) const {
	// dont compare normal
	return ( (v1 == face2.v1 && v2 == face2.v2) ||
		     (v1 == face2.v2 && v2 == face2.v1) );
}

std::ostream& operator<< (std::ostream& os, const Face &face) {
	os << "Face( " << face.v1 << "; " << face.v2 << "; " << face.normal << " )";
	return os;
}


/*------------------
 * Polygon
 *------------------*/

Polygon::Polygon() {
}


Polygon::Polygon(const Face& face) {
	this->Points.push_back(face.v1);
	this->Points.push_back(face.v2);
}

Polygon::Polygon(const Game::Rectangle& rect) {
	Points.push_back(Ogre::Vector2(rect.Left(), rect.Bottom()));
	Points.push_back(Ogre::Vector2(rect.Right(), rect.Bottom()));
	Points.push_back(Ogre::Vector2(rect.Right(), rect.Top()));
	Points.push_back(Ogre::Vector2(rect.Left(), rect.Top()));
}

Polygon::~Polygon() {
}

bool Polygon::operator==(const Polygon& poly2) const {
	if (Points.size() != poly2.Points.size())
		return false;
	// search for each point of this in poly2
	for (int i = 0; i < Points.size(); i++) {
		if (std::find(poly2.Points.begin(), poly2.Points.end(), Points[i]) == poly2.Points.end())
			return false;
	}
	return true;
}

void Polygon::AddPoint(const Ogre::Vector2& vector) {
	if (std::find(Points.begin(), Points.end(), vector) == Points.end()) {
		Points.push_back(vector);
	}
}

void Polygon::RemovePoint(const Ogre::Vector2& vector) {
	VectorList::iterator it = std::find(Points.begin(), Points.end(), vector);
	if (it != Points.end())
		Points.erase(it);
}

void Polygon::Clear() {
	Points.clear();
}

int Polygon::FaceCount() const {
	if (Points.size() == 2)
		return 1;
	else if (Points.size() > 2)
		return Points.size();
	else
		return 0;
}

std::vector<Face> Polygon::GetFaces(bool NoNormals) const {
	std::vector<Face> result;
	if (Points.size() == 2) {
		result.push_back(Face(Points[0], Points[1]));
	} else if (Points.size() > 2) {
		for (int i = 0; i < Points.size(); i++) {
			if (i != Points.size()-1) {
				if (NoNormals)
					result.push_back(Face(Points[i], Points[i+1], Ogre::Vector2::ZERO));
				else
					result.push_back(Face(Points[i], Points[i+1]));
			} else {
				if (NoNormals)
					result.push_back(Face(Points[i], Points[0], Ogre::Vector2::ZERO));
				else
					result.push_back(Face(Points[i], Points[0]));
			}
		}
	}
	return result;
}

void Polygon::Translate(const Ogre::Vector2& translation) {
	// translate all points
	for (VectorList::iterator it = Points.begin(); it != Points.end(); ++it) {
		*it = *it + translation;
	}
}

/** Performs separating axis test for a given axis and polygon
@return Test Result; see Polygon::SATResult */
SATResult Polygon::IsSeparatingAxis(const Polygon& polygon, const Ogre::Vector2& axis) const {
	if (this->Points.size() < 1 || polygon.Points.size() < 1) {
		return SATResult(true, 0.0f, 0.0f);
	}

	// get normal of axis
	Ogre::Vector2 normal = LeftHandNormal(axis);

	// project this
	float min1, max1; // projected intervall of this
	float dp;
	min1 = max1 = normal.dotProduct(Points[0]);
	for (int i = 1; i < Points.size(); i++) {
		dp = normal.dotProduct(Points[i]);
		if (dp < min1) min1 = dp;
		if (dp > max1) max1 = dp;
	}

	// project polygon2
	float min2, max2; // projected intervall of polygon2
	min2 = max2 = normal.dotProduct(polygon.Points[0]);
	for (int i = 1; i < polygon.Points.size(); i++) {
		dp = normal.dotProduct(polygon.Points[i]);
		if (dp < min2) min2 = dp;
		if (dp > max2) max2 = dp;
	}


	SATResult result;
	result.IsSeparating = definitelyGreaterThan(min1 - max2, 0.0f) || definitelyGreaterThan(min2 - max1, 0.0f);

	if (min2 <= min1) {
		result.MinimumOverlap = min2 - max1;
		result.MaximumOverlap = max2 - min1;
	} else {
		result.MinimumOverlap = min2 - max1;
		result.MaximumOverlap = max2 - min1;
	}

	if (fabs(result.MinimumOverlap) > fabs(result.MaximumOverlap))
		std::swap(result.MinimumOverlap, result.MaximumOverlap);

	return result;
}

std::pair<bool, Ogre::Vector2> Polygon::SeparatingAxesTest(const Polygon& polygon, const std::vector<Face>& faces, float &minOverlap) const {
	Ogre::Vector2 minAxis(0,0);

	bool FoundAxis = false;
	for (int i = 0; i < faces.size(); i++) {
		Ogre::Vector2 axis = faces[i].GetVector();
		axis.normalise();
		SATResult sat = this->IsSeparatingAxis(polygon, axis);
		if (!sat.IsSeparating) {
			if (fabs(minOverlap) > fabs(sat.MinimumOverlap)) {
				minOverlap = sat.MinimumOverlap;
				minAxis = axis;
			}
		} else {
			FoundAxis = true;
		}
	}


	if (FoundAxis) {
		return std::pair<bool, Ogre::Vector2>(true, Ogre::Vector2::ZERO);
	} else {
		Ogre::Vector2 normal = LeftHandNormal(minAxis);
		Ogre::Vector2 MTV = normal * minOverlap;

		return std::pair<bool, Ogre::Vector2>(false, MTV);
	}
}

/** Performs separating axis test for all axes parallel to any faces
@return true if a separating axis was found
        in case of intersection, also returns minimum translation vector */
std::pair<bool, Ogre::Vector2> Polygon::SeparatingAxesTest(const Polygon& polygon) const {
	float minOverlap = std::numeric_limits<float>::infinity();

	// check all faces of this
	std::vector<Face> faces = this->GetFaces(true);
	std::pair<bool, Ogre::Vector2> SATRes = SeparatingAxesTest(polygon, faces, minOverlap);

	// check all faces of polygon
	faces = polygon.GetFaces(true);
	float minOverlap2 = minOverlap;
	std::pair<bool, Ogre::Vector2> SATRes2 = SeparatingAxesTest(polygon, faces, minOverlap2);

	if (SATRes.first || SATRes2.first)
		return std::pair<bool, Ogre::Vector2>(true, Ogre::Vector2::ZERO);
	else {
		if (fabs(minOverlap) <= fabs(minOverlap2))
			return std::pair<bool, Ogre::Vector2>(false, SATRes.second);
		else
			return std::pair<bool, Ogre::Vector2>(false, SATRes2.second);
	}
}

/** Checks for intersection when translating this by direction
	@return false if no intersection occurs
	        in case of intersection also returns maximum factor that a translation of factor*direction leads to no collision
	        with 0 <= factor <= 1 */
std::pair<bool, float> Polygon::TranslationIntersect(const Polygon& polygon, const Ogre::Vector2& direction) const {
	float factor = std::numeric_limits<float>::infinity();
	bool bIntersection = false;

	// check all rays in direction through all points of this
	for (int i = 0; i < Points.size(); i++) {
		Ray ray(Points[i], direction);
		std::pair<bool, float> intersection = ray.Intersects(polygon);
		if (!std::isinf(intersection.second))
			if (approximatelyEqual(intersection.second, 0.0f) || approximatelyEqual(intersection.second, 1.0f) ||
					(intersection.second >= 0.0f && intersection.second <= 1.0f)) {
				bIntersection = true;
				if (factor > intersection.second) {
					factor = intersection.second;
				}
			}
	}

	// check all rays in direction through all points of polygon
	for (int i = 0; i < polygon.Points.size(); i++) {
		Ray ray(polygon.Points[i], -direction);
		std::pair<bool, float> intersection = ray.Intersects(*this);
		if (!std::isinf(intersection.second))
			if (approximatelyEqual(intersection.second, 0.0f) || approximatelyEqual(intersection.second, 1.0f) ||
					(intersection.second >= 0.0f && intersection.second <= 1.0f)) {
				bIntersection = true;
				if (factor > intersection.second) {
					factor = intersection.second;
				}
			}
	}

	return std::pair<bool, float>(bIntersection, factor);
}

Game::Rectangle Polygon::GetMinimumEnclosingRectangle() const {
	Game::Rectangle result;
	if (Points.size() < 1)
		return result;

	// get maximum/minimum coordinates
	result.SetExtends(Points[0], Points[0]);
	for (int i = 1; i < Points.size(); i++) {
		if (Points[i].x > result.Right())
			result.SetRight(Points[i].x);
		if (Points[i].x < result.Left())
			result.SetLeft(Points[i].x);
		if (Points[i].y > result.Top())
			result.SetTop(Points[i].y);
		if (Points[i].y < result.Bottom())
			result.SetBottom(Points[i].y);
	}
	return result;
}

float Polygon::CalculateArea() const {
	if (Points.size() < 3)
		return 0.0f;

    // A = \frac{1}{2}\sum_{i=0}^{N-1} (x_i\ y_{i+1} - x_{i+1}\ y_i)
	float area = 0.0f;

	for (int i = 0; i < Points.size(); i++) {
		int iplusone = i+1;
		if (iplusone >= Points.size())
			iplusone = 0;
		area += Points[i].x * Points[iplusone].y - Points[iplusone].x * Points[i].y;
	}

	return 0.5f * area;
}

Ogre::Vector2 Polygon::CalculateCenter() const {
	if (Points.size() <= 0)
		return Ogre::Vector2::ZERO;
	if (Points.size() == 1)
		return Points[0];
	if (Points.size() == 2)
		return 0.5f * (Points[0] + Points[1]);

	float area = CalculateArea();
	if (area == 0.0f)
		return Points[0];

	Ogre::Vector2 center(0.0f, 0.0f);
	for (int i = 0; i < Points.size(); i++) {
		int iplusone = i+1;
		if (iplusone >= Points.size())
			iplusone = 0;

		//  C_x = \frac{1}{6A}\sum_{i=0}^{N-1}(x_i+x_{i+1})(x_i\ y_{i+1} - x_{i+1}\ y_i)
		center.x += (Points[i].x + Points[iplusone].x) * (Points[i].x*Points[iplusone].y - Points[iplusone].x*Points[i].y);

		// C_y = \frac{1}{6A}\sum_{i=0}^{N-1}(y_i+y_{i+1})(x_i\ y_{i+1} - x_{i+1}\ y_i)
		center.y += (Points[i].y + Points[iplusone].y) * (Points[i].x*Points[iplusone].y - Points[iplusone].x*Points[i].y);
	}

	return ( 1.0f / (6.0f * area) ) * center;
}

void Polygon::Rotate(float angle) {
	if (Points.size() <= 1)
		return;

	if (angle == 0.0f)
		return;

	Ogre::Vector2 center = CalculateCenter();

	float sine = sin(angle);
	float cosine = cos(angle);

	// translate origin to center, rotate, translate back
	for (int i = 0; i < Points.size(); i++) {
		Ogre::Vector2 v = Points[i];
		v -= center;
		float x = cosine*v.x - sine*v.y;
		float y = sine*v.x + cosine*v.y;
		v.x = x; v.y = y;
		v += center;
		Points[i] = v;
	}
}

std::ostream& operator<< (std::ostream& os, const Polygon& polygon) {
	os << "Polygon(";

	for (int i = 0; i < polygon.GetPoints().size(); i++) {
		os << polygon.GetPoints()[i];
		if (i != polygon.GetPoints().size()-1)
			os << ", ";
	}

	os << " )";
	return os;
}


/*------------------
 * Ray
 *------------------*/

Ray::Ray() : Origin(0.0f, 0.0f), Direction(0.0f, 0.0f)
{}

Ray::Ray(const Ogre::Vector2& origin, const Ogre::Vector2& direction) : Origin(origin), Direction(direction)
{}

/** Checks for intersection with given ray
@returns Second element indicates distance from origin of intersection point */
std::pair<bool, float> Ray::Intersects(const Ray& ray) const {
	/*
	 * Solve t*v1 + o1 = u*v2 + o2   <=>  t*v1 - u*v2 = o2 - o1
	 * <=>  Ax = y  with  y=o2-o1,  A = (v1, -v2),  x = (t, u)^t
	 * <=> x = A^-1 y
	 * <=> t = A^-1[1,1] * y[1] + A^-1[1,2] * y[2]
	 *
	 */

	// calculate A^-1 using Cramer's rule

	// det(A) = a*d - b*c
	float det =  -(this->Direction.x * ray.Direction.y) + (this->Direction.y * ray.Direction.x);

	// if det(A) is 0 the rays are parallel
	//if (approximatelyEqual(det, 0.0f))
	if (det == 0.0f)
		return std::pair<bool, float>(false, 0.0f);

	Ogre::Vector2 y = ray.Origin - this->Origin;

	// first row of A^-1 is 1/det(A)*(d,-b)
	float t = (1.0f / det) * ( - ray.Direction.y * y.x  + ray.Direction.x * y.y);

	if (approximatelyEqual(det, 0.0f))
		return std::pair<bool, float>(false, t);
	else
		return std::pair<bool, float>(true, t);
}

/** Checks for intersection with given polygon
@returns Second element indicates distance from origin of intersection point */
std::pair<bool, float> Ray::Intersects(const Face& face) const {
	// construct ray through both points of face and check for intersection
	Ogre::Vector2 faceDirection = face.v2 - face.v1;
	Ray faceRay(face.v1, faceDirection);
	std::pair<bool, float> rayIntersection = faceRay.Intersects(*this);

	// check if intersection is between the two points of face
	if (rayIntersection.first && rayIntersection.second >= 0.0f && rayIntersection.second <= 1.0f) {
		return this->Intersects(faceRay);
	} else {
		return std::pair<bool, float>(false, 0.0f);
	}
}

/** Checks for intersection with given polygon
@returns Second element indicates distance from origin of intersection point
@remarks Returns intersection point which is closest to ray's origin*/
std::pair<bool, float> Ray::Intersects(const Polygon& polygon) const {
	float nearestFactor = std::numeric_limits<float>::infinity();
	bool bIntersection = false;

	// check all faces of polygon for intersection; return the nearest
	std::vector<Face> faces = polygon.GetFaces(true);
	for (int i = 0; i < faces.size(); i++) {
		std::pair<bool, float> intersection = this->Intersects(faces[i]);
		if (intersection.first) {
			bIntersection = true;
			if (fabs(nearestFactor) > fabs(intersection.second))
				nearestFactor = intersection.second;
		}
	}

	return std::pair<bool, float>(bIntersection, nearestFactor);
}

}
/*
 * Geometry.h
 *
 *  Created on: Sep 28, 2010
 *      Author: crt
 */

#ifndef GEOMETRY_H_
#define GEOMETRY_H_

#include "../testlog.h"
#include "Ogre.h"
#include <vector>

namespace Game {

/** Maximum allowed relative rounding error */
const float TOLERANCE = 0.005f;

/** Maximum allowed absolute rounding error*/
const float TOLERANCE_ABS = 0.005f;

/** Source of float comparison functions: Knuth, The Art of computer programming Vol 2 */

inline bool approximatelyEqual(float a, float b) {
	// check absolute error first to be correctly compare numbers close to zero
	if (fabs(a-b) <= TOLERANCE_ABS) return true;
    return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * TOLERANCE);
}

inline bool essentiallyEqual(float a, float b) {
    return fabs(a - b) <= ( (fabs(a) > fabs(b) ? fabs(b) : fabs(a)) * TOLERANCE);
}

inline bool definitelyGreaterThan(float a, float b) {
	if (fabs(a-b) <= TOLERANCE_ABS) return false;
    return (a - b) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * TOLERANCE);
}

inline bool definitelyLessThan(float a, float b) {
    return (b - a) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * TOLERANCE);
}

/** Calculate left hand normal */
inline Ogre::Vector2 LeftHandNormal(const Ogre::Vector2& v) {
	return Ogre::Vector2(-v.y, v.x).normalisedCopy();
}

/** Calculate right hand normal */
inline Ogre::Vector2 RightHandNormal(const Ogre::Vector2& v) {
	return Ogre::Vector2(v.y, -v.x).normalisedCopy();
}

/** Checks if two vectors are linearly dependent */
inline bool LinearlyDependent(const Ogre::Vector2& v, const Ogre::Vector2& w) {
	// check if a*v + b*w = 0 has a unique solution <=> det(v,w) = 0
	float det = v.x*w.y - v.y*w.x;
	return approximatelyEqual(det, 0.0f);
}

class Rectangle {
public:
	Rectangle();
	Rectangle(float fLeft, float fBottom, float fRight, float fTop);
	Rectangle(const Ogre::Vector2& vMin, const Ogre::Vector2& vMax);

	/** Returns bottom left Point */
	inline Ogre::Vector2 GetMinimum() const { return Ogre::Vector2(left, bottom); }
	/** Returns top right Point */
	inline Ogre::Vector2 GetMaximum() const { return Ogre::Vector2(right, top); }

	inline bool operator==(const Rectangle& rect2) const {
		return left == rect2.left && right == rect2.right && top == rect2.top && bottom == rect2.bottom;
	}
	inline bool operator!=(const Rectangle& rect2) const { return !(*this == rect2); }

	inline float Left() const { return left; }
	inline float Bottom() const { return bottom; }
	inline float Right() const { return right; }
	inline float Top() const { return top; }
	inline Ogre::Vector2 TopLeft() const { return Ogre::Vector2(left, top); }
	inline Ogre::Vector2 TopRight() const { return Ogre::Vector2(right, top); }
	inline Ogre::Vector2 BottomLeft() const { return Ogre::Vector2(left, bottom); }
	inline Ogre::Vector2 BottomRight() const { return Ogre::Vector2(right, bottom); }

	void SetLeft(float fLeft);
	void SetBottom(float fBottom);
	void SetRight(float fRight);
	void SetTop(float fTop);

	void SetExtends(const Ogre::Vector2& vMin, const Ogre::Vector2& vMax);
	void SetExtends(float fLeft, float fBottom, float fRight, float fTop);

	/** Translates Rectangle by given vector */
	void Translate(const Ogre::Vector2& translate);

	inline bool Contains(const Rectangle& rect) const {
		return ((rect.left >= left) && (rect.right <= right) &&
				(rect.top >= top) && (rect.bottom <= bottom));
	}

	inline bool Intersects(const Rectangle& rect) const {
		return (left < rect.right) &&
			   (right > rect.left) &&
			   (top > rect.bottom) &&
			   (bottom < rect.top);
	}
private:
	float left, bottom, right, top;
};

std::ostream& operator<< (std::ostream& os, const Rectangle &rect);

struct Face {
	Ogre::Vector2 v1;
	Ogre::Vector2 v2;
	Ogre::Vector2 normal;

	Face();
	Face(const Ogre::Vector2& vector1, const Ogre::Vector2& vector2);
	Face(const Ogre::Vector2& vector1, const Ogre::Vector2& vector2, const Ogre::Vector2& normal);
	bool operator==(const Face& face2) const;
	bool operator!=(const Face& face2) const { return !(*this == face2); }
	Ogre::Vector2 GetVector() const { return v2 - v1; }

	// do some random comparison to be able to use Face as a Key in a std::map
	bool operator< (const Face &face) const { return v1.x < face.v1.x; }
};

std::ostream& operator<< (std::ostream& os, const Face &face);

/** Defines Result of a Separating Axes Test */
struct SATResult {
	/** True, if given Axis is separating */
	bool IsSeparating;
	/** Smallest translation along axis which resolves intersection (MinimumOverlap*axis)
	 *  Undefined if IsSeparating==true*/
	float MinimumOverlap;
	/** Smallest translation along axis which resolves intersection in opposite direction of MinimumOverlap
	 * Undefined if IsSeparating==true*/
	float MaximumOverlap;

	SATResult() : IsSeparating(true), MinimumOverlap(0.0f), MaximumOverlap(0.0f) {}
	SATResult(bool isSeparating, float minOverlap, float maxOverlap)
		: IsSeparating(isSeparating), MinimumOverlap(minOverlap), MaximumOverlap(maxOverlap) {}
};

/** Defines a Polygon in 2D Space */
class Polygon {
public:
	/** Create empty Polygon */
	Polygon();
	/** Create Polygon from one Face */
	Polygon(const Face& face);
	/** Create Polygon from Rectangle */
	Polygon(const Game::Rectangle& rect);
	virtual ~Polygon();

	bool operator==(const Polygon& poly2) const;
	bool operator!=(const Polygon& poly2) const { return !(*this == poly2); }

	/** Add Point to Polygon
	@remarks Normals will be calculated wrong if points are not added counter-clockwise */
	void AddPoint(const Ogre::Vector2& vector);
	/** Remove Point from Polygon */
	void RemovePoint(const Ogre::Vector2& vector);
	/** Remove all Points */
	void Clear();
	/** Get Number of Faces */
	int FaceCount() const;
	/** Get all faces
	@param NoNormals Set true to not calculate any normals (faster)
	@see AddPoint */
	std::vector<Face> GetFaces(bool NoNormals = false) const;
	/** Get Points*/
	const std::vector<Ogre::Vector2>& GetPoints() const { return Points; }

	/** Move all Points by translation */
	void Translate(const Ogre::Vector2& translation);

	/** Calculates Area */
	float CalculateArea() const;
	/** Calculates Center */
	Ogre::Vector2 CalculateCenter() const;

	/** Rotate by angle around center */
	void Rotate(float angle);


	/** Get Minimum Enclosing Rectangle */
	Game::Rectangle GetMinimumEnclosingRectangle() const;

	/** Performs separating axis test for a given axis and polygon; uses left hand normal of axis
	 *  Use result.MinimumOverlap * LeftHandNormal(axis) to get translation vector
	@return Test Result
	@see Polygon::SATResult */
	SATResult IsSeparatingAxis(const Polygon& polygon, const Ogre::Vector2& axis) const;

	/** Performs separating axis test for all axes parallel to any faces
	@return true if a separating axis was found
	        in case of intersection, also returns minimum translation vector
	@remarks Only works if polygon is convex */
	std::pair<bool, Ogre::Vector2> SeparatingAxesTest(const Polygon& polygon) const;

	/** Checks for intersection when translating this by direction
	@return false if no intersection occurs
	        in case of intersection also returns maximum factor that a translation of factor*direction leads to no collision */
	std::pair<bool, float> TranslationIntersect(const Polygon& polygon, const Ogre::Vector2& direction) const;
private:
	typedef std::vector<Ogre::Vector2> VectorList;
	VectorList Points;

	std::pair<bool, Ogre::Vector2> SeparatingAxesTest(const Polygon& polygon, const std::vector<Face>& faces, float &minOverlap) const;
};

std::ostream& operator<< (std::ostream& os, const Polygon &polygon);

/** Defines a Ray in 2D Space
 *  Note: direction vector is not neccessarily normalized */
class Ray {
public:
	Ray();
	Ray(const Ogre::Vector2& origin, const Ogre::Vector2& direction);

	inline void SetOrigin(const Ogre::Vector2& origin) { Origin = origin; }
	inline const Ogre::Vector2& GetOrigin() const { return Origin; }
	inline void SetDirection(const Ogre::Vector2& direction) { Direction = direction; }
	inline const Ogre::Vector2& GetDirection() const { return Direction; }
	inline Ogre::Vector2 GetPoint(float t) const { return Origin + t*Direction; }

	/** Checks for intersection with given ray
	@return Second element indicates distance from origin of intersection point */
	std::pair<bool, float> Intersects(const Ray& ray) const;

	/** Checks for intersection with given polygon
	@return Second element indicates distance from origin of intersection point */
	std::pair<bool, float> Intersects(const Face& face) const;

	/** Checks for intersection with given polygon
	@return Second element indicates distance from origin of intersection point
	@remarks Returns intersection point which is closest to ray's origin*/
	std::pair<bool, float> Intersects(const Polygon& polygon) const;

private:
 	Ogre::Vector2 Origin;
 	Ogre::Vector2 Direction;
};

}

#endif /* GEOMETRY_H_ */
/*
 * LevelDataReader.cpp
 *
 *  Created on: Aug 9, 2010
 *      Author: crt
 */

#include "LevelDataReader.h"

namespace Game {
namespace GameObjects {

CXMLReader::CXMLReader() {
}

CXMLReader::~CXMLReader() {
}

std::string CXMLReader::ReadString(const ticpp::Element& node, const std::string& name) {
	return node.GetAttribute<std::string>(name);
}

Ogre::Vector2 CXMLReader::ReadVector2(const ticpp::Element& node, const std::string& prefix) {
	Ogre::Vector2 result;
	result.x = node.GetAttribute<float>(prefix + "x");
	result.y = node.GetAttribute<float>(prefix + "y");
	return result;
}

Game::Rectangle CXMLReader::ReadRectangle(const ticpp::Element& node) {
	Ogre::Vector2 vMin = ReadVector2(node, "min_");
	Ogre::Vector2 vMax = ReadVector2(node, "max_");
	return Game::Rectangle(vMin, vMax);
}

Game::Polygon CXMLReader::ReadPolygon(const ticpp::Element& node) {
	Game::Polygon result;
	// iterate <point../>
	ticpp::Iterator< ticpp::Element > child("point");
	for (child = child.begin( &node ); child != child.end(); child++) {
		result.AddPoint(ReadVector2(*child));
	}
	return result;
}

Ogre::Vector3 CXMLReader::ReadVector(const ticpp::Element& node, const std::string& prefix) {
	Ogre::Vector3 result;
	result.x = node.GetAttribute<float>(prefix + "x");
	result.y = node.GetAttribute<float>(prefix + "y");
	result.z = node.GetAttribute<float>(prefix + "z");
	return result;
}

Ogre::Quaternion CXMLReader::ReadQuaternion(const ticpp::Element& node) {
	float w = node.GetAttribute<float>("w");
	float x = node.GetAttribute<float>("x");
	float y = node.GetAttribute<float>("y");
	float z = node.GetAttribute<float>("z");
	return Ogre::Quaternion(w,x,y,z);
}

void CXMLReader::ReadLevelObject(const ticpp::Element& node, PLevelObject object) {
	Ogre::Vector2 position;
	node.GetAttributeOrDefault<float>("x", &position.x, 0.0f);
	node.GetAttributeOrDefault<float>("y", &position.y, 0.0f);
	object->SetPosition(position);

	ticpp::Element* AABBsize = node.FirstChildElement("AABBsize", false);
	if (AABBsize) {
		object->SetAABBSize(ReadVector2(*AABBsize));
	}

	ticpp::Element* AABBextends = node.FirstChildElement("AABBextends", false);
	if (AABBextends) {
		object->SetBoundingBox(ReadRectangle(*AABBextends));
	}

	ticpp::Element* collision = node.FirstChildElement("Collision", false);
	if (collision) {
		object->SetRotation(collision->GetAttribute<float>("rotation"));
		object->SetCollisionPolygon(ReadPolygon(*collision));
	}

	ticpp::Element* handler = node.FirstChildElement("CollisionHandler", false);
	if (handler) {
		std::string handlerType = ReadString(*handler, "type");
//		if (handlerType == "Coin")
//			object->SetCollisionHandler(TestHandler());
	}
}

void CXMLReader::ReadOgreEntityView(const ticpp::Element& node, POgreEntityView view) {
	ticpp::Element* position = node.FirstChildElement("position", false);
	if (position) {
		view->SetPositionOffset(ReadVector(*position));
	}

	ticpp::Element* entity = node.FirstChildElement("entity", false);
	if (entity) {
		view->SetEntityName(ReadString(*entity));
	}

	ticpp::Element* scale = node.FirstChildElement("scale", false);
	if (scale) {
		view->SetScale(ReadVector(*scale));
	}

	ticpp::Element* material = node.FirstChildElement("material", false);
	if (material) {
		view->SetMaterial(ReadString(*material));
	}

	ticpp::Element* orientation = node.FirstChildElement("orientation", false);
	if (orientation) {
		view->SetOrientation(ReadQuaternion(*orientation));
	}
}

void CXMLReader::ReadOgreBillboardView(const ticpp::Element& node, POgreBillboardView view) {
	ticpp::Element* material = node.FirstChildElement("material", false);
	if (material) {
		view->SetMaterial(ReadString(*material));
	}

	ticpp::Element* direction = node.FirstChildElement("direction", false);
	if (direction) {
		view->SetDirection(ReadVector(*direction));
	}
}

void CXMLReader::ReadObject(const ticpp::Element& node, Listener* listener, bool asTemplate) {
	try {
		std::string sType = ReadString(node, "type");

		PLevelObject object;
		POgreView view;

		if (sType == "CustomAABB") {
			object = CLevelObject::Create();
			view = COgreEntityView::Create(object);
		} else if (sType == "Billboard") {
			object = CLevelObject::Create();
			view = COgreBillboardView::Create(object);
		} else {
			// copy template
			ModelViewPair Template = templates[sType];
			if (Template.first != NULL && Template.second != NULL) {
				// copy template
				object = Template.first->Copy();
				view = Template.second->Copy(object);
			}
			else {
				// template not found
				return;
			}
		}

		// TODO find better solution than dynamic_cast

		// read model data
		ReadLevelObject(node, object);

		// read view data
		if (boost::dynamic_pointer_cast<COgreEntityView>(view) != NULL)
			ReadOgreEntityView(node, boost::static_pointer_cast<COgreEntityView>(view));
		if (boost::dynamic_pointer_cast<COgreBillboardView>(view) != NULL)
			ReadOgreBillboardView(node, boost::static_pointer_cast<COgreBillboardView>(view));

		if (!asTemplate) {
			std::string sLayer = ReadString(node, "layer");
			ObjectType otype;
			if (sLayer == "static")
				otype = otStatic;
			else if (sLayer == "background")
				otype = otBackground;
			else
				otype = otDynamic;

			listener->ReadLevelObject(object, otype);
			listener->ReadOgreView(view, otype);
		} else {
			std::string sName = ReadString(node);
			templates[sName] = ModelViewPair(object, view);
			listener->ReadTemplate(sName, object, view);
		}
	} catch(ticpp::Exception& ex) {
	}
}


bool CXMLReader::Read(const std::string& filename, Listener* listener, bool TemplatesOnly) {
	try {
		ticpp::Document document(filename);
		document.LoadFile();
		ticpp::Element* root = document.FirstChildElement("leveldata", false);
		if (!root) return false;

		int iVersion = root->GetAttribute<int>("version");
		if (iVersion != 1) return false;

		// read templates
		ticpp::Element* templatesNode = root->FirstChildElement("templates", false);
		if (templatesNode) {
			// iterate <template>..</template>
			ticpp::Iterator< ticpp::Element > child("template");
			for (child = child.begin( templatesNode ); child != child.end(); child++) {
				ReadObject(*child, listener, true);
			}
		}

		if (!TemplatesOnly) {
			// read objects
			ticpp::Element* objectsNode = root->FirstChildElement("levelobjects", false);
			if (objectsNode) {
				// iterate <object... />
				ticpp::Iterator< ticpp::Element > child("object");
				for (child = child.begin( objectsNode ); child != child.end(); child++) {
					ReadObject(*child, listener, false);
				}
			}
		}

	} catch(...) {
		return false;
	}
	return true;
}

}
}
/*
 * LevelDataReader.h
 *
 *  Created on: Aug 9, 2010
 *      Author: crt
 */

#ifndef LEVELDATAREADER_H_
#define LEVELDATAREADER_H_

#include "../Core/CLog.h"
#include "ObjectType.h"
#include "LevelObjects.h"
#include "OgreViews.h"

#define TIXML_USE_TICPP
#include "ticpp.h"

#include <vector>
#include <string>
#include <fstream>
#include <map>
#include "boost/smart_ptr.hpp"

namespace Game {
namespace GameObjects {

class CXMLReader {
public:
	class Listener {
	public:
		Listener() { }
		virtual ~Listener() { }

		virtual void ReadTemplate(std::string name, PLevelObject object, POgreView view) { }
		virtual void ReadLevelObject(PLevelObject object, ObjectType layer) { }
		virtual void ReadOgreView(POgreView view, ObjectType layer) { }
	};

	CXMLReader();
	virtual ~CXMLReader();

	bool Read(const std::string& filename, Listener* listener, bool TemplatesOnly = false);
private:
	typedef std::pair<PLevelObject, POgreView> ModelViewPair;
	typedef std::map<std::string, ModelViewPair> TemplateMap;
	TemplateMap templates;

	void ReadOgreEntityView(const ticpp::Element& node, POgreEntityView view);
	void ReadOgreBillboardView(const ticpp::Element& node, POgreBillboardView view);
	void ReadLevelObject(const ticpp::Element& node, PLevelObject object);
	void ReadObject(const ticpp::Element& node, Listener* listener, bool asTemplate);

	Ogre::Quaternion ReadQuaternion(const ticpp::Element& node);
	std::string ReadString(const ticpp::Element& node, const std::string& name = "name");
	Ogre::Vector3 ReadVector(const ticpp::Element& node, const std::string& prefix = "");
	Ogre::Vector2 ReadVector2(const ticpp::Element& node, const std::string& prefix = "");
	Game::Rectangle ReadRectangle(const ticpp::Element& node);
	Game::Polygon ReadPolygon(const ticpp::Element& node);
};
typedef boost::shared_ptr<CXMLReader> PXMLReader;

}
}

#endif /* LEVELDATAREADER_H_ */
/*
 * LevelDataWriter.cpp
 *
 *  Created on: Aug 28, 2010
 *      Author: crt
 */

#include "LevelDataWriter.h"

using namespace ticpp;
using namespace std;

namespace Game {
namespace GameObjects {

CXMLWriter::CXMLWriter() {
	root = (Element*)document.InsertEndChild(Element("leveldata"));
	root->SetAttribute("version", 1);
	templates = new Element("templates");
	levelobjects = new Element("levelobjects");
	root->LinkEndChild(templates);
	root->LinkEndChild(levelobjects);
}

CXMLWriter::~CXMLWriter() {
	// ticpp nodes are deleted automatically when document dies
}

void CXMLWriter::Save(const std::string& filename) {
	document.SaveFile(filename);
}

void CXMLWriter::WriteTemplate(const std::string& name, PLevelObject object, POgreEntityView view) {
	Element* element = new Element("template");

	element->SetAttribute("type", "CustomAABB");
	element->SetAttribute("name", name);

	WriteString(*element, "entity", view->GetEntityName());
	if (view->GetMaterial() != "")
		WriteString(*element, "material", view->GetMaterial());
	WriteVector(*element, "scale", view->GetScale());
	WriteVector(*element, "position", view->GetPositionOffset());
	WriteQuaternion(*element, "orientation", view->GetOrientation());
	WriteRectangle(*element, "AABBextends", object->GetBoundingBox());

	levelobjects->LinkEndChild(element);
}

void CXMLWriter::WriteObject(ObjectType layer, PLevelObject object, POgreEntityView view) {
	Element* element = new Element("object");

	std::string sLayer = "";
	if (layer == otStatic) sLayer = "static";
	else if (layer == otDynamic) sLayer = "dynamic";
	else if (layer == otBackground) sLayer == "background";

	element->SetAttribute("type", "CustomAABB");
	element->SetAttribute("layer", sLayer);

	Ogre::Vector2 position = object->GetPosition();
	element->SetAttribute("x", position.x);
	element->SetAttribute("y", position.y);

	WriteString(*element, "entity", view->GetEntityName());
	if (view->GetMaterial() != "")
		WriteString(*element, "material", view->GetMaterial());
	WriteVector(*element, "scale", view->GetScale());
	WriteVector(*element, "position", view->GetPositionOffset());
	WriteQuaternion(*element, "orientation", view->GetOrientation());
	if (object->BoundingBoxCollisionEnabled())
		WriteRectangle(*element, "AABBextends", object->GetBoundingBox());
	else {
		Element* collision = WritePolygon(*element, "Collision", object->GetCleanCollisionPolygon());
		collision->SetAttribute("rotation", object->GetRotation());
	}

	levelobjects->LinkEndChild(element);
}

void CXMLWriter::WriteVector(Element& node, const string& name, const Ogre::Vector3& vec) {
	Element* element = new Element(name);
	element->SetAttribute("x", vec.x);
	element->SetAttribute("y", vec.y);
	element->SetAttribute("z", vec.z);
	node.LinkEndChild(element);
}

void CXMLWriter::WriteVector2(Element& node, const string& name, const Ogre::Vector2& vec) {
	Element* element = new Element(name);
	element->SetAttribute("x", vec.x);
	element->SetAttribute("y", vec.y);
	node.LinkEndChild(element);
}

void CXMLWriter::WriteAABB(Element& node, const string& name, const Ogre::AxisAlignedBox& box) {
	Element* element = new Element(name);
	Ogre::Vector3 vMin = box.getMinimum();
	element->SetAttribute("min_x", vMin.x);
	element->SetAttribute("min_y", vMin.y);
	element->SetAttribute("min_z", vMin.z);
	Ogre::Vector3 vMax = box.getMaximum();
	element->SetAttribute("max_x", vMax.x);
	element->SetAttribute("max_y", vMax.y);
	element->SetAttribute("max_z", vMax.z);
	node.LinkEndChild(element);
}

void CXMLWriter::WriteRectangle(ticpp::Element& node, const std::string& name, const Game::Rectangle& rect) {
	Element* element = new Element(name);
	Ogre::Vector2 vMin = rect.GetMinimum();
	element->SetAttribute("min_x", vMin.x);
	element->SetAttribute("min_y", vMin.y);
	Ogre::Vector2 vMax = rect.GetMaximum();
	element->SetAttribute("max_x", vMax.x);
	element->SetAttribute("max_y", vMax.y);
	node.LinkEndChild(element);
}

void CXMLWriter::WriteQuaternion(Element& node, const string& name, const Ogre::Quaternion& quater) {
	Element* element = new Element(name);
	element->SetAttribute("w", quater.w);
	element->SetAttribute("x", quater.x);
	element->SetAttribute("y", quater.y);
	element->SetAttribute("z", quater.z);
	node.LinkEndChild(element);
}
void CXMLWriter::WriteString(Element& node, const string& name, const string& value) {
	Element* element = new Element(name);
	element->SetAttribute("name", value);
	node.LinkEndChild(element);
}

Element* CXMLWriter::WritePolygon(ticpp::Element& node, const std::string& name, const Game::Polygon& poly) {
	Element* element = new Element(name);
	std::vector<Ogre::Vector2> points = poly.GetPoints();

	for (std::vector<Ogre::Vector2>::iterator it = points.begin(); it != points.end(); ++it) {
		WriteVector2(*element, "point", *it);
	}

	node.LinkEndChild(element);
	return element;
}

}
}
/*
 * LevelDataWriter.h
 *
 *  Created on: Aug 28, 2010
 *      Author: crt
 */

#ifndef LEVELDATAWRITER_H_
#define LEVELDATAWRITER_H_

#include "../Core/CLog.h"
#include "ObjectType.h"
#include "LevelObjects.h"
#include "OgreViews.h"

#define TIXML_USE_TICPP
#include "ticpp.h"
#include "Ogre.h"

#include <vector>
#include "boost/utility.hpp"
#include "boost/smart_ptr.hpp"

namespace Game {
namespace GameObjects {

/** XML Writer
 *
 *  Call WriteTemplate/ WriteObject for each template or object you want to save; then write to file using Save() */
class CXMLWriter : boost::noncopyable { //TODO: copy constructor etc
public:
	CXMLWriter();
	virtual ~CXMLWriter();

	void WriteTemplate(const std::string& name, PLevelObject object, POgreEntityView view);
	void WriteObject(ObjectType layer, PLevelObject object, POgreEntityView view);
	void Save(const std::string& filename);
private:
	void WriteQuaternion(ticpp::Element& node, const std::string& name, const Ogre::Quaternion& quater);
	void WriteVector(ticpp::Element& node, const std::string& name, const Ogre::Vector3& vec);
	void WriteVector2(ticpp::Element& node, const std::string& name, const Ogre::Vector2& vec);
	void WriteAABB(ticpp::Element& node, const std::string& name, const Ogre::AxisAlignedBox& box);
	void WriteRectangle(ticpp::Element& node, const std::string& name, const Game::Rectangle& rect);
	void WriteString(ticpp::Element& node, const std::string& name, const std::string& value);
	ticpp::Element* WritePolygon(ticpp::Element& node, const std::string& name, const Game::Polygon& poly);

	ticpp::Document document;
	ticpp::Element *root, *templates, *levelobjects;
};

typedef boost::shared_ptr<CXMLWriter> PXMLWriter;

}
}

#endif /* LEVELDATAWRITER_H_ */
/*
 * LevelObjectManager.h
 *
 *  Created on: Oct 4, 2010
 *      Author: crt
 */

#ifndef LEVELOBJECTMANAGER_H_
#define LEVELOBJECTMANAGER_H_

#include "Messaging.h"
#include "Geometry.h"
#include "boost/shared_ptr.hpp"

namespace Game {
namespace GameObjects {

class CLevelObject;

class ILevelObjectManager : public CMessageManager {
public:
	typedef std::vector<boost::shared_ptr<CLevelObject> > LevelObjectList;

	ILevelObjectManager() { }
	virtual ~ILevelObjectManager() { }

	/** Return all Objects inside given Rectangle */
	virtual LevelObjectList GetObjectRectangle(const Game::Rectangle& rect) = 0;

	/** Called by a level object when it changes its position or boundaries */
	virtual void ObjectPositionChanged(boost::shared_ptr<CLevelObject> object) { }
};

typedef boost::shared_ptr<ILevelObjectManager> PLevelObjectManager;
typedef boost::weak_ptr<ILevelObjectManager> WLevelObjectManager;

}
}

#endif /* LEVELOBJECTMANAGER_H_ */
/*
 * LevelObjects.cpp
 *
 *  Created on: Aug 9, 2010
 *      Author: crt
 */

#include "LevelObjects.h"

namespace Game {
namespace GameObjects {

CLevelObject::CLevelObject()
	: IMessagingObject(), vPosition(0.0f, 0.0f), collisionType(ctBlocking)
{
	EnableBoundingBoxCollision();
}

CLevelObject::CLevelObject(const Ogre::Vector2& position)
	: IMessagingObject(), vPosition(position), collisionType(ctBlocking)
{
	EnableBoundingBoxCollision();
}

CLevelObject::CLevelObject(const Game::Rectangle& bounds)
	: IMessagingObject(), vPosition(0.0f, 0.0f), aabBounds(bounds), collisionType(ctBlocking)
{
	EnableBoundingBoxCollision();
}

CLevelObject::CLevelObject(const CLevelObject& obj) : IMessagingObject(obj) {
	// don't copy listeners
	aabBounds = obj.aabBounds;
	collisionData = obj.collisionData;
	cachedCollisionData = obj.cachedCollisionData;
	angle = obj.angle;
	vPosition = obj.vPosition;
	collisionType = obj.collisionType;
	BoundingBoxCollision = obj.BoundingBoxCollision;
	collisionHandler = obj.collisionHandler;
}

PLevelObject CLevelObject::Create() {
	CLevelObject* obj = new CLevelObject();
	PLevelObject objPtr(obj);
	obj->self = objPtr;
	return objPtr;
}

PLevelObject CLevelObject::Copy() const {
	CLevelObject* copy = new CLevelObject(*this);
	PLevelObject copyPtr(copy);
	copy->self = copyPtr;
	return copyPtr;
}

void CLevelObject::notifyPositionChanged() {
	PLevelObjectManager manager = parent.lock();
	if (manager) manager->ObjectPositionChanged(self.lock());

	for (ListenerList::iterator it = Listeners.begin(); it != Listeners.end(); ++it) {
		(*it)->PositionChanged(this);
	}
}

void CLevelObject::notifyBoundsChanged() {
	PLevelObjectManager manager = parent.lock();
	if (manager) manager->ObjectPositionChanged(self.lock());

	for (ListenerList::iterator it = Listeners.begin(); it != Listeners.end(); ++it) {
		(*it)->PositionChanged(this);
	}
}

void CLevelObject::notifyCollisionTypeChanged() {
	for (ListenerList::iterator it = Listeners.begin(); it != Listeners.end(); ++it) {
		(*it)->PositionChanged(this);
	}
}

void CLevelObject::AddListener(PListener listener) {
	if (listener)
		Listeners.insert(listener);
}

void CLevelObject::RemoveListener(PListener listener) {
	Listeners.erase(listener);
}

void CLevelObject::EnableBoundingBoxCollision() {
	collisionData = Game::Polygon(aabBounds);
	cachedCollisionData = collisionData;
	angle = 0.0f;
	BoundingBoxCollision = true;
	notifyBoundsChanged();
}

void CLevelObject::SetCollisionPolygon(const Game::Polygon& polygon) {
	if (collisionData != polygon) {
		collisionData = polygon;
		cachedCollisionData = polygon;
		cachedCollisionData.Rotate(this->angle);
		BoundingBoxCollision = false;
		aabBounds = cachedCollisionData.GetMinimumEnclosingRectangle();
		notifyBoundsChanged();
	}
}

void CLevelObject::SetPosition(const Ogre::Vector2& position) {
	if (vPosition != position) {
		Ogre::Vector2 translate = position - vPosition;
		aabBounds.Translate(translate);
		collisionData.Translate(translate);
		cachedCollisionData = collisionData;
		cachedCollisionData.Rotate(angle);
		vPosition = position;
		notifyPositionChanged();
		notifyBoundsChanged();
	}
}

void CLevelObject::SetCollisionType(CollisionType collisionType) {
	if (this->collisionType != collisionType) {
		this->collisionType = collisionType;
		notifyCollisionTypeChanged();
	}
}

void CLevelObject::SetAABBSize(const Ogre::Vector2& size) {
	Game::Rectangle newRect(vPosition - 0.5f*size, vPosition + 0.5f*size);

	if (aabBounds != newRect) {
		aabBounds = newRect;
		if (BoundingBoxCollision)
			collisionData = cachedCollisionData = Game::Polygon(aabBounds);
		notifyBoundsChanged();
	}
}

void CLevelObject::SetBoundingBox(const Game::Rectangle& box) {
	if (aabBounds != box) {
		aabBounds = box;
		if (BoundingBoxCollision)
			collisionData = cachedCollisionData = Game::Polygon(aabBounds);
		notifyBoundsChanged();
	}
}

void CLevelObject::SetRotation(float angle) {
	if (this->angle != angle) {
		this->angle = angle;
		cachedCollisionData = collisionData;
		if (angle != 0.0f) {
			BoundingBoxCollision = false;
			cachedCollisionData.Rotate(angle);
		}
		if (!BoundingBoxCollision) {
			aabBounds = cachedCollisionData.GetMinimumEnclosingRectangle();
		}
		notifyBoundsChanged();
	}
}


PMovableObject CMovableObject::Create() {
	CMovableObject* obj = new CMovableObject();
	PMovableObject objPtr(obj);
	obj->self = objPtr;
	return objPtr;
}

PLevelObject CMovableObject::Copy() const {
	CMovableObject* copy = new CMovableObject(*this);
	PMovableObject copyPtr(copy);
	copy->self = copyPtr;
	return copyPtr;
}

Game::Polygon CMovableObject::MakePolygon(const Game::Rectangle& rect, const Ogre::Vector2& translation) {
	Game::Polygon polygon;
	if (translation.x > 0 && translation.y > 0) { // top right
		polygon.AddPoint(rect.TopLeft());
		polygon.AddPoint(rect.TopLeft() + translation);
		polygon.AddPoint(rect.TopRight() + translation);
		polygon.AddPoint(rect.BottomRight() + translation);
		polygon.AddPoint(rect.BottomRight());
		polygon.AddPoint(rect.BottomLeft());
	} else if (translation.x > 0 && translation.y == 0) { // right
		polygon.AddPoint(rect.TopLeft());
		polygon.AddPoint(rect.TopRight() + Ogre::Vector2(translation.x, 0.0f));
		polygon.AddPoint(rect.BottomRight() + Ogre::Vector2(translation.x, 0.0f));
		polygon.AddPoint(rect.BottomLeft());
	} else if (translation.x > 0 && translation.y < 0) { // bottom right
		polygon.AddPoint(rect.TopLeft());
		polygon.AddPoint(rect.TopRight());
		polygon.AddPoint(rect.TopRight() + translation);
		polygon.AddPoint(rect.BottomRight() + translation);
		polygon.AddPoint(rect.BottomLeft() + translation);
		polygon.AddPoint(rect.BottomLeft());
	} else if (translation.x == 0 && translation.y > 0) { // top
		polygon.AddPoint(rect.TopLeft() + Ogre::Vector2(0.0f, translation.y));
		polygon.AddPoint(rect.TopRight() + Ogre::Vector2(0.0f, translation.y));
		polygon.AddPoint(rect.BottomRight());
		polygon.AddPoint(rect.BottomLeft());
	} else if (translation.x == 0 && translation.y < 0) { // bottom
		polygon.AddPoint(rect.TopLeft());
		polygon.AddPoint(rect.TopRight());
		polygon.AddPoint(rect.BottomRight() + Ogre::Vector2(0.0f, translation.y));
		polygon.AddPoint(rect.BottomLeft() + Ogre::Vector2(0.0f, translation.y));
	} else if (translation.x < 0 && translation.y > 0) { // top left
		polygon.AddPoint(rect.TopLeft() + translation);
		polygon.AddPoint(rect.TopRight() + translation);
		polygon.AddPoint(rect.TopRight());
		polygon.AddPoint(rect.BottomRight());
		polygon.AddPoint(rect.BottomLeft());
		polygon.AddPoint(rect.BottomLeft() + translation);
	} else if (translation.x < 0 && translation.y == 0) { // Left()
		polygon.AddPoint(rect.TopLeft() + Ogre::Vector2(translation.x, 0.0f));
		polygon.AddPoint(rect.TopRight());
		polygon.AddPoint(rect.BottomRight());
		polygon.AddPoint(rect.BottomLeft() + Ogre::Vector2(translation.x, 0.0f));
	} else if (translation.x < 0 && translation.y < 0) { // Bottom() Left()
		polygon.AddPoint(rect.TopLeft() + translation);
		polygon.AddPoint(rect.TopLeft());
		polygon.AddPoint(rect.TopRight());
		polygon.AddPoint(rect.BottomRight());
		polygon.AddPoint(rect.BottomRight() + translation);
		polygon.AddPoint(rect.BottomLeft() + translation);
	}
	return polygon;
}

float CMovableObject::GetTranslationFactorFromDirection(const Ogre::Vector2& translation, const Ogre::Vector2& direction) {
	if (approximatelyEqual(direction.y, 0.0f))
		return translation.x / direction.x;
	else if (approximatelyEqual(direction.x, 0.0f))
		return translation.y / direction.y;
	else {
		if (fabs(translation.x) > fabs(translation.y))
			return translation.x / direction.x;
		else
			return translation.y / direction.y;
	}
}

Ogre::Vector2 CMovableObject::Move(const Ogre::Vector2& translation) {
	PLevelObject object = self.lock();
	PLevelObjectManager manager = parent.lock();
	if (!object || !manager) {
		this->SetPosition(this->GetPosition() + translation);
		return translation;
	}
	Ogre::Vector2 resolve = ResolveCollision(object, translation);
	if (!std::isnan(resolve.x) && !std::isnan(resolve.y) && !std::isinf(resolve.x) && !std::isinf(resolve.y))
		this->SetPosition(this->GetPosition() + resolve);
	return resolve;
}

typedef ILevelObjectManager::LevelObjectList LevelObjectList;

Ogre::Vector2 CMovableObject::ResolveCollision(PLevelObject object, const Ogre::Vector2& translation) {
	PLevelObjectManager manager = parent.lock();
	if (!manager)
		return translation;


	// TODO: Make sure that length of resulting translation does not exceed the lenght of the translation
	// TODO: Possible infinite loop if object is intersecting with two objects at the same time

	bool bResolveFinished = false;

	// get Rectangle and corresponding Polygon once; change manually if needed
	Game::Rectangle rect = object->GetBoundingBox();
	Game::Polygon objectPolygon = object->GetBoundingBoxPolygon();

	Ogre::Vector2 currentTranslation = translation; // translation we are performing currently
	Ogre::Vector2 result(0,0); 	// all performed translations until any given point

	std::map<PLevelObject, Ogre::Vector2> Collisions; // store collisions

	float maxLength = translation.length(); // maximum allowed transformation length

	// stores translation vector for each face we already moved along
	std::map<Game::Face, Ogre::Vector2> visitedFaces;

	LevelObjectList ignoreObjects; // ignored objects - objects which already returned non-blocking collision

	while (!bResolveFinished) {

		// check if we move with zero length
		if ( (approximatelyEqual(currentTranslation.x, 0.0f) && approximatelyEqual(currentTranslation.y, 0.0f))
			 || approximatelyEqual(maxLength, 0.0f) || (maxLength <= 0.0f))  {
			bResolveFinished = true;
			continue;
		}

		// limit current translation by maxlength
		float currentLength = currentTranslation.length();
		if (currentLength > maxLength) {
			currentTranslation = (maxLength / currentLength) * currentTranslation;
		}

		// check again if we are now close to zero
		if (approximatelyEqual(currentTranslation.x, 0.0f) && approximatelyEqual(currentTranslation.y, 0.0f)) {
			bResolveFinished = true;
			continue;
		}

		TEST_LOG("ResolveCollision: (" << rect << ") " << currentTranslation);

		// I. get all objects inside the smallest rectangle containing rect and rect+translation

		// expand bounding rect by current translation
		Game::Rectangle broadRect( rect );
		if (currentTranslation.x > 0)
			broadRect.SetRight( rect.Right() + currentTranslation.x );
		else
			broadRect.SetLeft( rect.Left() + currentTranslation.x );
		if (currentTranslation.y > 0)
			broadRect.SetTop( rect.Top() + currentTranslation.y );
		else
			broadRect.SetBottom( rect.Bottom() + currentTranslation.y );

		LevelObjectList objects = manager->GetObjectRectangle(broadRect); // objects we could collide with

		// if no objects are in range, we will not collide
		if (objects.empty()) {
			result += currentTranslation;
			maxLength -= currentTranslation.length();
			currentTranslation = translation - result;
			TEST_LOG("objects.empty()");
			continue;
		}

		// II. get objects which actually intersect with the parallelogram described
		//     by rect and translation (separating axis test)
		//	   (also check for collision)

		Game::Polygon movementParallelogram = MakePolygon(rect, currentTranslation);

		LevelObjectList collisionObjects; // objects we could collide with
		LevelObjectList intersectingObjects; // objects we currently are colliding with

		// do more accurate intersection test for objects that are in range
		for (LevelObjectList::iterator it = objects.begin(); it != objects.end(); ++it) {
			const PLevelObject& obj = *it;
			if (obj == object) continue;

			// dont check non-blocking objects twice
			if (std::find(ignoreObjects.begin(), ignoreObjects.end(), obj) != ignoreObjects.end())
				continue;

			Game::Rectangle boundingRect = obj->GetBoundingBox();
			Game::Polygon objPolygon = obj->GetCollisionPolygon();

			// check for intersection with object
			if (rect.Intersects(boundingRect)) {
				std::pair<bool, Ogre::Vector2> result = objPolygon.SeparatingAxesTest(objectPolygon);
				if (!result.first && !approximatelyEqual(result.second.length(), 0.0f)) {
					if (obj->GetCollisionType(object, currentTranslation) == CLevelObject::ctBlocking) {
						intersectingObjects.push_back(obj);
					} else {
						ignoreObjects.push_back(obj);
					}
					Collisions[obj] = currentTranslation;
				}
			}

			// skip if we already have intersection
			if (!intersectingObjects.empty())
				continue;

			// test separating axes with movement parallelogram
			std::pair<bool, Ogre::Vector2> result = objPolygon.SeparatingAxesTest(movementParallelogram);
			if (!result.first && !approximatelyEqual(result.second.length(), 0.0f)) {
				collisionObjects.push_back(obj);
			}
		}

		// in case of collision, resolve:
		/* - Find minimum translation vector
		 * - translate -> collision is resolved
		 * - try again to move along translation; this time hopefully without collision
		 */
		if (!intersectingObjects.empty()) {
			TEST_LOG("COLLISION");

			const PLevelObject& obj = intersectingObjects[0];
			Game::Polygon objPoly = obj->GetCollisionPolygon();

			// get minimum translation vector
			std::pair<bool, Ogre::Vector2> SATresult = objectPolygon.SeparatingAxesTest(objPoly);
			Ogre::Vector2 translationResolve = SATresult.second;

			float translationLength = translationResolve.length();

			// always use MTV if it is _very_ short (usually a rounding error)
			/*if (translationLength > 0.01f) {
				// find solution in opposite moving direction
				Ogre::Vector2 currentTranslationDir = currentTranslation.normalisedCopy();
				Game::SATResult SATres = objectPolygon.IsSeparatingAxis(objPoly, Ogre::Vector2(currentTranslationDir.y, -currentTranslationDir.x));
				if (SATres.MinimumOverlap < 0.0f)
					translationResolve = SATres.MinimumOverlap * currentTranslationDir;
				else
					translationResolve = SATres.MaximumOverlap * currentTranslationDir;
				translationLength = translationResolve.length();
			}*/

			if (approximatelyEqual(translationLength, 0.0f)) {
				translationResolve.x = copysign(TOLERANCE_ABS, translationResolve.x);
				translationResolve.y = copysign(TOLERANCE_ABS, translationResolve.y);
			}

			translationResolve *= (1.0f + TOLERANCE);



			/*
			// now translationResolve will resolve the collision
			// perform and repeat translation
			*/

			// limit translation by maxLength
			if (translationLength > maxLength) {
				translationResolve = (maxLength / translationLength) * translationResolve;
				maxLength = 0;
			} else {
				maxLength -= translationLength;
			}

			TEST_LOG(translationResolve);

			rect.Translate(translationResolve);
			objectPolygon.Translate(translationResolve);

			result = result + translationResolve;
			currentTranslation = translation - result;
			continue;
		}

		// no objects inside parallelogram
		if (collisionObjects.empty()) {
			result += currentTranslation;
			maxLength -= currentTranslation.length();
			currentTranslation = translation - result;
			TEST_LOG("collisionObjects.empty()");

			continue;
		}

		// III. get maximum translation without collision
		/* - get for each object inside parallelogram maximum translation vector
		 *   along current translation (vector by which we can translate without collision)
		 * - perform maximum translation
		 * - check if collision is blocking; if not ignore object and repeat
		 */

		Game::Face nearestFace; // face we are colliding with
		PLevelObject nearestObj; // object we are colliding with
		float nearestFactor; // maximum factor that nearestFactor*currentTranslation can be performed without collision
		bool bNotFound = true; // no collision found?
		bool LastCollisionNonBlocking = false;

		do {
			std::vector<Game::Face> objFaces;
			bNotFound = true;
			LastCollisionNonBlocking = false;

			for (LevelObjectList::iterator it = collisionObjects.begin(); it != collisionObjects.end(); ++it) {
				const PLevelObject& obj = *it;
				// ignore non-blocking objects we already processed
				if (std::find(ignoreObjects.begin(), ignoreObjects.end(), obj) != ignoreObjects.end())
					continue;

				// check all faces for possible collision
				objFaces = obj->GetCollisionPolygon().GetFaces(false);
				for (int i = 0; i < objFaces.size(); i++) {
					// only process faces facing against movement direction
					if (objFaces[i].normal.dotProduct(currentTranslation) >= 0)
						continue;

					Game::Polygon facePoly(objFaces[i]);
					std::pair<bool, float> result = objectPolygon.TranslationIntersect(facePoly, currentTranslation);
					TEST_LOG(result.first << ", " << result.second << " " << objFaces[i]);
					if (result.first && (approximatelyEqual(result.second, 0.0f) || result.second >= 0.0f)) {
						 // find nearest collision
						if (bNotFound || fabs(nearestFactor) > fabs(result.second)) {
							bNotFound = false;
							nearestFace = objFaces[i];
							nearestFactor = result.second;
							nearestObj = obj;
							TEST_LOG("found collision");
						}
					}
				}
			}

			// an object has been found - perform maximum translation
			if (!bNotFound) {
				// translate towards nearest object
				Ogre::Vector2 maxTranslation = nearestFactor*currentTranslation*(1.0f - TOLERANCE);

				// limit by maxLength
				float maxTranslationLength = maxTranslation.length();
				if (maxTranslationLength > maxLength) {
					maxTranslation = (maxLength/maxTranslationLength) * maxTranslation;
					maxLength = 0.0f;
				} else {
					maxLength -= maxTranslationLength;
				}

				result += maxTranslation;
				objectPolygon.Translate(maxTranslation);
				rect.Translate(maxTranslation);
				currentTranslation -= maxTranslation;

				Collisions[nearestObj] = maxTranslation;

				// check if collision is blocking
				if (nearestObj->GetCollisionType(object, maxTranslation) != CLevelObject::ctBlocking) {
					ignoreObjects.push_back(nearestObj);
					nearestObj.reset();
					LastCollisionNonBlocking = true;
					TEST_LOG("non-blocking");
				}
			}
		} while (LastCollisionNonBlocking &&
				 !approximatelyEqual(maxLength, 0.0f) &&
				 !(approximatelyEqual(currentTranslation.x, 0.0f) && approximatelyEqual(currentTranslation.y, 0.0f)) );

		if (approximatelyEqual(currentTranslation.x, 0.0f) && approximatelyEqual(currentTranslation.y, 0.0f)) {
			// we have been able to move to our goal; continue
			currentTranslation = translation - result;
			TEST_LOG("currentTranslation = 0");
			continue;
		}

		if (approximatelyEqual(maxLength, 0.0f)) {
			// dont move any further
			bResolveFinished = true;
			TEST_LOG("maxLength = 0");
			continue;
		}

		if (bNotFound) {
			// no objects are blocking our way
			result += currentTranslation;
			maxLength -= currentTranslation.length();
			currentTranslation = translation - result;
			TEST_LOG("bNotFound=true");
			continue;
		}

		// IV. move along nearest Face
		/* We now arrived at a face which blocks our way
		 * since we alreade moved towards it, there should be exactly one separating axis
		 * out of the possible {X, Y, face_direction}
		 * if we move along the separating axis, it is impossible for us to collide with the face.
		 * thus, we check the remaining axes (which are non-separating) and test how far along
		 * the separating axis we'd have to move that one of these axes become separating.
		 * at last only one axis remains which is non-separating. now we move along the newly
		 * discovered separating axis until all three axes are separating.
		 * now we should be able to continue towards the goal.
		 * if any collision occurs along our way, we cancel and try to resolve that collision.
		 */

		TEST_LOG("nearestface= " << nearestFace);

		Ogre::Vector2 faceDirection = nearestFace.v2 - nearestFace.v1;
		Game::Polygon facePoly(nearestFace);

		// possible separating axes are UNIT_X, UNIT_Y, facedirection
		std::vector<Ogre::Vector2> separatingAxes;
		separatingAxes.push_back(faceDirection);
		if (!LinearlyDependent(faceDirection, Ogre::Vector2::UNIT_X))
			separatingAxes.push_back(Ogre::Vector2::UNIT_X);
		if (!LinearlyDependent(faceDirection, Ogre::Vector2::UNIT_Y))
			separatingAxes.push_back(Ogre::Vector2::UNIT_Y);

		// find separating axis
		Ogre::Vector2 separatingAxis(0.0f, 0.0f);

		int separatingAxisIndex = -1;
		float maxDp = 0.0f;
		for (int i = 0; i < separatingAxes.size(); i++) {

			SATResult satResult = objectPolygon.IsSeparatingAxis(facePoly, separatingAxes[i]);

			TEST_LOG("sep axis = " << separatingAxes[i]);
			TEST_LOG("SAT Result: " << satResult.IsSeparating << "; " << satResult.MinimumOverlap << "; " << satResult.MaximumOverlap);

			if (satResult.IsSeparating || approximatelyEqual(satResult.MinimumOverlap, 0.0f)) {
				float dp = currentTranslation.dotProduct(separatingAxes[i]);
				if (fabs(maxDp) <= fabs(dp)) {
					maxDp = dp;
					separatingAxis = separatingAxes[i].normalisedCopy();
					TEST_LOG("^ choose");
					separatingAxisIndex = i;
				}
			}
		}

		TEST_LOG("remaining axes: " << separatingAxes.size());

		// no axis found - cancel
		if (separatingAxis == Ogre::Vector2::ZERO) {
			TEST_LOG("sep.axis = 0");
			bResolveFinished = true;
			continue;
		}

		separatingAxes.erase(separatingAxes.begin() + separatingAxisIndex);

		// make separatingAxis face in same direction as translation
		if (separatingAxis.dotProduct(currentTranslation) < 0.0f)
			separatingAxis = -separatingAxis;

		TEST_LOG("sep.axis = " << separatingAxis);

		// calculate maximum allowed translation along separatingAxis
		float maxFactor = separatingAxis.dotProduct(translation);

		// dont allow movement against translation direction
		if (maxFactor < 0.0f || approximatelyEqual(maxFactor, 0.0f)) {
			TEST_LOG("maxFactor <= 0  ("<< maxFactor <<")");
			bResolveFinished = true;
			continue;
		}


		// find minimum translation to "create" a new separating axis
		float minFactor = std::numeric_limits<float>::infinity();
		for (int i = 0; i < separatingAxes.size(); i++) {
			SATResult satResult = objectPolygon.IsSeparatingAxis(facePoly, separatingAxes[i]);
			if (!satResult.IsSeparating && !approximatelyEqual(satResult.MinimumOverlap, 0.0f)) {
				// get minimum translation vector in direction of currentTranslation
				Ogre::Vector2 axisNormal = LeftHandNormal(separatingAxes[i]);
				Ogre::Vector2 MTV = satResult.MinimumOverlap * axisNormal;

				MTV *= (1.0f + TOLERANCE);
				TEST_LOG("MTV: "<<MTV);

				float factor = GetTranslationFactorFromDirection(MTV, separatingAxis);

				if (factor < 0.0f) {
					MTV = satResult.MaximumOverlap * axisNormal;
					MTV *= (1.0f + TOLERANCE);
					TEST_LOG("MTV: "<<MTV);

					factor = GetTranslationFactorFromDirection(MTV, separatingAxis);
				}

				TEST_LOG("->factor="<<factor);

				if (fabs(minFactor) > fabs(factor))
					minFactor = factor;
			} else {
				TEST_LOG("found another sep. axis: " << separatingAxes[i]);
				TEST_LOG("SAT Result: " << satResult.IsSeparating << "; " << satResult.MinimumOverlap << "; " << satResult.MaximumOverlap);
			}
		}

		if (minFactor == std::numeric_limits<float>::infinity()) {
			// error, abort
			TEST_LOG("minFactor=inf");
			bResolveFinished = true;
			continue;
		}

		float factor = (fabs(minFactor) < fabs(maxFactor)) ? minFactor : maxFactor;

		TEST_LOG("minFactor="<<minFactor<<"; maxFactor="<<maxFactor);

		Ogre::Vector2 nextTranslation = factor*separatingAxis;
		if (approximatelyEqual(nextTranslation.x, currentTranslation.x) && approximatelyEqual(nextTranslation.y, currentTranslation.y)) {
			TEST_LOG("next=current");
			bResolveFinished = true;
			continue;
		} else {
			currentTranslation = nextTranslation;
		}

		Collisions[nearestObj] = currentTranslation;

		// if we already visited that face, we dont want to move in opposite direction
		if (visitedFaces.find(nearestFace) != visitedFaces.end()) {
			// check if we are moving backwards
			float dp = visitedFaces[nearestFace].dotProduct(currentTranslation);
			if (dp < 0.0f) {
				// cancel
				TEST_LOG("dotProduct < 0");
				bResolveFinished = true;
				continue;
			}
		} else {
			visitedFaces[nearestFace] = currentTranslation;
		}


		TEST_LOG("currentTranslation = " << currentTranslation);
	}

	TEST_LOG("result=" << result);
	TEST_LOG("collisions=" << Collisions.size());
	TEST_LOG("========================"<<std::endl);

	// fire collision handlers of objects we collided with
	for (std::map<PLevelObject, Ogre::Vector2>::iterator it = Collisions.begin(); it != Collisions.end(); ++it) {
		it->first->HandleCollision(object, it->second);
	}


	return result;
}

}
}
/*
 * LevelObjects.h
 *
 *  Created on: Aug 9, 2010
 *      Author: crt
 */

#ifndef LEVELOBJECTS_H_
#define LEVELOBJECTS_H_

#include "Messaging.h"
#include "Geometry.h"
#include "LevelObjectManager.h"

#include "../testlog.h"

#include "Ogre.h"
#include "boost/smart_ptr.hpp"
#include "boost/utility.hpp"
#include "boost/function.hpp"
#include <set>

namespace Game {
namespace GameObjects {

class CLevelObject;
typedef boost::shared_ptr<CLevelObject> PLevelObject;
typedef boost::shared_ptr<const CLevelObject> cPLevelObject;
typedef boost::weak_ptr<CLevelObject> WLevelObject;

/** Level Object Model with Convex Polygon Collision */
class CLevelObject : public IMessagingObject {
public:
	/** void CollisionHandler(PLevelObject this, cPLevelObject sender, const Ogre::Vector2& direction) */
	typedef boost::function<void (PLevelObject, cPLevelObject, const Ogre::Vector2&)> CollisionHandler;

	enum CollisionType {ctBlocking, ctNonBlocking};
	typedef std::vector<Game::Face> FaceList;

	class Listener {
	public:
		Listener() { }
		virtual ~Listener() { }

		/** Called when Position has changed */
		virtual void PositionChanged(CLevelObject*) { }
		/** Called when Bounding Box has changed */
		virtual void BoundsChanged(CLevelObject*) { }
		/** Called when Collision Type has changed */
		virtual void CollisionTypeChanged(CLevelObject*) { }
	};
	typedef boost::shared_ptr<Listener> PListener;

public:
	virtual ~CLevelObject() {}

	/** Factory Method */
	static PLevelObject Create();

	/** Creates a copy of this object; does not copy listeners */
	virtual PLevelObject Copy() const;

	virtual void AddListener(PListener listener);
	virtual void RemoveListener(PListener listener);

	/** Set Parent Object Manager */
	virtual void SetParent(PLevelObjectManager manager) { parent = manager; }
	/** Get Parent Object Manager */
	virtual PLevelObjectManager GetParent() const { return parent.lock(); }

	/** Returns bounding box of object */
	virtual const Game::Rectangle& GetBoundingBox() const { return aabBounds; }
	/** Set bounding box of object */
	virtual void SetBoundingBox(const Game::Rectangle& box);
	/** Returns Bounding Box as Polygon */
	virtual Game::Polygon GetBoundingBoxPolygon() const { return Game::Polygon(aabBounds); }

	/** Resets collision data to bounding box */
	virtual void EnableBoundingBoxCollision();
	virtual bool BoundingBoxCollisionEnabled() const { return BoundingBoxCollision; }

	/** Set collision polygon */
	virtual void SetCollisionPolygon(const Game::Polygon& polygon);
	/** Returns Collision Polygon with applied rotation (cached) */
	virtual const Game::Polygon& GetCollisionPolygon() const { return cachedCollisionData; }
	/** Returns Collision Polygon without applied rotation */
	virtual const Game::Polygon& GetCleanCollisionPolygon() const { return collisionData; }

	/** Set Rotation; disables bounding box collision */
	virtual void SetRotation(float angle);
	/** Get Rotation */
	virtual float GetRotation() const { return angle; }

	/** Return Collision Type for a given level object and direction
	 *  Overwrite to get dynamic behaviour
	 @remarks As opposed to HandleCollision(...) this function might get called a lot during one Movement.
			  Returns this->collisionType as default. */
	virtual CollisionType GetCollisionType(cPLevelObject sender, const Ogre::Vector2& direction) const { return collisionType; };

	/** Set Collision Type */
	virtual void SetCollisionType(CollisionType collisionType);

	/** Called once if another Object collides with this
	@param sender Origin of collision
	@param direction Direction of collision
	@return Type of Collision
	@remarks Overwrite to respond to Collision. */
	virtual void HandleCollision(cPLevelObject sender, const Ogre::Vector2& direction) {
		if (collisionHandler) collisionHandler(self.lock(), sender, direction);
	}

	virtual void SetCollisionHandler(CollisionHandler handler) { collisionHandler = handler; }

	/** Set Position (also updates bounding box) */
	virtual void SetPosition(const Ogre::Vector2& position);
	/** Returns Center Position */
	virtual const Ogre::Vector2& GetPosition() const { return vPosition; }

	/** Set AABB Size (symmetric to center) */
	virtual void SetAABBSize(const Ogre::Vector2& size);
protected:
	CLevelObject();
	CLevelObject(const Ogre::Vector2& position);
	CLevelObject(const Game::Rectangle& bounds);
	CLevelObject(const CLevelObject& obj);

	/** Bounding Box */
	Game::Rectangle aabBounds;
	/** Position of Center */
	Ogre::Vector2 vPosition;
	/** Define if Collision is blocking */
	CollisionType collisionType;
	/** Collision Polygon */
	Game::Polygon collisionData;
	/** Cached rotated collision polygon */
	Game::Polygon cachedCollisionData;
	/** Rotation */
	float angle;
	/** Indicates if object has complex collision data */
	bool BoundingBoxCollision;
	/** Parent Level Object Manager */
	WLevelObjectManager parent;
	/** Smart Pointer to this */
	WLevelObject self;

	/** Collision Handler */
	CollisionHandler collisionHandler;


	typedef std::set<PListener> ListenerList;
	ListenerList Listeners;

	virtual void notifyPositionChanged();
	virtual void notifyBoundsChanged();
	virtual void notifyCollisionTypeChanged();
};


class CMovableObject;
typedef boost::shared_ptr<CMovableObject> PMovableObject;

/** Level Object which can be moved with collision check */
class CMovableObject : public CLevelObject {
public:
	virtual ~CMovableObject() { }

	/** Factory Method */
	static PMovableObject Create();

	/** Copy this object */
	virtual PLevelObject Copy() const;

	/** Move object by translation with collision (needs Parent to be set) */
	virtual Ogre::Vector2 Move(const Ogre::Vector2& translation);

protected:
	CMovableObject() : CLevelObject() { }

	float GetTranslationFactorFromDirection(const Ogre::Vector2& translation, const Ogre::Vector2& direction);
	Game::Polygon MakePolygon(const Game::Rectangle& rect, const Ogre::Vector2& translation);
	Ogre::Vector2 ResolveCollision(PLevelObject object, const Ogre::Vector2& translation);
};




}
}

#endif /* LEVELOBJECTS_H_ */
/*
 * Messaging.h
 *
 *  Created on: Sep 26, 2010
 *      Author: crt
 */

#ifndef MESSAGING_H_
#define MESSAGING_H_

#include "boost/smart_ptr.hpp"
#include "boost/any.hpp"
#include <string>
#include <map>
#include <queue>

namespace Game {
namespace GameObjects {

/** Wrapper for easier handling of a map<string,any> */
class ParameterList {
private:
	typedef std::map<std::string, boost::any> StringAnyMap;
	StringAnyMap parameters;

public:
	ParameterList() { }
	virtual ~ParameterList() { }

	/** Checks if given key contains specific type */
	template <typename T>
	bool IsType(const std::string& key) const {
		try {
			boost::any_cast<T>(parameters[key]);
		} catch (...) {
			return false;
		}
		return true;
	}

	template<typename T>
	T operator[](const std::string& key) {
		boost::any value = parameters[key];
		T result;
		try {
			result = boost::any_cast<T>(value);
		} catch (...) { }

		return result;
	}

	template<typename T>
	void Set(const std::string& key, const T& value) {
		parameters[key] = value;
	}
};

class IMessagingObject;
typedef boost::shared_ptr<IMessagingObject> PMessagingObject;
typedef boost::weak_ptr<IMessagingObject> WMessagingObject;

/** Object containing Message Information */
struct SMessage {
	enum MessageType {mtKill, mtGetItem};
	PMessagingObject Sender;
	PMessagingObject Target;
	ParameterList Parameters;
};

/** Interface for objects which can receive messages*/
class IMessagingObject {
public:
	IMessagingObject() { }
	virtual ~IMessagingObject() { }

	/** Handle given message */
	virtual void ReceiveMessage(const SMessage& message) { }

	virtual void SetName(const std::string& Name) { name = Name; }
	virtual const std::string& GetName() const { return name; }

	/** Meta Data */
	ParameterList Tags;
protected:
	std::string name;
};
typedef boost::shared_ptr<IMessagingObject> PMessagingObject;

/** Messaging Manager
 *  Inserts Messages into a Queue when sent. Delivers all messages in queue when calling DispatchMessages */
class CMessageManager {
private:
	typedef std::pair<WMessagingObject, SMessage> ObjectMessagePair;
	typedef std::queue<ObjectMessagePair> MessageQueue;

	MessageQueue Queue;

public:
	CMessageManager() { }
	virtual ~CMessageManager() { }

	/** Sends a message to a messaging object */
	virtual void SendMessage(PMessagingObject target, const SMessage& message) {
		Queue.push(ObjectMessagePair(target, message));
	}

	/** Delivers all messages currently in queue */
	virtual void DispatchMessages() {
		if (Queue.empty())
			return;

		// copy Queue
		MessageQueue currentMessages = Queue;
		// replace queue with empty one
		Queue = MessageQueue();

		// dispatch all messages
		while (!currentMessages.empty()) {
			ObjectMessagePair message = currentMessages.front();
			PMessagingObject receiver = message.first.lock();
			if (receiver)
				receiver->ReceiveMessage(message.second);
			currentMessages.pop();
		}
	}
};

}
}

#endif /* MESSAGING_H_ */
/*
 * LevelDataReaderListener.h
 *
 *  Created on: Oct 2, 2010
 *      Author: crt
 */

#ifndef LEVELDATAREADERLISTENER_H_
#define LEVELDATAREADERLISTENER_H_

namespace Game {
namespace GameObjects {

// workaroung to solve circular dependency

enum ObjectType {otStatic = 1, otDynamic = 2, otBackground = 3};

}
}

#endif /* LEVELDATAREADERLISTENER_H_ */
/*
 * OgreViews.cpp
 *
 *  Created on: Oct 4, 2010
 *      Author: crt
 */

#include "OgreViews.h"

namespace Game {
namespace GameObjects {

COgreEntityView::COgreEntityView(PLevelObject model, Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode)
	: IOgreView(model),
	  sEntityName(""),
	  vScale(1.0, 1.0, 1.0),
	  sMaterial(""),
	  vPositionOffset(Ogre::Vector3::ZERO),
	  oEntity(NULL),
	  qOrientation(Ogre::Quaternion::IDENTITY)
{
	oScene = ogreScene;
	oParentNode = ogreNode;
	UpdateGeometry();
}

POgreEntityView COgreEntityView::Create(PLevelObject model, Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode) {
	COgreEntityView* obj = new COgreEntityView(model, ogreScene, ogreNode);
	POgreEntityView objPtr( obj );
	obj->self = objPtr;
	model->AddListener(objPtr);
	return objPtr;
}

POgreView COgreEntityView::Copy(PLevelObject model) {
	COgreEntityView* copy = new COgreEntityView(model);
	POgreEntityView copyPtr( copy );
	copy->self = copyPtr;
	model->AddListener(copyPtr);
	copy->qOrientation = this->qOrientation;
	copy->sEntityName = this->sEntityName;
	copy->sMaterial = this->sMaterial;
	copy->vPositionOffset = this->vPositionOffset;
	copy->vScale = this->vScale;
	return copyPtr;
}

void COgreEntityView::UpdateGeometry() {
	PLevelObject model = Model.lock();
	if (oScene) {
		if (!oParentNode) {
			oParentNode = oScene->getRootSceneNode();
		}
		if (!oNode) {
			oNode = oParentNode->createChildSceneNode(Ogre::Vector3::ZERO);
		}
		if (oNode) {
			if (!oEntity && !sEntityName.empty()) {
				oEntity = oScene->createEntity(sEntityName);
				if (sMaterial != "")
					oEntity->setMaterialName(sMaterial);
				oNode->attachObject(oEntity);
			}
			Ogre::Vector2 modelPosition(0.0f, 0.0f);
			if (model)
				modelPosition = model->GetPosition();
			oNode->setPosition(vPositionOffset + Ogre::Vector3(0.0f, modelPosition.y, modelPosition.x));
			oNode->setScale(vScale);
			oNode->setOrientation(qOrientation);
		}
	}
}

void COgreEntityView::SetOgreScene(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode) {
	oScene = ogreScene;
	if (oParentNode != ogreNode) {
		oParentNode = ogreNode;
		oNode = NULL; oEntity = NULL;
	}
	if (ogreScene && !oParentNode)
		oParentNode = ogreScene->getRootSceneNode();
	UpdateGeometry();
}


void COgreEntityView::PositionChanged(CLevelObject*) {
	UpdateGeometry();
}

void COgreEntityView::SetPositionOffset(const Ogre::Vector3& offset) {
	if (vPositionOffset != offset) {
		vPositionOffset = offset;
		UpdateGeometry();
	}
}

void COgreEntityView::SetEntityName(const std::string& name) {
	if (sEntityName != name) {
		if (oEntity) {
			oNode->detachObject(oEntity);
			oScene->destroyEntity(oEntity);
		}
		oEntity = NULL;
		sEntityName = name;
		UpdateGeometry();
	}
}

void COgreEntityView::SetScale(const Ogre::Vector3& scale) {
	vScale = scale;
	UpdateGeometry();
}

void COgreEntityView::SetMaterial(const std::string& material) {
	if (sMaterial != material) {
		sMaterial = material;
		if (oEntity && sMaterial != "") {
			oEntity->setMaterialName(sMaterial);
		}
		UpdateGeometry();
	}
}

void COgreEntityView::SetOrientation(const Ogre::Quaternion& orientation) {
	qOrientation = orientation;
	UpdateGeometry();
}


COgreBoundsView::COgreBoundsView(PLevelObject model, Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode)
	: COgreEntityView(model, ogreScene, ogreNode)
{
	this->sEntityName = "cube.mesh";
	UpdateGeometry();
}

POgreBoundsView COgreBoundsView::Create(PLevelObject model, Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode) {
	COgreBoundsView* obj = new COgreBoundsView(model, ogreScene, ogreNode);
	POgreBoundsView objPtr( obj );
	obj->self = objPtr;
	model->AddListener(objPtr);
	return objPtr;
}

POgreView COgreBoundsView::Copy(PLevelObject model) {
	COgreBoundsView* copy = new COgreBoundsView(model);
	POgreBoundsView copyPtr( copy );
	copy->self = copyPtr;
	model->AddListener(copyPtr);
	copy->qOrientation = this->qOrientation;
	copy->sEntityName = this->sEntityName;
	copy->sMaterial = this->sMaterial;
	copy->vPositionOffset = this->vPositionOffset;
	copy->vScale = this->vScale;
	return copyPtr;
}

void COgreBoundsView::BoundsChanged(CLevelObject*) {
	UpdateGeometry();
}

void COgreBoundsView::UpdateGeometry() {
	PLevelObject model = Model.lock();
	float angle = 0.0f;
	if (model) {
		Game::Rectangle bounds = model->GetBoundingBox();
		Ogre::Vector2 center = 0.5f*(bounds.GetMaximum() + bounds.GetMinimum());
		Ogre::Vector2 scale2d =  bounds.GetMaximum() - bounds.GetMinimum();

		std::vector<Ogre::Vector2> poly = model->GetCleanCollisionPolygon().GetPoints();
		// assume it's a oriented bounding box
		if (poly.size() == 4) {
			center = model->GetCleanCollisionPolygon().CalculateCenter();
			scale2d = poly[2] - poly[0];
			angle = model->GetRotation();
		}

		// cube.mesh is 100x100x100
		this->vScale.x = 1.0f * 0.01f;
		this->vScale.y = scale2d.y * 0.01f;
		this->vScale.z = scale2d.x * 0.01f;

		this->vPositionOffset = Ogre::Vector3(0.0f, center.y, center.x);
	}

	if (oScene) {
		if (!oParentNode) {
			oParentNode = oScene->getRootSceneNode();
		}
		if (!oNode) {
			oNode = oParentNode->createChildSceneNode(Ogre::Vector3::ZERO);
		}
		if (oNode) {
			if (!oEntity && !sEntityName.empty()) {
				oEntity = oScene->createEntity(sEntityName);
				if (sMaterial != "")
					oEntity->setMaterialName(sMaterial);
				oNode->attachObject(oEntity);
			}
			oNode->setPosition(vPositionOffset);
			oNode->setScale(vScale);
			oNode->setOrientation(Ogre::Quaternion(Ogre::Radian(angle), Ogre::Vector3::NEGATIVE_UNIT_X));
		}
	}

	if (oEntity) {
		oEntity->setRenderQueueGroup(Ogre::RENDER_QUEUE_OVERLAY - 1);
	}
}

COgreBillboardView::COgreBillboardView(PLevelObject model)
	: IOgreView(model), sMaterial(""), billboardDirection(0, 0, 0)
{ }

POgreBillboardView COgreBillboardView::Create(PLevelObject model) {
	COgreBillboardView* obj = new COgreBillboardView(model);
	POgreBillboardView objPtr(obj);
	model->AddListener(objPtr);
	obj->self = objPtr;
	return objPtr;
}

POgreView COgreBillboardView::Copy(PLevelObject model) {
	COgreBillboardView* copy = new COgreBillboardView(model);
	POgreBillboardView copyPtr( copy );
	copy->self = copyPtr;
	model->AddListener(copyPtr);
	copy->sMaterial = this->sMaterial;
	copy->billboardDirection = this->billboardDirection;
	return copyPtr;
}

void COgreBillboardView::SetMaterial(const std::string& material) {
	if (sMaterial != material) {
		sMaterial = material;
		UpdateGeometry();
	}
}

void COgreBillboardView::BoundsChanged(CLevelObject*) {
	UpdateGeometry();
}

void COgreBillboardView::PositionChanged(CLevelObject*) {
	UpdateGeometry();
}

void COgreBillboardView::SetOgreScene(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode) {
	this->oScene = ogreScene;
	this->oParentNode = ogreNode;
	this->oBillboard = NULL;
	this->oBillboardSet = NULL;
	UpdateGeometry();
}

void COgreBillboardView::SetDirection(const Ogre::Vector3& direction) {
	if (direction != billboardDirection) {
		billboardDirection = direction;
		UpdateGeometry();
	}
}

void COgreBillboardView::UpdateGeometry() {
	PLevelObject model = Model.lock();
	Ogre::Vector2 position(0,0);
	Game::Rectangle rect;
	if (model) {
		position = model->GetPosition();
		rect = model->GetBoundingBox();
	}
	if (oScene) {
		if (!oParentNode) {
			oParentNode = oScene->getRootSceneNode();
		}
		if (!oNode) {
			oNode = oParentNode->createChildSceneNode(Ogre::Vector3::ZERO);
		}
		if (!oBillboardSet) {
			oBillboardSet = oScene->createBillboardSet(1);
			oBillboard = NULL;
			oNode->attachObject(oBillboardSet);
		}

		if (billboardDirection == Ogre::Vector3::ZERO) {
			oBillboardSet->setBillboardType(Ogre::BBT_POINT);
		} else {
			oBillboardSet->setBillboardType(Ogre::BBT_ORIENTED_COMMON);
			oBillboardSet->setCommonDirection(billboardDirection);
		}

		float width = fabs(rect.Right() - rect.Left());
		float height = fabs(rect.Top() - rect.Bottom());
		oBillboardSet->setDefaultDimensions(width, height);

		if (!oBillboard) {
			oBillboard = oBillboardSet->createBillboard(Ogre::Vector3::ZERO, Ogre::ColourValue::White);
		}

		oBillboard->setDimensions(width, height);
		oBillboard->setPosition(0.0f, position.y, position.x);
		oBillboardSet->_updateBounds();
		if (sMaterial != "")
			oBillboardSet->setMaterialName(sMaterial);
	}
}

}
}
/*
 * OgreViews.h
 *
 *  Created on: Oct 4, 2010
 *      Author: crt
 */

#ifndef OGREVIEWS_H_
#define OGREVIEWS_H_

#include "LevelObjects.h"
#include "Ogre.h"
#include "boost/shared_ptr.hpp"

namespace Game {
namespace GameObjects {


class IOgreView;
typedef boost::shared_ptr<IOgreView> POgreView;
typedef boost::weak_ptr<IOgreView> WOgreView;

/** Interface for Ogre Views
@remarks Provide static factory methods in derived classes and use these to make sure
		 Model->AddListener is called with a Smart Pointer to this. You may also take the chance
		 and store a weak pointer to this in your class.
		 Implement the methods from CLevelObject::Listener to synchronize the view with its model.
		 Usually an Ogre View should create an Ogre SceneNode and attach everything to it (see oNode, GetOgreNode).
		 Make sure whenever SetOgreScene is called, your view is actually displayed using the provieded scenemanager and node.
		 If you don't need to know about the view object, you can just create one and forget about it.
         The view object will be deleted when the Model is deleted (if no other references exist).
		 See COgreEntityView as an example */
class IOgreView : boost::noncopyable, public CLevelObject::Listener  {
public:
	/** Copy this object and set model (use this method instead of copy constructor) */
	virtual POgreView Copy(PLevelObject model) = 0;

	/** Set Ogre SceneManager and Node. Use rootSceneNode if no Scene Node given
	@remarks Existing Ogre Entity and Ogre Node will not be deleted */
	virtual void SetOgreScene(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode = NULL) = 0;

	/** Returns created Ogre Scene Node */
	virtual Ogre::SceneNode* GetOgreNode() { return oNode; }

	/** Returns true if object should be updated every frame */
	virtual bool IsUpdateable() const { return false; }

	/** Override this to do some updating every frame
	@param deltaTime Time since last update */
	virtual void Update(float deltaTime) { }

	/** Returns corresponding model (can return NULL) */
	virtual PLevelObject GetModel() { return Model.lock(); }

	virtual ~IOgreView() {
		PLevelObject model = Model.lock();
		if (model) model->RemoveListener(self.lock());
	}
protected:
	IOgreView(PLevelObject model) : oScene(NULL), oNode(NULL), oParentNode(NULL), Model(model) {
		assert(model != NULL);
	}

	/** Ogre Scene Manager */
	Ogre::SceneManager* oScene;
	/** Pointer to own ogre node */
	Ogre::SceneNode* oNode;
	/** Pointer to parent ogre node */
	Ogre::SceneNode* oParentNode;
	/** Model */
	WLevelObject Model;
	/** Smart Pointer to this */
	WOgreView self;
};

class COgreEntityView;
typedef boost::shared_ptr<COgreEntityView> POgreEntityView;
typedef boost::weak_ptr<COgreEntityView> WOgreEntityView;

/** Level Object View bound to Ogre Entity  */
class COgreEntityView : public IOgreView {
public:
	/** Factory Method */
	static POgreEntityView Create(PLevelObject model, Ogre::SceneManager* ogreScene = NULL, Ogre::SceneNode* ogreNode = NULL);

	virtual ~COgreEntityView() { }

	/** Copy object, set new model
	@remarks Sets Ogre Scene Manager and Node to NULL */
	virtual POgreView Copy(PLevelObject model);

	/** Implementation of CLevelObject::Listener::PositionChanged */
	virtual void PositionChanged(CLevelObject*);

	/** Set Ogre SceneManager and Node. Use rootSceneNode if no Scene Node given
	@remarks Existing Ogre Entity and Ogre Node will not be deleted */
	virtual void SetOgreScene(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode = NULL);

	virtual void SetPositionOffset(const Ogre::Vector3& offset);
	virtual const Ogre::Vector3& GetPositionOffset() const { return vPositionOffset; }

	/** Set ogre entity name */
	virtual void SetEntityName(const std::string& name);
	virtual const std::string& GetEntityName() const { return sEntityName; }

	/** Set scale factor */
	virtual void SetScale(const Ogre::Vector3& scale);
	virtual const Ogre::Vector3& GetScale() const { return vScale; }

	/** Set Material */
	virtual void SetMaterial(const std::string& material);
	virtual const std::string& GetMaterial() const { return sMaterial; }

	/** Set Orientation */
	virtual void SetOrientation(const Ogre::Quaternion& orientation);
	virtual const Ogre::Quaternion& GetOrientation() const { return qOrientation; }

	virtual Ogre::Entity* GetOgreEntity() { return oEntity; }
protected:
	COgreEntityView(PLevelObject model, Ogre::SceneManager* ogreScene = NULL, Ogre::SceneNode* ogreNode = NULL);
	virtual void UpdateGeometry();

	/** ogre entity name*/
	std::string sEntityName;
	/** scale factor of ogre entity */
	Ogre::Vector3 vScale;
	/** material for ogre entity */
	std::string sMaterial;
	/** position offset */
	Ogre::Vector3 vPositionOffset;

	/** Pointer to actual ogre entity*/
	Ogre::Entity* oEntity;

	/** orientation of ogre entity */
	Ogre::Quaternion qOrientation;
};


class COgreBoundsView;
typedef boost::shared_ptr<COgreBoundsView> POgreBoundsView;
typedef boost::weak_ptr<COgreBoundsView> WOgreBoundsView;

/** Level Object View which displays Bounding Box using cube.mesh */
class COgreBoundsView : public COgreEntityView {
public:
	static POgreBoundsView Create(PLevelObject model, Ogre::SceneManager* ogreScene = NULL, Ogre::SceneNode* ogreNode = NULL);

	virtual POgreView Copy(PLevelObject model);

	virtual void BoundsChanged(CLevelObject*);
protected:
	COgreBoundsView(PLevelObject model, Ogre::SceneManager* ogreScene = NULL, Ogre::SceneNode* ogreNode = NULL);

	virtual void UpdateGeometry();
};


class COgreBillboardView;
typedef boost::shared_ptr<COgreBillboardView> POgreBillboardView;
typedef boost::weak_ptr<COgreBillboardView> WOgreBillboardView;

/** Level Object View which displays object as billboard with the size of its bounding box */
class COgreBillboardView : public IOgreView {
public:
	virtual ~COgreBillboardView() { }

	static POgreBillboardView Create(PLevelObject model);
	virtual POgreView Copy(PLevelObject model);

	/** Set Material */
	virtual void SetMaterial(const std::string& material);
	virtual const std::string& GetMaterial() const { return sMaterial; }

	/** Set Billboard Direction; call with Ogre::Vector3::ZERO to enable all axes for rotation */
	virtual void SetDirection(const Ogre::Vector3& direction);

	/** Implementation of IOgreView */
	virtual void SetOgreScene(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode = NULL);
	/** Implementation of CLevelObject::Listener */
	virtual void BoundsChanged(CLevelObject*);
	/** Implementation of CLevelObject::Listener */
	virtual void PositionChanged(CLevelObject*);
protected:
	COgreBillboardView(PLevelObject model);
	virtual void UpdateGeometry();

	std::string sMaterial;
	Ogre::Billboard* oBillboard;
	Ogre::BillboardSet* oBillboardSet;
	Ogre::Vector3 billboardDirection;
};

}
}

#endif /* OGREVIEWS_H_ */
/*
 * PlayerModel.cpp
 *
 *  Created on: Oct 7, 2010
 *      Author: crt
 */

#include "PlayerModel.h"

namespace Game {
namespace GameObjects {

CPlayerModel::CPlayerModel()
	: CMovableObject(),
	  state(stFalling),
	  score(0),
	  speed(0,0),
	  fGravity(90),
	  fMaxJumpTime(0.5),
	  fJumpAcceleration(30),
	  fMinSpeed(60),
	  fMaxSpeed(100),
	  fAcceleration(25)
{
	this->SetAABBSize(Ogre::Vector2(6.0f, 9.0f));
}

PPlayerModel CPlayerModel::Create() {
	CPlayerModel* obj = new CPlayerModel();
	PPlayerModel objPtr(obj);
	obj->self = objPtr;
	return objPtr;
}

PLevelObject CPlayerModel::Copy() const {
	CPlayerModel* copy = new CPlayerModel(*this);
	PPlayerModel copyPtr(copy);
	copy->self = copyPtr;
	return copyPtr;
}

void CPlayerModel::AddPlayerListener(CPlayerModel::PListener listener) {
	if (listener)
		PlayerListeners.insert(listener);
}

void CPlayerModel::RemovePlayerListener(CPlayerModel::PListener listener) {
	PlayerListeners.erase(listener);
}


void CPlayerModel::Update(float deltaTime) {
	if (state == stOnGround)
		speed.y = -fGravity * deltaTime;

	if (state == stJumping) {
		jumpTime += deltaTime;

		if (jumpTime > fMaxJumpTime) {
			SetState(stFalling);
		}
	}

	if (state == stFalling) {
		speed.y -= fGravity * deltaTime;
	}

	speed.x += fAcceleration * deltaTime;
	if (speed.x > fMaxSpeed)
		speed.x = fMaxSpeed;

	if (state != stDead && state != stAtGoal) {
		Ogre::Vector2 translation = deltaTime * speed;
		Ogre::Vector2 actualTranslation = this->Move(translation);

		if (approximatelyEqual(actualTranslation.x, 0.0f)) actualTranslation.x = 0.0f;
		if (approximatelyEqual(actualTranslation.y, 0.0f)) actualTranslation.y = 0.0f;

		if (state == stOnGround && actualTranslation.y < 0.0f) {
			SetState(stFalling);
		}

		if (actualTranslation.x <= 0.0f) {
			speed.x = fMinSpeed;
		}

		if (state != stOnGround) {
			if (translation.y > 0.0f && actualTranslation.y <= 0.0f) {
				speed.y = 0.0f;
				SetState(stFalling);
			}
			if (translation.y < 0.0f && actualTranslation.y >= 0.0f) {
				SetState(stOnGround);
			}
		}
	}
}

void CPlayerModel::BeginJump() {
	if (state == stOnGround) {
		jumpTime = 0.0f;
		speed.y = fJumpAcceleration;
		SetState(stJumping);
	}
}

void CPlayerModel::FinishJump() {
	if (state == stJumping) {
		SetState(stFalling);
	}
}

void CPlayerModel::ReceiveMessage(const SMessage& message) {
	//TODO
}

void CPlayerModel::SetState(CPlayerModel::PlayerState newState) {
	if (state != newState) {
		state = newState;
		notifyStateChanged();
	}
}

void CPlayerModel::notifyPositionChanged() {
	CLevelObject::notifyPositionChanged();

	for (PlayerListenerList::iterator it = PlayerListeners.begin(); it != PlayerListeners.end(); ++it) {
		(*it)->PositionChanged(this);
	}
}

void CPlayerModel::notifyStateChanged() {
	for (PlayerListenerList::iterator it = PlayerListeners.begin(); it != PlayerListeners.end(); ++it) {
		(*it)->StateChanged(this);
	}
	TEST_LOG("state change: " << this->state);
}

}
}
/*
 * PlayerModel.h
 *
 *  Created on: Oct 7, 2010
 *      Author: crt
 */

#ifndef PLAYERMODEL_H_
#define PLAYERMODEL_H_

#include "LevelObjects.h"

namespace Game {
namespace GameObjects {

class CPlayerModel;
typedef boost::shared_ptr<CPlayerModel> PPlayerModel;

class CPlayerModel : public CMovableObject {
public:
	class Listener {
	public:
		Listener() { }
		virtual ~Listener() { }

		virtual void PositionChanged(CPlayerModel*) { }
		virtual void StateChanged(CPlayerModel*) { }
	};
	typedef boost::shared_ptr<Listener> PListener;

	enum PlayerState { stFalling, stOnGround, stJumping, stDead, stAtGoal };
public:
	virtual ~CPlayerModel() { }

	/** Factory Method */
	static PPlayerModel Create();
	/** Copy this object */
	virtual PLevelObject Copy() const;

	virtual void AddPlayerListener(CPlayerModel::PListener listener);
	virtual void RemovePlayerListener(CPlayerModel::PListener listener);

	/** Update State, Move Player ; Called every frame */
	virtual void Update(float deltaTime);

	/** Starts Jump; every Update adds delaTime until MaxJumpTime is reached */
	virtual void BeginJump();

	/** Finishes Jump before MaxJumpTime is reached */
	virtual void FinishJump();

	/** Implementation of IMessagingObject */
	virtual void ReceiveMessage(const SMessage& message);

	virtual PlayerState GetState() const { return state; }

	virtual int GetScore() const { return score; }

	virtual float GetSpeed() const { return speed.x; }

	/** Set Gravity (units/second^2)
		Default: 90.0*/
	virtual void SetGravity(float g) { fGravity = g; }
	virtual float GetGravity() { return fGravity; }

	/** Set maximum Time the character should accelerate when jumping (seconds)
	    Default: 1.0*/
	virtual void SetMaxJumpTime(float time) { fMaxJumpTime = time; }
	virtual float GetMaxJumpTime() { return fMaxJumpTime; }

	/** Set Jump Acceleration (units/second^2)
	    Default: 30.0*/
	virtual void SetJumpAcceleration(float acceleration) { fJumpAcceleration = acceleration; }
	virtual float GetJumpAcceleration() { return fJumpAcceleration; }

	/** Set Speed and Acceleration
	 *  Player starts with minSpeed, then accelerates upto maxspeed
	 *  Speed is reset to minspeed whenever player hits wall */
	virtual void SetSpeedLimits(float minSpeed, float maxSpeed, float acceleration) {
		fMinSpeed = speed.x = minSpeed;
		fMaxSpeed = maxSpeed;
		fAcceleration = acceleration;
	}

protected:
	CPlayerModel();

	typedef std::set<CPlayerModel::PListener> PlayerListenerList;
	PlayerListenerList PlayerListeners;

	// state
	PlayerState state;
	int score;
	Ogre::Vector2 speed;
	float jumpTime;

	// settings
	float fGravity;
	float fMaxJumpTime;
	float fJumpAcceleration;
	float fMinSpeed, fMaxSpeed;
	float fAcceleration;

	virtual void notifyStateChanged();
	virtual void notifyPositionChanged();

	void SetState(PlayerState newState);
};

}
}

#endif /* PLAYERMODEL_H_ */
/*
 * PlayerView.cpp
 *
 *  Created on: Oct 7, 2010
 *      Author: crt
 */

#include "PlayerView.h"

namespace Game {
namespace GameObjects{

CPlayerOgreView::CPlayerOgreView(PPlayerModel model)
	: IOgreView(model),
	  oEntity(NULL),
	  fAnimationFadeSpeed(7.5),
	  fAnimationTimer(0.0)
{
	// setup helper arrays
	AnimationIDs.clear();
	AnimationIDs.push_back(animNone);
	AnimationIDs.push_back(animIdleTop);
	AnimationIDs.push_back(animIdleBase);
	AnimationIDs.push_back(animRunTop);
	AnimationIDs.push_back(animRunBase);
	AnimationIDs.push_back(animJumpStart);
	AnimationIDs.push_back(animJumpLoop);
	AnimationIDs.push_back(animJumpEnd);
	AnimationTargets.clear();
	AnimationTargets.push_back(atTop);
	AnimationTargets.push_back(atBase);

	Animations[animIdleBase] = "IdleBase";
	Animations[animIdleTop] = "IdleTop";
	Animations[animRunBase] = "RunBase";
	Animations[animRunTop] = "RunTop";
	Animations[animJumpStart] = "JumpStart";
	Animations[animJumpLoop] = "JumpLoop";
	Animations[animJumpEnd] = "JumpEnd";

	SetupAnimations();
}

PPlayerOgreView CPlayerOgreView::Create(PPlayerModel model) {
	CPlayerOgreView* obj = new CPlayerOgreView(model);
	PPlayerOgreView objPtr(obj);
	model->AddPlayerListener(objPtr);
	obj->self = objPtr;
	return objPtr;
}

POgreView CPlayerOgreView::Copy(PPlayerModel model) {
	CPlayerOgreView* copy = new CPlayerOgreView(model);
	PPlayerOgreView copyPtr( copy );
	copy->self = copyPtr;
	model->AddPlayerListener(copyPtr);
	copy->fAnimationFadeSpeed = this->fAnimationFadeSpeed;
	return copyPtr;
}


void CPlayerOgreView::SetupAnimations() {
	for (int i=0; i < AnimationIDs.size(); ++i) {
		AnimationID id = AnimationIDs[i];

		// set default values
		AnimationStates[id] = NULL;
		AnimationFadeIn[id] = false;
		AnimationFadeOut[id] = false;

		// dont setup animNone
		if (id == animNone)
			continue;

		// try to get Ogre Animation State by name
		if (oEntity) {
			std::string animName = Animations[id];
			if (animName != "") {
				Ogre::AnimationState* animState = oEntity->getAnimationState(animName);
				if (animState) {
					AnimationStates[id] = animState;
					animState->setLoop(true);
					animState->setEnabled(false);
				}
			}
		}
	}

	// rest all animation targets
	for (int i=0; i < AnimationTargets.size(); ++i) {
		AnimationTarget target = AnimationTargets[i];
		SetAnimation(target, animNone);
	}
}

void CPlayerOgreView::SetAnimation(AnimationTarget target, AnimationID animation, bool reset) {
	// fade old animation out
	if (currentAnimations[target] != animNone) {
		AnimationFadeIn[currentAnimations[target]] = false;
		AnimationFadeOut[currentAnimations[target]] = true;
	}

	currentAnimations[target] = animation;

	if (animation != animNone) {
		// fade new animation in
		if (AnimationStates[animation] != NULL) {
			AnimationStates[animation]->setEnabled(true);
			AnimationStates[animation]->setWeight(0);
			if (reset)
				AnimationStates[animation]->setTimePosition(0);
		}

		AnimationFadeIn[animation] = true;
		AnimationFadeOut[animation] = false;
	}
}

void CPlayerOgreView::fadeAnimations(float deltaTime) {
	for (int i=0; i < AnimationIDs.size(); ++i) {
		AnimationID id = AnimationIDs[i];

		if (AnimationStates[id] == NULL)
			continue;

		if (AnimationFadeIn[id]) {
			Ogre::Real newWeight = AnimationStates[id]->getWeight() + deltaTime * fAnimationFadeSpeed;
			AnimationStates[id]->setWeight(Ogre::Math::Clamp<Ogre::Real>(newWeight, 0, 1));
			if (newWeight >= 1)
				AnimationFadeIn[id] = false;
		} else if (AnimationFadeOut[id]) {
			Ogre::Real newWeight = AnimationStates[id]->getWeight() - deltaTime * fAnimationFadeSpeed;
			AnimationStates[id]->setWeight(Ogre::Math::Clamp<Ogre::Real>(newWeight, 0, 1));
			if (newWeight <= 0)
			{
				AnimationStates[id]->setEnabled(false);
				AnimationFadeOut[id] = false;
			}
		}
	}
}

void CPlayerOgreView::UpdateGeometry() {
	PLevelObject model = Model.lock();
	Ogre::Vector2 position(0,0);
	if (model) {
		position = model->GetPosition();
	}

	if (oScene) {
		if (!oParentNode) {
			oParentNode = oScene->getRootSceneNode();
		}
		if (!oNode) {
			oNode = oParentNode->createChildSceneNode(Ogre::Vector3::ZERO);
		}
		if (!oEntity) {
			oEntity = oScene->createEntity("sinbad.mesh");
			oNode->attachObject(oEntity);
			oEntity->getSkeleton()->setBlendMode(Ogre::ANIMBLEND_CUMULATIVE);
			oEntity->setCastShadows(true);
			oEntity->getAnimationState("HandsRelaxed")->setLoop(true);
			oEntity->getAnimationState("HandsRelaxed")->setEnabled(true);
			SetupAnimations();
		}
		oNode->setPosition(Ogre::Vector3(0.0f, position.y, position.x));
	}
}

void CPlayerOgreView::SetOgreScene(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode) {
	this->oScene = ogreScene;
	this->oParentNode = ogreNode;
	this->oNode = NULL;
	this->oEntity = NULL;
	UpdateGeometry();
}

void CPlayerOgreView::PositionChanged(CPlayerModel*) {
	UpdateGeometry();
}

void CPlayerOgreView::StateChanged(CPlayerModel*) {
	PLevelObject model = Model.lock();
	if (!model) return;

	if (!oEntity) return;

	PPlayerModel player = boost::static_pointer_cast<CPlayerModel>(model);
	CPlayerModel::PlayerState newState = player->GetState();

	if (newState == CPlayerModel::stFalling) {
		if (currentAnimations[atTop] != animNone) {
			SetAnimation(atTop, animNone);
		}
		if (currentAnimations[atBase] != animJumpLoop) {
			SetAnimation(atBase, animJumpLoop, true);
		}
	}

	if (newState == CPlayerModel::stOnGround) {
		if (currentAnimations[atBase] != animRunBase) {
			if (currentAnimations[atBase] != animJumpEnd) {
				SetAnimation(atBase, animJumpEnd, true);
				fAnimationTimer = 0;
			} else if (fAnimationTimer >= AnimationStates[animJumpEnd]->getLength()) {
				SetAnimation(atTop, animRunTop);
				SetAnimation(atBase, animRunBase);
			}
		}
	}

	if (newState == CPlayerModel::stJumping) {
		if (currentAnimations[atBase] != animJumpLoop) {
			if (currentAnimations[atBase] != animJumpStart) {
				SetAnimation(atBase, animJumpStart, true);
				fAnimationTimer = 0;
			} else if (fAnimationTimer >= AnimationStates[animJumpStart]->getLength()) {
				SetAnimation(atBase, animJumpLoop, true);
			}
		}
	}
}

void CPlayerOgreView::Update(float deltaTime) {
	fAnimationTimer += deltaTime;

	if (!oEntity)
		return;

	if (currentAnimations[atBase] == animJumpStart) {
		if (fAnimationTimer >= AnimationStates[animJumpStart]->getLength()) {
			SetAnimation(atBase, animJumpLoop, true);
		}
	}

	if (currentAnimations[atBase] == animJumpEnd) {
		if (fAnimationTimer >= AnimationStates[animJumpEnd]->getLength()) {
			SetAnimation(atBase, animRunBase);
			SetAnimation(atTop, animRunTop);
		}
	}

	for (int i=0; i < AnimationTargets.size(); ++i) {
		AnimationTarget target = static_cast<AnimationTarget>(AnimationTargets[i]);

		if (currentAnimations[target] != animNone) {
			if (AnimationStates[currentAnimations[target]] != NULL) {
				AnimationStates[currentAnimations[target]]->addTime(deltaTime);
			}
		}
	}

	fadeAnimations(deltaTime);
}

}
}
/*
 * PlayerView.h
 *
 *  Created on: Oct 7, 2010
 *      Author: crt
 */

#ifndef PLAYERVIEW_H_
#define PLAYERVIEW_H_

#include "OgreViews.h"
#include "PlayerModel.h"

namespace Game {
namespace GameObjects {

class CPlayerOgreView;
typedef boost::shared_ptr<CPlayerOgreView> PPlayerOgreView;
typedef boost::weak_ptr<CPlayerOgreView> WPlayerOgreView;

class CPlayerOgreView : public IOgreView, public CPlayerModel::Listener {
public:
	virtual ~CPlayerOgreView() { }

	static PPlayerOgreView Create(PPlayerModel model);

	virtual POgreView Copy(PPlayerModel model);

	/** Implementation of IOgreView */
	virtual void SetOgreScene(Ogre::SceneManager* ogreScene, Ogre::SceneNode* ogreNode = NULL);

	/** Set Animation Crossfade Speed (%weight/second)
		Default: 7.5*/
	virtual void SetAnimationFadeSpeed(float fadespeed) { fAnimationFadeSpeed = fadespeed; }
	virtual float GetAnimationFadeSpeed() { return fAnimationFadeSpeed; }

	/** Implementation of IOgreView */
	virtual bool IsUpdateable() const { return true; }

	/** Implementation of IOgreView */
	virtual void Update(float deltaTime);

	/** Implementation of CPlayerModel::Listener */
	virtual void PositionChanged(CPlayerModel*);

	/** Implementation of CPlayerModel::Listener */
	virtual void StateChanged(CPlayerModel*);

protected:
	CPlayerOgreView(PPlayerModel model);

	POgreView Copy(PLevelObject model) { return POgreView(); }

	enum AnimationID
	{
		animNone,
		animIdleTop,
		animIdleBase,
		animRunTop,
		animRunBase,
		animJumpStart,
		animJumpLoop,
		animJumpEnd
	};
	enum AnimationTarget
	{
		atTop,
		atBase
	};

	typedef std::map<AnimationID, std::string> AnimationMap;
	typedef std::map<AnimationID, Ogre::AnimationState*> AnimationStateMap;
	typedef std::map<AnimationTarget, AnimationID> AnimationTargetMap;

	// helper arrays
	std::vector<AnimationID> AnimationIDs;
	std::vector<AnimationTarget> AnimationTargets;

	// stores names for each animation id
	AnimationMap Animations;

	// Ogre Animation States
	AnimationStateMap AnimationStates;

	// Defines which Animations are currently fading in or out
	std::map<AnimationID, bool> AnimationFadeIn;
	std::map<AnimationID, bool> AnimationFadeOut;

	AnimationTargetMap currentAnimations;

	// pointer to ogre entity
	Ogre::Entity* oEntity;

	float fAnimationFadeSpeed;
	float fAnimationTimer;

	void UpdateGeometry();
	void SetupAnimations();
	void SetAnimation(AnimationTarget target, AnimationID animation, bool reset = false);
	void fadeAnimations(float deltaTime);
};

}
}

#endif /* PLAYERVIEW_H_ */
/*
 * CEditorState.cpp
 *
 *  Created on: Aug 22, 2010
 *      Author: crt
 */

#include "CEditorState.h"

namespace Game {

const Ogre::ColourValue HUD_STANDARD (1,1,1);
const Ogre::ColourValue HUD_ACTIVE (1,1,0);
const Ogre::ColourValue HUD_SELECT (1,0.2,0.2);
const std::string WIREFRAME ("Editor/Wireframe");
const std::string WIREFRAME_SELECTED ("Editor/WireframeRed");
const std::string WIREFRAME_ACTIVE ("Editor/WireframeGreen");

CLightListener::CLightListener(const Ogre::ColourValue& diffuse, const Ogre::ColourValue& specular) {
	Ogre::Light* light = new Ogre::Light();
	light->setType(Ogre::Light::LT_DIRECTIONAL);
    light->setDiffuseColour(diffuse);
    light->setSpecularColour(specular);
    light->setDirection(Ogre::Vector3( 1, -1, -1 ));
    LightList.push_back(light);

	light = new Ogre::Light();
	light->setType(Ogre::Light::LT_DIRECTIONAL);
    light->setDiffuseColour(diffuse);
    light->setSpecularColour(specular);
    light->setDirection(Ogre::Vector3( 1, -1, 1 ));
    LightList.push_back(light);

	light = new Ogre::Light();
	light->setType(Ogre::Light::LT_DIRECTIONAL);
    light->setDiffuseColour(diffuse);
    light->setSpecularColour(specular);
    light->setDirection(Ogre::Vector3( -1, -1, 0 ));
    LightList.push_back(light);
}

CLightListener::~CLightListener() {
	// delete all lights in list
	for (Ogre::LightList::iterator it = LightList.begin(); it != LightList.end(); ++it)
		delete *it;
	LightList.clear();
}


CEditorState::CEditorState()
	: ogreLevelNode(NULL),
	  bWndCreated(false),
	  bSpinCamera(false),
	  bLeftPressed(false),
	  bRightPressed(false),
	  bUpPressed(false),
	  bDownPressed(false),
	  bMouseDown(false),
	  bAxisX(false),
	  bAxisY(true),
	  bAxisZ(true),
	  bBoundingBoxes(false),
	  oBBNode(NULL),
	  bShowGrid(false),
	  bPreview(false),
	  bKeepSelectedOnLayerChange(false),
	  bAlwaysAlignToBoundingBox(false),
	  oGreenListener(Ogre::ColourValue(0.3, 1, 0.3), Ogre::ColourValue(0.3, 1, 0.3)),
	  oRedListener(Ogre::ColourValue(1, 0.3, 0.3), Ogre::ColourValue(1, 0.3, 0.3)),
	  oDarkListener(Ogre::ColourValue(0.1, 0.1, 0.1), Ogre::ColourValue(0.1, 0.1, 0.1)),
	  ActiveLayer(GameObjects::otStatic),
	  ActiveMode(emMove),
	  ogreGrid(NULL),
	  AlignX(alCenter),
	  AlignY(alTop),
	  AlignZ(alRight),
	  TargetAlignX(alCenter),
	  TargetAlignY(alTop),
	  TargetAlignZ(alLeft) {
	ogreRoot = Ogre::Root::getSingletonPtr();
	ogreRenderWindow = dynamic_cast<Ogre::RenderWindow*>(ogreRoot->getRenderSystem()->getRenderTarget("Game"));
}

CEditorState::~CEditorState() {
}

void nukeSceneNode(Ogre::SceneNode* sceneNode)
{
   if (sceneNode == NULL) return;

   // Destroy all the attached objects
   Ogre::SceneNode::ObjectIterator itObject = sceneNode->getAttachedObjectIterator();

   while (itObject.hasMoreElements())
   {
      Ogre::MovableObject* pObject = static_cast<Ogre::MovableObject*>(itObject.getNext());
      sceneNode->getCreator()->destroyMovableObject(pObject);
   }

   // Recurse to child SceneNodes
   Ogre::SceneNode::ChildNodeIterator itChild = sceneNode->getChildIterator();

   while (itChild.hasMoreElements())
   {
      Ogre::SceneNode* pChildNode = static_cast<Ogre::SceneNode*>(itChild.getNext());
      nukeSceneNode(pChildNode);
   }
}

bool CEditorState::Start() {
	// remove old scene
	ogreRenderWindow->removeAllViewports();

	// create new scene, camera, viewport
	ogreScene = ogreRoot->createSceneManager(Ogre::ST_GENERIC, "Editor");
	ogreCamera = ogreScene->createCamera("MainCamera");
	ogreViewport = ogreRenderWindow->addViewport(ogreCamera);
	ogreViewport->setOverlaysEnabled(false);
	ogreCamera->setAspectRatio(Ogre::Real(ogreViewport->getActualWidth()) / Ogre::Real(ogreViewport->getActualHeight()));


	// create extra viewport for overlays only in order to share overlay across all viewports
	// set cleareveryframe=false to make viewport "transparent"
	ogreOverlayScene = ogreRoot->createSceneManager(Ogre::ST_GENERIC,"OverlayScene");
	ogreOverlayCamera = ogreOverlayScene->createCamera("OverlayCamera");
	ogreOverlayViewport = ogreRenderWindow->addViewport(ogreOverlayCamera,50, 0, 0, 1, 1);
	ogreOverlayViewport->setBackgroundColour(Ogre::ColourValue(0,0,0));
	ogreOverlayViewport->setClearEveryFrame(false);
	ogreOverlayViewport->setOverlaysEnabled(true);
	ogreOverlayViewport->setSkiesEnabled(false);


	// make textures look nice
    Ogre::MaterialManager::getSingleton().setDefaultTextureFiltering(Ogre::TFO_ANISOTROPIC);
    Ogre::MaterialManager::getSingleton().setDefaultAnisotropy(7);

	ogreCamera->setNearClipDistance(0.1);
	ogreCamera->setFarClipDistance(0);

	ogreViewport->setBackgroundColour(Ogre::ColourValue(0.6f, 0.6f, 0.6f));

	ogreScene->setAmbientLight(Ogre::ColourValue(0.1, 0.1, 0.1));

	Ogre::Light* light = ogreScene->createLight();
	light->setType(Ogre::Light::LT_DIRECTIONAL);
    light->setDiffuseColour(Ogre::ColourValue(1, 1, 1));
    light->setSpecularColour(Ogre::ColourValue(1, 1, 1));
    light->setDirection(Ogre::Vector3( 1, -1, -1 ));

	light = ogreScene->createLight();
	light->setType(Ogre::Light::LT_DIRECTIONAL);
    light->setDiffuseColour(Ogre::ColourValue(1, 1, 1));
    light->setSpecularColour(Ogre::ColourValue(1, 1, 1));
    light->setDirection(Ogre::Vector3( 1, -1, 1 ));

	light = ogreScene->createLight();
	light->setType(Ogre::Light::LT_DIRECTIONAL);
    light->setDiffuseColour(Ogre::ColourValue(1, 1, 1));
    light->setSpecularColour(Ogre::ColourValue(1, 1, 1));
    light->setDirection(Ogre::Vector3( -1, -1, 0 ));

	vPivot = Ogre::Vector3::UNIT_Y * -5;

	goCamera = GameObjects::CPivotCamera::Create(ogreCamera, 15.0f);
	goCamera->SetPivot(vPivot);
	goCamera->Zoom(2.0f);
	goCamera->Yaw(-90);
	goCamera->MoveToGoal();

//	goHero = GameObjects::CSindbadCharacter::Create(ogreScene, "SinbadBody");
//	goHero->SetPosition(Ogre::Vector3::UNIT_Y * 5);
//	goHero->SetSpeed(0);
	Ogre::Rectangle nullRect;
	nullRect.left = nullRect.top = nullRect.right = nullRect.bottom = 0.0f;
//	goHero->SetConstraints(nullRect);


	goHud = GameObjects::COverlay::Create("Editor/HUD", "hud", 100);
	goHud->Hide("BoundingBoxPanel");

	Ogre::OverlayManager& om = Ogre::OverlayManager::getSingleton();

	// create cursor
	oCursorLayer = om.create("cursorLayer");
	oCursorLayer->setZOrder(500);

	oCursor = (Ogre::OverlayContainer*)om.createOverlayElementFromTemplate("Editor/Cursor", "Panel", "Cursor");
	oCursorLayer->add2D(oCursor);

	oCursorLayer->show();

	sCurrentFilename = "level.xml";
	LoadFile();
	ShowDialog(edNone);

	return true;
}

void CEditorState::CreateWndViewport() {
	ogreWndScene = ogreRoot->createSceneManager(Ogre::ST_GENERIC, "TEditor");
	ogreWndCamera = ogreWndScene->createCamera("TCamera");
	ogreWndViewport = ogreRenderWindow->addViewport(ogreWndCamera, 1, 0.125, 0.125, 0.75, 0.75);
	ogreWndViewport->setBackgroundColour(Ogre::ColourValue(0,0,0));
	ogreWndViewport->setOverlaysEnabled(false);
	ogreWndViewport->setClearEveryFrame(true, Ogre::FBT_DEPTH | Ogre::FBT_STENCIL);

	ogreWndCamera->setNearClipDistance(0.1);
	ogreWndCamera->setFarClipDistance(0);
	ogreWndCamera->setPosition(5,5,10);
	ogreWndCamera->lookAt(0,0,0);

	bWndCreated = true;
}

void CEditorState::DestroyWndViewport() {
	ogreWndScene->clearScene();
	ogreWndScene->destroyAllCameras();
	ogreRoot->destroySceneManager(ogreWndScene);
	ogreRenderWindow->removeViewport(1);
	ogreWndScene = NULL;
	ogreWndCamera = NULL;
	ogreWndViewport = NULL;
	goWndFrame.reset();
	bWndCreated = false;
}

void CEditorState::Stop() {
	goHud.reset();
//	goHero.reset();
	goCamera.reset();

	Ogre::OverlayManager::getSingleton().destroy(oCursorLayer);
	GameObjects::COverlay::nukeOverlayElement(oCursor);

	ogreScene->clearScene();
	ogreScene->destroyAllCameras();
	ogreOverlayScene->clearScene();
	ogreOverlayScene->destroyAllCameras();
	ogreRoot->destroySceneManager(ogreScene);
	ogreRoot->destroySceneManager(ogreOverlayScene);
	ogreRenderWindow->removeAllViewports();
}

void CEditorState::Update() {
	if (bLeftPressed)
		vPivot.z -= CTimerTask::dT*100.0f;
	if (bRightPressed)
		vPivot.z += CTimerTask::dT*100.0f;
	if (bDownPressed)
		vPivot.y -= CTimerTask::dT*100.0f;
	if (bUpPressed)
		vPivot.y += CTimerTask::dT*100.0f;

	goCamera->SetPivot(vPivot);
	goCamera->Update(CTimerTask::dT);

//	goHero->Update(CTimerTask::dT);
}

void CEditorState::ClearLevelData() {
	DestroySceneNode(ogreLevelNode);
	ogreLevelNode = NULL;
	DestroySceneNode(oBBNode);
	oBBNode = NULL;

	for (OgreViewList::iterator it = staticViews.begin(); it != staticViews.end(); ++it) {
		(*it)->GetModel()->RemoveListener(*it);
	}
	for (OgreViewList::iterator it = dynamicViews.begin(); it != dynamicViews.end(); ++it) {
		(*it)->GetModel()->RemoveListener(*it);
	}
	for (OgreViewList::iterator it = backgroundViews.begin(); it != backgroundViews.end(); ++it) {
		(*it)->GetModel()->RemoveListener(*it);
	}

	staticLevelData.clear();
	staticViews.clear();
	backgroundLevelData.clear();
	backgroundViews.clear();
	dynamicLevelData.clear();
	dynamicViews.clear();

	for (ViewObjectViewPairMap::iterator it = backupObjects.begin(); it != backupObjects.end(); ++it) {
		it->second.first->RemoveListener(it->second.second);
	}
	backupObjects.clear();

	for (OgreObjectViewPairQueue::iterator it = deletedObjects.begin(); it != deletedObjects.end(); ++it) {
		it->first->RemoveListener(it->second);
	}
	deletedObjects.clear();

	for (OgreViewBoundsMap::iterator it = mBoundingBoxes.begin(); it != mBoundingBoxes.end(); ++it) {
		it->second->GetModel()->RemoveListener(it->second);
	}
	mBoundingBoxes.clear();

	// destroy data reader and reload templates
	GameObjects::CXMLReader xmlReader;

	if (!xmlReader.Read("media/leveldata/templates.xml", this, true))
		CLog::Get().Write("error loading templates", CLog::logRelease);
}

void CEditorState::ReadTemplate(std::string name, GameObjects::PLevelObject object, GameObjects::POgreView view) {
	// workaround: currently only ogreentityview is supported
	GameObjects::POgreEntityView entview = boost::dynamic_pointer_cast<GameObjects::COgreEntityView>(view);
	if (!entview) return;

	this->templates[name].first = object;
	this->templates[name].second = entview;
}

void CEditorState::ReadLevelObject(GameObjects::PLevelObject object, GameObjects::ObjectType layer) {
	this->GetContainer(layer).push_back(object);
}

void CEditorState::ReadOgreView(GameObjects::POgreView view, GameObjects::ObjectType layer) {
	// workaround: currently only ogreentityview is supported
	GameObjects::POgreEntityView entview = boost::dynamic_pointer_cast<GameObjects::COgreEntityView>(view);
	if (!entview) return;
	this->GetViewContainer(layer).push_back(entview);
}

void CEditorState::LoadFile() {
	ClearLevelData();

	GameObjects::CXMLReader xmlReader;

	if (!xmlReader.Read("media/leveldata/" + sCurrentFilename, this))
		CLog::Get().Write("error loading level data", CLog::logRelease);

	// backup objects
	for (OgreViewList::iterator it = staticViews.begin(); it != staticViews.end(); ++it) {
		GameObjects::PLevelObject modelCopy = (*it)->GetModel()->Copy();
		GameObjects::POgreEntityView viewCopy = boost::dynamic_pointer_cast<GameObjects::COgreEntityView>( (*it)->Copy(modelCopy) );
		backupObjects[*it].first = modelCopy;
		backupObjects[*it].second = viewCopy;
	}
	for (OgreViewList::iterator it = backgroundViews.begin(); it != backgroundViews.end(); ++it) {
		GameObjects::PLevelObject modelCopy = (*it)->GetModel()->Copy();
		GameObjects::POgreEntityView viewCopy = boost::dynamic_pointer_cast<GameObjects::COgreEntityView>( (*it)->Copy(modelCopy) );
		backupObjects[*it].first = modelCopy;
		backupObjects[*it].second = viewCopy;
	}
	for (OgreViewList::iterator it = dynamicViews.begin(); it != dynamicViews.end(); ++it) {
		GameObjects::PLevelObject modelCopy = (*it)->GetModel()->Copy();
		GameObjects::POgreEntityView viewCopy = boost::dynamic_pointer_cast<GameObjects::COgreEntityView>( (*it)->Copy(modelCopy) );
		backupObjects[*it].first = modelCopy;
		backupObjects[*it].second = viewCopy;
	}

	DrawLevel();
	RefreshActiveLayer();
	RefreshActiveAxis();
	RefreshActiveMode();
	RefreshAlign();
	SwitchTemplate();

	goHud->SetText("FilePanel/File", "File: " + sCurrentFilename);
}

void CEditorState::SaveFile() {
	GameObjects::CXMLWriter xmlWriter;

	for (OgreViewList::iterator it = staticViews.begin(); it != staticViews.end(); ++it) {
		xmlWriter.WriteObject(GameObjects::otStatic, (*it)->GetModel(), *it);
	}
	for (OgreViewList::iterator it = dynamicViews.begin(); it != dynamicViews.end(); ++it) {
		xmlWriter.WriteObject(GameObjects::otDynamic, (*it)->GetModel(), *it);
	}
	for (OgreViewList::iterator it = backgroundViews.begin(); it != backgroundViews.end(); ++it) {
		xmlWriter.WriteObject(GameObjects::otBackground, (*it)->GetModel(), *it);
	}

	xmlWriter.Save("media/leveldata/" + sCurrentFilename);
}

void CEditorState::DestroySceneNode(Ogre::SceneNode* node) {
	if (node) {
		nukeSceneNode(node);
		node->removeAndDestroyAllChildren();
		ogreScene->destroySceneNode(node);
	}
}

void CEditorState::UndoAll(bool undoTranslation) {/*
	if (objSelected == NULL) return;

	LevelObjectPtr backup = backupObjects[objSelected];
	if (backup == NULL) return;

	// in standard mode, replace object completely
	if (!bBoundingBoxes) {
		// copy backup
		LevelObjectPtr obj(new LevelObject(*backup));

		if (!undoTranslation)
			obj->SetPosition(objSelected->GetPosition());

		// update backup list
		backupObjects.erase(objSelected);
		backupObjects[obj] = backup;

		// delete object from scene
		DestroySceneNode(objSelected->GetOgreNode());

		// replace object in container
		LevelObjectList& container = GetContainer(ActiveLayer);
		LevelObjectListItor it = std::find(container.begin(), container.end(), objSelected);
		if (it != container.end())
			container.erase(it);
		container.push_back(obj);

		// draw new object
		obj->Draw(ogreScene, ogreLevelNode);

		Select(obj);
	} else {
		// replace bounding box

		// calculate scale factor
		Ogre::Vector3 scaleOld = backup->GetScale();
		Ogre::Vector3 scaleNew = objSelected->GetScale();

		Ogre::Vector3 vScale(0,0,0);
		vScale.x = scaleNew.x / scaleOld.x;
		vScale.y = scaleNew.y / scaleOld.y;
		vScale.z = scaleNew.z / scaleOld.z;

		// calculate relative translation
		Ogre::Vector3 translation;
		if (undoTranslation)
			translation = objSelected->GetPosition() - backup->GetPosition();
		else
			translation = objSelected->GetBoundingBox().getCenter() - backup->GetBoundingBox().getCenter();

		Ogre::AxisAlignedBox box = backup->GetBoundingBox();

		// scale backup bounding box
		Ogre::Vector3 center = box.getCenter();
		box.setExtents(box.getMinimum() - center, box.getMaximum() - center);
		box.scale(vScale);
		box.setExtents(box.getMinimum() + center, box.getMaximum() + center);

		// translate backup bounding box
		box.setExtents(box.getMinimum() + translation, box.getMaximum() + translation);

		objSelected->SetBoundingBox(box);

		// update display
		DestroySceneNode(mBoundingBoxes[objSelected].first);
		MakeBoundingBox(objSelected);

		// redraw selection
		Select(objSelected);
	}
*/}

void CEditorState::UndoRotation() {/*
	if (objSelected == NULL) return;
	LevelObjectPtr backup = backupObjects[objSelected];
	if (backup == NULL) return;

	if (!bBoundingBoxes) {
		objSelected->SetOrientation(backup->GetOrientation());
		objSelected->GetOgreNode()->setOrientation(backup->GetOrientation());
	}
*/}

void CEditorState::ResetRotation() {
	if (objSelected == NULL) return;

	if (!bBoundingBoxes) {
		objSelected->SetOrientation(Ogre::Quaternion::IDENTITY);
	}
}

void CEditorState::UndoTranslation() {/*
	if (objSelected == NULL) return;
	LevelObjectPtr backup = backupObjects[objSelected];
	if (backup == NULL) return;

	if (!bBoundingBoxes) {
		// fallback to backup's position
		objSelected->SetPosition(backup->GetPosition());

		// update display
		Ogre::SceneNode* objNode = objSelected->GetOgreNode();
		if (objNode) {
			objNode->setPosition(backup->GetPosition());
		}
	} else {

		// translate bounding box

		// get relative positions
		Ogre::Vector3 positionOld = backup->GetBoundingBox().getCenter() - backup->GetPosition();
		Ogre::Vector3 positionNew = objSelected->GetBoundingBox().getCenter() - objSelected->GetPosition();

		// calculate translation
		Ogre::Vector3 translation = positionNew - positionOld;

		// reverse translation
		Ogre::AxisAlignedBox box = objSelected->GetBoundingBox();
		box.setExtents(box.getMinimum() - translation, box.getMaximum() - translation);
		objSelected->SetBoundingBox(box);

		// update display
		Ogre::SceneNode* bboxNode = mBoundingBoxes[objSelected].first;
		if (bboxNode) {
			bboxNode->translate(-1.0f*translation, Ogre::Node::TS_LOCAL);
		}
	}
*/}

void CEditorState::SetToOgreBoundingBox() {
	if (objSelected != NULL) {
		// get bounding box from ogre and transform
		Ogre::AxisAlignedBox box = GetTransformedBoundingBox(objSelected->GetOgreEntity());
		Game::Rectangle rect(box.getMinimum().z, box.getMinimum().y, box.getMaximum().z, box.getMaximum().y);
		objSelected->GetModel()->SetBoundingBox(rect);
	}
}

void CEditorState::DrawLevel() {
	ogreLevelNode = ogreScene->getRootSceneNode()->createChildSceneNode(Ogre::Vector3::ZERO);

	for (OgreViewList::iterator it = staticViews.begin(); it != staticViews.end(); ++it) {
		(*it)->SetOgreScene(ogreScene, ogreLevelNode);
	}

	for (OgreViewList::iterator it = backgroundViews.begin(); it != backgroundViews.end(); ++it) {
		(*it)->SetOgreScene(ogreScene, ogreLevelNode);
	}

	for (OgreViewList::iterator it = dynamicViews.begin(); it != dynamicViews.end(); ++it) {
		(*it)->SetOgreScene(ogreScene, ogreLevelNode);
	}
}

void CEditorState::MakeBoundingBox(GameObjects::POgreEntityView obj) {
	if (obj != NULL) {
		mBoundingBoxes[obj] = GameObjects::COgreBoundsView::Create(obj->GetModel(), ogreScene, oBBNode);
		mBoundingBoxes[obj]->SetMaterial(WIREFRAME);
	}
}

CEditorState::OgreViewList& CEditorState::GetViewContainer(GameObjects::ObjectType layer) {
	switch (layer) {
	case GameObjects::otStatic:
		return staticViews;
		break;
	case GameObjects::otBackground:
		return backgroundViews;
		break;
	case GameObjects::otDynamic:
		return dynamicViews;
		break;
	}
}

CEditorState::LevelObjectList& CEditorState::GetContainer(GameObjects::ObjectType layer) {
	switch (layer) {
	case GameObjects::otStatic:
		return staticLevelData;
		break;
	case GameObjects::otBackground:
		return backgroundLevelData;
		break;
	case GameObjects::otDynamic:
		return dynamicLevelData;
		break;
	}
}

void CEditorState::ToggleBoundingBoxes() {
	bBoundingBoxes = !bBoundingBoxes;
	if (!bBoundingBoxes) {
		goHud->Show("Area2");
		goHud->Hide("BoundingBoxPanel");
		goHud->SetColor("Area1/BoundingBoxes", HUD_STANDARD);
		DestroySceneNode(oBBNode);
		oBBNode = NULL;

		for (OgreViewBoundsMap::iterator it = mBoundingBoxes.begin(); it != mBoundingBoxes.end(); ++it) {
			it->second->GetModel()->RemoveListener(it->second);
		}
		mBoundingBoxes.clear();
	} else {
		if (objSelected != NULL)
			objSelected->GetOgreEntity()->setListener(NULL);

		goHud->Hide("Area2");
		goHud->Show("BoundingBoxPanel");
		goHud->SetColor("Area1/BoundingBoxes", HUD_SELECT);
		oBBNode = ogreScene->getRootSceneNode()->createChildSceneNode();

		OgreViewList& container = GetViewContainer(ActiveLayer);

		for (OgreViewList::iterator it = container.begin(); it != container.end(); ++it) {
			MakeBoundingBox(*it);
		}
	}

	Select(objSelected);
}

void CEditorState::TogglePreview() {
	UnSelect();
	bPreview = !bPreview;
	if (bPreview) {
		goHud->Hide();
		if (this->bBoundingBoxes)
			ogreScene->getRootSceneNode()->removeChild(this->oBBNode);
		if (this->bShowGrid)
			ogreScene->getRootSceneNode()->detachObject(this->ogreGrid);

		for (OgreViewList::iterator it = staticViews.begin(); it != staticViews.end(); ++it) {
			(*it)->GetOgreEntity()->setListener(NULL);
		}

		for (OgreViewList::iterator it = backgroundViews.begin(); it != backgroundViews.end(); ++it) {
			(*it)->GetOgreEntity()->setListener(NULL);
		}

		for (OgreViewList::iterator it = dynamicViews.begin(); it != dynamicViews.end(); ++it) {
			(*it)->GetOgreEntity()->setListener(NULL);
		}
		ogreScene->setSkyBox(true, "Textures/SkyBox", 5000);
	} else {
		ogreScene->setSkyBox(false, "", 5000);
		goHud->Show();
		if (this->bBoundingBoxes)
			ogreScene->getRootSceneNode()->addChild(this->oBBNode);
		if (this->bShowGrid)
			ogreScene->getRootSceneNode()->attachObject(this->ogreGrid);
		RefreshActiveLayer();
	}
}

void CEditorState::CheckMinMax(GameObjects::POgreEntityView obj, float& minX, float& minY, float& maxX, float& maxY) {
	const Ogre::AxisAlignedBox& bbox = GetTransformedBoundingBox(obj->GetOgreEntity());
	if (bbox.getMinimum().z < minX)
		minX = bbox.getMinimum().z;
	if (bbox.getMinimum().y < minY)
		minY = bbox.getMinimum().y;
	if (bbox.getMaximum().z > maxX)
		maxX = bbox.getMaximum().z;
	if (bbox.getMaximum().y > maxY)
		maxY = bbox.getMaximum().y;
}

Ogre::Rectangle CEditorState::GetGridBounds() {
	// get min and max coordinates
	float minX = 0;
	float minY = 0;
	float maxX = 0;
	float maxY = 0;

	for (OgreViewList::iterator it = staticViews.begin(); it != staticViews.end(); ++it) {
		CheckMinMax(*it, minX, minY, maxX, maxY);
	}

	for (OgreViewList::iterator it = backgroundViews.begin(); it != backgroundViews.end(); ++it) {
		CheckMinMax(*it, minX, minY, maxX, maxY);
	}

	for (OgreViewList::iterator it = dynamicViews.begin(); it != dynamicViews.end(); ++it) {
		CheckMinMax(*it, minX, minY, maxX, maxY);
	}

	minX = round(minX/10.0f)*10.0f; minY = round(minY/10.0f)*10.0f;
	maxX = round(maxX/10.0f)*10.0f; maxY = round(maxY/10.0f)*10.0f;

	Ogre::Rectangle rect;
	rect.left = minX; rect.right = maxX;
	rect.bottom = minY; rect.top = maxY;
	return rect;
}

Ogre::ManualObject* CEditorState::MakeGrid(Ogre::Rectangle extends) {
	Ogre::ManualObject* grid =  ogreScene->createManualObject("grid");
	grid->begin("Editor/Plane", Ogre::RenderOperation::OT_LINE_LIST);
	for (int y = (int)extends.bottom; y <= extends.top; y += 10) {
		grid->position(0, y, extends.left);
		grid->position(0, y, extends.right);
	}
	for (int z = (int)extends.left; z <= extends.right; z += 10) {
		grid->position(0, extends.bottom, z);
		grid->position(0, extends.top, z);
	}
	grid->end();

	return grid;
}

void CEditorState::ToggleGrid() {
	bShowGrid = !bShowGrid;
	if (bShowGrid) {
		goHud->SetColor("Area1/Grid", HUD_SELECT);
		if (ogreGrid)
			ogreScene->destroyManualObject(ogreGrid);

		Ogre::Rectangle gridRect = GetGridBounds();
		gridRect.left -= 250;
		gridRect.bottom -= 250;
		gridRect.top += 250;
		gridRect.right += 250;

		ogreGrid = MakeGrid(gridRect);
		ogreScene->getRootSceneNode()->attachObject(ogreGrid);
	} else {
		goHud->SetColor("Area1/Grid", HUD_STANDARD);
		if (ogreGrid)
			ogreScene->destroyManualObject(ogreGrid);
		ogreGrid = NULL;
	}
}

void CEditorState::RefreshActiveMode() {
	goHud->SetColor("Area1/ModeMove", (ActiveMode == emMove) ? HUD_SELECT : HUD_STANDARD);
	goHud->SetColor("Area1/ModeScale", (ActiveMode == emScale) ? HUD_SELECT : HUD_STANDARD);
	goHud->SetColor("Area1/ModeRotate", (ActiveMode == emRotate) ? HUD_SELECT : HUD_STANDARD);
	goHud->SetColor("Area1/ModeSelect", (ActiveMode == emSelect) ? HUD_SELECT : HUD_STANDARD);
}

void CEditorState::RefreshActiveAxis() {
	goHud->SetColor("Area1/AxisX", bAxisX ? HUD_SELECT : HUD_STANDARD);
	goHud->SetColor("Area1/AxisY", bAxisY ? HUD_SELECT : HUD_STANDARD);
	goHud->SetColor("Area1/AxisZ", bAxisZ ? HUD_SELECT : HUD_STANDARD);
}

GameObjects::ObjectType CEditorState::FindLayer(GameObjects::POgreEntityView obj) {
	if ( std::find(staticViews.begin(), staticViews.end(), obj) != staticViews.end() )
		return GameObjects::otStatic;
	if ( std::find(dynamicViews.begin(), dynamicViews.end(), obj) != dynamicViews.end() )
		return GameObjects::otDynamic;
	return GameObjects::otBackground;
}

void CEditorState::RefreshActiveLayer() {
	goHud->SetColor("Area1/LayerStatic", (ActiveLayer == GameObjects::otStatic) ? HUD_SELECT : HUD_STANDARD);
	goHud->SetColor("Area1/LayerBackground", (ActiveLayer == GameObjects::otBackground) ? HUD_SELECT : HUD_STANDARD);
	goHud->SetColor("Area1/LayerDynamic", (ActiveLayer == GameObjects::otDynamic) ? HUD_SELECT : HUD_STANDARD);

	if (!bKeepSelectedOnLayerChange || bBoundingBoxes) {
		UnSelect();
	} else if (objSelected != NULL) {
		GameObjects::ObjectType layer = FindLayer(objSelected);
		if (layer != ActiveLayer) {
			OgreViewList& container = GetViewContainer(layer);
			OgreViewList::iterator it = std::find(container.begin(), container.end(), objSelected);
			if (it != container.end()) {
				container.erase(it);
				GetViewContainer(ActiveLayer).push_back(objSelected);
			}
		}
	}

	for (OgreViewList::iterator it = staticViews.begin(); it != staticViews.end(); ++it) {
		(*it)->GetOgreEntity()->setListener((ActiveLayer == GameObjects::otStatic) ? NULL : &oDarkListener);
	}

	for (OgreViewList::iterator it = backgroundViews.begin(); it != backgroundViews.end(); ++it) {
		(*it)->GetOgreEntity()->setListener((ActiveLayer == GameObjects::otBackground) ? NULL : &oDarkListener);
	}

	for (OgreViewList::iterator it = dynamicViews.begin(); it != dynamicViews.end(); ++it) {
		(*it)->GetOgreEntity()->setListener((ActiveLayer == GameObjects::otDynamic) ? NULL : &oDarkListener);
	}

	if (!bBoundingBoxes) {
		Select(objSelected);
	}
}

/** returns vector with smalles angle to direction, ignoring signs of v and w */
Ogre::Vector3 FindSmallestAngle(Ogre::Vector3 direction, const Ogre::Vector3& v, const Ogre::Vector3& w) {
	// calculate angles
	float angleDV = fabs(direction.angleBetween(v).valueDegrees());
	float angleDW = fabs(direction.angleBetween(w).valueDegrees());
	float angleDNV = fabs(direction.angleBetween(-1.0f*v).valueDegrees());
	float angleDNW = fabs(direction.angleBetween(-1.0f*w).valueDegrees());

	// get minimum
	float angleMin = std::min<float>(std::min<float>(angleDV, angleDW), std::min<float>(angleDNV, angleDNW));

	// return corresponding vector
	if (angleMin == angleDV) return v;
	if (angleMin == angleDW) return w;
	if (angleMin == angleDNV) return -1.0f*v;
	if (angleMin == angleDNW) return -1.0f*w;
}

void CEditorState::Select(GameObjects::POgreEntityView obj, bool green) {
	UnSelect();
	if (obj != NULL) {
		objSelected = obj;
		if (bBoundingBoxes) {
			GameObjects::POgreBoundsView view = mBoundingBoxes[objSelected];
			if (view) view->SetMaterial(green ? WIREFRAME_ACTIVE : WIREFRAME_SELECTED);
		} else {
			objSelected->GetOgreEntity()->setListener(green ? &oGreenListener : &oRedListener);
		}
	}
}

void CEditorState::UnSelect() {
	if (objSelected != NULL) {

		GameObjects::POgreBoundsView view = mBoundingBoxes[objSelected];
		if (view)
			view->SetMaterial(WIREFRAME);

		objSelected->GetOgreEntity()->setListener(NULL);

		objSelected.reset();
	}
}

void CEditorState::SwitchTemplate() {
	// find position of current template and iterate one step further
	StringObjectPairMap::iterator it = this->templates.find(sCurrentTemplate);
	++it;
	if (it == templates.end())
		sCurrentTemplate = templates.begin()->first;
	else
		sCurrentTemplate = it->first;
	goHud->SetText("InsertPanel/CurrentTemplate", "Template: " + sCurrentTemplate);
}

std::string CEditorState::AlignToStr(CEditorState::Align align) {
	switch (align) {
	case alFront:
		return "front";
	case alBack:
		return "back";
	case alLeft:
		return "left";
	case alRight:
		return "right";
	case alTop:
		return "top";
	case alBottom:
		return "bottom";
	default:
		return "center";
	}
}

void CEditorState::ToggleAlignX(CEditorState::Align& align) {
	if (align == alFront) align = alCenter;
	else if (align == alCenter) align = alBack;
	else align = alFront;

	RefreshAlign();
}

void CEditorState::ToggleAlignY(CEditorState::Align& align) {
	if (align == alTop) align = alCenter;
	else if (align == alCenter) align = alBottom;
	else align = alTop;

	RefreshAlign();
}

void CEditorState::ToggleAlignZ(CEditorState::Align& align) {
	if (align == alLeft) align = alCenter;
	else if (align == alCenter) align = alRight;
	else align = alLeft;

	RefreshAlign();
}

void CEditorState::RefreshAlign() {
	goHud->SetText("AlignPanel/AlignX","^[X] Align X: " + AlignToStr(AlignX) + " | " + AlignToStr(TargetAlignX));
	goHud->SetText("AlignPanel/AlignY","^[Y] Align Y: " + AlignToStr(AlignY) + " | " + AlignToStr(TargetAlignY));
	goHud->SetText("AlignPanel/AlignZ","^[Z] Align Z: " + AlignToStr(AlignZ) + " | " + AlignToStr(TargetAlignZ));
}

Ogre::Vector3 CEditorState::AlignTransform(Ogre::Vector3 translation, bool target) {
	switch (target ? TargetAlignX : AlignX) {
	case alBack:
		if (target) translation.x = -translation.x;
		break;
	case alFront:
		if (!target) translation.x = -translation.x;
		break;
	default:
		translation.x = 0.0f;
	}

	switch (target ? TargetAlignY : AlignY) {
	case alTop:
		if (target) translation.y = -translation.y;
		break;
	case alBottom:
		if (!target) translation.y = -translation.y;
		break;
	default:
		translation.y = 0.0f;
	}

	switch (target ? TargetAlignZ : AlignZ) {
	case alLeft:
		if (!target) translation.z = -translation.z;
		break;
	case alRight:
		if (target) translation.z = -translation.z;
		break;
	default:
		translation.z = 0.0f;
	}

	return translation;
}

/** get entity bounding box and transform to world coordinates */
Ogre::AxisAlignedBox CEditorState::GetTransformedBoundingBox(Ogre::Entity* entity) {
	Ogre::AxisAlignedBox box = entity->getBoundingBox();
	box.transform(entity->getParentNode()->_getFullTransform());
	return box;
}

void CEditorState::InsertObject(bool clone) {
	GameObjects::PLevelObject templateModel;
	GameObjects::POgreEntityView templateView;
	if (clone) {
		// use selected object
		if (objSelected == NULL) return;
		templateView = objSelected;
		templateModel = objSelected->GetModel();
	} else {
		// use template
		templateModel = templates[sCurrentTemplate].first;
		templateView = templates[sCurrentTemplate].second;
	}

	if (templateModel == NULL || templateView == NULL)
		return;

	// copy template
	GameObjects::PLevelObject objModel = templateModel->Copy();
	GameObjects::POgreEntityView objView = boost::dynamic_pointer_cast<GameObjects::COgreEntityView>( templateView->Copy(objModel) );

	objView->SetOgreScene(ogreScene, ogreLevelNode);

	// calculate insert position
	Ogre::Vector3 insertPosition;

	if (objSelected == NULL) {
		// insert at cursor; calculate intersection point at YZ plane
		Ogre::Ray mouseRay = ogreCamera->getCameraToViewportRay(fMouseX, fMouseY);
		Ogre::Plane plane(Ogre::Vector3::NEGATIVE_UNIT_X, Ogre::Vector3::ZERO);
		std::pair<bool, Ogre::Real> intersection = mouseRay.intersects(plane);
		Ogre::Vector3 intersectPoint = mouseRay.getPoint(intersection.second);

		// calculate translation
		Ogre::Vector3 translation;
		if (bBoundingBoxes || bAlwaysAlignToBoundingBox) {
			Game::Rectangle bbox = objModel->GetBoundingBox();
			Ogre::Vector2 center = 0.5f*(bbox.GetMaximum() + bbox.GetMinimum());
			translation.x = 0.0f;
			translation.y = center.y;
			translation.z = center.x;
		} else {
			translation = GetTransformedBoundingBox(objView->GetOgreEntity()).getHalfSize();
		}

		translation = AlignTransform(translation, true);
		insertPosition = intersectPoint + translation;
	} else {
		// insert next to selected object
		Ogre::Vector3 translation;
		if (bBoundingBoxes || bAlwaysAlignToBoundingBox) {
			Game::Rectangle bbox = objModel->GetBoundingBox();
			Ogre::Vector2 centerObj = 0.5f*(bbox.GetMaximum() + bbox.GetMinimum());
			Ogre::Vector3 centerObjTrans(0.0f, centerObj.y, centerObj.x);
			bbox = objSelected->GetModel()->GetBoundingBox();
			Ogre::Vector2 centerSelected = 0.5f*(bbox.GetMaximum() + bbox.GetMinimum());
			Ogre::Vector3 centerSelectedTrans(0.0f, centerSelected.y, centerSelected.x);

			translation = AlignTransform(centerSelectedTrans, false) +
						  AlignTransform(centerObjTrans, true);
			insertPosition = centerObjTrans + translation;
		} else {
			translation = AlignTransform(GetTransformedBoundingBox(objSelected->GetOgreEntity()).getHalfSize(), false) +
					      AlignTransform(GetTransformedBoundingBox(objView->GetOgreEntity()).getHalfSize(), true);
			insertPosition = GetTransformedBoundingBox(objSelected->GetOgreEntity()).getCenter() + translation;
		}
	}

	objModel->SetPosition(Ogre::Vector2(insertPosition.z, insertPosition.y));
	objView->SetPositionOffset(Ogre::Vector3(insertPosition.x, 0.0f, 0.0f));

	// make backup copy
	GameObjects::PLevelObject modelCopy = objModel->Copy();
	GameObjects::POgreEntityView viewCopy = boost::dynamic_pointer_cast<GameObjects::COgreEntityView>( objView->Copy(modelCopy) );
	backupObjects[objView].first = modelCopy;
	backupObjects[objView].second = viewCopy;

	GetViewContainer(ActiveLayer).push_back(objView);
	GetContainer(ActiveLayer).push_back(objModel);

	if (bBoundingBoxes) {
		MakeBoundingBox(objView);
	}

	if (objSelected != NULL) {
		Select(objView);
	}
}

void CEditorState::UndoDelete() {
	if (deletedObjects.empty()) return;

	// get newest deleted object and redraw
	GameObjects::POgreEntityView obj = deletedObjects.back().second;
	GetViewContainer(ActiveLayer).push_back(obj);
	GetContainer(ActiveLayer).push_back(obj->GetModel());
	deletedObjects.pop_back();

	obj->SetOgreScene(ogreScene, ogreLevelNode);
	if (bBoundingBoxes) {
		MakeBoundingBox(obj);
	}
	Select(obj);
}

void CEditorState::ShowDialog(CEditorState::EditDialog dlg) {
	if (dlg == edNone) {
		goHud->Hide("Input");
	} else {
		goHud->Show("Input");
		switch (dlg) {
		case edSave:
			goHud->SetText("Input/InputCaption", "Save as:");
			goHud->SetText("Input/InputText", this->sCurrentFilename);
			sInput = sCurrentFilename.substr(0, sInput.length()-4);
			break;
		case edNew:
			goHud->SetText("Input/InputCaption", "Create new file:");
			goHud->SetText("Input/InputText", "");
			sInput = "";
			break;
		case edOpen:
			goHud->SetText("Input/InputCaption", "Open file:");
			goHud->SetText("Input/InputText", "");
			sInput = "";
			break;
		}
	}

	ActiveDialog = dlg;
}

void CEditorState::DialogProcessKey(const OIS::KeyEvent &e, bool pressed) {
	if (!pressed) {
		if (e.key == OIS::KC_ESCAPE)
			ShowDialog(edNone);
	} else {
		std::string validChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_.";

		if (validChars.find((char)e.text) != std::string::npos) {
			sInput += (char)e.text;
			goHud->SetText("Input/InputText", sInput);
		}

		if (e.key == OIS::KC_BACK) {
			if (sInput.length() > 0) {
				sInput.erase(sInput.length()-1, 1);
				goHud->SetText("Input/InputText", sInput);
			}
		}

		if (e.key == OIS::KC_RETURN && !sInput.empty()) {
			switch (ActiveDialog) {
			case edSave:
				if (sInput.substr(sInput.length()-4,4) != ".xml")
					sInput += ".xml";
				sCurrentFilename = sInput;
				SaveFile();
				break;
			case edNew:
				if (sInput.substr(sInput.length()-4,4) != ".xml")
					sInput += ".xml";
				sCurrentFilename = sInput;
				ClearLevelData();
				DrawLevel();
				RefreshActiveLayer();
				RefreshActiveAxis();
				RefreshActiveMode();
				RefreshAlign();
				SwitchTemplate();
				break;
			case edOpen:
				if (sInput.substr(sInput.length()-4,4) != ".xml")
					sInput += ".xml";
				sCurrentFilename = sInput;
				LoadFile();
				break;
			}
			ShowDialog(edNone);
			goHud->SetText("FilePanel/File", "File: " + sCurrentFilename);
		}
	}
}

void CEditorState::DeleteObject() {
	if (objSelected == NULL) return;

	// remove object view; (safe to do because we still have a reference from objSelected
	OgreViewList& container = GetViewContainer(ActiveLayer);
	OgreViewList::iterator it2 = std::find(container.begin(), container.end(), objSelected);

	if (it2 != container.end())
		container.erase(it2);

	// limit size of deleted objects queue
	while (deletedObjects.size() > 10) {
		GameObjects::POgreEntityView front = deletedObjects.front().second;
		backupObjects[front].first->RemoveListener(backupObjects[front].second);
		backupObjects[front].first.reset();
		backupObjects[front].second.reset();
		front.reset();

		deletedObjects.front().first->RemoveListener(deletedObjects.front().second);
		deletedObjects.pop_front();
	}

	deletedObjects.push_back(ObjectViewPair(objSelected->GetModel(),objSelected));

	// remove ogre objects
	DestroySceneNode(objSelected->GetOgreNode());
	objSelected->SetOgreScene(NULL, NULL);

	if (bBoundingBoxes) {
		objSelected->GetModel()->RemoveListener(mBoundingBoxes[objSelected]);
		DestroySceneNode(mBoundingBoxes[objSelected]->GetOgreNode());
		mBoundingBoxes.erase(objSelected);
	}

	// find container and remove object model
	LevelObjectList& objContainer = GetContainer(ActiveLayer);
	LevelObjectList::iterator it = std::find(objContainer.begin(), objContainer.end(), objSelected->GetModel());

	if (it != objContainer.end())
		objContainer.erase(it);

	objSelected.reset();
}

void CEditorState::ToggleAxisX() {
	if (ActiveMode == emRotate) {
		if (!bAxisX) {
			bAxisX = true;
			bAxisY = bAxisZ = false;
		}
	} else {
		bAxisX = !bAxisX;
	}
	this->RefreshActiveAxis();
}

void CEditorState::ToggleAxisY() {
	if (ActiveMode == emRotate) {
		if (!bAxisY) {
			bAxisY = true;
			bAxisX = bAxisZ = false;
		}
	} else {
		bAxisY = !bAxisY;
	}
	this->RefreshActiveAxis();
}

void CEditorState::ToggleAxisZ() {
	if (ActiveMode == emRotate) {
		if (!bAxisZ) {
			bAxisZ = true;
			bAxisX = bAxisY = false;
		}
	} else {
		bAxisZ = !bAxisZ;
	}
	this->RefreshActiveAxis();
}

/*----------------------------
 * Input - Keyboard
 -----------------------------*/

void CEditorState::keyPressed( const OIS::KeyEvent &e ) {
	// get modifiers
	bool modCTRL = false;
	bool modALT = false;
	bool modSHIFT = false;
	bool modWIN = false;
	const OIS::Keyboard* const_kbrd = dynamic_cast<const OIS::Keyboard*>(e.device);
	if (const_kbrd) {
		OIS::Keyboard* kbrd = const_cast<OIS::Keyboard*>(const_kbrd);
		modSHIFT = kbrd->isModifierDown(OIS::Keyboard::Shift) || kbrd->isKeyDown(OIS::KC_LSHIFT) || kbrd->isKeyDown(OIS::KC_RSHIFT);
		modALT = kbrd->isModifierDown(OIS::Keyboard::Alt) || kbrd->isKeyDown(OIS::KC_LMENU) || kbrd->isKeyDown(OIS::KC_RMENU);
		modCTRL = kbrd->isModifierDown(OIS::Keyboard::Ctrl) || kbrd->isKeyDown(OIS::KC_LCONTROL) || kbrd->isKeyDown(OIS::KC_RCONTROL);
		modWIN = kbrd->isKeyDown(OIS::KC_LWIN) || kbrd->isKeyDown(OIS::KC_RWIN);
	}

	if (ActiveDialog != edNone) {
		DialogProcessKey(e, true);
		return;
	}

	if (e.key == OIS::KC_F) {
		bSpinCamera = true;
		goHud->SetColor("Area1/RotateCamera", HUD_ACTIVE);
	}

	if (e.key == OIS::KC_LEFT || (e.key == OIS::KC_A && !modWIN && !modCTRL)) {
		bLeftPressed = true;
		goHud->SetColor("Area1/MoveCamera", HUD_ACTIVE);
	}
	if (e.key == OIS::KC_RIGHT || e.key == OIS::KC_D) {
		bRightPressed = true;
		goHud->SetColor("Area1/MoveCamera", HUD_ACTIVE);
	}
	if (e.key == OIS::KC_UP || e.key == OIS::KC_W) {
		bUpPressed = true;
		goHud->SetColor("Area1/MoveCamera", HUD_ACTIVE);
	}
	if (e.key == OIS::KC_DOWN || (e.key == OIS::KC_S && !modWIN && !modCTRL)) {
		bDownPressed = true;
		goHud->SetColor("Area1/MoveCamera", HUD_ACTIVE);
	}
}

void CEditorState::keyReleased( const OIS::KeyEvent &e ) {
	// get modifiers
	bool modCTRL = false;
	bool modALT = false;
	bool modSHIFT = false;
	bool modWIN = false;
	const OIS::Keyboard* const_kbrd = dynamic_cast<const OIS::Keyboard*>(e.device);
	if (const_kbrd) {
		OIS::Keyboard* kbrd = const_cast<OIS::Keyboard*>(const_kbrd);
		modSHIFT = kbrd->isModifierDown(OIS::Keyboard::Shift) || kbrd->isKeyDown(OIS::KC_LSHIFT) || kbrd->isKeyDown(OIS::KC_RSHIFT);
		modALT = kbrd->isModifierDown(OIS::Keyboard::Alt) || kbrd->isKeyDown(OIS::KC_LMENU) || kbrd->isKeyDown(OIS::KC_RMENU);
		modCTRL = kbrd->isModifierDown(OIS::Keyboard::Ctrl) || kbrd->isKeyDown(OIS::KC_LCONTROL) || kbrd->isKeyDown(OIS::KC_RCONTROL);
		modWIN = kbrd->isKeyDown(OIS::KC_LWIN) || kbrd->isKeyDown(OIS::KC_RWIN);
	}

	if (ActiveDialog != edNone) {
		DialogProcessKey(e, false);
		return;
	}

	if (e.key == OIS::KC_ESCAPE) {
		//CTaskManager::GetSingleton().KillAll();
		CStateManager::GetSingleton().ChangeState("MainMenu");
	}
	if (e.key == OIS::KC_F) {
		bSpinCamera = false;
		goHud->SetColor("Area1/RotateCamera", HUD_STANDARD);
	}
	if (e.key == OIS::KC_LEFT || (e.key == OIS::KC_A && !modWIN && !modCTRL)) {
		bLeftPressed = false;
		goHud->SetColor("Area1/MoveCamera", HUD_STANDARD);
	}
	if (e.key == OIS::KC_RIGHT || e.key == OIS::KC_D) {
		bRightPressed = false;
		goHud->SetColor("Area1/MoveCamera", HUD_STANDARD);
	}
	if (e.key == OIS::KC_UP || e.key == OIS::KC_W) {
		bUpPressed = false;
		goHud->SetColor("Area1/MoveCamera", HUD_STANDARD);
	}
	if (e.key == OIS::KC_DOWN || (e.key == OIS::KC_S && !modWIN && !modCTRL)) {
		bDownPressed = false;
		goHud->SetColor("Area1/MoveCamera", HUD_STANDARD);
	}

	if (e.key == OIS::KC_1) {
		ActiveMode = emMove;
		bMouseDown = false;
		RefreshActiveMode();
	}
	if (e.key == OIS::KC_2) {
		ActiveMode = emScale;
		bMouseDown = false;
		RefreshActiveMode();
	}
	if (e.key == OIS::KC_3) {
		ActiveMode = emRotate;
		if (bAxisX) {
			bAxisY = bAxisZ = false;
		} else if (bAxisY) {
			bAxisX = bAxisZ = false;
		} else {
			bAxisZ = true;
			bAxisY = bAxisX = false;
		}
		bMouseDown = false;
		RefreshActiveAxis();
		RefreshActiveMode();
	}
	if (e.key == OIS::KC_4) {
		ActiveMode = emSelect;
		bMouseDown = false;
		RefreshActiveMode();
	}


	if (e.key == OIS::KC_5) {
		if (ActiveLayer != GameObjects::otStatic && bBoundingBoxes) {
			ActiveLayer = GameObjects::otStatic;
			ToggleBoundingBoxes(); ToggleBoundingBoxes();
		}
		ActiveLayer = GameObjects::otStatic;
		RefreshActiveLayer();
	}
	if (e.key == OIS::KC_6) {
		if (ActiveLayer != GameObjects::otBackground && bBoundingBoxes) {
			ActiveLayer = GameObjects::otBackground;
			ToggleBoundingBoxes(); ToggleBoundingBoxes();
		}
		ActiveLayer = GameObjects::otBackground;
		RefreshActiveLayer();
	}
	if (e.key == OIS::KC_7) {
		if (ActiveLayer != GameObjects::otDynamic && bBoundingBoxes) {
			ActiveLayer = GameObjects::otDynamic;
			ToggleBoundingBoxes(); ToggleBoundingBoxes();
		}
		ActiveLayer = GameObjects::otDynamic;
		RefreshActiveLayer();
	}
	if (e.key == OIS::KC_8) {
		ToggleBoundingBoxes();
	}

	if (e.key == OIS::KC_X) {
		if (modCTRL || modWIN) {
			ToggleAlignX(AlignX);
		} else if (modALT || modSHIFT) {
			ToggleAlignX(TargetAlignX);
		} else {
			ToggleAxisX();
		}
	}
	// note: swapped Z and Y for german keyboards
	if (e.key == OIS::KC_Z) {
		if (modCTRL || modWIN) {
			ToggleAlignY(AlignY);
		} else if (modALT || modSHIFT) {
			ToggleAlignY(TargetAlignY);
		} else {
			ToggleAxisY();
		}
	}
	if (e.key == OIS::KC_Y) {
		if (modCTRL || modWIN) {
			ToggleAlignZ(AlignZ);
		} else if (modALT || modSHIFT) {
			ToggleAlignZ(TargetAlignZ);
		} else {
			ToggleAxisZ();
		}
	}



	if (e.key == OIS::KC_G)
		ToggleGrid();

	if (e.key == OIS::KC_Q) {
		if (bWndCreated)
			this->DestroyWndViewport();
		else
			this->CreateWndViewport();
	}

	if (e.key == OIS::KC_O) {
		if (bBoundingBoxes)
			SetToOgreBoundingBox();
	}

	if (e.key == OIS::KC_P)
		TogglePreview();

	if (e.key == OIS::KC_U) {
		UndoAll(!modCTRL && !modWIN);
	}

	if (e.key == OIS::KC_T)
		if (modCTRL || modWIN)
			UndoRotation();
		else
			UndoTranslation();

	if (e.key == OIS::KC_A && (modWIN || modCTRL)) {
		bAlwaysAlignToBoundingBox = !bAlwaysAlignToBoundingBox;
		goHud->SetColor("AlignPanel/AlwaysAlign", bAlwaysAlignToBoundingBox ? HUD_SELECT : HUD_STANDARD);
	}

	if (e.key == OIS::KC_K) {
		bKeepSelectedOnLayerChange = !bKeepSelectedOnLayerChange;
		goHud->SetColor("Area2/Keep", bKeepSelectedOnLayerChange ? HUD_SELECT : HUD_STANDARD);
	}
	if (e.key == OIS::KC_E)
		SwitchTemplate();
	if (e.key == OIS::KC_I)
		InsertObject(false);
	if (e.key == OIS::KC_C)
		InsertObject(true);
	if (e.key == OIS::KC_DELETE || e.key == OIS::KC_BACK) {
		if (modCTRL || modWIN)
			UndoDelete();
		else
			DeleteObject();
	}

	if (e.key == OIS::KC_R)
		if (modWIN || modCTRL)
			LoadFile();
		else
			ResetRotation();



	if (e.key == OIS::KC_S && (modWIN || modCTRL) )
		ShowDialog(edSave);

	if (e.key == OIS::KC_O && (modWIN || modCTRL) )
		ShowDialog(edOpen);

	if (e.key == OIS::KC_N && (modWIN || modCTRL) )
		ShowDialog(edNew);
}

/*----------------------------
 * Input - Mouse
 -----------------------------*/

void CEditorState::mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id ) {
	if (bPreview) return;

	bMouseDown = true;

	fMouseX = e.state.X.abs/float(e.state.width);
	fMouseY = e.state.Y.abs/float(e.state.height);

	// create ray through cursor
	Ogre::Ray mouseRay = ogreCamera->getCameraToViewportRay(fMouseX, fMouseY);

	UnSelect();

	LevelObjectList& container = GetContainer(ActiveLayer);
	OgreViewList& viewContainer = GetViewContainer(ActiveLayer);

	float minDistance = 0; // current minimal distance
	std::pair<bool,float> intersection; // ogre intersection results
	Ogre::AxisAlignedBox bounds; // AABB of current object
	float distance; // current distance
	Ogre::Vector3 intersectionP; // current intersection point

	// find nearest intersection
	for (OgreViewList::iterator it = viewContainer.begin(); it != viewContainer.end(); ++it) {
		if (bBoundingBoxes) {
			// use actual bounding box
			Game::Rectangle rect = (*it)->GetModel()->GetBoundingBox();
			bounds = Ogre::AxisAlignedBox(Ogre::Vector3(-0.5f, rect.Bottom(), rect.Left()), Ogre::Vector3(0.5f, rect.Top(), rect.Right()));
		} else {
			// use ogre bounding box
			bounds = GetTransformedBoundingBox((*it)->GetOgreEntity());
		}

		// calculate intersection
		intersection = mouseRay.intersects(bounds);
		if (intersection.first) {
			// calculate distance to camera
			intersectionP = mouseRay.getPoint(intersection.second);
			distance = intersectionP.squaredDistance(goCamera->GetPosition());
			if (objSelected == NULL || minDistance > distance) {
				minDistance = distance;
				objSelected = *it;
				intersectionPoint = intersectionP;
			}
		}
	}

	if (objSelected != NULL) {

		// construct planes to intersect with
		if (ActiveMode == emMove) {
			// base point for plane
			Ogre::Vector3 refPoint = intersectionPoint;

			// if all axes are chosen, create plane orthogonal to camera
			if (bAxisX && bAxisY && bAxisZ)
				intersectionPlane = Ogre::Plane(mouseRay.getDirection(), refPoint);

			if (!bAxisX && bAxisY && bAxisZ)
				intersectionPlane = Ogre::Plane(Ogre::Vector3::NEGATIVE_UNIT_X, refPoint);
			if (bAxisX && !bAxisY && bAxisZ)
				intersectionPlane = Ogre::Plane(Ogre::Vector3::NEGATIVE_UNIT_Y, refPoint);
			if (bAxisX && bAxisY && !bAxisZ)
				intersectionPlane = Ogre::Plane(Ogre::Vector3::NEGATIVE_UNIT_Z, refPoint);

			// if only one axis is selected, choose plane which is "most orthogonal" towards camera
			Ogre::Vector3 rayDir = mouseRay.getDirection().normalisedCopy();

			if (bAxisX && !bAxisY && !bAxisZ) {
				Ogre::Vector3 normal = FindSmallestAngle(rayDir, Ogre::Vector3::UNIT_Z, Ogre::Vector3::UNIT_Y);
				intersectionPlane = Ogre::Plane(normal, refPoint);
			}

			if (!bAxisX && bAxisY && !bAxisZ) {
				Ogre::Vector3 normal = FindSmallestAngle(rayDir, Ogre::Vector3::UNIT_Z, Ogre::Vector3::UNIT_X);
				intersectionPlane = Ogre::Plane(normal, refPoint);
			}

			if (!bAxisX && !bAxisY && bAxisZ) {
				Ogre::Vector3 normal = FindSmallestAngle(rayDir, Ogre::Vector3::UNIT_X, Ogre::Vector3::UNIT_Y);
				intersectionPlane = Ogre::Plane(normal, refPoint);
			}
		} else if (ActiveMode == emScale) {
			// construct plane containing center of object and intersection point, which is as orthogonal
			// to the camera as possible

			Ogre::Vector3 refPoint;
			if (bBoundingBoxes) {
				Ogre::Vector2 center = objSelected->GetModel()->GetBoundingBox().GetMaximum() + objSelected->GetModel()->GetBoundingBox().GetMinimum();
				center = 0.5f * center;
				refPoint.x = 0.0f;
				refPoint.y = center.y;
				refPoint.z = center.x;
			} else {
				refPoint = objSelected->GetPositionOffset();
				Ogre::Vector2 pos = objSelected->GetModel()->GetPosition();
				refPoint.y += pos.y;
				refPoint.z += pos.x;
			}

			// find normal vector by projecting camera vector onto the ray through intersection point and center of object
			Ogre::Vector3 rayNormal = Ogre::Vector3(intersectionPoint - refPoint).normalisedCopy();
			Ogre::Plane orthoPl(rayNormal, Ogre::Vector3::ZERO);

			Ogre::Vector3 normal = orthoPl.projectVector(mouseRay.getDirection().normalisedCopy());

			intersectionPlane = Ogre::Plane(normal.normalisedCopy(), refPoint);
		} else if (ActiveMode == emRotate) {
			Ogre::Vector3 refPoint = intersectionPoint;
			if (bAxisX)
				intersectionPlane = Ogre::Plane(Ogre::Vector3::NEGATIVE_UNIT_X, refPoint);
			else if (bAxisY)
				intersectionPlane = Ogre::Plane(Ogre::Vector3::NEGATIVE_UNIT_Y, refPoint);
			else if (bAxisZ)
				intersectionPlane = Ogre::Plane(Ogre::Vector3::NEGATIVE_UNIT_Z, refPoint);
		}

		// calculate intersection point on chosen plane
		intersectionPoint = mouseRay.getPoint(mouseRay.intersects(intersectionPlane).second);
		intersectionStart = intersectionPoint;

		Select(objSelected, true);
	}
}

void CEditorState::mouseMoved( const OIS::MouseEvent &e ) {
	fMouseX = e.state.X.abs/float(e.state.width);
	fMouseY = e.state.Y.abs/float(e.state.height);

	// move cursor
	oCursor->setPosition(e.state.X.abs, e.state.Y.abs);

	// move camera
	goCamera->Zoom(-0.0005f * e.state.Z.rel);
	if (bSpinCamera) {
		goCamera->Yaw(-0.1f * e.state.X.rel);
		goCamera->Pitch(-0.1f * e.state.Y.rel);
	}

	if (bMouseDown && objSelected != NULL) {
		Ogre::Ray mouseRay = ogreCamera->getCameraToViewportRay(fMouseX, fMouseY);

		// calculate new intersection point
		std::pair<bool,float> intersection = mouseRay.intersects(intersectionPlane);
		if (!intersection.first) return; // should never happen
		Ogre::Vector3 point = mouseRay.getPoint(intersection.second);

		if (ActiveMode == emMove) {
			Ogre::Vector3 diff = point - intersectionPoint;

			if (!bAxisX) diff.x = 0;
			if (!bAxisY) diff.y = 0;
			if (!bAxisZ) diff.z = 0;

			if (!bBoundingBoxes) {
				objSelected->SetPositionOffset(objSelected->GetPositionOffset() + Ogre::Vector3(diff.x, 0.0f, 0.0f));

				Ogre::Vector2 pos = objSelected->GetModel()->GetPosition();
				pos.x += diff.z;
				pos.y += diff.y;
				objSelected->GetModel()->SetPosition(pos);
			} else {
				Game::Polygon poly = objSelected->GetModel()->GetCleanCollisionPolygon();
				poly.Translate(Ogre::Vector2(diff.z, diff.y));
				objSelected->GetModel()->SetCollisionPolygon(poly);
			}
		} else if (ActiveMode == emScale) {
			Ogre::Vector3 position = objSelected->GetPositionOffset();
			position.y += objSelected->GetModel()->GetPosition().y;
			position.z += objSelected->GetModel()->GetPosition().x;

			float angle = objSelected->GetModel()->GetRotation();
			objSelected->GetModel()->SetRotation(0.0f);
			Game::Rectangle bbox = objSelected->GetModel()->GetBoundingBox();
			Ogre::Vector2 center = 0.5f* (bbox.GetMaximum() + bbox.GetMinimum());
			Ogre::Vector3 positionBB;
			positionBB.x = 0.0f;
			positionBB.y = center.y;
			positionBB.z = center.x;

			Ogre::Vector3 pointCpy = point;
			Ogre::Vector3 intPointCpy = intersectionPoint;

			if (!bAxisX) position.x = positionBB.z = pointCpy.x = intPointCpy.x = 0.0f;
			if (!bAxisY) position.y = positionBB.y = pointCpy.y = intPointCpy.y = 0.0f;
			if (!bAxisZ) position.z = positionBB.x = pointCpy.z = intPointCpy.z = 0.0f;


			Ogre::Vector3 vScale;

			float distanceNew = pointCpy.squaredDistance(position);
			float distanceOld = intPointCpy.squaredDistance(position);
			float scaleFactor = sqrt(distanceNew / distanceOld);

			vScale = Ogre::Vector3::UNIT_SCALE * scaleFactor;
			if (!bAxisX) vScale.x = 1.0f;
			if (!bAxisY) vScale.y = 1.0f;
			if (!bAxisZ) vScale.z = 1.0f;

			if (!bBoundingBoxes) {
				Ogre::Vector3 objScale(vScale);
				objScale.x *= objSelected->GetScale().x;
				objScale.y *= objSelected->GetScale().y;
				objScale.z *= objSelected->GetScale().z;
				objSelected->SetScale(objScale);
			}

			bbox.Translate(-center);
			Ogre::Vector2 vMin = bbox.GetMinimum();
			Ogre::Vector2 vMax = bbox.GetMaximum();
			vMin.x *= vScale.z; vMin.y *= vScale.y;
			vMax.x *= vScale.z; vMax.y *= vScale.y;
			if (vScale.x < 0)
				std::swap(vMin.x, vMax.x);
			if (vScale.y < 0)
				std::swap(vMin.y, vMax.y);
			bbox.SetExtends(vMin, vMax);
			bbox.Translate(center);
			objSelected->GetModel()->SetBoundingBox(bbox);

			objSelected->GetModel()->EnableBoundingBoxCollision();
			objSelected->GetModel()->SetRotation(angle);

		} else if (ActiveMode == emRotate) {
			if (!bBoundingBoxes) {
				Ogre::Vector3 position = objSelected->GetPositionOffset();
				position.y += objSelected->GetModel()->GetPosition().y;
				position.z += objSelected->GetModel()->GetPosition().x;

				Ogre::Vector3 vOld = intersectionPoint - position;
				Ogre::Vector3 vNew = point - position;

				if (bAxisX) vOld.x = vNew.x = 0.0f;
				if (bAxisY) vOld.y = vNew.y = 0.0f;
				if (bAxisZ) vOld.z = vNew.z = 0.0f;
				vOld.normalise(); vNew.normalise();
				Ogre::Quaternion angle = vOld.getRotationTo(vNew);

				objSelected->SetOrientation(angle*objSelected->GetOrientation());
				if (bAxisX) {
					Ogre::Radian oAngle;
					Ogre::Vector3 axis;
					angle.ToAngleAxis(oAngle, axis);
					float radian = oAngle.valueRadians();
					if (axis.x > 0.0f)
						radian = -radian;
					objSelected->GetModel()->SetRotation(objSelected->GetModel()->GetRotation() + radian);
				}
			} else {
				Game::Rectangle bbox = objSelected->GetModel()->GetBoundingBox();
				Ogre::Vector2 center = 0.5f* (bbox.GetMaximum() + bbox.GetMinimum());
				Ogre::Vector3 position;
				position.x = 0.0f;
				position.y = center.y;
				position.z = center.x;

				Ogre::Vector3 vOld = intersectionPoint - position;
				Ogre::Vector3 vNew = point - position;

				if (bAxisX && !bAxisY && !bAxisZ) {
					vOld.x = vNew.x = 0.0f;
					vOld.normalise(); vNew.normalise();
					Ogre::Quaternion angle = vOld.getRotationTo(vNew);
					Ogre::Radian oAngle;
					Ogre::Vector3 axis;
					angle.ToAngleAxis(oAngle, axis);
					float radian = oAngle.valueRadians();
					if (axis.x > 0.0f)
						radian = -radian;

					objSelected->GetModel()->SetRotation(objSelected->GetModel()->GetRotation() + radian);
				}
			}
		}

		intersectionPoint = point;
	}
}

void CEditorState::mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id ) {
	if (bPreview) return;

	bMouseDown = false;

	Select(objSelected);
}

}
/*
 * CEditorState.h
 *
 *  Created on: Aug 22, 2010
 *      Author: crt
 */

#ifndef CEDITORSTATE_H_
#define CEDITORSTATE_H_

#include "../Core/IState.h"
#include "../Core/CTaskManager.h"
#include "../Core/CStateManager.h"
#include "../Tasks/CTimerTask.h"
#include "../GameObjects/COverlay.h"
#include "../GameObjects/CPivotCamera.h"
#include "../GameObjects/LevelDataReader.h"
#include "../GameObjects/LevelDataWriter.h"
#include "../GameObjects/ObjectType.h"
#include "../GameObjects/LevelObjects.h"
#include "../GameObjects/OgreViews.h"
#include "../GameObjects/PlayerModel.h"
#include "../GameObjects/PlayerView.h"
#include "Ogre.h"
#include "boost/smart_ptr.hpp"
#include <math.h>
#include <deque>

namespace Game {

/** Implements MovableObject::Listener::objectQueryLights
 *  returns custom Light List */
class CLightListener : public Ogre::MovableObject::Listener {
public:
	Ogre::LightList LightList;

	// Ogre::MovableObject::Listener
	virtual const Ogre::LightList* objectQueryLights(const Ogre::MovableObject* obj) {
		return &LightList;
	}

	CLightListener(const Ogre::ColourValue& diffuse, const Ogre::ColourValue& specular);
	virtual ~CLightListener();
};

class CEditorState;
typedef boost::shared_ptr<CEditorState> PEditorState;

class CEditorState: public IState, public GameObjects::CXMLReader::Listener {
public:
	CEditorState();
	virtual ~CEditorState();

	virtual bool Start();
	virtual void Stop();

	virtual void Pause() { };
	virtual void Resume() { };

	virtual void Update();

	virtual void mouseMoved( const OIS::MouseEvent &e );
	virtual void keyReleased( const OIS::KeyEvent &e );
	virtual void keyPressed( const OIS::KeyEvent &e );

	virtual void mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id );
	virtual void mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id );

	static PEditorState Create() {
		return PEditorState(new CEditorState());
	}

	virtual void ReadTemplate(std::string name, GameObjects::PLevelObject object, GameObjects::POgreView view);
	virtual void ReadLevelObject(GameObjects::PLevelObject object, GameObjects::ObjectType layer);
	virtual void ReadOgreView(GameObjects::POgreView view, GameObjects::ObjectType layer);

private:
	typedef std::vector<GameObjects::PLevelObject> LevelObjectList;
	typedef std::vector<GameObjects::POgreEntityView> OgreViewList;
	typedef std::vector<GameObjects::POgreBoundsView> OgreBoundsViewList;
	typedef std::map<GameObjects::POgreEntityView, GameObjects::POgreBoundsView> OgreViewBoundsMap;
	typedef std::pair<GameObjects::PLevelObject, GameObjects::POgreEntityView> ObjectViewPair;
	typedef std::map<GameObjects::PLevelObject, ObjectViewPair> ObjectPairMap;
	typedef std::map<GameObjects::POgreEntityView, ObjectViewPair> ViewObjectViewPairMap;
	typedef std::map<std::string, ObjectViewPair> StringObjectPairMap;
	typedef std::deque<ObjectViewPair> OgreObjectViewPairQueue;

	enum EditorMode { emMove, emScale, emRotate, emSelect };
	enum Align { alLeft, alTop, alRight, alBottom, alFront, alBack, alCenter };
	enum EditDialog { edNone, edSave, edNew, edOpen };

	Ogre::AxisAlignedBox GetTransformedBoundingBox(Ogre::Entity* entity);
	void DestroySceneNode(Ogre::SceneNode* node);
	void CreateWndViewport();
	void DestroyWndViewport();
	void DrawLevel();
	void RefreshActiveLayer();
	void RefreshActiveAxis();
	void RefreshActiveMode();
	void ToggleBoundingBoxes();
	void ToggleGrid();
	void CheckMinMax(GameObjects::POgreEntityView obj, float& minX, float& minY, float& maxX, float& maxY);
	void MakeBoundingBox(GameObjects::POgreEntityView obj);
	Ogre::Rectangle GetGridBounds();
	Ogre::ManualObject* MakeGrid(Ogre::Rectangle extends);
	void Select(GameObjects::POgreEntityView obj, bool green = false);
	void UnSelect();
	void SetToOgreBoundingBox();
	void TogglePreview();
	void UndoAll(bool undoTranslation);
	void UndoTranslation();
	void UndoRotation();
	void ResetRotation();
	GameObjects::ObjectType FindLayer(GameObjects::POgreEntityView obj);
	void SwitchTemplate();
	void ToggleAlignX(Align& align);
	void ToggleAlignY(Align& align);
	void ToggleAlignZ(Align& align);
	void ToggleAxisX();
	void ToggleAxisY();
	void ToggleAxisZ();
	std::string AlignToStr(Align align);
	void InsertObject(bool clone);
	Ogre::Vector3 AlignTransform(Ogre::Vector3 translation, bool target);
	void RefreshAlign();
	void DeleteObject();
	void UndoDelete();
	void ClearLevelData();
	void LoadFile();
	void SaveFile();
	void ShowDialog(EditDialog dlg);
	void DialogProcessKey(const OIS::KeyEvent &e, bool pressed);

	LevelObjectList& GetContainer(GameObjects::ObjectType layer);
	OgreViewList& GetViewContainer(GameObjects::ObjectType layer);

	Ogre::RenderWindow* ogreRenderWindow;
	Ogre::Root* ogreRoot;

	// main scene
	Ogre::SceneManager* ogreScene;
	Ogre::Camera* ogreCamera;
	Ogre::Viewport* ogreViewport;
	Ogre::SceneNode* ogreLevelNode;

	// second viewport
	Ogre::SceneManager* ogreWndScene;
	Ogre::Camera* ogreWndCamera;
	Ogre::Viewport* ogreWndViewport;
	GameObjects::POverlay goWndFrame;
	bool bWndCreated;

	// overlay viewport
	Ogre::SceneManager* ogreOverlayScene;
	Ogre::Camera* ogreOverlayCamera;
	Ogre::Viewport* ogreOverlayViewport;

	GameObjects::POverlay goHud;
	GameObjects::PPivotCamera goCamera;
//	GameObjects::PSindbadCharacter goHero;

	Ogre::Overlay* oCursorLayer;
	Ogre::OverlayContainer* oCursor;

	bool bSpinCamera;
	bool bLeftPressed;
	bool bRightPressed;
	bool bUpPressed;
	bool bDownPressed;

	bool bMouseDown;

	bool bAxisX;
	bool bAxisY;
	bool bAxisZ;

	bool bBoundingBoxes;
	Ogre::SceneNode* oBBNode;

	bool bShowGrid;
	bool bPreview;
	bool bKeepSelectedOnLayerChange;
	bool bAlwaysAlignToBoundingBox;

	// current cursor position in relative coordinates ([0,1])
	float fMouseX;
	float fMouseY;

	// camera pivot
	Ogre::Vector3 vPivot;

	// level data
	StringObjectPairMap templates;
	LevelObjectList staticLevelData;
	OgreViewList staticViews;
	LevelObjectList backgroundLevelData;
	OgreViewList backgroundViews;
	LevelObjectList dynamicLevelData;
	OgreViewList dynamicViews;

	ViewObjectViewPairMap backupObjects;
	OgreObjectViewPairQueue deletedObjects;

	OgreViewBoundsMap mBoundingBoxes;

	// selection
	GameObjects::POgreEntityView objSelected;
	GameObjects::POgreBoundsView boundsSelected;

	Ogre::Vector3 intersectionStart;
	Ogre::Vector3 intersectionPoint;
	Ogre::Plane intersectionPlane;

	CLightListener oGreenListener;
	CLightListener oRedListener;
	CLightListener oDarkListener;

	Ogre::ManualObject* ogreGrid;

	GameObjects::ObjectType ActiveLayer;
	EditorMode ActiveMode;
	EditDialog ActiveDialog;
	std::string sInput;

	std::string sCurrentTemplate;
	Align AlignX;
	Align AlignY;
	Align AlignZ;
	Align TargetAlignX;
	Align TargetAlignY;
	Align TargetAlignZ;

	std::string sCurrentFilename;
};

}

#endif /* CEDITORSTATE_H_ */
/*
 * CGameState.cpp
 *
 *  Created on: Jul 2, 2010
 *      Author: crt
 */

#include "CGameState.h"

namespace Game {

CGameState::CGameState()
	: LevelFileName("level.xml"), lTimeShift(0), lTimePaused(0), bRotateCamera(false), fSkyRotation(-90), fAcceleration(1.0), bSkipOneFrame(false)
{
}

CGameState::~CGameState() {
}

bool CGameState::Start() {
	// play music
	OgreOggSound::OgreOggSoundManager::getSingleton().getSound("bgmusic")->play();

	// remove old scene
	CVideoTask::ogreRenderWindow->removeAllViewports();

	// create new scene, camera, viewport
	ogreScene = CVideoTask::ogreRoot->createSceneManager(Ogre::ST_GENERIC, "MainGame");
	ogreCamera = ogreScene->createCamera("MainCamera");
	ogreViewport = CVideoTask::ogreRenderWindow->addViewport(ogreCamera);
	ogreCamera->setAspectRatio(Ogre::Real(ogreViewport->getActualWidth()) / Ogre::Real(ogreViewport->getActualHeight()));

	// make textures look nice
    Ogre::MaterialManager::getSingleton().setDefaultTextureFiltering(Ogre::TFO_ANISOTROPIC);
    Ogre::MaterialManager::getSingleton().setDefaultAnisotropy(7);

	ogreViewport->setBackgroundColour(Ogre::ColourValue(0.3f, 0.3f, 0.3f));

	ogreScene->setAmbientLight(Ogre::ColourValue(0.1, 0.1, 0.1));

	// set shadow properties
	ogreScene->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);
	ogreScene->setShadowColour(Ogre::ColourValue(0.0, 0.0, 0.0));
	ogreScene->setShadowTextureSize(1024);
	ogreScene->setShadowTextureCount(1);
	ogreScene->setShadowUseInfiniteFarPlane(false);

	// Create a rainstorm
	Ogre::ParticleSystem* pSys = ogreScene->createParticleSystem("rain", "Rain");

	ogreScene->setSkyBox(true, "Textures/SkyBox", 5000, true, Ogre::Quaternion(Ogre::Degree(fSkyRotation), Ogre::Vector3::UNIT_Y));

	ogreCamera->setNearClipDistance(0.1f);
	ogreCamera->setFarClipDistance(0); // infinity

	// create ogre light
	Ogre::Light* light = ogreScene->createLight();
	light->setType(Ogre::Light::LT_DIRECTIONAL);
	//light->setPosition(-10, 50, 20);
	light->setDirection(0.25, -0.8, 0);
	light->setSpecularColour(Ogre::ColourValue::White);
	light->setDiffuseColour(Ogre::ColourValue(0.4, 0.4, 0.2));
	light->setShadowFarClipDistance(-1);
	light->setShadowFarDistance(500);
	light->setShadowNearClipDistance(0.1);

	goLevel = GameObjects::CLevelData::Create();

	GameObjects::CXMLReader xmlReader;
	if (!xmlReader.Read("media/leveldata/" + LevelFileName, goLevel.get()))
		CLog::Get().Write("error loading level data", CLog::logRelease);

	goLevel->Draw(ogreScene);

	goHud = GameObjects::COverlay::Create("Main/HUD", "hud", 100);
	goHud->SetValue<int>("Score", 0);

	goCamera = GameObjects::CPivotCamera::Create(ogreCamera, CSettingsManager::GetSingleton().get<float>("Camera", "distance", 15.0f));
	Ogre::Vector2 pos = goLevel->GetPlayer()->GetPosition();
	goCamera->SetPivot(Ogre::Vector3(0.0f, pos.y, pos.x));
	goCamera->Zoom(CSettingsManager::GetSingleton().get<float>("Camera", "zoom", 5.0f));
	goCamera->Yaw(CSettingsManager::GetSingleton().get<float>("Camera", "yaw", -90));
	goCamera->SetSpeed(CSettingsManager::GetSingleton().get<float>("Camera", "speed", 9.0f));
	goCamera->MoveToGoal();
	//goCamera->GetCameraNode()->attachObject(light);

	Ogre::SceneNode* rNode = goLevel->GetPlayerView()->GetOgreNode()->createChildSceneNode();
	rNode->translate(0,250,150);
	rNode->attachObject(pSys);
	// Fast-forward the rain so it looks more natural
	pSys->fastForward(10);

	bSkipOneFrame = true;
	return true;
}

void CGameState::Stop() {
	goHud.reset();
	goCamera.reset();
	goLevel.reset();

	ogreScene->clearScene();
	CVideoTask::ogreRoot->destroySceneManager(ogreScene);
	CVideoTask::ogreRenderWindow->removeAllViewports();

	OgreOggSound::OgreOggSoundManager::getSingleton().getSound("bgmusic")->stop();
}

void CGameState::Pause() {
	// save current time for time shift
	lTimePaused = CTimerTask::thisFrameIndex;
}

void CGameState::Resume() {
	// calculate new time shift
	lTimeShift += CTimerTask::thisFrameIndex - lTimePaused;
}

void CGameState::keyReleased( const OIS::KeyEvent &e ) {
	if (e.key == OIS::KC_SPACE) goLevel->GetPlayer()->FinishJump();
	else if (e.key == OIS::KC_F) bRotateCamera = false;
	else if (e.key == OIS::KC_ESCAPE) CStateManager::GetSingleton().ChangeState("MainMenu");
	else if (e.key == OIS::KC_RETURN) CStateManager::GetSingleton().ChangeState("MainMenu");


	if (e.key == OIS::KC_L)
		ogreScene->setAmbientLight(Ogre::ColourValue(0.1, 0.1, 0.1));
}

void CGameState::keyPressed( const OIS::KeyEvent &e ) {
	if (e.key == OIS::KC_F) bRotateCamera = true;
	else if (e.key == OIS::KC_SPACE) goLevel->GetPlayer()->BeginJump();

	if (e.key == OIS::KC_L)
		ogreScene->setAmbientLight(Ogre::ColourValue(0.6, 0.6, 0.8));
}

void CGameState::mouseMoved( const OIS::MouseEvent &e ) {
	goCamera->Zoom(-0.0005f * e.state.Z.rel);
	if (bRotateCamera) {
		goCamera->Yaw(-0.1f * e.state.X.rel);
		goCamera->Pitch(-0.1f * e.state.Y.rel);
	}
}

void CGameState::Update() {
	if (bSkipOneFrame) {
		bSkipOneFrame = false;
		return;
	}


	long lastFrameIndex = CTimerTask::lastFrameIndex + lTimeShift;
	long thisFrameIndex = CTimerTask::thisFrameIndex + lTimeShift;

	// limit dT to 0.1 (=> dont go below 10 FPS)
	if (thisFrameIndex - lastFrameIndex > 100) {
		lTimeShift += thisFrameIndex - lastFrameIndex - 100;
		lastFrameIndex += thisFrameIndex - lastFrameIndex - 100;
	}

	float deltaTime = ((float)(thisFrameIndex-lastFrameIndex))/1000.0f;

	goLevel->Update(deltaTime);

	if (bLightning && lLightningStarted+200 <= thisFrameIndex) {
		ogreScene->setAmbientLight(Ogre::ColourValue(0.1, 0.1, 0.1));
		bLightning = false;
	}

	if (!bLightning) {
		boost::uniform_int<int> distrib(0, static_cast<int>(round(CTimerTask::FPS*2.5f)));
		boost::variate_generator<boost::mt19937&, boost::uniform_int<int> > random_number(engine, distrib);
		if (random_number() == 1) {
			boost::uniform_int<int> distrib2(1, 2);
			boost::variate_generator<boost::mt19937&, boost::uniform_int<int> > random_number2(engine, distrib2);

			if (OgreOggSound::OgreOggSoundManager::getSingleton().getSound("thunder2")->isPlaying() || random_number2() == 1) {
				OgreOggSound::OgreOggSoundManager::getSingleton().getSound("thunder")->setPlayPosition(0.0f);
				OgreOggSound::OgreOggSoundManager::getSingleton().getSound("thunder")->play();
			} else {
				OgreOggSound::OgreOggSoundManager::getSingleton().getSound("thunder2")->setPlayPosition(0.0f);
				OgreOggSound::OgreOggSoundManager::getSingleton().getSound("thunder2")->play();
			}
			lLightningStarted = thisFrameIndex;
			bLightning = true;
			ogreScene->setAmbientLight(Ogre::ColourValue(0.8, 0.8, 1.0));
		}

	}

	Ogre::Vector2 pos = goLevel->GetPlayer()->GetPosition();
	goCamera->SetPivot(Ogre::Vector3(0.0f, pos.y, pos.x));
	goCamera->Update(deltaTime);

	goHud->SetValue<float>("Score", CVideoTask::ogreRenderWindow->getAverageFPS());

}

void CGameState::GameOver() {
	CTaskManager::GetSingleton().KillAll();
//		PGameOverState gameover = CStateManager::GetSingleton().CreateState("GameOver");
//		gameover->SetScore(9002);
//		CStateManager::GetSingleton().PushState(gameover);
//		gameover.reset();
}

}
/*
 * CGameState.h
 *
 *  Created on: Jul 2, 2010
 *      Author: crt
 */

#ifndef CGAMESTATE_H_
#define CGAMESTATE_H_

#include "../Core/IState.h"
#include "../Core/CTaskManager.h"
#include "../Core/CSettingsManager.h"
#include "../Tasks/CTimerTask.h"
#include "../Tasks/CVideoTask.h"
#include "../Core/CStateManager.h"
#include "../GameObjects/CPivotCamera.h"
#include "../GameObjects/COverlay.h"
#include "../GameObjects/CLevelData.h"
#include "../GameObjects/LevelDataReader.h"
#include "Ogre.h"
#include "OgreOggSound.h"

#include "boost/smart_ptr.hpp"
#include "boost/random/uniform_int.hpp"
#include "boost/random/variate_generator.hpp"
#include "boost/random/mersenne_twister.hpp"


namespace Game {

class CGameState;
typedef boost::shared_ptr<CGameState> PGameState;

class CGameState: public Game::IState {
public:
	static PGameState Create() {
		return PGameState(new CGameState());
	}

	CGameState();
	virtual ~CGameState();

	virtual bool Start();
	virtual void Stop();

	virtual void Pause();
	virtual void Resume();

	virtual void Update();

	virtual void keyReleased( const OIS::KeyEvent &e );
	virtual void keyPressed( const OIS::KeyEvent &e );

	virtual void mouseMoved( const OIS::MouseEvent &e );

	std::string LevelFileName;

protected:
	long lTimeShift;
	long lTimePaused;

	int iScore;

	bool bRotateCamera;

	float fSkyRotation;

	float fAcceleration;

	bool bLightning;
	long lLightningStarted;

	bool bSkipOneFrame;

	GameObjects::POverlay goHud;
	GameObjects::PPivotCamera goCamera;
	GameObjects::PLevelData goLevel;

	Ogre::SceneManager* ogreScene;
	Ogre::Camera* ogreCamera;
	Ogre::Viewport* ogreViewport;
	Ogre::SceneNode* dragonNode;

	boost::mt19937 engine;

	void GameOver();
};

}

#endif /* CGAMESTATE_H_ */
/*
 * CLoadingState.cpp
 *
 *  Created on: Jun 19, 2010
 *      Author: crt
 */

#include "CLoadingState.h"

namespace Game {

CLoadingState::StringStringMap CLoadingState::AudioNames;
CLoadingState::StringBoolMap CLoadingState::AudioStream;
CLoadingState::StringBoolMap CLoadingState::AudioLoop;
CLoadingState::StringBoolMap CLoadingState::AudioPrebuffer;
CLoadingState::StringFloatMap CLoadingState::AudioVolume;
boost::mutex CLoadingState::AudioMutex;
bool CLoadingState::bAudioThreadFinished;
GameObjects::PProgressBar CLoadingState::goProgressBar;

CLoadingState::CLoadingState()
	: ogreScene(NULL),
	  ogreViewport(NULL),
	  ogreCamera(NULL),
	  bFadeOut(false),
	  lFadeDuration(1000),
	  sNextState("MainMenu")
{
	ResourceGroups.push_back("Main");
}

CLoadingState::~CLoadingState() {
}

bool CLoadingState::Start() {
	try {
		// create new ogre scene
		CVideoTask::ogreRenderWindow->removeAllViewports();

		ogreScene = CVideoTask::ogreRoot->createSceneManager(Ogre::ST_GENERIC, "IntroScene");
		ogreCamera = ogreScene->createCamera("IntroCamera");
		ogreViewport = CVideoTask::ogreRenderWindow->addViewport(ogreCamera);

		ogreViewport->setBackgroundColour(Ogre::ColourValue(0.0,0.0,0.0,1.0));


		// create progress bar
		goProgressBar = GameObjects::CProgressBar::Create("Boot/ProgressBar", "pbar");
		goProgressBar->Setup(ResourceGroups.size()+1, ResourceGroups.size()+1, 0.7);
		goProgressBar->SetProgress(0.0);

		Ogre::ResourceGroupManager::getSingleton().addResourceGroupListener(goProgressBar.get());

		panel = Ogre::OverlayManager::getSingleton().create("panel");
		panel->setZOrder(100);

		// setup transparent black layer, used for fading out later
		blackLayer = (Ogre::OverlayContainer*)Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate
				("Boot/Fade", "BorderPanel", "fade");

		// make completely transparent
		Ogre::MaterialPtr FadeMaterial = Ogre::MaterialManager::getSingleton().getByName("Boot/FadeBlack");
		Ogre::TextureUnitState *FadeTextureLayer = FadeMaterial->getTechnique(0)->getPass(0)->getTextureUnitState(0);
		FadeMaterial->getTechnique(0)->getPass(0)->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);

		FadeTextureLayer->setAlphaOperation(Ogre::LBX_SOURCE1, Ogre::LBS_MANUAL, Ogre::LBS_CURRENT, 0.0f);

		panel->add2D(goProgressBar->OverlayContainer);
		panel->add2D(blackLayer);
		panel->show();

		// gather sound preload information
		CSettingsManager::GetSingleton().readConfig("media/audio/preload.cfg");
		SetupAudioPreload();
		bLoadAudioStarted = false;

		// start loading stuff
		for (GroupListItor it = ResourceGroups.begin(); it != ResourceGroups.end(); ++it) {
			Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(*it);
			Ogre::ResourceGroupManager::getSingleton().loadResourceGroup(*it);
		}

	} catch (Ogre::Exception& ex) {
		CLog::Get().Write("Intro Startup Error: " + ex.getFullDescription(), CLog::logDebug);
		return false;
	}

	return true;
}

void CLoadingState::Stop() {
	Ogre::ResourceGroupManager::getSingleton().removeResourceGroupListener(goProgressBar.get());

	goProgressBar.reset();
	GameObjects::COverlay::nukeOverlayElement(blackLayer);
	Ogre::OverlayManager::getSingleton().destroy(panel);

	ogreScene->clearScene();
	CVideoTask::ogreRoot->destroySceneManager(ogreScene);

	CVideoTask::ogreRenderWindow->removeAllViewports();
}

void CLoadingState::SetupAudioPreload() {
	CSettingsManager& sm = CSettingsManager::GetSingleton();
	std::vector<std::string> preloadKeys;
	std::vector<std::string> configKeys = sm.EnumerateSection("PreloadAudio");

	AudioNames.clear();
	AudioLoop.clear();
	AudioStream.clear();
	AudioPrebuffer.clear();

	if (configKeys.empty()) return;


	// remove all keys with dot
	std::vector<std::string>::iterator it;
	for (it = configKeys.begin(); it != configKeys.end(); ++it) {
		if (it->find(".") == std::string::npos && *it != "")
			preloadKeys.push_back(*it);
	}

	// load settings for each key
	for (it = preloadKeys.begin(); it != preloadKeys.end(); ++it) {
		std::string key = *it;
		std::string filename = sm.get<std::string>("PreloadAudio", key, "");

		if (filename == "") continue;

		bool bLoop = sm.get<bool>("PreloadAudio", key + ".loop", false);
		bool bStream = sm.get<bool>("PreloadAudio", key + ".stream", true);
		bool bPrebuffer = sm.get<bool>("PreloadAudio", key + ".prebuffer", false);
		float fVolume = sm.get<float>("PreloadAudio", key + ".volume", 1.0f);

		AudioNames[key] = filename;
		AudioLoop[key] = bLoop;
		AudioStream[key] = bStream;
		AudioPrebuffer[key] = bPrebuffer;
		AudioVolume[key] = fVolume;
	}
}

void CLoadingState::AudioThreadMain() {
	float fProgressStep = (1 - goProgressBar->GetProgress()) / (float)AudioNames.size();

	for (StringStringMap::iterator it = AudioNames.begin(); it != AudioNames.end(); ++it) {
		goProgressBar->SetComment(it->first);

		std::string AudioName = it->first;
		std::string filename = it->second;
		bool bLoop = AudioLoop[AudioName];
		bool bStream = AudioStream[AudioName];
		bool bPrebuffer = AudioPrebuffer[AudioName];
		float fVolume = AudioVolume[AudioName];

		if (OgreOggSound::OgreOggSoundManager::getSingleton().createSound(AudioName, filename, bStream, bLoop, bPrebuffer))
			OgreOggSound::OgreOggSoundManager::getSingleton().getSound(AudioName)->setVolume(fVolume);

		goProgressBar->SetProgress(goProgressBar->GetProgress() + fProgressStep);
	}

	goProgressBar->SetProgress(1.0f);

	{
		boost::mutex::scoped_lock lock(AudioMutex);
		bAudioThreadFinished = true;
	}
}

void CLoadingState::Update() {
	// does acutally nothing until loading is finished

	// load audio when ogre loading is finishes
	if (!bLoadAudioStarted && goProgressBar->LoadingEnded()) {
		bLoadAudioStarted = true;
		bAudioThreadFinished = false;

		AudioThread = boost::thread(&CLoadingState::AudioThreadMain);
		AudioThread.detach();
	}


	{
		boost::mutex::scoped_lock lock(AudioMutex);
		if (!bFadeOut && bLoadAudioStarted && bAudioThreadFinished) {
			lTimeStart = CTimerTask::thisFrameIndex;
			bFadeOut = true;
		}
	}

	// fade out
	if (bFadeOut) {
		// get Boot/FadeBlack material and make it opaque

		Ogre::MaterialPtr FadeMaterial = Ogre::MaterialManager::getSingleton().getByName("Boot/FadeBlack");
		Ogre::TextureUnitState *FadeTextureLayer = FadeMaterial->getTechnique(0)->getPass(0)->getTextureUnitState(0);
		FadeMaterial->getTechnique(0)->getPass(0)->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);

		float currentAlpha = (CTimerTask::thisFrameIndex - this->lTimeStart)/(float)lFadeDuration;
		FadeTextureLayer->setAlphaOperation(Ogre::LBX_SOURCE1, Ogre::LBS_MANUAL, Ogre::LBS_CURRENT, currentAlpha);
	}

	// fade out finished
	if (bFadeOut && (CTimerTask::thisFrameIndex - this->lTimeStart)/(float)lFadeDuration > 1.0f) {
		if (pNextState != NULL)
			CStateManager::GetSingleton().ChangeState(pNextState);
		else
			CStateManager::GetSingleton().ChangeState(sNextState);
	}
}

void CLoadingState::keyReleased( const OIS::KeyEvent &e ) {
	if (e.key == OIS::KC_ESCAPE)
		CTaskManager::GetSingletonPtr()->KillAll();
}

}
/*
 * CLoadingState.h
 *
 *  Created on: Jun 19, 2010
 *      Author: crt
 */

#ifndef CLOADINGSTATE_H_
#define CLOADINGSTATE_H_

#include "../Core/IState.h"
#include "../Tasks/CVideoTask.h"
#include "../Tasks/CTimerTask.h"
#include "../Core/CStateManager.h"
#include "../Core/CTaskManager.h"
#include "../Core/CLog.h"
#include "../GameObjects/CProgressBar.h"
#include "../Core/CSettingsManager.h"

#include "CMainMenuState.h"

#include "Ogre.h"
#include "OgreFontManager.h"
#include "OgreBorderPanelOverlayElement.h"
#include "OgreTextAreaOverlayElement.h"
#include "OgreOggSound.h"

#include <vector>
#include "boost/smart_ptr.hpp"
#include "boost/thread/thread.hpp"
#include "boost/thread/mutex.hpp"

namespace Game {

class CLoadingState;
typedef boost::shared_ptr<CLoadingState> PLoadingState;

class CLoadingState: public Game::IState {
public:
	typedef std::vector<std::string> GroupList;
	typedef std::vector<std::string>::iterator GroupListItor;

	virtual ~CLoadingState();

	virtual bool Start();
	virtual void Stop();

	// please don't pause/resume introstate
	virtual void Pause() { };
	virtual void Resume() { };

	virtual void Update();

	virtual void keyReleased( const OIS::KeyEvent &e );

	static PLoadingState Create() {
		return PLoadingState(new CLoadingState());
	}

	/** Set state to switch to when loading is done */
	inline void SetNextState(const std::string& stateName) { sNextState = stateName; }
	/** Set state to switch to when loading is done */
	inline void SetNextState(PState state) { pNextState = state; }

	/** Set duration of fade out in ms */
	inline void SetFadeDuration(long time) { lFadeDuration = time; }

	/** List of ogre resource groups to load
	 *  Default: Main */
	GroupList ResourceGroups;
private:
	CLoadingState();
	void SetupAudioPreload();

	Ogre::SceneManager* ogreScene;
	Ogre::Viewport* ogreViewport;
	Ogre::Camera* ogreCamera;

	Ogre::Overlay* panel;
	Ogre::OverlayContainer* blackLayer;

	// misc
	bool bFadeOut;
	long lTimeStart;
	long lFadeDuration;

	// next state
	std::string sNextState;
	PState pNextState;

	static GameObjects::PProgressBar goProgressBar;

	typedef std::map<std::string, std::string> StringStringMap;
	typedef std::map<std::string, bool> StringBoolMap;
	typedef std::map<std::string, float> StringFloatMap;

	static StringStringMap AudioNames;
	static StringBoolMap AudioStream;
	static StringBoolMap AudioLoop;
	static StringBoolMap AudioPrebuffer;
	static StringFloatMap AudioVolume;
	boost::thread AudioThread;
	static boost::mutex AudioMutex;
	static void AudioThreadMain();
	bool bLoadAudioStarted;
	static bool bAudioThreadFinished;
};

}

#endif /* CLOADINGSTATE_H_ */
/*
 * CMainMenuState.cpp
 *
 *  Created on: Jun 19, 2010
 *      Author: crt
 */

#include "CMainMenuState.h"

namespace Game {

CMainMenuState::CMainMenuState() {
}

CMainMenuState::~CMainMenuState() {
}

bool CMainMenuState::Start() {
	try {
		// read level config
		ReadLevelConfig();


		// create new ogre scene
		CVideoTask::ogreRenderWindow->removeAllViewports();

		ogreScene = CVideoTask::ogreRoot->createSceneManager(Ogre::ST_GENERIC, "MainMenuScene");
		ogreCamera = ogreScene->createCamera("MainMenuCamera");
		ogreViewport = CVideoTask::ogreRenderWindow->addViewport(ogreCamera);
		ogreCamera->setAspectRatio(Ogre::Real(ogreViewport->getActualWidth()) / Ogre::Real(ogreViewport->getActualHeight()));

		ogreViewport->setBackgroundColour(Ogre::ColourValue(189.0f/255.0f, 215.0f/255.0f, 225.0f/255.0f));

		ogreScene->setAmbientLight(Ogre::ColourValue(0.3, 0.3, 0.3));

		ogreLight = ogreScene->createLight();
		ogreLight->setType(Ogre::Light::LT_POINT);
		ogreLight->setPosition(-10, 40, 20);
		ogreLight->setSpecularColour(Ogre::ColourValue::White);

		ogreCamera->setNearClipDistance(0.1);
		ogreCamera->setFarClipDistance(100);
		ogreCamera->setPosition(0,2,15);
/*
		Ogre::Overlay* panel = Ogre::OverlayManager::getSingleton().create("panel");
		panel->setZOrder(100);

		Ogre::OverlayElement* mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate
			("MainMenu/Main", "BorderPanel", "mainmenu");

		panel->add2D((Ogre::OverlayContainer*)mElement);
		panel->show();
*/
		overlay = GameObjects::COverlay::Create("MainMenu", "mainmenu", 100);
		overlay->Show();
		overlay->SetText("Main/Level", ">> " + Levels[levelSelected]);

	} catch (Ogre::Exception& ex) {
		CLog::Get().Write("Main Menu Startup Error: " + ex.getFullDescription(), CLog::logDebug);
		return false;
	}

	return true;
}

void CMainMenuState::Stop() {
	overlay.reset();


	ogreScene->clearScene();
	CVideoTask::ogreRoot->destroySceneManager(ogreScene);

	CVideoTask::ogreRenderWindow->removeAllViewports();
}

void CMainMenuState::Update() {

	// follow character
	ogreCamera->setPosition(ogreCamera->getPosition() + Ogre::Vector3::UNIT_Z*CTimerTask::dT);
	ogreLight->setPosition(ogreLight->getPosition() + Ogre::Vector3::UNIT_Z*CTimerTask::dT);
}

void CMainMenuState::keyReleased( const OIS::KeyEvent &e ) {
	if (e.key == OIS::KC_ESCAPE)
		CTaskManager::GetSingletonPtr()->KillAll();
	else if (e.key == OIS::KC_E)
		CStateManager::GetSingleton().ChangeState("Editor");
	else if (e.key == OIS::KC_RETURN) {
		PState state = CStateManager::GetSingleton().CreateState("Game");
		if (state) {
			PGameState gameState = boost::static_pointer_cast<CGameState>(state);
			gameState->LevelFileName = levelSelected;
		}
		CStateManager::GetSingleton().ChangeState(state);
	} else if (e.key == OIS::KC_LEFT) {
		LevelMap::iterator it = Levels.find(levelSelected);
		if (it == Levels.begin()) it = Levels.end();
		it--;
		levelSelected = it->first;
		overlay->SetText("Main/Level", ">> " + it->second);
	}
	else if (e.key == OIS::KC_RIGHT) {
		LevelMap::iterator it = Levels.find(levelSelected);
		it++;
		if (it == Levels.end()) it = Levels.begin();
		levelSelected = it->first;
		overlay->SetText("Main/Level", ">> " + it->second);
	}
}

void CMainMenuState::ReadLevelConfig() {
	CSettingsManager& sm = CSettingsManager::GetSingleton();
	std::vector<std::string> levelKeys;
	std::vector<std::string> configKeys = sm.EnumerateSection("Levels");

	if (configKeys.empty()) return;


	// remove all keys with dot
	std::vector<std::string>::iterator it;
	for (it = configKeys.begin(); it != configKeys.end(); ++it) {
		if (it->find(".") == std::string::npos && *it != "")
			levelKeys.push_back(*it);
	}

	// load settings for each key
	for (it = levelKeys.begin(); it != levelKeys.end(); ++it) {
		std::string key = *it;
		std::string filename = sm.get<std::string>("Levels", key, "");

		if (filename == "") continue;

		std::string displayname = sm.get<std::string>("Levels", key + ".displayname", filename);
		Levels[filename] = displayname;
	}

	levelSelected = Levels.begin()->first;
}

}
/*
 * CMainMenuState.h
 *
 *  Created on: Jun 19, 2010
 *      Author: crt
 */

#ifndef CMAINMENUSTATE_H_
#define CMAINMENUSTATE_H_

#include "../Core/IState.h"
#include "../Tasks/CVideoTask.h"
#include "../Tasks/CTimerTask.h"
#include "../Core/CStateManager.h"
#include "../Core/CTaskManager.h"
#include "../Core/CLog.h"
#include "../GameObjects/COverlay.h"
#include "CGameState.h"

#include "Ogre.h"

#include "boost/shared_ptr.hpp"
#include <string>
#include <map>

namespace Game {

class CMainMenuState;
typedef boost::shared_ptr<CMainMenuState> PMainMenuState;

class CMainMenuState: public Game::IState {
public:
	virtual ~CMainMenuState();

	virtual bool Start();
	virtual void Stop();

	virtual void Pause() { };
	virtual void Resume() { };

	virtual void Update();

	virtual void keyReleased( const OIS::KeyEvent &e );

	static PMainMenuState Create() {
		return PMainMenuState(new CMainMenuState());
	}

private:
	void ReadLevelConfig();
	typedef std::map<std::string, std::string> LevelMap;
	LevelMap Levels;
	std::string levelSelected;
	std::string levelDisplay;

	Ogre::SceneManager* ogreScene;
	Ogre::Viewport* ogreViewport;
	Ogre::Camera* ogreCamera;

	Ogre::Light* ogreLight;

	GameObjects::POverlay overlay;



	CMainMenuState();
};

}

#endif /* CMAINMENUSTATE_H_ */
/*
 * CInputTask.cpp
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#include "CInputTask.h"

namespace Game {

CInputTask::CInputTask()
	: oisMouse(NULL),
	  oisKeyboard(NULL),
	  oisJoysticks(),
	  oisInputSystem(NULL),
	  ogreRenderWindow(NULL)
{
}

CInputTask::~CInputTask() {
	// destroy OIS objects, if exsist
    if (oisInputSystem) {
        if (oisMouse) {
            oisInputSystem->destroyInputObject(oisMouse);
            oisMouse = 0;
        }

        if (oisKeyboard) {
            oisInputSystem->destroyInputObject(oisKeyboard);
            oisKeyboard = 0;
        }

        if(oisJoysticks.size() > 0) {
            itJoystick    = oisJoysticks.begin();
            itJoystickEnd = oisJoysticks.end();
            for(; itJoystick != itJoystickEnd; ++itJoystick ) {
                oisInputSystem->destroyInputObject( *itJoystick );
            }

            oisJoysticks.clear();
        }

        // If you use OIS1.0RC1 or above, uncomment this line
        // and comment the line below it
        oisInputSystem->destroyInputSystem(oisInputSystem);
        //mInputSystem->destroyInputSystem();
        oisInputSystem = 0;
    }
}

bool CInputTask::Start()
{
	// don't startup twice
	if (this->running())
		return true;

	ITask::Start();

	// ogre render window is mandatory
	if (!ogreRenderWindow) {
		CLog::Get().Write("Can't startup Input Task with RenderWindows=NULL", CLog::logDebug);
		return false;
	}

	try {
		// Setup basic variables
		OIS::ParamList paramList;
		size_t windowHnd = 0;
		std::ostringstream windowHndStr;

		// Get window handle
		ogreRenderWindow->getCustomAttribute( "WINDOW", &windowHnd );

		// Fill parameter list
		windowHndStr << (unsigned int) windowHnd;
		paramList.insert( std::make_pair( std::string( "WINDOW" ), windowHndStr.str() ) );

		// non-exclusive input
#if defined OIS_WIN32_PLATFORM
		paramList.insert(std::make_pair(std::string("w32_mouse"), std::string("DISCL_FOREGROUND" )));
		paramList.insert(std::make_pair(std::string("w32_mouse"), std::string("DISCL_NONEXCLUSIVE")));
		paramList.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_FOREGROUND")));
		paramList.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_NONEXCLUSIVE")));
#elif defined OIS_LINUX_PLATFORM
		paramList.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
		paramList.insert(std::make_pair(std::string("x11_mouse_hide"), std::string("false")));
		paramList.insert(std::make_pair(std::string("x11_keyboard_grab"), std::string("false")));
		paramList.insert(std::make_pair(std::string("XAutoRepeatOn"), std::string("true")));
#endif

		// Create inputsystem
		oisInputSystem = OIS::InputManager::createInputSystem( paramList );

		// If possible create a buffered keyboard
		if (oisInputSystem->getNumberOfDevices(OIS::OISKeyboard) > 0) {
			oisKeyboard = static_cast<OIS::Keyboard*>( oisInputSystem->createInputObject( OIS::OISKeyboard, true ) );
			oisKeyboard->setEventCallback( this );
		} else {
			CLog::Get().Write("Unable to initialize OIS Keyboard.", CLog::logDebug);
			return false;
		}

		// If possible create a buffered mouse
		if (oisInputSystem->getNumberOfDevices(OIS::OISMouse) > 0) {
			oisMouse = static_cast<OIS::Mouse*>( oisInputSystem->createInputObject( OIS::OISMouse, true ) );
			oisMouse->setEventCallback( this );

			// Get window size
			unsigned int width, height, depth;
			int left, top;
			ogreRenderWindow->getMetrics( width, height, depth, left, top );

			// Set mouse region
			this->setWindowExtents( width, height );
		} else {
			CLog::Get().Write("Unable to initialize OIS Mouse.", CLog::logDebug);
		}

		// If possible create all joysticks in buffered mode
		if (oisInputSystem->getNumberOfDevices(OIS::OISJoyStick) > 0) {
			//mJoysticks.resize( mInputSystem->numJoySticks() );
			oisJoysticks.resize( oisInputSystem->getNumberOfDevices(OIS::OISJoyStick) );

			itJoystick    = oisJoysticks.begin();
			itJoystickEnd = oisJoysticks.end();
			for(; itJoystick != itJoystickEnd; ++itJoystick ) {
				(*itJoystick) = static_cast<OIS::JoyStick*>( oisInputSystem->createInputObject( OIS::OISJoyStick, true ) );
				(*itJoystick)->setEventCallback( this );
			}
		} else {
			CLog::Get().Write("Unable to initialize OIS Joysticks.", CLog::logDebug);
		}

	} catch (Ogre::Exception& ex) {
		CLog::Get().Write("Failed to initialize Input: " + ex.getFullDescription(), CLog::logDebug);
		return false;
	}

	return true;
}

void CInputTask::setWindowExtents( int width, int height ) {
    // Set mouse region (if window resizes, we should alter this to reflect as well)
    const OIS::MouseState &mouseState = oisMouse->getMouseState();
    mouseState.width  = width;
    mouseState.height = height;
}

void CInputTask::Update()
{
	// capture everything
    if (oisMouse) {
        oisMouse->capture();
    }

    if (oisKeyboard) {
        oisKeyboard->capture();
    }

    if (oisJoysticks.size() > 0) {
        itJoystick    = oisJoysticks.begin();
        itJoystickEnd = oisJoysticks.end();
        for(; itJoystick != itJoystickEnd; ++itJoystick ) {
            (*itJoystick)->capture();
        }
    }
}

void CInputTask::Stop()
{
	ITask::Stop();
}


void CInputTask::addKeyListener( PKeyListener keyListener, const std::string& instanceName ) {
    if (oisKeyboard) {
        // Check for duplicate items
        itKeyListener = mKeyListeners.find( instanceName );
        if( itKeyListener == mKeyListeners.end() ) {
            mKeyListeners[ instanceName ] = keyListener;
        }
        else {
            // Duplicate Item
        }
    }
}

void CInputTask::addMouseListener( PMouseListener mouseListener, const std::string& instanceName ) {
    if (oisMouse) {
        // Check for duplicate items
        itMouseListener = mMouseListeners.find( instanceName );
        if( itMouseListener == mMouseListeners.end() ) {
            mMouseListeners[ instanceName ] = mouseListener;
        }
        else {
            // Duplicate Item
        }
    }
}

void CInputTask::addJoystickListener( PJoyStickListener joystickListener, const std::string& instanceName ) {
    if (oisJoysticks.size() > 0) {
        // Check for duplicate items
        itJoystickListener = mJoystickListeners.find( instanceName );
        if( itJoystickListener == mJoystickListeners.end() ) {
            mJoystickListeners[ instanceName ] = joystickListener;
        }
        else {
            // Duplicate Item
        }
    }
}

void CInputTask::removeKeyListener( const std::string& instanceName ) {
    // Check if item exists
    itKeyListener = mKeyListeners.find( instanceName );
    if( itKeyListener != mKeyListeners.end() ) {
        mKeyListeners.erase( itKeyListener );
    }
    else {
        // Doesn't Exist
    }
}

void CInputTask::removeMouseListener( const std::string& instanceName ) {
    // Check if item exists
    itMouseListener = mMouseListeners.find( instanceName );
    if( itMouseListener != mMouseListeners.end() ) {
        mMouseListeners.erase( itMouseListener );
    }
    else {
        // Doesn't Exist
    }
}

void CInputTask::removeJoystickListener( const std::string& instanceName ) {
    // Check if item exists
    itJoystickListener = mJoystickListeners.find( instanceName );
    if( itJoystickListener != mJoystickListeners.end() ) {
        mJoystickListeners.erase( itJoystickListener );
    }
    else {
        // Doesn't Exist
    }
}

void CInputTask::removeKeyListener( PKeyListener keyListener ) {
    itKeyListener    = mKeyListeners.begin();
    itKeyListenerEnd = mKeyListeners.end();
    for(; itKeyListener != itKeyListenerEnd; ++itKeyListener ) {
        if( itKeyListener->second == keyListener ) {
            mKeyListeners.erase( itKeyListener );
            break;
        }
    }
}

void CInputTask::removeMouseListener( PMouseListener mouseListener ) {
    itMouseListener    = mMouseListeners.begin();
    itMouseListenerEnd = mMouseListeners.end();
    for(; itMouseListener != itMouseListenerEnd; ++itMouseListener ) {
        if( itMouseListener->second == mouseListener ) {
            mMouseListeners.erase( itMouseListener );
            break;
        }
    }
}

void CInputTask::removeJoystickListener( PJoyStickListener joystickListener ) {
    itJoystickListener    = mJoystickListeners.begin();
    itJoystickListenerEnd = mJoystickListeners.end();
    for(; itJoystickListener != itJoystickListenerEnd; ++itJoystickListener ) {
        if( itJoystickListener->second == joystickListener ) {
            mJoystickListeners.erase( itJoystickListener );
            break;
        }
    }
}

/*
 * Listeners Impl
 */

bool CInputTask::keyPressed( const OIS::KeyEvent &e ) {
    itKeyListener    = mKeyListeners.begin();
    itKeyListenerEnd = mKeyListeners.end();
    for(; itKeyListener != itKeyListenerEnd; ++itKeyListener ) {
        if(!itKeyListener->second->keyPressed( e ))
            break;
    }

    return true;
}

bool CInputTask::keyReleased( const OIS::KeyEvent &e ) {
    itKeyListener    = mKeyListeners.begin();
    itKeyListenerEnd = mKeyListeners.end();
    for(; itKeyListener != itKeyListenerEnd; ++itKeyListener ) {
        if(!itKeyListener->second->keyReleased( e ))
            break;
    }

    return true;
}

bool CInputTask::mouseMoved( const OIS::MouseEvent &e ) {
    itMouseListener    = mMouseListeners.begin();
    itMouseListenerEnd = mMouseListeners.end();
    for(; itMouseListener != itMouseListenerEnd; ++itMouseListener ) {
        if(!itMouseListener->second->mouseMoved( e ))
            break;
    }

    return true;
}

bool CInputTask::mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id ) {
    itMouseListener    = mMouseListeners.begin();
    itMouseListenerEnd = mMouseListeners.end();
    for(; itMouseListener != itMouseListenerEnd; ++itMouseListener ) {
        if(!itMouseListener->second->mousePressed( e, id ))
            break;
    }

    return true;
}

bool CInputTask::mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id ) {
    itMouseListener    = mMouseListeners.begin();
    itMouseListenerEnd = mMouseListeners.end();
    for(; itMouseListener != itMouseListenerEnd; ++itMouseListener ) {
        if(!itMouseListener->second->mouseReleased( e, id ))
            break;
    }

    return true;
}

bool CInputTask::povMoved( const OIS::JoyStickEvent &e, int pov ) {
    itJoystickListener    = mJoystickListeners.begin();
    itJoystickListenerEnd = mJoystickListeners.end();
    for(; itJoystickListener != itJoystickListenerEnd; ++itJoystickListener ) {
        if(!itJoystickListener->second->povMoved( e, pov ))
            break;
    }

    return true;
}

bool CInputTask::axisMoved( const OIS::JoyStickEvent &e, int axis ) {
    itJoystickListener    = mJoystickListeners.begin();
    itJoystickListenerEnd = mJoystickListeners.end();
    for(; itJoystickListener != itJoystickListenerEnd; ++itJoystickListener ) {
        if(!itJoystickListener->second->axisMoved( e, axis ))
            break;
    }

    return true;
}

bool CInputTask::sliderMoved( const OIS::JoyStickEvent &e, int sliderID ) {
    itJoystickListener    = mJoystickListeners.begin();
    itJoystickListenerEnd = mJoystickListeners.end();
    for(; itJoystickListener != itJoystickListenerEnd; ++itJoystickListener ) {
        if(!itJoystickListener->second->sliderMoved( e, sliderID ))
            break;
    }

    return true;
}

bool CInputTask::buttonPressed( const OIS::JoyStickEvent &e, int button ) {
    itJoystickListener    = mJoystickListeners.begin();
    itJoystickListenerEnd = mJoystickListeners.end();
    for(; itJoystickListener != itJoystickListenerEnd; ++itJoystickListener ) {
        if(!itJoystickListener->second->buttonPressed( e, button ))
            break;
    }

    return true;
}

bool CInputTask::buttonReleased( const OIS::JoyStickEvent &e, int button ) {
    itJoystickListener    = mJoystickListeners.begin();
    itJoystickListenerEnd = mJoystickListeners.end();
    for(; itJoystickListener != itJoystickListenerEnd; ++itJoystickListener ) {
        if(!itJoystickListener->second->buttonReleased( e, button ))
            break;
    }

    return true;
}

}
/*
 * CInputTask.h
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#ifndef CINPUTTASK_H_
#define CINPUTTASK_H_

#include "../Core/ITask.h"
#include "../Core/CLog.h"

#include "OISMouse.h"
#include "OISKeyboard.h"
#include "OISJoyStick.h"
#include "OISInputManager.h"

#include "OgreRenderWindow.h"

#include "boost/smart_ptr.hpp"

#include <string>
#include <map>
#include <sstream>
#include <vector>

namespace Game {

typedef boost::shared_ptr<OIS::KeyListener> PKeyListener;
typedef boost::shared_ptr<OIS::MouseListener> PMouseListener;
typedef boost::shared_ptr<OIS::JoyStickListener> PJoyStickListener;

/** Handles input
@remarks synchronizes with main loop; checks for input once every cycle */
class CInputTask: public Game::ITask, public OIS::KeyListener, public OIS::MouseListener, public OIS::JoyStickListener {
public:
	CInputTask();
	virtual ~CInputTask();

	virtual bool Start();
	virtual void Update();
	virtual void Stop();

    void addKeyListener( PKeyListener keyListener, const std::string& instanceName );
    void addMouseListener( PMouseListener mouseListener, const std::string& instanceName );
    void addJoystickListener( PJoyStickListener joystickListener, const std::string& instanceName );

    void removeKeyListener( const std::string& instanceName );
    void removeMouseListener( const std::string& instanceName );
    void removeJoystickListener( const std::string& instanceName );

    void removeKeyListener( PKeyListener keyListener );
    void removeMouseListener( PMouseListener mouseListener );
    void removeJoystickListener( PJoyStickListener joystickListener );

    /** Set window size; used for mouse*/
    void setWindowExtents( int width, int height );

    /** Set ogre render window; mandatory for OIS*/
    inline void SetWindow( Ogre::RenderWindow* renderwindow) { ogreRenderWindow = renderwindow; }
private:
	// OIS::KeyListener
    bool keyPressed( const OIS::KeyEvent &e );
    bool keyReleased( const OIS::KeyEvent &e );

    // OIS::MouseListener
    bool mouseMoved( const OIS::MouseEvent &e );
    bool mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id );
    bool mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id );

    // OIS::JoyStickListener
    bool povMoved( const OIS::JoyStickEvent &e, int pov );
    bool axisMoved( const OIS::JoyStickEvent &e, int axis );
    bool sliderMoved( const OIS::JoyStickEvent &e, int sliderID );
    bool buttonPressed( const OIS::JoyStickEvent &e, int button );
    bool buttonReleased( const OIS::JoyStickEvent &e, int button );


    OIS::Mouse* oisMouse;
    OIS::Keyboard* oisKeyboard;

    std::vector<OIS::JoyStick*> oisJoysticks;
    std::vector<OIS::JoyStick*>::iterator itJoystick;
    std::vector<OIS::JoyStick*>::iterator itJoystickEnd;

    OIS::InputManager* oisInputSystem;

    Ogre::RenderWindow* ogreRenderWindow;

    // Attached Listeners
    std::map<std::string, PKeyListener> mKeyListeners;
    std::map<std::string, PMouseListener> mMouseListeners;
    std::map<std::string, PJoyStickListener> mJoystickListeners;

    std::map<std::string, PKeyListener>::iterator itKeyListener;
    std::map<std::string, PMouseListener>::iterator itMouseListener;
    std::map<std::string, PJoyStickListener>::iterator itJoystickListener;

    std::map<std::string, PKeyListener>::iterator itKeyListenerEnd;
    std::map<std::string, PMouseListener>::iterator itMouseListenerEnd;
    std::map<std::string, PJoyStickListener>::iterator itJoystickListenerEnd;
};

typedef boost::shared_ptr<CInputTask> PInputTask;

}

#endif /* CINPUTTASK_H_ */
/*
 * CSoundTask.cpp
 *
 *  Created on: Sep 3, 2010
 *      Author: crt
 */

#include "CSoundTask.h"

namespace Game {

CSoundTask::CSoundTask() {
}

CSoundTask::~CSoundTask() {
}

bool CSoundTask::Start() {
	return OgreOggSound::OgreOggSoundManager::getSingleton().init();
}

void CSoundTask::Update() {
	OgreOggSound::OgreOggSoundManager::getSingleton().update(CTimerTask::dT);
}

void CSoundTask::Stop() {
	OgreOggSound::OgreOggSoundManager::getSingleton().stopAllSounds();
	// Note: destructs automatically
}

}
/*
 * CSoundTask.h
 *
 *  Created on: Sep 3, 2010
 *      Author: crt
 */

#ifndef CSOUNDTASK_H_
#define CSOUNDTASK_H_

#include "../Core/ITask.h"
#include "../Core/CLog.h"

#include "CTimerTask.h"

#include "OgreOggSound.h"

#include "boost/smart_ptr.hpp"

namespace Game {

class CSoundTask: public Game::ITask {
public:
	CSoundTask();
	virtual ~CSoundTask();

	virtual bool Start();
	virtual void Update();
	virtual void Stop();
};

typedef boost::shared_ptr<CSoundTask> PSoundTask;

}

#endif /* CSOUNDTASK_H_ */
/*
 * CStateTask.cpp
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#include "CStateTask.h"

namespace Game {

CStateTask::CStateTask()
{
}

CStateTask::~CStateTask() {
}

bool CStateTask::Start() {
	ITask::Start();
	return true;
}

void CStateTask::Update() {
	// terminate program, if no more states
	if (getState() == NULL) {
		CTaskManager::GetSingletonPtr()->KillAll();
		return;
	} else {
		// update current frame
		getState()->Update();
	}
}

void CStateTask::Stop() {
	ITask::Stop();

	// remove states
	CStateManager::GetSingleton().PopAll();
}

/* OIS Listeners
 * pass input to current frame
 */

// OIS::KeyListener
bool CStateTask::keyPressed( const OIS::KeyEvent &e ) {
	if (getState() != NULL)
		getState()->keyPressed(e);
	return true;
}

bool CStateTask::keyReleased( const OIS::KeyEvent &e ) {
	if (getState() != NULL) {
		getState()->keyReleased(e);
	} else {
		CTaskManager::GetSingletonPtr()->KillAll();
	}
	return true;
}

// OIS::MouseListener
bool CStateTask::mouseMoved( const OIS::MouseEvent &e ) {
	if (getState() != NULL)
		getState()->mouseMoved(e);
	return true;
}

bool CStateTask::mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id ) {
	if (getState() != NULL)
		getState()->mousePressed(e, id);
	return true;
}

bool CStateTask::mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id ) {
	if (getState() != NULL)
		getState()->mouseReleased(e, id);
	return true;
}

// OIS::JoyStickListener
bool CStateTask::povMoved( const OIS::JoyStickEvent &e, int pov ) {
	if (getState() != NULL)
		getState()->povMoved(e, pov);
	return true;
}

bool CStateTask::axisMoved( const OIS::JoyStickEvent &e, int axis ) {
	if (getState() != NULL)
		getState()->axisMoved(e, axis);
	return true;
}

bool CStateTask::sliderMoved( const OIS::JoyStickEvent &e, int sliderID ) {
	if (getState() != NULL)
		getState()->sliderMoved(e, sliderID);
	return true;
}

bool CStateTask::buttonPressed( const OIS::JoyStickEvent &e, int button ) {
	if (getState() != NULL)
		getState()->buttonPressed(e, button);
	return true;
}

bool CStateTask::buttonReleased( const OIS::JoyStickEvent &e, int button ) {
	if (getState() != NULL)
		getState()->buttonReleased(e, button);
	return true;
}

}
/*
 * CStateTask.h
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#ifndef CSTATETASK_H_
#define CSTATETASK_H_

#include "../Core/ITask.h"
#include "../Core/CTaskManager.h"
#include "../Core/CStateManager.h"

#include "OISMouse.h"
#include "OISKeyboard.h"
#include "OISJoyStick.h"
#include "OISInputManager.h"

#include "boost/smart_ptr.hpp"

namespace Game {

/** Updates current state every frame; passes Input to current frame
@remarks terminates TaskManager if current state is NULL */
class CStateTask: public Game::ITask, public OIS::KeyListener, public OIS::MouseListener, public OIS::JoyStickListener {
public:
	CStateTask();
	virtual ~CStateTask();

	virtual bool Start();
	virtual void Update();
	virtual void Stop();
private:
	inline PState getState() { return CStateManager::GetSingleton().GetCurrentState(); }

	// OIS::KeyListener
    bool keyPressed( const OIS::KeyEvent &e );
    bool keyReleased( const OIS::KeyEvent &e );

    // OIS::MouseListener
    bool mouseMoved( const OIS::MouseEvent &e );
    bool mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id );
    bool mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id );

    // OIS::JoyStickListener
    bool povMoved( const OIS::JoyStickEvent &e, int pov );
    bool axisMoved( const OIS::JoyStickEvent &e, int axis );
    bool sliderMoved( const OIS::JoyStickEvent &e, int sliderID );
    bool buttonPressed( const OIS::JoyStickEvent &e, int button );
    bool buttonReleased( const OIS::JoyStickEvent &e, int button );
};

typedef boost::shared_ptr<CStateTask> PStateTask;

}

#endif /* CSTATETASK_H_ */
/*
 * CTimerTask.cpp
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#include "CTimerTask.h"

namespace Game {

// TODO: maybe use ogre timer or sth instead

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#elif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
	long GetTickCount()
	{
		uint64_t time = mach_absolute_time();

	    // this is the timebase info
	    mach_timebase_info_data_t info;
	    mach_timebase_info(&info);
	    double nano = 1e-9 * ( (double) info.numer) / ((double) info.denom);

	    // so here's the delta in nanoseconds:
	    double nanoSeconds = ((double) time) * nano;

	    // 1000 times that for microSeconds:
	    double microSeconds = 1000.0f * nanoSeconds;

	    return round(microSeconds);

	}
#else
	long GetTickCount()
	{
		struct sysinfo si;
		if (sysinfo(&si) == 0)
			return si.uptime;
		else
			return -1L;
	}
#endif

float CTimerTask::dT = 0;
long CTimerTask::lastFrameIndex = 0;
long CTimerTask::thisFrameIndex = 0;
float CTimerTask::FPS = 0;

CTimerTask::CTimerTask() : lastFPSUpdate(0), nFrames(0)
{
}

CTimerTask::~CTimerTask() {
}

bool CTimerTask::Start() {
	ITask::Start();
	thisFrameIndex = GetTickCount();
	lastFrameIndex = thisFrameIndex;
	dT = 0;
	return true;
}

void CTimerTask::Update()
{
	lastFrameIndex = thisFrameIndex;
	thisFrameIndex = GetTickCount();
	dT = ((float)(thisFrameIndex-lastFrameIndex))/1000.0f;

	// calculate framerate
	if ((thisFrameIndex - lastFPSUpdate) >= 1000)
	{
		FPS = nFrames/((float)(thisFrameIndex - lastFPSUpdate))*1000.0f;

		lastFPSUpdate = thisFrameIndex;
		nFrames = 0;
	}
	else
		nFrames++;
}

void CTimerTask::Stop() {
	ITask::Stop();
}

}
/*
 * CTimerTask.h
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#ifndef CTIMERTASK_H_
#define CTIMERTASK_H_

#include "../Core/ITask.h"
#include "OgrePlatform.h"
#include "boost/smart_ptr.hpp"

#include <math.h>

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
	#include <windows.h>
#elif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
	#include <mach/mach.h>
	#include <mach/mach_time.h>
#else
	#include <sys/sysinfo.h>
#endif

namespace Game {

/** Captures a time stamp in milliseconds every frame
@remarks use this to synchronize animations etc*/
class CTimerTask: public ITask {
private:
	long lastFPSUpdate;
	long nFrames;
public:
	CTimerTask();
	virtual ~CTimerTask();

	/** delta time in seconds*/
	static float dT;

	/** last time stamp in milliseconds*/
	static long lastFrameIndex;

	/** current time stamp in milliseconds*/
	static long thisFrameIndex;

	/** frames per second*/
	static float FPS;

	virtual bool Start();
	virtual void Update();
	virtual void Stop();
};

typedef boost::shared_ptr<CTimerTask> PTimerTask;

}

#endif /* CTIMERTASK_H_ */
/*
 * CVideoTask.cpp
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#include "CVideoTask.h"
#include <iostream>
#include <fstream>
#include "string.h"

namespace Game {

Ogre::Root* CVideoTask::ogreRoot = NULL;
Ogre::RenderWindow* CVideoTask::ogreRenderWindow = NULL;

CVideoTask::CVideoTask() {
}

CVideoTask::~CVideoTask() {
}

bool CVideoTask::Start() {
	assert(ogreRoot == NULL);

	try {
		ogreRoot = new Ogre::Root("","","ogre.log");

		for (PluginListItor it = Plugins.begin(); it != Plugins.end(); ++it) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32 && defined(DEBUG)
			ogreRoot->loadPlugin(*it + "_d");
#else
			ogreRoot->loadPlugin(*it);
#endif
		}

		Ogre::RenderSystemList renderSystems;
		Ogre::RenderSystemList::iterator rsItor;

		renderSystems = ogreRoot->getAvailableRenderers();
		rsItor = renderSystems.begin();
		// TODO: use rsItor to select Render System from config file

		ogreRoot->setRenderSystem(*rsItor);
		ogreRoot->initialise(false);

		// TODO: load settings from config file

		// load settings from config.cfg
		CSettingsManager::GetSingleton().readConfig("config.cfg");

		Ogre::NameValuePairList options = CSettingsManager::GetSingleton().getVideoOptions();

		ogreRenderWindow = ogreRoot->createRenderWindow("Game",
				CSettingsManager::GetSingleton().get<int>("VideoSettings","width",800),
				CSettingsManager::GetSingleton().get<int>("VideoSettings","height",600),
				CSettingsManager::GetSingleton().get<bool>("VideoSettings","fullscreen",false),
				&options);

		Ogre::ResourceGroupManager::getSingleton().addResourceLocation("media/bootstrap/", "FileSystem", "Bootstrap", true);

		Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup("Bootstrap");

		Ogre::ResourceGroupManager::getSingleton().loadResourceGroup("Bootstrap", true, true);

		// create dummy scene
		ogreRenderWindow->removeAllViewports();

		Ogre::SceneManager* sm = ogreRoot->createSceneManager(Ogre::ST_GENERIC, "DummyScene");
		Ogre::Camera* cam = sm->createCamera("DummyCamera");
		Ogre::Viewport* vp = ogreRenderWindow->addViewport(cam);

		vp->setBackgroundColour(Ogre::ColourValue(0.0,0.0,0.0,1.0));

		ogreRenderWindow->setActive(true);

	} catch (Ogre::Exception& ex) {
		CLog::Get().Write("Failed to initialize Video: " + ex.getFullDescription(), CLog::logDebug);
		return false;
	}
	ITask::Start();
	return true;
}


void CVideoTask::Update() {
	ogreRoot->renderOneFrame();
	Ogre::WindowEventUtilities::messagePump();
}

void CVideoTask::Stop() {
	delete ogreRoot;
	ITask::Stop();
}

}
/*
 * CVideoTask.h
 *
 *  Created on: Jun 18, 2010
 *      Author: crt
 */

#ifndef CVIDEOTASK_H_
#define CVIDEOTASK_H_

#include "../Core/ITask.h"
#include "../Core/CLog.h"
#include "../Core/CSettingsManager.h"

#include "Ogre.h"

#include "boost/smart_ptr.hpp"

#include <string>
#include <vector>

namespace Game {

/** Sets up an Ogre Render Context and updates every frame */
class CVideoTask: public Game::ITask {
public:

	typedef std::vector<std::string> PluginList;
	typedef std::vector<std::string>::iterator PluginListItor;

	CVideoTask();
	virtual ~CVideoTask();

	virtual bool Start();
	virtual void Update();
	virtual void Stop();

	/** List of plugins to load
	@remarks Add plugins BEFORE calling Start()
	@remarks When compiled as debug, automatically appends _d on Win32*/
	PluginList Plugins;

	static Ogre::Root* ogreRoot;
	static Ogre::RenderWindow* ogreRenderWindow;
};

typedef boost::shared_ptr<CVideoTask> PVideoTask;

}

#endif /* CVIDEOTASK_H_ */
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 2.8

# Relative path conversion top directories.
SET(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/arne/Quell/Programme/runner-computerspiele-vorlesung")
SET(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/arne/Quell/Programme/runner-computerspiele-vorlesung")

# Force unix paths in dependencies.
SET(CMAKE_FORCE_UNIX_PATHS 1)

# The C and CXX include file search paths:
SET(CMAKE_C_INCLUDE_PATH
  "/usr/include/OIS"
  "/usr/include/boost-1_41"
  "/usr/include/OGRE"
  "dependencies/tinyxml"
  "dependencies/OgreOggSound/include"
  )
SET(CMAKE_CXX_INCLUDE_PATH ${CMAKE_C_INCLUDE_PATH})
SET(CMAKE_Fortran_INCLUDE_PATH ${CMAKE_C_INCLUDE_PATH})

# The C and CXX include file regular expressions for this directory.
SET(CMAKE_C_INCLUDE_REGEX_SCAN "^.*$")
SET(CMAKE_C_INCLUDE_REGEX_COMPLAIN "^$")
SET(CMAKE_CXX_INCLUDE_REGEX_SCAN ${CMAKE_C_INCLUDE_REGEX_SCAN})
SET(CMAKE_CXX_INCLUDE_REGEX_COMPLAIN ${CMAKE_C_INCLUDE_REGEX_COMPLAIN})
# Install script for directory: /home/arne/Quell/Programme/runner-computerspiele-vorlesung/tools/LevelDataConverter

# Set the install prefix
IF(NOT DEFINED CMAKE_INSTALL_PREFIX)
  SET(CMAKE_INSTALL_PREFIX "/usr/local")
ENDIF(NOT DEFINED CMAKE_INSTALL_PREFIX)
STRING(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
IF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  IF(BUILD_TYPE)
    STRING(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  ELSE(BUILD_TYPE)
    SET(CMAKE_INSTALL_CONFIG_NAME "Release")
  ENDIF(BUILD_TYPE)
  MESSAGE(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
ENDIF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)

# Set the component getting installed.
IF(NOT CMAKE_INSTALL_COMPONENT)
  IF(COMPONENT)
    MESSAGE(STATUS "Install component: \"${COMPONENT}\"")
    SET(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  ELSE(COMPONENT)
    SET(CMAKE_INSTALL_COMPONENT)
  ENDIF(COMPONENT)
ENDIF(NOT CMAKE_INSTALL_COMPONENT)

# Install shared libraries without execute permission?
IF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
  SET(CMAKE_INSTALL_SO_NO_EXE "0")
ENDIF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)

/*
 * main.cpp
 *
 *  Created on: Aug 21, 2010
 *      Author: crt
 */

#define TIXML_USE_TICPP
#include "ticpp.h"

#include <iostream>
#include <fstream>

using namespace std;
using namespace ticpp;

/** Check if file exists */
bool fexists(const string& filename)
{
  ifstream ifile(filename.c_str());
  return ifile;
}

void WriteVector(Element& node, const string& name, float x, float y, float z) {
	Element* element = new Element(name);
	element->SetAttribute("x", x);
	element->SetAttribute("y", y);
	element->SetAttribute("z", z);
	node.LinkEndChild(element);
}

void WriteString(Element& node, const string& name, const string& value) {
	Element* element = new Element(name);
	element->SetAttribute("name", value);
	node.LinkEndChild(element);
}

/** Create Template Nodes */
void WriteTemplates(Element& root) {
	Element* templatenode = new Element("template");
		templatenode->SetAttribute("name", "house");
		templatenode->SetAttribute("type", "CustomAABB");
		WriteVector(*templatenode, "position", 0, 0, 0);
		WriteString(*templatenode, "entity", "tudorhouse.mesh");
		WriteVector(*templatenode, "scale", 0.1, 0.1, 0.1);
		WriteVector(*templatenode, "AABBsize", 70, 100, 70);
	root.LinkEndChild(templatenode);

	templatenode = new Element("template");
		templatenode->SetAttribute("name", "cube1");
		templatenode->SetAttribute("type", "CustomAABB");
		WriteVector(*templatenode, "position", 0, 0, 0);
		WriteString(*templatenode, "entity", "cube.mesh");
		WriteString(*templatenode, "material", "Textures/Marmor");
		WriteVector(*templatenode, "scale", 0.1, 0.1, 0.1);
		WriteVector(*templatenode, "AABBsize", 10, 10, 10);
	root.LinkEndChild(templatenode);

	templatenode = new Element("template");
		templatenode->SetAttribute("name", "cube2");
		templatenode->SetAttribute("type", "cube1");
		WriteString(*templatenode, "material", "Textures/Rockwall");
	root.LinkEndChild(templatenode);
}

int main(int argc, char **argv) {
	cout << "*** lvl to xml Level Data converter" << endl;

	string inFile;
	string outFile;

	if (argc == 2) {
		inFile = string(argv[1]);
		outFile = inFile + ".xml";
	} else if (argc == 3) {
		inFile = string(argv[1]);
		outFile = string(argv[2]);
	} else {
		cout << "Invalid command line parameters." << endl;
		cout << "Syntax: " << argv[0] << " [input file] [output file]" << endl;
		return -1;
	}

	if (!fexists(inFile)) {
		cout << "Input file does not exist: " << inFile << endl;
		return -1;
	}

	if (fexists(outFile)) {
		cout << "Output file already exists: " << outFile << endl;
		return -1;
	}

	cout << "Read from: " << inFile << endl;
	cout << "Write to: " << outFile << endl;

	Document doc;

	try {
		Element* root = (Element*)doc.InsertEndChild(Element("leveldata"));
		root->SetAttribute("version", 1);

		// Write Templates
		Element templates("templates");
		WriteTemplates(templates);
		root->InsertEndChild(templates);

		// Write Levelobjects
		Element* levelobjects = new Element("levelobjects");
		Element* object;

		fstream input;
		input.open(inFile.c_str(), std::ios::in);
		string line;

		// start at (5/-5)
		float z = 5;
		float y = -5;

		// parse .lvl file
		while( getline(input,line) ) {
			for (int i = 0; i < line.length(); ++i) {

				if (line[i] == 'H') {   // make house

					object = new Element("object");
					object->SetAttribute("type", "house");
					object->SetAttribute("layer", "static");
					object->SetAttribute("x", 2.0f);
					object->SetAttribute("y", y - 45.0f);
					object->SetAttribute("z", z + 30.0f);
					levelobjects->LinkEndChild(object);

				} else if (std::tolower(line[i]) == 'x' ||
						   std::tolower(line[i]) == 'w') {	// make cube

					// add house in background if lowercase
					if (std::islower(line[i])) {
						object = new Element("object");
						object->SetAttribute("type", "house");
						object->SetAttribute("layer", "background");
						object->SetAttribute("x", 45.0f);
						object->SetAttribute("y", y + 5.0f);
						object->SetAttribute("z", z + 30.0f);
						levelobjects->LinkEndChild(object);
					}

					// create two cubes, one with x=5, one with x=-5
					// (unfortunately ticpp::Element's copy constructor is broken)

					object = new Element("object");

					if (line[i] == 'W' || line[i] == 'w')
						object->SetAttribute("type", "cube2");
					else if (line[i] == 'X' || line[i] == 'x')
						object->SetAttribute("type", "cube1");
					else
						continue;

					object->SetAttribute("layer", "static");
					object->SetAttribute("x", -5.0f);
					object->SetAttribute("y", y);
					object->SetAttribute("z", z);
					levelobjects->LinkEndChild(object);

					object = new Element("object");

					if (line[i] == 'W' || line[i] == 'w')
						object->SetAttribute("type", "cube2");
					else if (line[i] == 'X' || line[i] == 'x')
						object->SetAttribute("type", "cube1");
					else
						continue;

					object->SetAttribute("layer", "background");
					object->SetAttribute("x", 5.0f);
					object->SetAttribute("y", y);
					object->SetAttribute("z", z);
					levelobjects->LinkEndChild(object);

				}

				// go right 10 each character
				z += 10.0f;
			}

			// go down 10 each line and reset z
			y -= 10.0f;
			z = 5.0f;
		}

		input.close();

		root->LinkEndChild(levelobjects);

		// save
		doc.SaveFile(outFile);
	} catch( ticpp::Exception& ex ) {
		cout << "Error: " << ex.what() << endl;
	} catch( std::exception& ex ) {
		cout << "Error: " << ex.what() << endl;
	} catch(...) {
		cout << "Unknown error." << endl;
	}

	cout << "Done. No Errors." << endl;

	return 0;
}
cmd_drivers/net/ixgb/ixgb_ethtool.o := gcc -Wp,-MD,drivers/net/ixgb/.ixgb_ethtool.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(ixgb_ethtool)"  -D"KBUILD_MODNAME=KBUILD_STR(ixgb)"  -c -o drivers/net/ixgb/.tmp_ixgb_ethtool.o drivers/net/ixgb/ixgb_ethtool.c

deps_drivers/net/ixgb/ixgb_ethtool.o := \
  drivers/net/ixgb/ixgb_ethtool.c \
  drivers/net/ixgb/ixgb.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/mm.h \
    $(wildcard include/config/sysctl.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/rbtree.h \
  include/linux/prio_tree.h \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mm/owner.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/s390.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  include/linux/pci.h \
    $(wildcard include/config/pci/iov.h) \
    $(wildcard include/config/pcieaspm.h) \
    $(wildcard include/config/pci/msi.h) \
    $(wildcard include/config/pci.h) \
    $(wildcard include/config/pcie/ecrc.h) \
    $(wildcard include/config/ht/irq.h) \
    $(wildcard include/config/pci/domains.h) \
    $(wildcard include/config/pci/quirks.h) \
    $(wildcard include/config/hotplug/pci.h) \
  include/linux/pci_regs.h \
  include/linux/mod_devicetable.h \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/io.h \
    $(wildcard include/config/has/ioport.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  include/linux/irqreturn.h \
  include/linux/pci_ids.h \
  include/linux/pci-dma.h \
  include/linux/dmapool.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/scatterlist.h \
  include/asm-generic/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
    $(wildcard include/config/need/sg/dma/length.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci_64.h \
    $(wildcard include/config/calgary/iommu.h) \
  include/asm-generic/pci-dma-compat.h \
  include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  include/linux/dma-attrs.h \
  include/linux/bug.h \
  include/linux/scatterlist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/dma-mapping.h \
    $(wildcard include/config/isa.h) \
  include/linux/kmemcheck.h \
  include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swiotlb.h \
    $(wildcard include/config/swiotlb.h) \
  include/linux/swiotlb.h \
  include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  include/asm-generic/dma-mapping-common.h \
  include/asm-generic/pci.h \
  include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/tr.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/net/dsa/tag/dsa.h) \
    $(wildcard include/config/net/dsa/tag/trailer.h) \
    $(wildcard include/config/netpoll/trap.h) \
  include/linux/if.h \
  include/linux/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/socket.h \
  include/asm-generic/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sockios.h \
  include/asm-generic/sockios.h \
  include/linux/sockios.h \
  include/linux/uio.h \
  include/linux/hdlc/ioctl.h \
  include/linux/if_ether.h \
  include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/dma.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
  include/linux/net.h \
  include/linux/random.h \
  include/linux/irqnr.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/sysctl.h \
  include/linux/ratelimit.h \
  include/linux/textsearch.h \
  include/net/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum_64.h \
  include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/disable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/if_packet.h \
  include/linux/if_link.h \
  include/linux/netlink.h \
  include/linux/capability.h \
  include/linux/pm_qos_params.h \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/miscdevice.h \
  include/linux/major.h \
  include/linux/rculist.h \
  include/linux/ethtool.h \
  include/net/net_namespace.h \
    $(wildcard include/config/ipv6.h) \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/wext/core.h) \
    $(wildcard include/config/net.h) \
  include/net/netns/core.h \
  include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  include/net/snmp.h \
  include/linux/snmp.h \
  include/linux/u64_stats_sync.h \
  include/net/netns/unix.h \
  include/net/netns/packet.h \
  include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/security.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  include/net/inet_frag.h \
  include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  include/net/dst_ops.h \
  include/net/netns/dccp.h \
  include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  include/linux/netfilter.h \
    $(wildcard include/config/netfilter/debug.h) \
    $(wildcard include/config/nf/nat/needed.h) \
  include/linux/in.h \
  include/linux/in6.h \
  include/net/flow.h \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/path.h \
  include/linux/radix-tree.h \
  include/linux/pid.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/percpu_counter.h \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/magic.h \
  include/net/netns/conntrack.h \
  include/linux/list_nulls.h \
  include/net/netns/xfrm.h \
  include/linux/xfrm.h \
  include/linux/seq_file_net.h \
  include/linux/seq_file.h \
  include/net/dsa.h \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/hardirq.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/cgroup/sched.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/proportions.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
  include/linux/key.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  include/linux/etherdevice.h \
    $(wildcard include/config/have/efficient/unaligned/access.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unaligned.h \
  include/linux/unaligned/access_ok.h \
  include/linux/unaligned/generic.h \
  include/linux/pagemap.h \
  include/linux/highmem.h \
    $(wildcard include/config/debug/highmem.h) \
  include/linux/uaccess.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cacheflush.h \
    $(wildcard include/config/x86/pat.h) \
    $(wildcard include/config/debug/rodata/test.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/kmap_types.h \
  include/asm-generic/kmap_types.h \
  include/linux/hugetlb_inline.h \
  include/linux/ip.h \
  include/linux/tcp.h \
    $(wildcard include/config/tcp/md5sig.h) \
  include/net/sock.h \
  include/linux/security.h \
    $(wildcard include/config/security/path.h) \
    $(wildcard include/config/security/network.h) \
    $(wildcard include/config/security/network/xfrm.h) \
    $(wildcard include/config/securityfs.h) \
  include/linux/fsnotify.h \
  include/linux/fsnotify_backend.h \
    $(wildcard include/config/fanotify.h) \
    $(wildcard include/config/fanotify/access/permissions.h) \
  include/linux/idr.h \
  include/linux/audit.h \
    $(wildcard include/config/change.h) \
  include/linux/binfmts.h \
  include/linux/shm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/shmparam.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/shmbuf.h \
  include/asm-generic/shmbuf.h \
  include/linux/msg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msgbuf.h \
  include/asm-generic/msgbuf.h \
  include/linux/filter.h \
  include/linux/rculist_nulls.h \
  include/linux/poll.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/poll.h \
  include/asm-generic/poll.h \
  include/net/dst.h \
    $(wildcard include/config/net/cls/route.h) \
  include/linux/rtnetlink.h \
  include/linux/if_addr.h \
  include/linux/neighbour.h \
  include/net/neighbour.h \
  include/net/rtnetlink.h \
  include/net/netlink.h \
  include/net/inet_connection_sock.h \
  include/net/inet_sock.h \
  include/linux/jhash.h \
  include/net/request_sock.h \
  include/net/netns/hash.h \
  include/net/inet_timewait_sock.h \
  include/net/tcp_states.h \
  include/net/timewait_sock.h \
  include/linux/udp.h \
  include/net/pkt_sched.h \
  include/net/sch_generic.h \
  include/linux/pkt_sched.h \
  include/linux/pkt_cls.h \
    $(wildcard include/config/net/cls/ind.h) \
  include/net/gen_stats.h \
  include/linux/gen_stats.h \
  include/linux/reboot.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/emergency-restart.h \
  include/linux/if_vlan.h \
    $(wildcard include/config/vlan/8021q.h) \
  drivers/net/ixgb/ixgb_hw.h \
  include/linux/mdio.h \
  include/linux/mii.h \
  drivers/net/ixgb/ixgb_osdep.h \
  drivers/net/ixgb/ixgb_ee.h \
  drivers/net/ixgb/ixgb_ids.h \

drivers/net/ixgb/ixgb_ethtool.o: $(deps_drivers/net/ixgb/ixgb_ethtool.o)

$(deps_drivers/net/ixgb/ixgb_ethtool.o):
/*
 *  DIO Driver Services
 *
 *  Copyright (C) 2004 Jochen Friedrich
 *
 *  Loosely based on drivers/pci/pci-driver.c and drivers/zorro/zorro-driver.c
 *
 *  This file is subject to the terms and conditions of the GNU General Public
 *  License.  See the file COPYING in the main directory of this archive
 *  for more details.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/dio.h>


/**
 *  dio_match_device - Tell if a DIO device structure has a matching DIO device id structure
 *  @ids: array of DIO device id structures to search in
 *  @d: the DIO device structure to match against
 *
 *  Used by a driver to check whether a DIO device present in the
 *  system is in its list of supported devices. Returns the matching
 *  dio_device_id structure or %NULL if there is no match.
 */

const struct dio_device_id *
dio_match_device(const struct dio_device_id *ids,
		   const struct dio_dev *d)
{
	while (ids->id) {
		if (ids->id == DIO_WILDCARD)
			return ids;
		if (DIO_NEEDSSECID(ids->id & 0xff)) {
			if (ids->id == d->id)
				return ids;
		} else {
			if ((ids->id & 0xff) == (d->id & 0xff))
				return ids;
		}
		ids++;
	}
	return NULL;
}

static int dio_device_probe(struct device *dev)
{
	int error = 0;
	struct dio_driver *drv = to_dio_driver(dev->driver);
	struct dio_dev *d = to_dio_dev(dev);

	if (!d->driver && drv->probe) {
		const struct dio_device_id *id;

		id = dio_match_device(drv->id_table, d);
		if (id)
			error = drv->probe(d, id);
		if (error >= 0) {
			d->driver = drv;
			error = 0;
		}
	}
	return error;
}


/**
 *  dio_register_driver - register a new DIO driver
 *  @drv: the driver structure to register
 *
 *  Adds the driver structure to the list of registered drivers
 *  Returns zero or a negative error value.
 */

int dio_register_driver(struct dio_driver *drv)
{
	/* initialize common driver fields */
	drv->driver.name = drv->name;
	drv->driver.bus = &dio_bus_type;

	/* register with core */
	return driver_register(&drv->driver);
}


/**
 *  dio_unregister_driver - unregister a DIO driver
 *  @drv: the driver structure to unregister
 *
 *  Deletes the driver structure from the list of registered DIO drivers,
 *  gives it a chance to clean up by calling its remove() function for
 *  each device it was responsible for, and marks those devices as
 *  driverless.
 */

void dio_unregister_driver(struct dio_driver *drv)
{
	driver_unregister(&drv->driver);
}


/**
 *  dio_bus_match - Tell if a DIO device structure has a matching DIO device id structure
 *  @dev: the DIO device structure to match against
 *  @drv: the &device_driver that points to the array of DIO device id structures to search
 *
 *  Used by a driver to check whether a DIO device present in the
 *  system is in its list of supported devices. Returns the matching
 *  dio_device_id structure or %NULL if there is no match.
 */

static int dio_bus_match(struct device *dev, struct device_driver *drv)
{
	struct dio_dev *d = to_dio_dev(dev);
	struct dio_driver *dio_drv = to_dio_driver(drv);
	const struct dio_device_id *ids = dio_drv->id_table;

	if (!ids)
		return 0;

	return dio_match_device(ids, d) ? 1 : 0;
}


struct bus_type dio_bus_type = {
	.name	= "dio",
	.match	= dio_bus_match,
	.probe	= dio_device_probe,
};


static int __init dio_driver_init(void)
{
	return bus_register(&dio_bus_type);
}

postcore_initcall(dio_driver_init);

EXPORT_SYMBOL(dio_match_device);
EXPORT_SYMBOL(dio_register_driver);
EXPORT_SYMBOL(dio_unregister_driver);
EXPORT_SYMBOL(dio_bus_type);
/*
 * I'm tired of doing "vsnprintf()" etc just to open a
 * file, so here's a "return static buffer with printf"
 * interface for paths.
 *
 * It's obviously not thread-safe. Sue me. But it's quite
 * useful for doing things like
 *
 *   f = open(mkpath("%s/%s.perf", base, name), O_RDONLY);
 *
 * which is what it's designed for.
 */
#include "cache.h"

static char bad_path[] = "/bad-path/";
/*
 * Two hacks:
 */

static const char *get_perf_dir(void)
{
	return ".";
}

size_t strlcpy(char *dest, const char *src, size_t size)
{
	size_t ret = strlen(src);

	if (size) {
		size_t len = (ret >= size) ? size - 1 : ret;
		memcpy(dest, src, len);
		dest[len] = '\0';
	}
	return ret;
}


static char *get_pathname(void)
{
	static char pathname_array[4][PATH_MAX];
	static int idx;

	return pathname_array[3 & ++idx];
}

static char *cleanup_path(char *path)
{
	/* Clean it up */
	if (!memcmp(path, "./", 2)) {
		path += 2;
		while (*path == '/')
			path++;
	}
	return path;
}

static char *perf_vsnpath(char *buf, size_t n, const char *fmt, va_list args)
{
	const char *perf_dir = get_perf_dir();
	size_t len;

	len = strlen(perf_dir);
	if (n < len + 1)
		goto bad;
	memcpy(buf, perf_dir, len);
	if (len && !is_dir_sep(perf_dir[len-1]))
		buf[len++] = '/';
	len += vsnprintf(buf + len, n - len, fmt, args);
	if (len >= n)
		goto bad;
	return cleanup_path(buf);
bad:
	strlcpy(buf, bad_path, n);
	return buf;
}

char *perf_pathdup(const char *fmt, ...)
{
	char path[PATH_MAX];
	va_list args;
	va_start(args, fmt);
	(void)perf_vsnpath(path, sizeof(path), fmt, args);
	va_end(args);
	return xstrdup(path);
}

char *mkpath(const char *fmt, ...)
{
	va_list args;
	unsigned len;
	char *pathname = get_pathname();

	va_start(args, fmt);
	len = vsnprintf(pathname, PATH_MAX, fmt, args);
	va_end(args);
	if (len >= PATH_MAX)
		return bad_path;
	return cleanup_path(pathname);
}

char *perf_path(const char *fmt, ...)
{
	const char *perf_dir = get_perf_dir();
	char *pathname = get_pathname();
	va_list args;
	unsigned len;

	len = strlen(perf_dir);
	if (len > PATH_MAX-100)
		return bad_path;
	memcpy(pathname, perf_dir, len);
	if (len && perf_dir[len-1] != '/')
		pathname[len++] = '/';
	va_start(args, fmt);
	len += vsnprintf(pathname + len, PATH_MAX - len, fmt, args);
	va_end(args);
	if (len >= PATH_MAX)
		return bad_path;
	return cleanup_path(pathname);
}

/* strip arbitrary amount of directory separators at end of path */
static inline int chomp_trailing_dir_sep(const char *path, int len)
{
	while (len && is_dir_sep(path[len - 1]))
		len--;
	return len;
}

/*
 * If path ends with suffix (complete path components), returns the
 * part before suffix (sans trailing directory separators).
 * Otherwise returns NULL.
 */
char *strip_path_suffix(const char *path, const char *suffix)
{
	int path_len = strlen(path), suffix_len = strlen(suffix);

	while (suffix_len) {
		if (!path_len)
			return NULL;

		if (is_dir_sep(path[path_len - 1])) {
			if (!is_dir_sep(suffix[suffix_len - 1]))
				return NULL;
			path_len = chomp_trailing_dir_sep(path, path_len);
			suffix_len = chomp_trailing_dir_sep(suffix, suffix_len);
		}
		else if (path[--path_len] != suffix[--suffix_len])
			return NULL;
	}

	if (path_len && !is_dir_sep(path[path_len - 1]))
		return NULL;
	return strndup(path, chomp_trailing_dir_sep(path, path_len));
}
/**
 * @file backtrace.c
 *
 * @remark Copyright 2002 OProfile authors
 * @remark Read the file COPYING
 *
 * @author John Levon
 * @author David Smith
 */

#include <linux/oprofile.h>
#include <linux/sched.h>
#include <linux/mm.h>
#include <asm/ptrace.h>
#include <asm/uaccess.h>
#include <asm/stacktrace.h>

static void backtrace_warning_symbol(void *data, char *msg,
				     unsigned long symbol)
{
	/* Ignore warnings */
}

static void backtrace_warning(void *data, char *msg)
{
	/* Ignore warnings */
}

static int backtrace_stack(void *data, char *name)
{
	/* Yes, we want all stacks */
	return 0;
}

static void backtrace_address(void *data, unsigned long addr, int reliable)
{
	unsigned int *depth = data;

	if ((*depth)--)
		oprofile_add_trace(addr);
}

static struct stacktrace_ops backtrace_ops = {
	.warning	= backtrace_warning,
	.warning_symbol	= backtrace_warning_symbol,
	.stack		= backtrace_stack,
	.address	= backtrace_address,
	.walk_stack	= print_context_stack,
};

struct frame_head {
	struct frame_head *bp;
	unsigned long ret;
} __attribute__((packed));

static struct frame_head *dump_user_backtrace(struct frame_head *head)
{
	struct frame_head bufhead[2];

	/* Also check accessibility of one struct frame_head beyond */
	if (!access_ok(VERIFY_READ, head, sizeof(bufhead)))
		return NULL;
	if (__copy_from_user_inatomic(bufhead, head, sizeof(bufhead)))
		return NULL;

	oprofile_add_trace(bufhead[0].ret);

	/* frame pointers should strictly progress back up the stack
	 * (towards higher addresses) */
	if (head >= bufhead[0].bp)
		return NULL;

	return bufhead[0].bp;
}

void
x86_backtrace(struct pt_regs * const regs, unsigned int depth)
{
	struct frame_head *head = (struct frame_head *)frame_pointer(regs);

	if (!user_mode_vm(regs)) {
		unsigned long stack = kernel_stack_pointer(regs);
		if (depth)
			dump_trace(NULL, regs, (unsigned long *)stack, 0,
				   &backtrace_ops, &depth);
		return;
	}

	while (depth-- && head)
		head = dump_user_backtrace(head);
}
cmd_drivers/media/video/uvc/uvc_v4l2.o := gcc -Wp,-MD,drivers/media/video/uvc/.uvc_v4l2.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(uvc_v4l2)"  -D"KBUILD_MODNAME=KBUILD_STR(uvcvideo)"  -c -o drivers/media/video/uvc/.tmp_uvc_v4l2.o drivers/media/video/uvc/uvc_v4l2.c

deps_drivers/media/video/uvc/uvc_v4l2.o := \
  drivers/media/video/uvc/uvc_v4l2.c \
  include/linux/kernel.h \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/linkage.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/32.h) \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  include/linux/stddef.h \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/paravirt.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/linux/version.h \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/linux/usb.h \
    $(wildcard include/config/usb/devicefs.h) \
    $(wildcard include/config/usb/mon.h) \
    $(wildcard include/config/usb/device/class.h) \
    $(wildcard include/config/pm.h) \
    $(wildcard include/config/usb/suspend.h) \
  include/linux/mod_devicetable.h \
  include/linux/usb/ch9.h \
    $(wildcard include/config/size.h) \
    $(wildcard include/config/att/one.h) \
    $(wildcard include/config/att/selfpower.h) \
    $(wildcard include/config/att/wakeup.h) \
    $(wildcard include/config/att/battery.h) \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/irqreturn.h \
  include/linux/irqnr.h \
  include/linux/hardirq.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  include/linux/capability.h \
  include/linux/rbtree.h \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/prio_tree.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/s390.h) \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/radix-tree.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/videodev2.h \
    $(wildcard include/config/video/adv/debug.h) \
  include/linux/vmalloc.h \
  include/linux/mm.h \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  include/media/v4l2-common.h \
    $(wildcard include/config/spi.h) \
  include/media/v4l2-dev.h \
  include/linux/poll.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/poll.h \
  include/asm-generic/poll.h \
  include/linux/cdev.h \
  include/media/v4l2-ioctl.h \
    $(wildcard include/config/video/v4l1/compat.h) \
  include/linux/videodev.h \
  drivers/media/video/uvc/uvcvideo.h \
  include/linux/usb/video.h \

drivers/media/video/uvc/uvc_v4l2.o: $(deps_drivers/media/video/uvc/uvc_v4l2.o)

$(deps_drivers/media/video/uvc/uvc_v4l2.o):
/*
 * zfcp device driver
 *
 * Data structure and helper functions for tracking pending FSF
 * requests.
 *
 * Copyright IBM Corporation 2009
 */

#ifndef ZFCP_REQLIST_H
#define ZFCP_REQLIST_H

/* number of hash buckets */
#define ZFCP_REQ_LIST_BUCKETS 128

/**
 * struct zfcp_reqlist - Container for request list (reqlist)
 * @lock: Spinlock for protecting the hash list
 * @list: Array of hashbuckets, each is a list of requests in this bucket
 */
struct zfcp_reqlist {
	spinlock_t lock;
	struct list_head buckets[ZFCP_REQ_LIST_BUCKETS];
};

static inline int zfcp_reqlist_hash(unsigned long req_id)
{
	return req_id % ZFCP_REQ_LIST_BUCKETS;
}

/**
 * zfcp_reqlist_alloc - Allocate and initialize reqlist
 *
 * Returns pointer to allocated reqlist on success, or NULL on
 * allocation failure.
 */
static inline struct zfcp_reqlist *zfcp_reqlist_alloc(void)
{
	unsigned int i;
	struct zfcp_reqlist *rl;

	rl = kzalloc(sizeof(struct zfcp_reqlist), GFP_KERNEL);
	if (!rl)
		return NULL;

	spin_lock_init(&rl->lock);

	for (i = 0; i < ZFCP_REQ_LIST_BUCKETS; i++)
		INIT_LIST_HEAD(&rl->buckets[i]);

	return rl;
}

/**
 * zfcp_reqlist_isempty - Check whether the request list empty
 * @rl: pointer to reqlist
 *
 * Returns: 1 if list is empty, 0 if not
 */
static inline int zfcp_reqlist_isempty(struct zfcp_reqlist *rl)
{
	unsigned int i;

	for (i = 0; i < ZFCP_REQ_LIST_BUCKETS; i++)
		if (!list_empty(&rl->buckets[i]))
			return 0;
	return 1;
}

/**
 * zfcp_reqlist_free - Free allocated memory for reqlist
 * @rl: The reqlist where to free memory
 */
static inline void zfcp_reqlist_free(struct zfcp_reqlist *rl)
{
	/* sanity check */
	BUG_ON(!zfcp_reqlist_isempty(rl));

	kfree(rl);
}

static inline struct zfcp_fsf_req *
_zfcp_reqlist_find(struct zfcp_reqlist *rl, unsigned long req_id)
{
	struct zfcp_fsf_req *req;
	unsigned int i;

	i = zfcp_reqlist_hash(req_id);
	list_for_each_entry(req, &rl->buckets[i], list)
		if (req->req_id == req_id)
			return req;
	return NULL;
}

/**
 * zfcp_reqlist_find - Lookup FSF request by its request id
 * @rl: The reqlist where to lookup the FSF request
 * @req_id: The request id to look for
 *
 * Returns a pointer to the FSF request with the specified request id
 * or NULL if there is no known FSF request with this id.
 */
static inline struct zfcp_fsf_req *
zfcp_reqlist_find(struct zfcp_reqlist *rl, unsigned long req_id)
{
	unsigned long flags;
	struct zfcp_fsf_req *req;

	spin_lock_irqsave(&rl->lock, flags);
	req = _zfcp_reqlist_find(rl, req_id);
	spin_unlock_irqrestore(&rl->lock, flags);

	return req;
}

/**
 * zfcp_reqlist_find_rm - Lookup request by id and remove it from reqlist
 * @rl: reqlist where to search and remove entry
 * @req_id: The request id of the request to look for
 *
 * This functions tries to find the FSF request with the specified
 * id and then removes it from the reqlist. The reqlist lock is held
 * during both steps of the operation.
 *
 * Returns: Pointer to the FSF request if the request has been found,
 * NULL if it has not been found.
 */
static inline struct zfcp_fsf_req *
zfcp_reqlist_find_rm(struct zfcp_reqlist *rl, unsigned long req_id)
{
	unsigned long flags;
	struct zfcp_fsf_req *req;

	spin_lock_irqsave(&rl->lock, flags);
	req = _zfcp_reqlist_find(rl, req_id);
	if (req)
		list_del(&req->list);
	spin_unlock_irqrestore(&rl->lock, flags);

	return req;
}

/**
 * zfcp_reqlist_add - Add entry to reqlist
 * @rl: reqlist where to add the entry
 * @req: The entry to add
 *
 * The request id always increases. As an optimization new requests
 * are added here with list_add_tail at the end of the bucket lists
 * while old requests are looked up starting at the beginning of the
 * lists.
 */
static inline void zfcp_reqlist_add(struct zfcp_reqlist *rl,
				    struct zfcp_fsf_req *req)
{
	unsigned int i;
	unsigned long flags;

	i = zfcp_reqlist_hash(req->req_id);

	spin_lock_irqsave(&rl->lock, flags);
	list_add_tail(&req->list, &rl->buckets[i]);
	spin_unlock_irqrestore(&rl->lock, flags);
}

/**
 * zfcp_reqlist_move - Move all entries from reqlist to simple list
 * @rl: The zfcp_reqlist where to remove all entries
 * @list: The list where to move all entries
 */
static inline void zfcp_reqlist_move(struct zfcp_reqlist *rl,
				     struct list_head *list)
{
	unsigned int i;
	unsigned long flags;

	spin_lock_irqsave(&rl->lock, flags);
	for (i = 0; i < ZFCP_REQ_LIST_BUCKETS; i++)
		list_splice_init(&rl->buckets[i], list);
	spin_unlock_irqrestore(&rl->lock, flags);
}

#endif /* ZFCP_REQLIST_H */
/*
 * k8temp.c - Linux kernel module for hardware monitoring
 *
 * Copyright (C) 2006 Rudolf Marek <r.marek@assembler.cz>
 *
 * Inspired from the w83785 and amd756 drivers.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <linux/module.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/jiffies.h>
#include <linux/pci.h>
#include <linux/hwmon.h>
#include <linux/hwmon-sysfs.h>
#include <linux/err.h>
#include <linux/mutex.h>
#include <asm/processor.h>

#define TEMP_FROM_REG(val)	(((((val) >> 16) & 0xff) - 49) * 1000)
#define REG_TEMP	0xe4
#define SEL_PLACE	0x40
#define SEL_CORE	0x04

struct k8temp_data {
	struct device *hwmon_dev;
	struct mutex update_lock;
	const char *name;
	char valid;		/* zero until following fields are valid */
	unsigned long last_updated;	/* in jiffies */

	/* registers values */
	u8 sensorsp;		/* sensor presence bits - SEL_CORE & SEL_PLACE */
	u32 temp[2][2];		/* core, place */
	u8 swap_core_select;    /* meaning of SEL_CORE is inverted */
	u32 temp_offset;
};

static struct k8temp_data *k8temp_update_device(struct device *dev)
{
	struct k8temp_data *data = dev_get_drvdata(dev);
	struct pci_dev *pdev = to_pci_dev(dev);
	u8 tmp;

	mutex_lock(&data->update_lock);

	if (!data->valid
	    || time_after(jiffies, data->last_updated + HZ)) {
		pci_read_config_byte(pdev, REG_TEMP, &tmp);
		tmp &= ~(SEL_PLACE | SEL_CORE);		/* Select sensor 0, core0 */
		pci_write_config_byte(pdev, REG_TEMP, tmp);
		pci_read_config_dword(pdev, REG_TEMP, &data->temp[0][0]);

		if (data->sensorsp & SEL_PLACE) {
			tmp |= SEL_PLACE;	/* Select sensor 1, core0 */
			pci_write_config_byte(pdev, REG_TEMP, tmp);
			pci_read_config_dword(pdev, REG_TEMP,
					      &data->temp[0][1]);
		}

		if (data->sensorsp & SEL_CORE) {
			tmp &= ~SEL_PLACE;	/* Select sensor 0, core1 */
			tmp |= SEL_CORE;
			pci_write_config_byte(pdev, REG_TEMP, tmp);
			pci_read_config_dword(pdev, REG_TEMP,
					      &data->temp[1][0]);

			if (data->sensorsp & SEL_PLACE) {
				tmp |= SEL_PLACE;	/* Select sensor 1, core1 */
				pci_write_config_byte(pdev, REG_TEMP, tmp);
				pci_read_config_dword(pdev, REG_TEMP,
						      &data->temp[1][1]);
			}
		}

		data->last_updated = jiffies;
		data->valid = 1;
	}

	mutex_unlock(&data->update_lock);
	return data;
}

/*
 * Sysfs stuff
 */

static ssize_t show_name(struct device *dev, struct device_attribute
			 *devattr, char *buf)
{
	struct k8temp_data *data = dev_get_drvdata(dev);

	return sprintf(buf, "%s\n", data->name);
}


static ssize_t show_temp(struct device *dev,
			 struct device_attribute *devattr, char *buf)
{
	struct sensor_device_attribute_2 *attr =
	    to_sensor_dev_attr_2(devattr);
	int core = attr->nr;
	int place = attr->index;
	int temp;
	struct k8temp_data *data = k8temp_update_device(dev);

	if (data->swap_core_select && (data->sensorsp & SEL_CORE))
		core = core ? 0 : 1;

	temp = TEMP_FROM_REG(data->temp[core][place]) + data->temp_offset;

	return sprintf(buf, "%d\n", temp);
}

/* core, place */

static SENSOR_DEVICE_ATTR_2(temp1_input, S_IRUGO, show_temp, NULL, 0, 0);
static SENSOR_DEVICE_ATTR_2(temp2_input, S_IRUGO, show_temp, NULL, 0, 1);
static SENSOR_DEVICE_ATTR_2(temp3_input, S_IRUGO, show_temp, NULL, 1, 0);
static SENSOR_DEVICE_ATTR_2(temp4_input, S_IRUGO, show_temp, NULL, 1, 1);
static DEVICE_ATTR(name, S_IRUGO, show_name, NULL);

static const struct pci_device_id k8temp_ids[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB_MISC) },
	{ 0 },
};

MODULE_DEVICE_TABLE(pci, k8temp_ids);

static int __devinit is_rev_g_desktop(u8 model)
{
	u32 brandidx;

	if (model < 0x69)
		return 0;

	if (model == 0xc1 || model == 0x6c || model == 0x7c)
		return 0;

	/*
	 * Differentiate between AM2 and ASB1.
	 * See "Constructing the processor Name String" in "Revision
	 * Guide for AMD NPT Family 0Fh Processors" (33610).
	 */
	brandidx = cpuid_ebx(0x80000001);
	brandidx = (brandidx >> 9) & 0x1f;

	/* Single core */
	if ((model == 0x6f || model == 0x7f) &&
	    (brandidx == 0x7 || brandidx == 0x9 || brandidx == 0xc))
		return 0;

	/* Dual core */
	if (model == 0x6b &&
	    (brandidx == 0xb || brandidx == 0xc))
		return 0;

	return 1;
}

static int __devinit k8temp_probe(struct pci_dev *pdev,
				  const struct pci_device_id *id)
{
	int err;
	u8 scfg;
	u32 temp;
	u8 model, stepping;
	struct k8temp_data *data;

	if (!(data = kzalloc(sizeof(struct k8temp_data), GFP_KERNEL))) {
		err = -ENOMEM;
		goto exit;
	}

	model = boot_cpu_data.x86_model;
	stepping = boot_cpu_data.x86_mask;

	switch (boot_cpu_data.x86) {
	case 0xf:
		/* feature available since SH-C0, exclude older revisions */
		if (((model == 4) && (stepping == 0)) ||
		    ((model == 5) && (stepping <= 1))) {
			err = -ENODEV;
			goto exit_free;
		}

		/*
		 * AMD NPT family 0fh, i.e. RevF and RevG:
		 * meaning of SEL_CORE bit is inverted
		 */
		if (model >= 0x40) {
			data->swap_core_select = 1;
			dev_warn(&pdev->dev, "Temperature readouts might be "
				 "wrong - check erratum #141\n");
		}

		if (is_rev_g_desktop(model)) {
			/*
			 * RevG desktop CPUs (i.e. no socket S1G1 or
			 * ASB1 parts) need additional offset,
			 * otherwise reported temperature is below
			 * ambient temperature
			 */
			data->temp_offset = 21000;
		}

		break;
	}

	pci_read_config_byte(pdev, REG_TEMP, &scfg);
	scfg &= ~(SEL_PLACE | SEL_CORE);		/* Select sensor 0, core0 */
	pci_write_config_byte(pdev, REG_TEMP, scfg);
	pci_read_config_byte(pdev, REG_TEMP, &scfg);

	if (scfg & (SEL_PLACE | SEL_CORE)) {
		dev_err(&pdev->dev, "Configuration bit(s) stuck at 1!\n");
		err = -ENODEV;
		goto exit_free;
	}

	scfg |= (SEL_PLACE | SEL_CORE);
	pci_write_config_byte(pdev, REG_TEMP, scfg);

	/* now we know if we can change core and/or sensor */
	pci_read_config_byte(pdev, REG_TEMP, &data->sensorsp);

	if (data->sensorsp & SEL_PLACE) {
		scfg &= ~SEL_CORE;	/* Select sensor 1, core0 */
		pci_write_config_byte(pdev, REG_TEMP, scfg);
		pci_read_config_dword(pdev, REG_TEMP, &temp);
		scfg |= SEL_CORE;	/* prepare for next selection */
		if (!((temp >> 16) & 0xff))	/* if temp is 0 -49C is not likely */
			data->sensorsp &= ~SEL_PLACE;
	}

	if (data->sensorsp & SEL_CORE) {
		scfg &= ~SEL_PLACE;	/* Select sensor 0, core1 */
		pci_write_config_byte(pdev, REG_TEMP, scfg);
		pci_read_config_dword(pdev, REG_TEMP, &temp);
		if (!((temp >> 16) & 0xff))	/* if temp is 0 -49C is not likely */
			data->sensorsp &= ~SEL_CORE;
	}

	data->name = "k8temp";
	mutex_init(&data->update_lock);
	dev_set_drvdata(&pdev->dev, data);

	/* Register sysfs hooks */
	err = device_create_file(&pdev->dev,
			   &sensor_dev_attr_temp1_input.dev_attr);
	if (err)
		goto exit_remove;

	/* sensor can be changed and reports something */
	if (data->sensorsp & SEL_PLACE) {
		err = device_create_file(&pdev->dev,
				   &sensor_dev_attr_temp2_input.dev_attr);
		if (err)
			goto exit_remove;
	}

	/* core can be changed and reports something */
	if (data->sensorsp & SEL_CORE) {
		err = device_create_file(&pdev->dev,
				   &sensor_dev_attr_temp3_input.dev_attr);
		if (err)
			goto exit_remove;
		if (data->sensorsp & SEL_PLACE) {
			err = device_create_file(&pdev->dev,
					   &sensor_dev_attr_temp4_input.
					   dev_attr);
			if (err)
				goto exit_remove;
		}
	}

	err = device_create_file(&pdev->dev, &dev_attr_name);
	if (err)
		goto exit_remove;

	data->hwmon_dev = hwmon_device_register(&pdev->dev);

	if (IS_ERR(data->hwmon_dev)) {
		err = PTR_ERR(data->hwmon_dev);
		goto exit_remove;
	}

	return 0;

exit_remove:
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp1_input.dev_attr);
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp2_input.dev_attr);
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp3_input.dev_attr);
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp4_input.dev_attr);
	device_remove_file(&pdev->dev, &dev_attr_name);
exit_free:
	dev_set_drvdata(&pdev->dev, NULL);
	kfree(data);
exit:
	return err;
}

static void __devexit k8temp_remove(struct pci_dev *pdev)
{
	struct k8temp_data *data = dev_get_drvdata(&pdev->dev);

	hwmon_device_unregister(data->hwmon_dev);
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp1_input.dev_attr);
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp2_input.dev_attr);
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp3_input.dev_attr);
	device_remove_file(&pdev->dev,
			   &sensor_dev_attr_temp4_input.dev_attr);
	device_remove_file(&pdev->dev, &dev_attr_name);
	dev_set_drvdata(&pdev->dev, NULL);
	kfree(data);
}

static struct pci_driver k8temp_driver = {
	.name = "k8temp",
	.id_table = k8temp_ids,
	.probe = k8temp_probe,
	.remove = __devexit_p(k8temp_remove),
};

static int __init k8temp_init(void)
{
	return pci_register_driver(&k8temp_driver);
}

static void __exit k8temp_exit(void)
{
	pci_unregister_driver(&k8temp_driver);
}

MODULE_AUTHOR("Rudolf Marek <r.marek@assembler.cz>");
MODULE_DESCRIPTION("AMD K8 core temperature monitor");
MODULE_LICENSE("GPL");

module_init(k8temp_init)
module_exit(k8temp_exit)
/*
 * Copyright (c) 2000,2005 Silicon Graphics, Inc.
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it would be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write the Free Software Foundation,
 * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef	__XFS_LOG_RECOVER_H__
#define __XFS_LOG_RECOVER_H__

/*
 * Macros, structures, prototypes for internal log manager use.
 */

#define XLOG_RHASH_BITS  4
#define XLOG_RHASH_SIZE	16
#define XLOG_RHASH_SHIFT 2
#define XLOG_RHASH(tid)	\
	((((__uint32_t)tid)>>XLOG_RHASH_SHIFT) & (XLOG_RHASH_SIZE-1))

#define XLOG_MAX_REGIONS_IN_ITEM   (XFS_MAX_BLOCKSIZE / XFS_BLF_CHUNK / 2 + 1)


/*
 * item headers are in ri_buf[0].  Additional buffers follow.
 */
typedef struct xlog_recover_item {
	struct list_head	ri_list;
	int			ri_type;
	int			ri_cnt;	/* count of regions found */
	int			ri_total;	/* total regions */
	xfs_log_iovec_t		*ri_buf;	/* ptr to regions buffer */
} xlog_recover_item_t;

struct xlog_tid;
typedef struct xlog_recover {
	struct hlist_node	r_list;
	xlog_tid_t		r_log_tid;	/* log's transaction id */
	xfs_trans_header_t	r_theader;	/* trans header for partial */
	int			r_state;	/* not needed */
	xfs_lsn_t		r_lsn;		/* xact lsn */
	struct list_head	r_itemq;	/* q for items */
} xlog_recover_t;

#define ITEM_TYPE(i)	(*(ushort *)(i)->ri_buf[0].i_addr)

/*
 * This is the number of entries in the l_buf_cancel_table used during
 * recovery.
 */
#define	XLOG_BC_TABLE_SIZE	64

#define	XLOG_RECOVER_PASS1	1
#define	XLOG_RECOVER_PASS2	2

#endif	/* __XFS_LOG_RECOVER_H__ */
cmd_net/802/built-in.o :=  ld -m elf_x86_64   -r -o net/802/built-in.o net/802/p8022.o net/802/psnap.o net/802/tr.o net/802/fc.o net/802/fddi.o net/802/hippi.o 
/*
 * Copyright (C) 2009 by Jan Weitzel Phytec Messtechnik GmbH <armlinux@phytec.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option, NO_PAD_CTRL) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#ifndef __MACH_IOMUX_MX35_H__
#define __MACH_IOMUX_MX35_H__

#include <mach/iomux-v3.h>

/*
 * The naming convention for the pad modes is MX35_PAD_<padname>__<padmode>
 * If <padname> or <padmode> refers to a GPIO, it is named
 * GPIO_<unit>_<num> see also iomux-v3.h
 */

/*									  PAD    MUX   ALT INPSE PATH */
#define MX35_PAD_CAPTURE__GPT_CAPIN1				IOMUX_PAD(0x328, 0x004, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CAPTURE__GPT_CMPOUT2				IOMUX_PAD(0x328, 0x004, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CAPTURE__CSPI2_SS1				IOMUX_PAD(0x328, 0x004, 2, 0x7f4, 0, NO_PAD_CTRL)
#define MX35_PAD_CAPTURE__EPIT1_EPITO				IOMUX_PAD(0x328, 0x004, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CAPTURE__CCM_CLK32K				IOMUX_PAD(0x328, 0x004, 4, 0x7d0, 0, NO_PAD_CTRL)
#define MX35_PAD_CAPTURE__GPIO1_4				IOMUX_PAD(0x328, 0x004, 5, 0x850, 0, NO_PAD_CTRL)

#define MX35_PAD_COMPARE__GPT_CMPOUT1				IOMUX_PAD(0x32c, 0x008, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_COMPARE__GPT_CAPIN2				IOMUX_PAD(0x32c, 0x008, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_COMPARE__GPT_CMPOUT3				IOMUX_PAD(0x32c, 0x008, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_COMPARE__EPIT2_EPITO				IOMUX_PAD(0x32c, 0x008, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_COMPARE__GPIO1_5				IOMUX_PAD(0x32c, 0x008, 5, 0x854, 0, NO_PAD_CTRL)
#define MX35_PAD_COMPARE__SDMA_EXTDMA_2				IOMUX_PAD(0x32c, 0x008, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_WDOG_RST__WDOG_WDOG_B				IOMUX_PAD(0x330, 0x00c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_WDOG_RST__IPU_FLASH_STROBE			IOMUX_PAD(0x330, 0x00c, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_WDOG_RST__GPIO1_6				IOMUX_PAD(0x330, 0x00c, 5, 0x858, 0, NO_PAD_CTRL)

#define MX35_PAD_GPIO1_0__GPIO1_0				IOMUX_PAD(0x334, 0x010, 0, 0x82c, 0, NO_PAD_CTRL)
#define MX35_PAD_GPIO1_0__CCM_PMIC_RDY				IOMUX_PAD(0x334, 0x010, 1, 0x7d4, 0, NO_PAD_CTRL)
#define MX35_PAD_GPIO1_0__OWIRE_LINE				IOMUX_PAD(0x334, 0x010, 2, 0x990, 0, NO_PAD_CTRL)
#define MX35_PAD_GPIO1_0__SDMA_EXTDMA_0				IOMUX_PAD(0x334, 0x010, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_GPIO1_1__GPIO1_1				IOMUX_PAD(0x338, 0x014, 0, 0x838, 0, NO_PAD_CTRL)
#define MX35_PAD_GPIO1_1__PWM_PWMO				IOMUX_PAD(0x338, 0x014, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_GPIO1_1__CSPI1_SS2				IOMUX_PAD(0x338, 0x014, 3, 0x7d8, 0, NO_PAD_CTRL)
#define MX35_PAD_GPIO1_1__SCC_TAMPER_DETECT			IOMUX_PAD(0x338, 0x014, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_GPIO1_1__SDMA_EXTDMA_1				IOMUX_PAD(0x338, 0x014, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_GPIO2_0__GPIO2_0				IOMUX_PAD(0x33c, 0x018, 0, 0x868, 0, NO_PAD_CTRL)
#define MX35_PAD_GPIO2_0__USB_TOP_USBOTG_CLK			IOMUX_PAD(0x33c, 0x018, 1, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_GPIO3_0__GPIO3_0				IOMUX_PAD(0x340, 0x01c, 0, 0x8e8, 0, NO_PAD_CTRL)
#define MX35_PAD_GPIO3_0__USB_TOP_USBH2_CLK			IOMUX_PAD(0x340, 0x01c, 1, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_RESET_IN_B__CCM_RESET_IN_B			IOMUX_PAD(0x344, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_POR_B__CCM_POR_B				IOMUX_PAD(0x348, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CLKO__CCM_CLKO					IOMUX_PAD(0x34c, 0x020, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CLKO__GPIO1_8					IOMUX_PAD(0x34c, 0x020, 5, 0x860, 0, NO_PAD_CTRL)

#define MX35_PAD_BOOT_MODE0__CCM_BOOT_MODE_0			IOMUX_PAD(0x350, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_BOOT_MODE1__CCM_BOOT_MODE_1			IOMUX_PAD(0x354, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CLK_MODE0__CCM_CLK_MODE_0			IOMUX_PAD(0x358, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CLK_MODE1__CCM_CLK_MODE_1			IOMUX_PAD(0x35c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_POWER_FAIL__CCM_DSM_WAKEUP_INT_26		IOMUX_PAD(0x360, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_VSTBY__CCM_VSTBY				IOMUX_PAD(0x364, 0x024, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_VSTBY__GPIO1_7					IOMUX_PAD(0x364, 0x024, 5, 0x85c, 0, NO_PAD_CTRL)

#define MX35_PAD_A0__EMI_EIM_DA_L_0				IOMUX_PAD(0x368, 0x028, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A1__EMI_EIM_DA_L_1				IOMUX_PAD(0x36c, 0x02c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A2__EMI_EIM_DA_L_2				IOMUX_PAD(0x370, 0x030, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A3__EMI_EIM_DA_L_3				IOMUX_PAD(0x374, 0x034, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A4__EMI_EIM_DA_L_4				IOMUX_PAD(0x378, 0x038, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A5__EMI_EIM_DA_L_5				IOMUX_PAD(0x37c, 0x03c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A6__EMI_EIM_DA_L_6				IOMUX_PAD(0x380, 0x040, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A7__EMI_EIM_DA_L_7				IOMUX_PAD(0x384, 0x044, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A8__EMI_EIM_DA_H_8				IOMUX_PAD(0x388, 0x048, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A9__EMI_EIM_DA_H_9				IOMUX_PAD(0x38c, 0x04c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A10__EMI_EIM_DA_H_10				IOMUX_PAD(0x390, 0x050, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_MA10__EMI_MA10					IOMUX_PAD(0x394, 0x054, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A11__EMI_EIM_DA_H_11				IOMUX_PAD(0x398, 0x058, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A12__EMI_EIM_DA_H_12				IOMUX_PAD(0x39c, 0x05c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A13__EMI_EIM_DA_H_13				IOMUX_PAD(0x3a0, 0x060, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A14__EMI_EIM_DA_H2_14				IOMUX_PAD(0x3a4, 0x064, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A15__EMI_EIM_DA_H2_15				IOMUX_PAD(0x3a8, 0x068, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A16__EMI_EIM_A_16				IOMUX_PAD(0x3ac, 0x06c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A17__EMI_EIM_A_17				IOMUX_PAD(0x3b0, 0x070, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A18__EMI_EIM_A_18				IOMUX_PAD(0x3b4, 0x074, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A19__EMI_EIM_A_19				IOMUX_PAD(0x3b8, 0x078, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A20__EMI_EIM_A_20				IOMUX_PAD(0x3bc, 0x07c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A21__EMI_EIM_A_21				IOMUX_PAD(0x3c0, 0x080, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A22__EMI_EIM_A_22				IOMUX_PAD(0x3c4, 0x084, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A23__EMI_EIM_A_23				IOMUX_PAD(0x3c8, 0x088, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A24__EMI_EIM_A_24				IOMUX_PAD(0x3cc, 0x08c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_A25__EMI_EIM_A_25				IOMUX_PAD(0x3d0, 0x090, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDBA1__EMI_EIM_SDBA1				IOMUX_PAD(0x3d4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDBA0__EMI_EIM_SDBA0				IOMUX_PAD(0x3d8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD0__EMI_DRAM_D_0				IOMUX_PAD(0x3dc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD1__EMI_DRAM_D_1				IOMUX_PAD(0x3e0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD2__EMI_DRAM_D_2				IOMUX_PAD(0x3e4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD3__EMI_DRAM_D_3				IOMUX_PAD(0x3e8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD4__EMI_DRAM_D_4				IOMUX_PAD(0x3ec, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD5__EMI_DRAM_D_5				IOMUX_PAD(0x3f0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD6__EMI_DRAM_D_6				IOMUX_PAD(0x3f4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD7__EMI_DRAM_D_7				IOMUX_PAD(0x3f8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD8__EMI_DRAM_D_8				IOMUX_PAD(0x3fc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD9__EMI_DRAM_D_9				IOMUX_PAD(0x400, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD10__EMI_DRAM_D_10				IOMUX_PAD(0x404, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD11__EMI_DRAM_D_11				IOMUX_PAD(0x408, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD12__EMI_DRAM_D_12				IOMUX_PAD(0x40c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD13__EMI_DRAM_D_13				IOMUX_PAD(0x410, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD14__EMI_DRAM_D_14				IOMUX_PAD(0x414, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD15__EMI_DRAM_D_15				IOMUX_PAD(0x418, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD16__EMI_DRAM_D_16				IOMUX_PAD(0x41c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD17__EMI_DRAM_D_17				IOMUX_PAD(0x420, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD18__EMI_DRAM_D_18				IOMUX_PAD(0x424, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD19__EMI_DRAM_D_19				IOMUX_PAD(0x428, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD20__EMI_DRAM_D_20				IOMUX_PAD(0x42c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD21__EMI_DRAM_D_21				IOMUX_PAD(0x430, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD22__EMI_DRAM_D_22				IOMUX_PAD(0x434, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD23__EMI_DRAM_D_23				IOMUX_PAD(0x438, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD24__EMI_DRAM_D_24				IOMUX_PAD(0x43c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD25__EMI_DRAM_D_25				IOMUX_PAD(0x440, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD26__EMI_DRAM_D_26				IOMUX_PAD(0x444, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD27__EMI_DRAM_D_27				IOMUX_PAD(0x448, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD28__EMI_DRAM_D_28				IOMUX_PAD(0x44c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD29__EMI_DRAM_D_29				IOMUX_PAD(0x450, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD30__EMI_DRAM_D_30				IOMUX_PAD(0x454, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD31__EMI_DRAM_D_31				IOMUX_PAD(0x458, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_DQM0__EMI_DRAM_DQM_0				IOMUX_PAD(0x45c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_DQM1__EMI_DRAM_DQM_1				IOMUX_PAD(0x460, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_DQM2__EMI_DRAM_DQM_2				IOMUX_PAD(0x464, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_DQM3__EMI_DRAM_DQM_3				IOMUX_PAD(0x468, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_EB0__EMI_EIM_EB0_B				IOMUX_PAD(0x46c, 0x094, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_EB1__EMI_EIM_EB1_B				IOMUX_PAD(0x470, 0x098, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_OE__EMI_EIM_OE					IOMUX_PAD(0x474, 0x09c, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CS0__EMI_EIM_CS0				IOMUX_PAD(0x478, 0x0a0, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CS1__EMI_EIM_CS1				IOMUX_PAD(0x47c, 0x0a4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CS1__EMI_NANDF_CE3				IOMUX_PAD(0x47c, 0x0a4, 3, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CS2__EMI_EIM_CS2				IOMUX_PAD(0x480, 0x0a8, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CS3__EMI_EIM_CS3				IOMUX_PAD(0x484, 0x0ac, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CS4__EMI_EIM_CS4				IOMUX_PAD(0x488, 0x0b0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CS4__EMI_DTACK_B				IOMUX_PAD(0x488, 0x0b0, 1, 0x800, 0, NO_PAD_CTRL)
#define MX35_PAD_CS4__EMI_NANDF_CE1				IOMUX_PAD(0x488, 0x0b0, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CS4__GPIO1_20					IOMUX_PAD(0x488, 0x0b0, 5, 0x83c, 0, NO_PAD_CTRL)

#define MX35_PAD_CS5__EMI_EIM_CS5				IOMUX_PAD(0x48c, 0x0b4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CS5__CSPI2_SS2					IOMUX_PAD(0x48c, 0x0b4, 1, 0x7f8, 0, NO_PAD_CTRL)
#define MX35_PAD_CS5__CSPI1_SS2					IOMUX_PAD(0x48c, 0x0b4, 2, 0x7d8, 1, NO_PAD_CTRL)
#define MX35_PAD_CS5__EMI_NANDF_CE2				IOMUX_PAD(0x48c, 0x0b4, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CS5__GPIO1_21					IOMUX_PAD(0x48c, 0x0b4, 5, 0x840, 0, NO_PAD_CTRL)

#define MX35_PAD_NF_CE0__EMI_NANDF_CE0				IOMUX_PAD(0x490, 0x0b8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NF_CE0__GPIO1_22				IOMUX_PAD(0x490, 0x0b8, 5, 0x844, 0, NO_PAD_CTRL)

#define MX35_PAD_ECB__EMI_EIM_ECB				IOMUX_PAD(0x494, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LBA__EMI_EIM_LBA				IOMUX_PAD(0x498, 0x0bc, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_BCLK__EMI_EIM_BCLK				IOMUX_PAD(0x49c, 0x0c0, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_RW__EMI_EIM_RW					IOMUX_PAD(0x4a0, 0x0c4, 0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_RAS__EMI_DRAM_RAS				IOMUX_PAD(0x4a4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CAS__EMI_DRAM_CAS				IOMUX_PAD(0x4a8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDWE__EMI_DRAM_SDWE				IOMUX_PAD(0x4ac, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDCKE0__EMI_DRAM_SDCKE_0			IOMUX_PAD(0x4b0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDCKE1__EMI_DRAM_SDCKE_1			IOMUX_PAD(0x4b4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDCLK__EMI_DRAM_SDCLK				IOMUX_PAD(0x4b8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDQS0__EMI_DRAM_SDQS_0				IOMUX_PAD(0x4bc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDQS1__EMI_DRAM_SDQS_1				IOMUX_PAD(0x4c0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDQS2__EMI_DRAM_SDQS_2				IOMUX_PAD(0x4c4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SDQS3__EMI_DRAM_SDQS_3				IOMUX_PAD(0x4c8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_NFWE_B__EMI_NANDF_WE_B				IOMUX_PAD(0x4cc, 0x0c8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFWE_B__USB_TOP_USBH2_DATA_3			IOMUX_PAD(0x4cc, 0x0c8, 1, 0x9d8, 0, NO_PAD_CTRL)
#define MX35_PAD_NFWE_B__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x4cc, 0x0c8, 2, 0x924, 0, NO_PAD_CTRL)
#define MX35_PAD_NFWE_B__GPIO2_18				IOMUX_PAD(0x4cc, 0x0c8, 5, 0x88c, 0, NO_PAD_CTRL)
#define MX35_PAD_NFWE_B__ARM11P_TOP_TRACE_0			IOMUX_PAD(0x4cc, 0x0c8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_NFRE_B__EMI_NANDF_RE_B				IOMUX_PAD(0x4d0, 0x0cc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFRE_B__USB_TOP_USBH2_DIR			IOMUX_PAD(0x4d0, 0x0cc, 1, 0x9ec, 0, NO_PAD_CTRL)
#define MX35_PAD_NFRE_B__IPU_DISPB_BCLK				IOMUX_PAD(0x4d0, 0x0cc, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFRE_B__GPIO2_19				IOMUX_PAD(0x4d0, 0x0cc, 5, 0x890, 0, NO_PAD_CTRL)
#define MX35_PAD_NFRE_B__ARM11P_TOP_TRACE_1			IOMUX_PAD(0x4d0, 0x0cc, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_NFALE__EMI_NANDF_ALE				IOMUX_PAD(0x4d4, 0x0d0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFALE__USB_TOP_USBH2_STP			IOMUX_PAD(0x4d4, 0x0d0, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFALE__IPU_DISPB_CS0				IOMUX_PAD(0x4d4, 0x0d0, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFALE__GPIO2_20				IOMUX_PAD(0x4d4, 0x0d0, 5, 0x898, 0, NO_PAD_CTRL)
#define MX35_PAD_NFALE__ARM11P_TOP_TRACE_2			IOMUX_PAD(0x4d4, 0x0d0, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_NFCLE__EMI_NANDF_CLE				IOMUX_PAD(0x4d8, 0x0d4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFCLE__USB_TOP_USBH2_NXT			IOMUX_PAD(0x4d8, 0x0d4, 1, 0x9f0, 0, NO_PAD_CTRL)
#define MX35_PAD_NFCLE__IPU_DISPB_PAR_RS			IOMUX_PAD(0x4d8, 0x0d4, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFCLE__GPIO2_21				IOMUX_PAD(0x4d8, 0x0d4, 5, 0x89c, 0, NO_PAD_CTRL)
#define MX35_PAD_NFCLE__ARM11P_TOP_TRACE_3			IOMUX_PAD(0x4d8, 0x0d4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_NFWP_B__EMI_NANDF_WP_B				IOMUX_PAD(0x4dc, 0x0d8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFWP_B__USB_TOP_USBH2_DATA_7			IOMUX_PAD(0x4dc, 0x0d8, 1, 0x9e8, 0, NO_PAD_CTRL)
#define MX35_PAD_NFWP_B__IPU_DISPB_WR				IOMUX_PAD(0x4dc, 0x0d8, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFWP_B__GPIO2_22				IOMUX_PAD(0x4dc, 0x0d8, 5, 0x8a0, 0, NO_PAD_CTRL)
#define MX35_PAD_NFWP_B__ARM11P_TOP_TRCTL			IOMUX_PAD(0x4dc, 0x0d8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_NFRB__EMI_NANDF_RB				IOMUX_PAD(0x4e0, 0x0dc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFRB__IPU_DISPB_RD				IOMUX_PAD(0x4e0, 0x0dc, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_NFRB__GPIO2_23					IOMUX_PAD(0x4e0, 0x0dc, 5, 0x8a4, 0, NO_PAD_CTRL)
#define MX35_PAD_NFRB__ARM11P_TOP_TRCLK				IOMUX_PAD(0x4e0, 0x0dc, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D15__EMI_EIM_D_15				IOMUX_PAD(0x4e4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D14__EMI_EIM_D_14				IOMUX_PAD(0x4e8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D13__EMI_EIM_D_13				IOMUX_PAD(0x4ec, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D12__EMI_EIM_D_12				IOMUX_PAD(0x4f0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D11__EMI_EIM_D_11				IOMUX_PAD(0x4f4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D10__EMI_EIM_D_10				IOMUX_PAD(0x4f8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D9__EMI_EIM_D_9				IOMUX_PAD(0x4fc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D8__EMI_EIM_D_8				IOMUX_PAD(0x500, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D7__EMI_EIM_D_7				IOMUX_PAD(0x504, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D6__EMI_EIM_D_6				IOMUX_PAD(0x508, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D5__EMI_EIM_D_5				IOMUX_PAD(0x50c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D4__EMI_EIM_D_4				IOMUX_PAD(0x510, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3__EMI_EIM_D_3				IOMUX_PAD(0x514, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D2__EMI_EIM_D_2				IOMUX_PAD(0x518, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D1__EMI_EIM_D_1				IOMUX_PAD(0x51c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D0__EMI_EIM_D_0				IOMUX_PAD(0x520, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D8__IPU_CSI_D_8				IOMUX_PAD(0x524, 0x0e0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D8__KPP_COL_0				IOMUX_PAD(0x524, 0x0e0, 1, 0x950, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D8__GPIO1_20				IOMUX_PAD(0x524, 0x0e0, 5, 0x83c, 1, NO_PAD_CTRL)
#define MX35_PAD_CSI_D8__ARM11P_TOP_EVNTBUS_13			IOMUX_PAD(0x524, 0x0e0, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D9__IPU_CSI_D_9				IOMUX_PAD(0x528, 0x0e4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D9__KPP_COL_1				IOMUX_PAD(0x528, 0x0e4, 1, 0x954, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D9__GPIO1_21				IOMUX_PAD(0x528, 0x0e4, 5, 0x840, 1, NO_PAD_CTRL)
#define MX35_PAD_CSI_D9__ARM11P_TOP_EVNTBUS_14			IOMUX_PAD(0x528, 0x0e4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D10__IPU_CSI_D_10				IOMUX_PAD(0x52c, 0x0e8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D10__KPP_COL_2				IOMUX_PAD(0x52c, 0x0e8, 1, 0x958, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D10__GPIO1_22				IOMUX_PAD(0x52c, 0x0e8, 5, 0x844, 1, NO_PAD_CTRL)
#define MX35_PAD_CSI_D10__ARM11P_TOP_EVNTBUS_15			IOMUX_PAD(0x52c, 0x0e8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D11__IPU_CSI_D_11				IOMUX_PAD(0x530, 0x0ec, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D11__KPP_COL_3				IOMUX_PAD(0x530, 0x0ec, 1, 0x95c, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D11__GPIO1_23				IOMUX_PAD(0x530, 0x0ec, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D12__IPU_CSI_D_12				IOMUX_PAD(0x534, 0x0f0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D12__KPP_ROW_0				IOMUX_PAD(0x534, 0x0f0, 1, 0x970, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D12__GPIO1_24				IOMUX_PAD(0x534, 0x0f0, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D13__IPU_CSI_D_13				IOMUX_PAD(0x538, 0x0f4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D13__KPP_ROW_1				IOMUX_PAD(0x538, 0x0f4, 1, 0x974, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D13__GPIO1_25				IOMUX_PAD(0x538, 0x0f4, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D14__IPU_CSI_D_14				IOMUX_PAD(0x53c, 0x0f8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D14__KPP_ROW_2				IOMUX_PAD(0x53c, 0x0f8, 1, 0x978, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D14__GPIO1_26				IOMUX_PAD(0x53c, 0x0f8, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_D15__IPU_CSI_D_15				IOMUX_PAD(0x540, 0x0fc, 0, 0x97c, 0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D15__KPP_ROW_3				IOMUX_PAD(0x540, 0x0fc, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_D15__GPIO1_27				IOMUX_PAD(0x540, 0x0fc, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_MCLK__IPU_CSI_MCLK				IOMUX_PAD(0x544, 0x100, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_MCLK__GPIO1_28				IOMUX_PAD(0x544, 0x100, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_VSYNC__IPU_CSI_VSYNC			IOMUX_PAD(0x548, 0x104, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_VSYNC__GPIO1_29				IOMUX_PAD(0x548, 0x104, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_HSYNC__IPU_CSI_HSYNC			IOMUX_PAD(0x54c, 0x108, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_HSYNC__GPIO1_30				IOMUX_PAD(0x54c, 0x108, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSI_PIXCLK__IPU_CSI_PIXCLK			IOMUX_PAD(0x550, 0x10c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSI_PIXCLK__GPIO1_31				IOMUX_PAD(0x550, 0x10c, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_I2C1_CLK__I2C1_SCL				IOMUX_PAD(0x554, 0x110, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_I2C1_CLK__GPIO2_24				IOMUX_PAD(0x554, 0x110, 5, 0x8a8, 0, NO_PAD_CTRL)
#define MX35_PAD_I2C1_CLK__CCM_USB_BYP_CLK			IOMUX_PAD(0x554, 0x110, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_I2C1_DAT__I2C1_SDA				IOMUX_PAD(0x558, 0x114, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_I2C1_DAT__GPIO2_25				IOMUX_PAD(0x558, 0x114, 5, 0x8ac, 0, NO_PAD_CTRL)

#define MX35_PAD_I2C2_CLK__I2C2_SCL				IOMUX_PAD(0x55c, 0x118, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_CLK__CAN1_TXCAN				IOMUX_PAD(0x55c, 0x118, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_CLK__USB_TOP_USBH2_PWR			IOMUX_PAD(0x55c, 0x118, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_CLK__GPIO2_26				IOMUX_PAD(0x55c, 0x118, 5, 0x8b0, 0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_CLK__SDMA_DEBUG_BUS_DEVICE_2		IOMUX_PAD(0x55c, 0x118, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_I2C2_DAT__I2C2_SDA				IOMUX_PAD(0x560, 0x11c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_DAT__CAN1_RXCAN				IOMUX_PAD(0x560, 0x11c, 1, 0x7c8, 0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_DAT__USB_TOP_USBH2_OC			IOMUX_PAD(0x560, 0x11c, 2, 0x9f4, 0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_DAT__GPIO2_27				IOMUX_PAD(0x560, 0x11c, 5, 0x8b4, 0, NO_PAD_CTRL)
#define MX35_PAD_I2C2_DAT__SDMA_DEBUG_BUS_DEVICE_3		IOMUX_PAD(0x560, 0x11c, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_STXD4__AUDMUX_AUD4_TXD				IOMUX_PAD(0x564, 0x120, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_STXD4__GPIO2_28				IOMUX_PAD(0x564, 0x120, 5, 0x8b8, 0, NO_PAD_CTRL)
#define MX35_PAD_STXD4__ARM11P_TOP_ARM_COREASID0		IOMUX_PAD(0x564, 0x120, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SRXD4__AUDMUX_AUD4_RXD				IOMUX_PAD(0x568, 0x124, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SRXD4__GPIO2_29				IOMUX_PAD(0x568, 0x124, 5, 0x8bc, 0, NO_PAD_CTRL)
#define MX35_PAD_SRXD4__ARM11P_TOP_ARM_COREASID1		IOMUX_PAD(0x568, 0x124, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SCK4__AUDMUX_AUD4_TXC				IOMUX_PAD(0x56c, 0x128, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SCK4__GPIO2_30					IOMUX_PAD(0x56c, 0x128, 5, 0x8c4, 0, NO_PAD_CTRL)
#define MX35_PAD_SCK4__ARM11P_TOP_ARM_COREASID2			IOMUX_PAD(0x56c, 0x128, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_STXFS4__AUDMUX_AUD4_TXFS			IOMUX_PAD(0x570, 0x12c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_STXFS4__GPIO2_31				IOMUX_PAD(0x570, 0x12c, 5, 0x8c8, 0, NO_PAD_CTRL)
#define MX35_PAD_STXFS4__ARM11P_TOP_ARM_COREASID3		IOMUX_PAD(0x570, 0x12c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_STXD5__AUDMUX_AUD5_TXD				IOMUX_PAD(0x574, 0x130, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_STXD5__SPDIF_SPDIF_OUT1			IOMUX_PAD(0x574, 0x130, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_STXD5__CSPI2_MOSI				IOMUX_PAD(0x574, 0x130, 2, 0x7ec, 0, NO_PAD_CTRL)
#define MX35_PAD_STXD5__GPIO1_0					IOMUX_PAD(0x574, 0x130, 5, 0x82c, 1, NO_PAD_CTRL)
#define MX35_PAD_STXD5__ARM11P_TOP_ARM_COREASID4		IOMUX_PAD(0x574, 0x130, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SRXD5__AUDMUX_AUD5_RXD				IOMUX_PAD(0x578, 0x134, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SRXD5__SPDIF_SPDIF_IN1				IOMUX_PAD(0x578, 0x134, 1, 0x998, 0, NO_PAD_CTRL)
#define MX35_PAD_SRXD5__CSPI2_MISO				IOMUX_PAD(0x578, 0x134, 2, 0x7e8, 0, NO_PAD_CTRL)
#define MX35_PAD_SRXD5__GPIO1_1					IOMUX_PAD(0x578, 0x134, 5, 0x838, 1, NO_PAD_CTRL)
#define MX35_PAD_SRXD5__ARM11P_TOP_ARM_COREASID5		IOMUX_PAD(0x578, 0x134, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SCK5__AUDMUX_AUD5_TXC				IOMUX_PAD(0x57c, 0x138, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SCK5__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x57c, 0x138, 1, 0x994, 0, NO_PAD_CTRL)
#define MX35_PAD_SCK5__CSPI2_SCLK				IOMUX_PAD(0x57c, 0x138, 2, 0x7e0, 0, NO_PAD_CTRL)
#define MX35_PAD_SCK5__GPIO1_2					IOMUX_PAD(0x57c, 0x138, 5, 0x848, 0, NO_PAD_CTRL)
#define MX35_PAD_SCK5__ARM11P_TOP_ARM_COREASID6			IOMUX_PAD(0x57c, 0x138, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_STXFS5__AUDMUX_AUD5_TXFS			IOMUX_PAD(0x580, 0x13c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_STXFS5__CSPI2_RDY				IOMUX_PAD(0x580, 0x13c, 2, 0x7e4, 0, NO_PAD_CTRL)
#define MX35_PAD_STXFS5__GPIO1_3				IOMUX_PAD(0x580, 0x13c, 5, 0x84c, 0, NO_PAD_CTRL)
#define MX35_PAD_STXFS5__ARM11P_TOP_ARM_COREASID7		IOMUX_PAD(0x580, 0x13c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SCKR__ESAI_SCKR				IOMUX_PAD(0x584, 0x140, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SCKR__GPIO1_4					IOMUX_PAD(0x584, 0x140, 5, 0x850, 1, NO_PAD_CTRL)
#define MX35_PAD_SCKR__ARM11P_TOP_EVNTBUS_10			IOMUX_PAD(0x584, 0x140, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FSR__ESAI_FSR					IOMUX_PAD(0x588, 0x144, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FSR__GPIO1_5					IOMUX_PAD(0x588, 0x144, 5, 0x854, 1, NO_PAD_CTRL)
#define MX35_PAD_FSR__ARM11P_TOP_EVNTBUS_11			IOMUX_PAD(0x588, 0x144, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_HCKR__ESAI_HCKR				IOMUX_PAD(0x58c, 0x148, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_HCKR__AUDMUX_AUD5_RXFS				IOMUX_PAD(0x58c, 0x148, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_HCKR__CSPI2_SS0				IOMUX_PAD(0x58c, 0x148, 2, 0x7f0, 0, NO_PAD_CTRL)
#define MX35_PAD_HCKR__IPU_FLASH_STROBE				IOMUX_PAD(0x58c, 0x148, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_HCKR__GPIO1_6					IOMUX_PAD(0x58c, 0x148, 5, 0x858, 1, NO_PAD_CTRL)
#define MX35_PAD_HCKR__ARM11P_TOP_EVNTBUS_12			IOMUX_PAD(0x58c, 0x148, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SCKT__ESAI_SCKT				IOMUX_PAD(0x590, 0x14c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SCKT__GPIO1_7					IOMUX_PAD(0x590, 0x14c, 5, 0x85c, 1, NO_PAD_CTRL)
#define MX35_PAD_SCKT__IPU_CSI_D_0				IOMUX_PAD(0x590, 0x14c, 6, 0x930, 0, NO_PAD_CTRL)
#define MX35_PAD_SCKT__KPP_ROW_2				IOMUX_PAD(0x590, 0x14c, 7, 0x978, 1, NO_PAD_CTRL)

#define MX35_PAD_FST__ESAI_FST					IOMUX_PAD(0x594, 0x150, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FST__GPIO1_8					IOMUX_PAD(0x594, 0x150, 5, 0x860, 1, NO_PAD_CTRL)
#define MX35_PAD_FST__IPU_CSI_D_1				IOMUX_PAD(0x594, 0x150, 6, 0x934, 0, NO_PAD_CTRL)
#define MX35_PAD_FST__KPP_ROW_3					IOMUX_PAD(0x594, 0x150, 7, 0x97c, 1, NO_PAD_CTRL)

#define MX35_PAD_HCKT__ESAI_HCKT				IOMUX_PAD(0x598, 0x154, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_HCKT__AUDMUX_AUD5_RXC				IOMUX_PAD(0x598, 0x154, 1, 0x7a8, 0, NO_PAD_CTRL)
#define MX35_PAD_HCKT__GPIO1_9					IOMUX_PAD(0x598, 0x154, 5, 0x864, 0, NO_PAD_CTRL)
#define MX35_PAD_HCKT__IPU_CSI_D_2				IOMUX_PAD(0x598, 0x154, 6, 0x938, 0, NO_PAD_CTRL)
#define MX35_PAD_HCKT__KPP_COL_3				IOMUX_PAD(0x598, 0x154, 7, 0x95c, 1, NO_PAD_CTRL)

#define MX35_PAD_TX5_RX0__ESAI_TX5_RX0				IOMUX_PAD(0x59c, 0x158, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX5_RX0__AUDMUX_AUD4_RXC			IOMUX_PAD(0x59c, 0x158, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX5_RX0__CSPI2_SS2				IOMUX_PAD(0x59c, 0x158, 2, 0x7f8, 1, NO_PAD_CTRL)
#define MX35_PAD_TX5_RX0__CAN2_TXCAN				IOMUX_PAD(0x59c, 0x158, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX5_RX0__UART2_DTR				IOMUX_PAD(0x59c, 0x158, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX5_RX0__GPIO1_10				IOMUX_PAD(0x59c, 0x158, 5, 0x830, 0, NO_PAD_CTRL)
#define MX35_PAD_TX5_RX0__EMI_M3IF_CHOSEN_MASTER_0		IOMUX_PAD(0x59c, 0x158, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TX4_RX1__ESAI_TX4_RX1				IOMUX_PAD(0x5a0, 0x15c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX4_RX1__AUDMUX_AUD4_RXFS			IOMUX_PAD(0x5a0, 0x15c, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX4_RX1__CSPI2_SS3				IOMUX_PAD(0x5a0, 0x15c, 2, 0x7fc, 0, NO_PAD_CTRL)
#define MX35_PAD_TX4_RX1__CAN2_RXCAN				IOMUX_PAD(0x5a0, 0x15c, 3, 0x7cc, 0, NO_PAD_CTRL)
#define MX35_PAD_TX4_RX1__UART2_DSR				IOMUX_PAD(0x5a0, 0x15c, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX4_RX1__GPIO1_11				IOMUX_PAD(0x5a0, 0x15c, 5, 0x834, 0, NO_PAD_CTRL)
#define MX35_PAD_TX4_RX1__IPU_CSI_D_3				IOMUX_PAD(0x5a0, 0x15c, 6, 0x93c, 0, NO_PAD_CTRL)
#define MX35_PAD_TX4_RX1__KPP_ROW_0				IOMUX_PAD(0x5a0, 0x15c, 7, 0x970, 1, NO_PAD_CTRL)

#define MX35_PAD_TX3_RX2__ESAI_TX3_RX2				IOMUX_PAD(0x5a4, 0x160, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX3_RX2__I2C3_SCL				IOMUX_PAD(0x5a4, 0x160, 1, 0x91c, 0, NO_PAD_CTRL)
#define MX35_PAD_TX3_RX2__EMI_NANDF_CE1				IOMUX_PAD(0x5a4, 0x160, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX3_RX2__GPIO1_12				IOMUX_PAD(0x5a4, 0x160, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX3_RX2__IPU_CSI_D_4				IOMUX_PAD(0x5a4, 0x160, 6, 0x940, 0, NO_PAD_CTRL)
#define MX35_PAD_TX3_RX2__KPP_ROW_1				IOMUX_PAD(0x5a4, 0x160, 7, 0x974, 1, NO_PAD_CTRL)

#define MX35_PAD_TX2_RX3__ESAI_TX2_RX3				IOMUX_PAD(0x5a8, 0x164, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX2_RX3__I2C3_SDA				IOMUX_PAD(0x5a8, 0x164, 1, 0x920, 0, NO_PAD_CTRL)
#define MX35_PAD_TX2_RX3__EMI_NANDF_CE2				IOMUX_PAD(0x5a8, 0x164, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX2_RX3__GPIO1_13				IOMUX_PAD(0x5a8, 0x164, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX2_RX3__IPU_CSI_D_5				IOMUX_PAD(0x5a8, 0x164, 6, 0x944, 0, NO_PAD_CTRL)
#define MX35_PAD_TX2_RX3__KPP_COL_0				IOMUX_PAD(0x5a8, 0x164, 7, 0x950, 1, NO_PAD_CTRL)

#define MX35_PAD_TX1__ESAI_TX1					IOMUX_PAD(0x5ac, 0x168, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX1__CCM_PMIC_RDY				IOMUX_PAD(0x5ac, 0x168, 1, 0x7d4, 1, NO_PAD_CTRL)
#define MX35_PAD_TX1__CSPI1_SS2					IOMUX_PAD(0x5ac, 0x168, 2, 0x7d8, 2, NO_PAD_CTRL)
#define MX35_PAD_TX1__EMI_NANDF_CE3				IOMUX_PAD(0x5ac, 0x168, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX1__UART2_RI					IOMUX_PAD(0x5ac, 0x168, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX1__GPIO1_14					IOMUX_PAD(0x5ac, 0x168, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX1__IPU_CSI_D_6				IOMUX_PAD(0x5ac, 0x168, 6, 0x948, 0, NO_PAD_CTRL)
#define MX35_PAD_TX1__KPP_COL_1					IOMUX_PAD(0x5ac, 0x168, 7, 0x954, 1, NO_PAD_CTRL)

#define MX35_PAD_TX0__ESAI_TX0					IOMUX_PAD(0x5b0, 0x16c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX0__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x5b0, 0x16c, 1, 0x994, 1, NO_PAD_CTRL)
#define MX35_PAD_TX0__CSPI1_SS3					IOMUX_PAD(0x5b0, 0x16c, 2, 0x7dc, 0, NO_PAD_CTRL)
#define MX35_PAD_TX0__EMI_DTACK_B				IOMUX_PAD(0x5b0, 0x16c, 3, 0x800, 1, NO_PAD_CTRL)
#define MX35_PAD_TX0__UART2_DCD					IOMUX_PAD(0x5b0, 0x16c, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX0__GPIO1_15					IOMUX_PAD(0x5b0, 0x16c, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TX0__IPU_CSI_D_7				IOMUX_PAD(0x5b0, 0x16c, 6, 0x94c, 0, NO_PAD_CTRL)
#define MX35_PAD_TX0__KPP_COL_2					IOMUX_PAD(0x5b0, 0x16c, 7, 0x958, 1, NO_PAD_CTRL)

#define MX35_PAD_CSPI1_MOSI__CSPI1_MOSI				IOMUX_PAD(0x5b4, 0x170, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_MOSI__GPIO1_16				IOMUX_PAD(0x5b4, 0x170, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_MOSI__ECT_CTI_TRIG_OUT1_2		IOMUX_PAD(0x5b4, 0x170, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSPI1_MISO__CSPI1_MISO				IOMUX_PAD(0x5b8, 0x174, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_MISO__GPIO1_17				IOMUX_PAD(0x5b8, 0x174, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_MISO__ECT_CTI_TRIG_OUT1_3		IOMUX_PAD(0x5b8, 0x174, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSPI1_SS0__CSPI1_SS0				IOMUX_PAD(0x5bc, 0x178, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS0__OWIRE_LINE				IOMUX_PAD(0x5bc, 0x178, 1, 0x990, 1, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS0__CSPI2_SS3				IOMUX_PAD(0x5bc, 0x178, 2, 0x7fc, 1, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS0__GPIO1_18				IOMUX_PAD(0x5bc, 0x178, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS0__ECT_CTI_TRIG_OUT1_4			IOMUX_PAD(0x5bc, 0x178, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSPI1_SS1__CSPI1_SS1				IOMUX_PAD(0x5c0, 0x17c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS1__PWM_PWMO				IOMUX_PAD(0x5c0, 0x17c, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS1__CCM_CLK32K				IOMUX_PAD(0x5c0, 0x17c, 2, 0x7d0, 1, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS1__GPIO1_19				IOMUX_PAD(0x5c0, 0x17c, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS1__IPU_DIAGB_29			IOMUX_PAD(0x5c0, 0x17c, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SS1__ECT_CTI_TRIG_OUT1_5			IOMUX_PAD(0x5c0, 0x17c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSPI1_SCLK__CSPI1_SCLK				IOMUX_PAD(0x5c4, 0x180, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SCLK__GPIO3_4				IOMUX_PAD(0x5c4, 0x180, 5, 0x904, 0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SCLK__IPU_DIAGB_30			IOMUX_PAD(0x5c4, 0x180, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SCLK__EMI_M3IF_CHOSEN_MASTER_1		IOMUX_PAD(0x5c4, 0x180, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CSPI1_SPI_RDY__CSPI1_RDY			IOMUX_PAD(0x5c8, 0x184, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SPI_RDY__GPIO3_5				IOMUX_PAD(0x5c8, 0x184, 5, 0x908, 0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SPI_RDY__IPU_DIAGB_31			IOMUX_PAD(0x5c8, 0x184, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CSPI1_SPI_RDY__EMI_M3IF_CHOSEN_MASTER_2	IOMUX_PAD(0x5c8, 0x184, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_RXD1__UART1_RXD_MUX				IOMUX_PAD(0x5cc, 0x188, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_RXD1__CSPI2_MOSI				IOMUX_PAD(0x5cc, 0x188, 1, 0x7ec, 1, NO_PAD_CTRL)
#define MX35_PAD_RXD1__KPP_COL_4				IOMUX_PAD(0x5cc, 0x188, 4, 0x960, 0, NO_PAD_CTRL)
#define MX35_PAD_RXD1__GPIO3_6					IOMUX_PAD(0x5cc, 0x188, 5, 0x90c, 0, NO_PAD_CTRL)
#define MX35_PAD_RXD1__ARM11P_TOP_EVNTBUS_16			IOMUX_PAD(0x5cc, 0x188, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TXD1__UART1_TXD_MUX				IOMUX_PAD(0x5d0, 0x18c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TXD1__CSPI2_MISO				IOMUX_PAD(0x5d0, 0x18c, 1, 0x7e8, 1, NO_PAD_CTRL)
#define MX35_PAD_TXD1__KPP_COL_5				IOMUX_PAD(0x5d0, 0x18c, 4, 0x964, 0, NO_PAD_CTRL)
#define MX35_PAD_TXD1__GPIO3_7					IOMUX_PAD(0x5d0, 0x18c, 5, 0x910, 0, NO_PAD_CTRL)
#define MX35_PAD_TXD1__ARM11P_TOP_EVNTBUS_17			IOMUX_PAD(0x5d0, 0x18c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_RTS1__UART1_RTS				IOMUX_PAD(0x5d4, 0x190, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_RTS1__CSPI2_SCLK				IOMUX_PAD(0x5d4, 0x190, 1, 0x7e0, 1, NO_PAD_CTRL)
#define MX35_PAD_RTS1__I2C3_SCL					IOMUX_PAD(0x5d4, 0x190, 2, 0x91c, 1, NO_PAD_CTRL)
#define MX35_PAD_RTS1__IPU_CSI_D_0				IOMUX_PAD(0x5d4, 0x190, 3, 0x930, 1, NO_PAD_CTRL)
#define MX35_PAD_RTS1__KPP_COL_6				IOMUX_PAD(0x5d4, 0x190, 4, 0x968, 0, NO_PAD_CTRL)
#define MX35_PAD_RTS1__GPIO3_8					IOMUX_PAD(0x5d4, 0x190, 5, 0x914, 0, NO_PAD_CTRL)
#define MX35_PAD_RTS1__EMI_NANDF_CE1				IOMUX_PAD(0x5d4, 0x190, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_RTS1__ARM11P_TOP_EVNTBUS_18			IOMUX_PAD(0x5d4, 0x190, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CTS1__UART1_CTS				IOMUX_PAD(0x5d8, 0x194, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CTS1__CSPI2_RDY				IOMUX_PAD(0x5d8, 0x194, 1, 0x7e4, 1, NO_PAD_CTRL)
#define MX35_PAD_CTS1__I2C3_SDA					IOMUX_PAD(0x5d8, 0x194, 2, 0x920, 1, NO_PAD_CTRL)
#define MX35_PAD_CTS1__IPU_CSI_D_1				IOMUX_PAD(0x5d8, 0x194, 3, 0x934, 1, NO_PAD_CTRL)
#define MX35_PAD_CTS1__KPP_COL_7				IOMUX_PAD(0x5d8, 0x194, 4, 0x96c, 0, NO_PAD_CTRL)
#define MX35_PAD_CTS1__GPIO3_9					IOMUX_PAD(0x5d8, 0x194, 5, 0x918, 0, NO_PAD_CTRL)
#define MX35_PAD_CTS1__EMI_NANDF_CE2				IOMUX_PAD(0x5d8, 0x194, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CTS1__ARM11P_TOP_EVNTBUS_19			IOMUX_PAD(0x5d8, 0x194, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_RXD2__UART2_RXD_MUX				IOMUX_PAD(0x5dc, 0x198, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_RXD2__KPP_ROW_4				IOMUX_PAD(0x5dc, 0x198, 4, 0x980, 0, NO_PAD_CTRL)
#define MX35_PAD_RXD2__GPIO3_10					IOMUX_PAD(0x5dc, 0x198, 5, 0x8ec, 0, NO_PAD_CTRL)

#define MX35_PAD_TXD2__UART2_TXD_MUX				IOMUX_PAD(0x5e0, 0x19c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_TXD2__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x5e0, 0x19c, 1, 0x994, 2, NO_PAD_CTRL)
#define MX35_PAD_TXD2__KPP_ROW_5				IOMUX_PAD(0x5e0, 0x19c, 4, 0x984, 0, NO_PAD_CTRL)
#define MX35_PAD_TXD2__GPIO3_11					IOMUX_PAD(0x5e0, 0x19c, 5, 0x8f0, 0, NO_PAD_CTRL)

#define MX35_PAD_RTS2__UART2_RTS				IOMUX_PAD(0x5e4, 0x1a0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_RTS2__SPDIF_SPDIF_IN1				IOMUX_PAD(0x5e4, 0x1a0, 1, 0x998, 1, NO_PAD_CTRL)
#define MX35_PAD_RTS2__CAN2_RXCAN				IOMUX_PAD(0x5e4, 0x1a0, 2, 0x7cc, 1, NO_PAD_CTRL)
#define MX35_PAD_RTS2__IPU_CSI_D_2				IOMUX_PAD(0x5e4, 0x1a0, 3, 0x938, 1, NO_PAD_CTRL)
#define MX35_PAD_RTS2__KPP_ROW_6				IOMUX_PAD(0x5e4, 0x1a0, 4, 0x988, 0, NO_PAD_CTRL)
#define MX35_PAD_RTS2__GPIO3_12					IOMUX_PAD(0x5e4, 0x1a0, 5, 0x8f4, 0, NO_PAD_CTRL)
#define MX35_PAD_RTS2__AUDMUX_AUD5_RXC				IOMUX_PAD(0x5e4, 0x1a0, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_RTS2__UART3_RXD_MUX				IOMUX_PAD(0x5e4, 0x1a0, 7, 0x9a0, 0, NO_PAD_CTRL)

#define MX35_PAD_CTS2__UART2_CTS				IOMUX_PAD(0x5e8, 0x1a4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CTS2__SPDIF_SPDIF_OUT1				IOMUX_PAD(0x5e8, 0x1a4, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CTS2__CAN2_TXCAN				IOMUX_PAD(0x5e8, 0x1a4, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CTS2__IPU_CSI_D_3				IOMUX_PAD(0x5e8, 0x1a4, 3, 0x93c, 1, NO_PAD_CTRL)
#define MX35_PAD_CTS2__KPP_ROW_7				IOMUX_PAD(0x5e8, 0x1a4, 4, 0x98c, 0, NO_PAD_CTRL)
#define MX35_PAD_CTS2__GPIO3_13					IOMUX_PAD(0x5e8, 0x1a4, 5, 0x8f8, 0, NO_PAD_CTRL)
#define MX35_PAD_CTS2__AUDMUX_AUD5_RXFS				IOMUX_PAD(0x5e8, 0x1a4, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CTS2__UART3_TXD_MUX				IOMUX_PAD(0x5e8, 0x1a4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_RTCK__ARM11P_TOP_RTCK				IOMUX_PAD(0x5ec, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TCK__SJC_TCK					IOMUX_PAD(0x5f0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TMS__SJC_TMS					IOMUX_PAD(0x5f4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TDI__SJC_TDI					IOMUX_PAD(0x5f8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TDO__SJC_TDO					IOMUX_PAD(0x5fc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TRSTB__SJC_TRSTB				IOMUX_PAD(0x600, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_DE_B__SJC_DE_B					IOMUX_PAD(0x604, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SJC_MOD__SJC_MOD				IOMUX_PAD(0x608, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_USBOTG_PWR__USB_TOP_USBOTG_PWR			IOMUX_PAD(0x60c, 0x1a8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_USBOTG_PWR__USB_TOP_USBH2_PWR			IOMUX_PAD(0x60c, 0x1a8, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_USBOTG_PWR__GPIO3_14				IOMUX_PAD(0x60c, 0x1a8, 5, 0x8fc, 0, NO_PAD_CTRL)

#define MX35_PAD_USBOTG_OC__USB_TOP_USBOTG_OC			IOMUX_PAD(0x610, 0x1ac, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_USBOTG_OC__USB_TOP_USBH2_OC			IOMUX_PAD(0x610, 0x1ac, 1, 0x9f4, 1, NO_PAD_CTRL)
#define MX35_PAD_USBOTG_OC__GPIO3_15				IOMUX_PAD(0x610, 0x1ac, 5, 0x900, 0, NO_PAD_CTRL)

#define MX35_PAD_LD0__IPU_DISPB_DAT_0				IOMUX_PAD(0x614, 0x1b0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD0__GPIO2_0					IOMUX_PAD(0x614, 0x1b0, 5, 0x868, 1, NO_PAD_CTRL)
#define MX35_PAD_LD0__SDMA_SDMA_DEBUG_PC_0			IOMUX_PAD(0x614, 0x1b0, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD1__IPU_DISPB_DAT_1				IOMUX_PAD(0x618, 0x1b4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD1__GPIO2_1					IOMUX_PAD(0x618, 0x1b4, 5, 0x894, 0, NO_PAD_CTRL)
#define MX35_PAD_LD1__SDMA_SDMA_DEBUG_PC_1			IOMUX_PAD(0x618, 0x1b4, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD2__IPU_DISPB_DAT_2				IOMUX_PAD(0x61c, 0x1b8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD2__GPIO2_2					IOMUX_PAD(0x61c, 0x1b8, 5, 0x8c0, 0, NO_PAD_CTRL)
#define MX35_PAD_LD2__SDMA_SDMA_DEBUG_PC_2			IOMUX_PAD(0x61c, 0x1b8, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD3__IPU_DISPB_DAT_3				IOMUX_PAD(0x620, 0x1bc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD3__GPIO2_3					IOMUX_PAD(0x620, 0x1bc, 5, 0x8cc, 0, NO_PAD_CTRL)
#define MX35_PAD_LD3__SDMA_SDMA_DEBUG_PC_3			IOMUX_PAD(0x620, 0x1bc, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD4__IPU_DISPB_DAT_4				IOMUX_PAD(0x624, 0x1c0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD4__GPIO2_4					IOMUX_PAD(0x624, 0x1c0, 5, 0x8d0, 0, NO_PAD_CTRL)
#define MX35_PAD_LD4__SDMA_SDMA_DEBUG_PC_4			IOMUX_PAD(0x624, 0x1c0, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD5__IPU_DISPB_DAT_5				IOMUX_PAD(0x628, 0x1c4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD5__GPIO2_5					IOMUX_PAD(0x628, 0x1c4, 5, 0x8d4, 0, NO_PAD_CTRL)
#define MX35_PAD_LD5__SDMA_SDMA_DEBUG_PC_5			IOMUX_PAD(0x628, 0x1c4, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD6__IPU_DISPB_DAT_6				IOMUX_PAD(0x62c, 0x1c8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD6__GPIO2_6					IOMUX_PAD(0x62c, 0x1c8, 5, 0x8d8, 0, NO_PAD_CTRL)
#define MX35_PAD_LD6__SDMA_SDMA_DEBUG_PC_6			IOMUX_PAD(0x62c, 0x1c8, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD7__IPU_DISPB_DAT_7				IOMUX_PAD(0x630, 0x1cc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD7__GPIO2_7					IOMUX_PAD(0x630, 0x1cc, 5, 0x8dc, 0, NO_PAD_CTRL)
#define MX35_PAD_LD7__SDMA_SDMA_DEBUG_PC_7			IOMUX_PAD(0x630, 0x1cc, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD8__IPU_DISPB_DAT_8				IOMUX_PAD(0x634, 0x1d0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD8__GPIO2_8					IOMUX_PAD(0x634, 0x1d0, 5, 0x8e0, 0, NO_PAD_CTRL)
#define MX35_PAD_LD8__SDMA_SDMA_DEBUG_PC_8			IOMUX_PAD(0x634, 0x1d0, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD9__IPU_DISPB_DAT_9				IOMUX_PAD(0x638, 0x1d4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD9__GPIO2_9					IOMUX_PAD(0x638, 0x1d4, 5, 0x8e4, 0, NO_PAD_CTRL)
#define MX35_PAD_LD9__SDMA_SDMA_DEBUG_PC_9			IOMUX_PAD(0x638, 0x1d4, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD10__IPU_DISPB_DAT_10				IOMUX_PAD(0x63c, 0x1d8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD10__GPIO2_10					IOMUX_PAD(0x63c, 0x1d8, 5, 0x86c, 0, NO_PAD_CTRL)
#define MX35_PAD_LD10__SDMA_SDMA_DEBUG_PC_10			IOMUX_PAD(0x63c, 0x1d8, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD11__IPU_DISPB_DAT_11				IOMUX_PAD(0x640, 0x1dc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD11__GPIO2_11					IOMUX_PAD(0x640, 0x1dc, 5, 0x870, 0, NO_PAD_CTRL)
#define MX35_PAD_LD11__SDMA_SDMA_DEBUG_PC_11			IOMUX_PAD(0x640, 0x1dc, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD11__ARM11P_TOP_TRACE_4			IOMUX_PAD(0x640, 0x1dc, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD12__IPU_DISPB_DAT_12				IOMUX_PAD(0x644, 0x1e0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD12__GPIO2_12					IOMUX_PAD(0x644, 0x1e0, 5, 0x874, 0, NO_PAD_CTRL)
#define MX35_PAD_LD12__SDMA_SDMA_DEBUG_PC_12			IOMUX_PAD(0x644, 0x1e0, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD12__ARM11P_TOP_TRACE_5			IOMUX_PAD(0x644, 0x1e0, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD13__IPU_DISPB_DAT_13				IOMUX_PAD(0x648, 0x1e4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD13__GPIO2_13					IOMUX_PAD(0x648, 0x1e4, 5, 0x878, 0, NO_PAD_CTRL)
#define MX35_PAD_LD13__SDMA_SDMA_DEBUG_PC_13			IOMUX_PAD(0x648, 0x1e4, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD13__ARM11P_TOP_TRACE_6			IOMUX_PAD(0x648, 0x1e4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD14__IPU_DISPB_DAT_14				IOMUX_PAD(0x64c, 0x1e8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD14__GPIO2_14					IOMUX_PAD(0x64c, 0x1e8, 5, 0x87c, 0, NO_PAD_CTRL)
#define MX35_PAD_LD14__SDMA_SDMA_DEBUG_EVENT_CHANNEL_0		IOMUX_PAD(0x64c, 0x1e8, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD14__ARM11P_TOP_TRACE_7			IOMUX_PAD(0x64c, 0x1e8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD15__IPU_DISPB_DAT_15				IOMUX_PAD(0x650, 0x1ec, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD15__GPIO2_15					IOMUX_PAD(0x650, 0x1ec, 5, 0x880, 0, NO_PAD_CTRL)
#define MX35_PAD_LD15__SDMA_SDMA_DEBUG_EVENT_CHANNEL_1		IOMUX_PAD(0x650, 0x1ec, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD15__ARM11P_TOP_TRACE_8			IOMUX_PAD(0x650, 0x1ec, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD16__IPU_DISPB_DAT_16				IOMUX_PAD(0x654, 0x1f0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD16__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x654, 0x1f0, 2, 0x928, 0, NO_PAD_CTRL)
#define MX35_PAD_LD16__GPIO2_16					IOMUX_PAD(0x654, 0x1f0, 5, 0x884, 0, NO_PAD_CTRL)
#define MX35_PAD_LD16__SDMA_SDMA_DEBUG_EVENT_CHANNEL_2		IOMUX_PAD(0x654, 0x1f0, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD16__ARM11P_TOP_TRACE_9			IOMUX_PAD(0x654, 0x1f0, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD17__IPU_DISPB_DAT_17				IOMUX_PAD(0x658, 0x1f4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD17__IPU_DISPB_CS2				IOMUX_PAD(0x658, 0x1f4, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD17__GPIO2_17					IOMUX_PAD(0x658, 0x1f4, 5, 0x888, 0, NO_PAD_CTRL)
#define MX35_PAD_LD17__SDMA_SDMA_DEBUG_EVENT_CHANNEL_3		IOMUX_PAD(0x658, 0x1f4, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD17__ARM11P_TOP_TRACE_10			IOMUX_PAD(0x658, 0x1f4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD18__IPU_DISPB_DAT_18				IOMUX_PAD(0x65c, 0x1f8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD18__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x65c, 0x1f8, 1, 0x924, 1, NO_PAD_CTRL)
#define MX35_PAD_LD18__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x65c, 0x1f8, 2, 0x928, 1, NO_PAD_CTRL)
#define MX35_PAD_LD18__ESDHC3_CMD				IOMUX_PAD(0x65c, 0x1f8, 3, 0x818, 0, NO_PAD_CTRL)
#define MX35_PAD_LD18__USB_TOP_USBOTG_DATA_3			IOMUX_PAD(0x65c, 0x1f8, 4, 0x9b0, 0, NO_PAD_CTRL)
#define MX35_PAD_LD18__GPIO3_24					IOMUX_PAD(0x65c, 0x1f8, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD18__SDMA_SDMA_DEBUG_EVENT_CHANNEL_4		IOMUX_PAD(0x65c, 0x1f8, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD18__ARM11P_TOP_TRACE_11			IOMUX_PAD(0x65c, 0x1f8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD19__IPU_DISPB_DAT_19				IOMUX_PAD(0x660, 0x1fc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD19__IPU_DISPB_BCLK				IOMUX_PAD(0x660, 0x1fc, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD19__IPU_DISPB_CS1				IOMUX_PAD(0x660, 0x1fc, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD19__ESDHC3_CLK				IOMUX_PAD(0x660, 0x1fc, 3, 0x814, 0, NO_PAD_CTRL)
#define MX35_PAD_LD19__USB_TOP_USBOTG_DIR			IOMUX_PAD(0x660, 0x1fc, 4, 0x9c4, 0, NO_PAD_CTRL)
#define MX35_PAD_LD19__GPIO3_25					IOMUX_PAD(0x660, 0x1fc, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD19__SDMA_SDMA_DEBUG_EVENT_CHANNEL_5		IOMUX_PAD(0x660, 0x1fc, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD19__ARM11P_TOP_TRACE_12			IOMUX_PAD(0x660, 0x1fc, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD20__IPU_DISPB_DAT_20				IOMUX_PAD(0x664, 0x200, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD20__IPU_DISPB_CS0				IOMUX_PAD(0x664, 0x200, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD20__IPU_DISPB_SD_CLK				IOMUX_PAD(0x664, 0x200, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD20__ESDHC3_DAT0				IOMUX_PAD(0x664, 0x200, 3, 0x81c, 0, NO_PAD_CTRL)
#define MX35_PAD_LD20__GPIO3_26					IOMUX_PAD(0x664, 0x200, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD20__SDMA_SDMA_DEBUG_CORE_STATUS_3		IOMUX_PAD(0x664, 0x200, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD20__ARM11P_TOP_TRACE_13			IOMUX_PAD(0x664, 0x200, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD21__IPU_DISPB_DAT_21				IOMUX_PAD(0x668, 0x204, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD21__IPU_DISPB_PAR_RS				IOMUX_PAD(0x668, 0x204, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD21__IPU_DISPB_SER_RS				IOMUX_PAD(0x668, 0x204, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD21__ESDHC3_DAT1				IOMUX_PAD(0x668, 0x204, 3, 0x820, 0, NO_PAD_CTRL)
#define MX35_PAD_LD21__USB_TOP_USBOTG_STP			IOMUX_PAD(0x668, 0x204, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD21__GPIO3_27					IOMUX_PAD(0x668, 0x204, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD21__SDMA_DEBUG_EVENT_CHANNEL_SEL		IOMUX_PAD(0x668, 0x204, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD21__ARM11P_TOP_TRACE_14			IOMUX_PAD(0x668, 0x204, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD22__IPU_DISPB_DAT_22				IOMUX_PAD(0x66c, 0x208, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD22__IPU_DISPB_WR				IOMUX_PAD(0x66c, 0x208, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD22__IPU_DISPB_SD_D_I				IOMUX_PAD(0x66c, 0x208, 2, 0x92c, 0, NO_PAD_CTRL)
#define MX35_PAD_LD22__ESDHC3_DAT2				IOMUX_PAD(0x66c, 0x208, 3, 0x824, 0, NO_PAD_CTRL)
#define MX35_PAD_LD22__USB_TOP_USBOTG_NXT			IOMUX_PAD(0x66c, 0x208, 4, 0x9c8, 0, NO_PAD_CTRL)
#define MX35_PAD_LD22__GPIO3_28					IOMUX_PAD(0x66c, 0x208, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD22__SDMA_DEBUG_BUS_ERROR			IOMUX_PAD(0x66c, 0x208, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD22__ARM11P_TOP_TRCTL				IOMUX_PAD(0x66c, 0x208, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_LD23__IPU_DISPB_DAT_23				IOMUX_PAD(0x670, 0x20c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD23__IPU_DISPB_RD				IOMUX_PAD(0x670, 0x20c, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD23__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x670, 0x20c, 2, 0x92c, 1, NO_PAD_CTRL)
#define MX35_PAD_LD23__ESDHC3_DAT3				IOMUX_PAD(0x670, 0x20c, 3, 0x828, 0, NO_PAD_CTRL)
#define MX35_PAD_LD23__USB_TOP_USBOTG_DATA_7			IOMUX_PAD(0x670, 0x20c, 4, 0x9c0, 0, NO_PAD_CTRL)
#define MX35_PAD_LD23__GPIO3_29					IOMUX_PAD(0x670, 0x20c, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD23__SDMA_DEBUG_MATCHED_DMBUS			IOMUX_PAD(0x670, 0x20c, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_LD23__ARM11P_TOP_TRCLK				IOMUX_PAD(0x670, 0x20c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3_HSYNC__IPU_DISPB_D3_HSYNC			IOMUX_PAD(0x674, 0x210, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_HSYNC__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x674, 0x210, 2, 0x92c, 2, NO_PAD_CTRL)
#define MX35_PAD_D3_HSYNC__GPIO3_30				IOMUX_PAD(0x674, 0x210, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_HSYNC__SDMA_DEBUG_RTBUFFER_WRITE		IOMUX_PAD(0x674, 0x210, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_HSYNC__ARM11P_TOP_TRACE_15			IOMUX_PAD(0x674, 0x210, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3_FPSHIFT__IPU_DISPB_D3_CLK			IOMUX_PAD(0x678, 0x214, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_FPSHIFT__IPU_DISPB_SD_CLK			IOMUX_PAD(0x678, 0x214, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_FPSHIFT__GPIO3_31				IOMUX_PAD(0x678, 0x214, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_FPSHIFT__SDMA_SDMA_DEBUG_CORE_STATUS_0	IOMUX_PAD(0x678, 0x214, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_FPSHIFT__ARM11P_TOP_TRACE_16		IOMUX_PAD(0x678, 0x214, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3_DRDY__IPU_DISPB_D3_DRDY			IOMUX_PAD(0x67c, 0x218, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_DRDY__IPU_DISPB_SD_D_O			IOMUX_PAD(0x67c, 0x218, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_DRDY__GPIO1_0				IOMUX_PAD(0x67c, 0x218, 5, 0x82c, 2, NO_PAD_CTRL)
#define MX35_PAD_D3_DRDY__SDMA_SDMA_DEBUG_CORE_STATUS_1		IOMUX_PAD(0x67c, 0x218, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_DRDY__ARM11P_TOP_TRACE_17			IOMUX_PAD(0x67c, 0x218, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_CONTRAST__IPU_DISPB_CONTR			IOMUX_PAD(0x680, 0x21c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CONTRAST__GPIO1_1				IOMUX_PAD(0x680, 0x21c, 5, 0x838, 2, NO_PAD_CTRL)
#define MX35_PAD_CONTRAST__SDMA_SDMA_DEBUG_CORE_STATUS_2	IOMUX_PAD(0x680, 0x21c, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_CONTRAST__ARM11P_TOP_TRACE_18			IOMUX_PAD(0x680, 0x21c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3_VSYNC__IPU_DISPB_D3_VSYNC			IOMUX_PAD(0x684, 0x220, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_VSYNC__IPU_DISPB_CS1			IOMUX_PAD(0x684, 0x220, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_VSYNC__GPIO1_2				IOMUX_PAD(0x684, 0x220, 5, 0x848, 1, NO_PAD_CTRL)
#define MX35_PAD_D3_VSYNC__SDMA_DEBUG_YIELD			IOMUX_PAD(0x684, 0x220, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_VSYNC__ARM11P_TOP_TRACE_19			IOMUX_PAD(0x684, 0x220, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3_REV__IPU_DISPB_D3_REV			IOMUX_PAD(0x688, 0x224, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_REV__IPU_DISPB_SER_RS			IOMUX_PAD(0x688, 0x224, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_REV__GPIO1_3				IOMUX_PAD(0x688, 0x224, 5, 0x84c, 1, NO_PAD_CTRL)
#define MX35_PAD_D3_REV__SDMA_DEBUG_BUS_RWB			IOMUX_PAD(0x688, 0x224, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_REV__ARM11P_TOP_TRACE_20			IOMUX_PAD(0x688, 0x224, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3_CLS__IPU_DISPB_D3_CLS			IOMUX_PAD(0x68c, 0x228, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_CLS__IPU_DISPB_CS2				IOMUX_PAD(0x68c, 0x228, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_CLS__GPIO1_4				IOMUX_PAD(0x68c, 0x228, 5, 0x850, 2, NO_PAD_CTRL)
#define MX35_PAD_D3_CLS__SDMA_DEBUG_BUS_DEVICE_0		IOMUX_PAD(0x68c, 0x228, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_CLS__ARM11P_TOP_TRACE_21			IOMUX_PAD(0x68c, 0x228, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_D3_SPL__IPU_DISPB_D3_SPL			IOMUX_PAD(0x690, 0x22c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_SPL__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x690, 0x22c, 2, 0x928, 2, NO_PAD_CTRL)
#define MX35_PAD_D3_SPL__GPIO1_5				IOMUX_PAD(0x690, 0x22c, 5, 0x854, 2, NO_PAD_CTRL)
#define MX35_PAD_D3_SPL__SDMA_DEBUG_BUS_DEVICE_1		IOMUX_PAD(0x690, 0x22c, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_D3_SPL__ARM11P_TOP_TRACE_22			IOMUX_PAD(0x690, 0x22c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD1_CMD__ESDHC1_CMD				IOMUX_PAD(0x694, 0x230, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_CMD__MSHC_SCLK				IOMUX_PAD(0x694, 0x230, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_CMD__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x694, 0x230, 3, 0x924, 2, NO_PAD_CTRL)
#define MX35_PAD_SD1_CMD__USB_TOP_USBOTG_DATA_4			IOMUX_PAD(0x694, 0x230, 4, 0x9b4, 0, NO_PAD_CTRL)
#define MX35_PAD_SD1_CMD__GPIO1_6				IOMUX_PAD(0x694, 0x230, 5, 0x858, 2, NO_PAD_CTRL)
#define MX35_PAD_SD1_CMD__ARM11P_TOP_TRCTL			IOMUX_PAD(0x694, 0x230, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD1_CLK__ESDHC1_CLK				IOMUX_PAD(0x698, 0x234, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_CLK__MSHC_BS				IOMUX_PAD(0x698, 0x234, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_CLK__IPU_DISPB_BCLK			IOMUX_PAD(0x698, 0x234, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_CLK__USB_TOP_USBOTG_DATA_5			IOMUX_PAD(0x698, 0x234, 4, 0x9b8, 0, NO_PAD_CTRL)
#define MX35_PAD_SD1_CLK__GPIO1_7				IOMUX_PAD(0x698, 0x234, 5, 0x85c, 2, NO_PAD_CTRL)
#define MX35_PAD_SD1_CLK__ARM11P_TOP_TRCLK			IOMUX_PAD(0x698, 0x234, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD1_DATA0__ESDHC1_DAT0				IOMUX_PAD(0x69c, 0x238, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA0__MSHC_DATA_0				IOMUX_PAD(0x69c, 0x238, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA0__IPU_DISPB_CS0			IOMUX_PAD(0x69c, 0x238, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA0__USB_TOP_USBOTG_DATA_6		IOMUX_PAD(0x69c, 0x238, 4, 0x9bc, 0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA0__GPIO1_8				IOMUX_PAD(0x69c, 0x238, 5, 0x860, 2, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA0__ARM11P_TOP_TRACE_23			IOMUX_PAD(0x69c, 0x238, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD1_DATA1__ESDHC1_DAT1				IOMUX_PAD(0x6a0, 0x23c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA1__MSHC_DATA_1				IOMUX_PAD(0x6a0, 0x23c, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA1__IPU_DISPB_PAR_RS			IOMUX_PAD(0x6a0, 0x23c, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA1__USB_TOP_USBOTG_DATA_0		IOMUX_PAD(0x6a0, 0x23c, 4, 0x9a4, 0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA1__GPIO1_9				IOMUX_PAD(0x6a0, 0x23c, 5, 0x864, 1, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA1__ARM11P_TOP_TRACE_24			IOMUX_PAD(0x6a0, 0x23c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD1_DATA2__ESDHC1_DAT2				IOMUX_PAD(0x6a4, 0x240, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA2__MSHC_DATA_2				IOMUX_PAD(0x6a4, 0x240, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA2__IPU_DISPB_WR			IOMUX_PAD(0x6a4, 0x240, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA2__USB_TOP_USBOTG_DATA_1		IOMUX_PAD(0x6a4, 0x240, 4, 0x9a8, 0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA2__GPIO1_10				IOMUX_PAD(0x6a4, 0x240, 5, 0x830, 1, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA2__ARM11P_TOP_TRACE_25			IOMUX_PAD(0x6a4, 0x240, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD1_DATA3__ESDHC1_DAT3				IOMUX_PAD(0x6a8, 0x244, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA3__MSHC_DATA_3				IOMUX_PAD(0x6a8, 0x244, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA3__IPU_DISPB_RD			IOMUX_PAD(0x6a8, 0x244, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA3__USB_TOP_USBOTG_DATA_2		IOMUX_PAD(0x6a8, 0x244, 4, 0x9ac, 0, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA3__GPIO1_11				IOMUX_PAD(0x6a8, 0x244, 5, 0x834, 1, NO_PAD_CTRL)
#define MX35_PAD_SD1_DATA3__ARM11P_TOP_TRACE_26			IOMUX_PAD(0x6a8, 0x244, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD2_CMD__ESDHC2_CMD				IOMUX_PAD(0x6ac, 0x248, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_CMD__I2C3_SCL				IOMUX_PAD(0x6ac, 0x248, 1, 0x91c, 2, NO_PAD_CTRL)
#define MX35_PAD_SD2_CMD__ESDHC1_DAT4				IOMUX_PAD(0x6ac, 0x248, 2, 0x804, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_CMD__IPU_CSI_D_2				IOMUX_PAD(0x6ac, 0x248, 3, 0x938, 2, NO_PAD_CTRL)
#define MX35_PAD_SD2_CMD__USB_TOP_USBH2_DATA_4			IOMUX_PAD(0x6ac, 0x248, 4, 0x9dc, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_CMD__GPIO2_0				IOMUX_PAD(0x6ac, 0x248, 5, 0x868, 2, NO_PAD_CTRL)
#define MX35_PAD_SD2_CMD__SPDIF_SPDIF_OUT1			IOMUX_PAD(0x6ac, 0x248, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_CMD__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x6ac, 0x248, 7, 0x928, 3, NO_PAD_CTRL)

#define MX35_PAD_SD2_CLK__ESDHC2_CLK				IOMUX_PAD(0x6b0, 0x24c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_CLK__I2C3_SDA				IOMUX_PAD(0x6b0, 0x24c, 1, 0x920, 2, NO_PAD_CTRL)
#define MX35_PAD_SD2_CLK__ESDHC1_DAT5				IOMUX_PAD(0x6b0, 0x24c, 2, 0x808, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_CLK__IPU_CSI_D_3				IOMUX_PAD(0x6b0, 0x24c, 3, 0x93c, 2, NO_PAD_CTRL)
#define MX35_PAD_SD2_CLK__USB_TOP_USBH2_DATA_5			IOMUX_PAD(0x6b0, 0x24c, 4, 0x9e0, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_CLK__GPIO2_1				IOMUX_PAD(0x6b0, 0x24c, 5, 0x894, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_CLK__SPDIF_SPDIF_IN1			IOMUX_PAD(0x6b0, 0x24c, 6, 0x998, 2, NO_PAD_CTRL)
#define MX35_PAD_SD2_CLK__IPU_DISPB_CS2				IOMUX_PAD(0x6b0, 0x24c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_SD2_DATA0__ESDHC2_DAT0				IOMUX_PAD(0x6b4, 0x250, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA0__UART3_RXD_MUX			IOMUX_PAD(0x6b4, 0x250, 1, 0x9a0, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA0__ESDHC1_DAT6				IOMUX_PAD(0x6b4, 0x250, 2, 0x80c, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA0__IPU_CSI_D_4				IOMUX_PAD(0x6b4, 0x250, 3, 0x940, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA0__USB_TOP_USBH2_DATA_6		IOMUX_PAD(0x6b4, 0x250, 4, 0x9e4, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA0__GPIO2_2				IOMUX_PAD(0x6b4, 0x250, 5, 0x8c0, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA0__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x6b4, 0x250, 6, 0x994, 3, NO_PAD_CTRL)

#define MX35_PAD_SD2_DATA1__ESDHC2_DAT1				IOMUX_PAD(0x6b8, 0x254, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA1__UART3_TXD_MUX			IOMUX_PAD(0x6b8, 0x254, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA1__ESDHC1_DAT7				IOMUX_PAD(0x6b8, 0x254, 2, 0x810, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA1__IPU_CSI_D_5				IOMUX_PAD(0x6b8, 0x254, 3, 0x944, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA1__USB_TOP_USBH2_DATA_0		IOMUX_PAD(0x6b8, 0x254, 4, 0x9cc, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA1__GPIO2_3				IOMUX_PAD(0x6b8, 0x254, 5, 0x8cc, 1, NO_PAD_CTRL)

#define MX35_PAD_SD2_DATA2__ESDHC2_DAT2				IOMUX_PAD(0x6bc, 0x258, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA2__UART3_RTS				IOMUX_PAD(0x6bc, 0x258, 1, 0x99c, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA2__CAN1_RXCAN				IOMUX_PAD(0x6bc, 0x258, 2, 0x7c8, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA2__IPU_CSI_D_6				IOMUX_PAD(0x6bc, 0x258, 3, 0x948, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA2__USB_TOP_USBH2_DATA_1		IOMUX_PAD(0x6bc, 0x258, 4, 0x9d0, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA2__GPIO2_4				IOMUX_PAD(0x6bc, 0x258, 5, 0x8d0, 1, NO_PAD_CTRL)

#define MX35_PAD_SD2_DATA3__ESDHC2_DAT3				IOMUX_PAD(0x6c0, 0x25c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA3__UART3_CTS				IOMUX_PAD(0x6c0, 0x25c, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA3__CAN1_TXCAN				IOMUX_PAD(0x6c0, 0x25c, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA3__IPU_CSI_D_7				IOMUX_PAD(0x6c0, 0x25c, 3, 0x94c, 1, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA3__USB_TOP_USBH2_DATA_2		IOMUX_PAD(0x6c0, 0x25c, 4, 0x9d4, 0, NO_PAD_CTRL)
#define MX35_PAD_SD2_DATA3__GPIO2_5				IOMUX_PAD(0x6c0, 0x25c, 5, 0x8d4, 1, NO_PAD_CTRL)

#define MX35_PAD_ATA_CS0__ATA_CS0				IOMUX_PAD(0x6c4, 0x260, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS0__CSPI1_SS3				IOMUX_PAD(0x6c4, 0x260, 1, 0x7dc, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS0__IPU_DISPB_CS1				IOMUX_PAD(0x6c4, 0x260, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS0__GPIO2_6				IOMUX_PAD(0x6c4, 0x260, 5, 0x8d8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS0__IPU_DIAGB_0				IOMUX_PAD(0x6c4, 0x260, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS0__ARM11P_TOP_MAX1_HMASTER_0		IOMUX_PAD(0x6c4, 0x260, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_CS1__ATA_CS1				IOMUX_PAD(0x6c8, 0x264, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS1__IPU_DISPB_CS2				IOMUX_PAD(0x6c8, 0x264, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS1__CSPI2_SS0				IOMUX_PAD(0x6c8, 0x264, 4, 0x7f0, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS1__GPIO2_7				IOMUX_PAD(0x6c8, 0x264, 5, 0x8dc, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS1__IPU_DIAGB_1				IOMUX_PAD(0x6c8, 0x264, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_CS1__ARM11P_TOP_MAX1_HMASTER_1		IOMUX_PAD(0x6c8, 0x264, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DIOR__ATA_DIOR				IOMUX_PAD(0x6cc, 0x268, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOR__ESDHC3_DAT0				IOMUX_PAD(0x6cc, 0x268, 1, 0x81c, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOR__USB_TOP_USBOTG_DIR			IOMUX_PAD(0x6cc, 0x268, 2, 0x9c4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOR__IPU_DISPB_BE0			IOMUX_PAD(0x6cc, 0x268, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOR__CSPI2_SS1				IOMUX_PAD(0x6cc, 0x268, 4, 0x7f4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOR__GPIO2_8				IOMUX_PAD(0x6cc, 0x268, 5, 0x8e0, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOR__IPU_DIAGB_2				IOMUX_PAD(0x6cc, 0x268, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOR__ARM11P_TOP_MAX1_HMASTER_2		IOMUX_PAD(0x6cc, 0x268, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DIOW__ATA_DIOW				IOMUX_PAD(0x6d0, 0x26c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOW__ESDHC3_DAT1				IOMUX_PAD(0x6d0, 0x26c, 1, 0x820, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOW__USB_TOP_USBOTG_STP			IOMUX_PAD(0x6d0, 0x26c, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOW__IPU_DISPB_BE1			IOMUX_PAD(0x6d0, 0x26c, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOW__CSPI2_MOSI				IOMUX_PAD(0x6d0, 0x26c, 4, 0x7ec, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOW__GPIO2_9				IOMUX_PAD(0x6d0, 0x26c, 5, 0x8e4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOW__IPU_DIAGB_3				IOMUX_PAD(0x6d0, 0x26c, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DIOW__ARM11P_TOP_MAX1_HMASTER_3		IOMUX_PAD(0x6d0, 0x26c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DMACK__ATA_DMACK				IOMUX_PAD(0x6d4, 0x270, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMACK__ESDHC3_DAT2				IOMUX_PAD(0x6d4, 0x270, 1, 0x824, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMACK__USB_TOP_USBOTG_NXT			IOMUX_PAD(0x6d4, 0x270, 2, 0x9c8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMACK__CSPI2_MISO				IOMUX_PAD(0x6d4, 0x270, 4, 0x7e8, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMACK__GPIO2_10				IOMUX_PAD(0x6d4, 0x270, 5, 0x86c, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMACK__IPU_DIAGB_4				IOMUX_PAD(0x6d4, 0x270, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMACK__ARM11P_TOP_MAX0_HMASTER_0		IOMUX_PAD(0x6d4, 0x270, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_RESET_B__ATA_RESET_B			IOMUX_PAD(0x6d8, 0x274, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_RESET_B__ESDHC3_DAT3			IOMUX_PAD(0x6d8, 0x274, 1, 0x828, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_RESET_B__USB_TOP_USBOTG_DATA_0		IOMUX_PAD(0x6d8, 0x274, 2, 0x9a4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_RESET_B__IPU_DISPB_SD_D_O			IOMUX_PAD(0x6d8, 0x274, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_RESET_B__CSPI2_RDY				IOMUX_PAD(0x6d8, 0x274, 4, 0x7e4, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_RESET_B__GPIO2_11				IOMUX_PAD(0x6d8, 0x274, 5, 0x870, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_RESET_B__IPU_DIAGB_5			IOMUX_PAD(0x6d8, 0x274, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_RESET_B__ARM11P_TOP_MAX0_HMASTER_1		IOMUX_PAD(0x6d8, 0x274, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_IORDY__ATA_IORDY				IOMUX_PAD(0x6dc, 0x278, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_IORDY__ESDHC3_DAT4				IOMUX_PAD(0x6dc, 0x278, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_IORDY__USB_TOP_USBOTG_DATA_1		IOMUX_PAD(0x6dc, 0x278, 2, 0x9a8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_IORDY__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x6dc, 0x278, 3, 0x92c, 3, NO_PAD_CTRL)
#define MX35_PAD_ATA_IORDY__ESDHC2_DAT4				IOMUX_PAD(0x6dc, 0x278, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_IORDY__GPIO2_12				IOMUX_PAD(0x6dc, 0x278, 5, 0x874, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_IORDY__IPU_DIAGB_6				IOMUX_PAD(0x6dc, 0x278, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_IORDY__ARM11P_TOP_MAX0_HMASTER_2		IOMUX_PAD(0x6dc, 0x278, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA0__ATA_DATA_0				IOMUX_PAD(0x6e0, 0x27c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA0__ESDHC3_DAT5				IOMUX_PAD(0x6e0, 0x27c, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA0__USB_TOP_USBOTG_DATA_2		IOMUX_PAD(0x6e0, 0x27c, 2, 0x9ac, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA0__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x6e0, 0x27c, 3, 0x928, 4, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA0__ESDHC2_DAT5				IOMUX_PAD(0x6e0, 0x27c, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA0__GPIO2_13				IOMUX_PAD(0x6e0, 0x27c, 5, 0x878, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA0__IPU_DIAGB_7				IOMUX_PAD(0x6e0, 0x27c, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA0__ARM11P_TOP_MAX0_HMASTER_3		IOMUX_PAD(0x6e0, 0x27c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA1__ATA_DATA_1				IOMUX_PAD(0x6e4, 0x280, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA1__ESDHC3_DAT6				IOMUX_PAD(0x6e4, 0x280, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA1__USB_TOP_USBOTG_DATA_3		IOMUX_PAD(0x6e4, 0x280, 2, 0x9b0, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA1__IPU_DISPB_SD_CLK			IOMUX_PAD(0x6e4, 0x280, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA1__ESDHC2_DAT6				IOMUX_PAD(0x6e4, 0x280, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA1__GPIO2_14				IOMUX_PAD(0x6e4, 0x280, 5, 0x87c, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA1__IPU_DIAGB_8				IOMUX_PAD(0x6e4, 0x280, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA1__ARM11P_TOP_TRACE_27			IOMUX_PAD(0x6e4, 0x280, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA2__ATA_DATA_2				IOMUX_PAD(0x6e8, 0x284, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA2__ESDHC3_DAT7				IOMUX_PAD(0x6e8, 0x284, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA2__USB_TOP_USBOTG_DATA_4		IOMUX_PAD(0x6e8, 0x284, 2, 0x9b4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA2__IPU_DISPB_SER_RS			IOMUX_PAD(0x6e8, 0x284, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA2__ESDHC2_DAT7				IOMUX_PAD(0x6e8, 0x284, 4, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA2__GPIO2_15				IOMUX_PAD(0x6e8, 0x284, 5, 0x880, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA2__IPU_DIAGB_9				IOMUX_PAD(0x6e8, 0x284, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA2__ARM11P_TOP_TRACE_28			IOMUX_PAD(0x6e8, 0x284, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA3__ATA_DATA_3				IOMUX_PAD(0x6e8, 0x288, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA3__ESDHC3_CLK				IOMUX_PAD(0x6e8, 0x288, 1, 0x814, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA3__USB_TOP_USBOTG_DATA_5		IOMUX_PAD(0x6e8, 0x288, 2, 0x9b8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA3__CSPI2_SCLK				IOMUX_PAD(0x6e8, 0x288, 4, 0x7e0, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA3__GPIO2_16				IOMUX_PAD(0x6e8, 0x288, 5, 0x884, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA3__IPU_DIAGB_10			IOMUX_PAD(0x6e8, 0x288, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA3__ARM11P_TOP_TRACE_29			IOMUX_PAD(0x6e8, 0x288, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA4__ATA_DATA_4				IOMUX_PAD(0x6f0, 0x28c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA4__ESDHC3_CMD				IOMUX_PAD(0x6f0, 0x28c, 1, 0x818, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA4__USB_TOP_USBOTG_DATA_6		IOMUX_PAD(0x6f0, 0x28c, 2, 0x9bc, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA4__GPIO2_17				IOMUX_PAD(0x6f0, 0x28c, 5, 0x888, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA4__IPU_DIAGB_11			IOMUX_PAD(0x6f0, 0x28c, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA4__ARM11P_TOP_TRACE_30			IOMUX_PAD(0x6f0, 0x28c, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA5__ATA_DATA_5				IOMUX_PAD(0x6f4, 0x290, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA5__USB_TOP_USBOTG_DATA_7		IOMUX_PAD(0x6f4, 0x290, 2, 0x9c0, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA5__GPIO2_18				IOMUX_PAD(0x6f4, 0x290, 5, 0x88c, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA5__IPU_DIAGB_12			IOMUX_PAD(0x6f4, 0x290, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA5__ARM11P_TOP_TRACE_31			IOMUX_PAD(0x6f4, 0x290, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA6__ATA_DATA_6				IOMUX_PAD(0x6f8, 0x294, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA6__CAN1_TXCAN				IOMUX_PAD(0x6f8, 0x294, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA6__UART1_DTR				IOMUX_PAD(0x6f8, 0x294, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA6__AUDMUX_AUD6_TXD			IOMUX_PAD(0x6f8, 0x294, 3, 0x7b4, 0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA6__GPIO2_19				IOMUX_PAD(0x6f8, 0x294, 5, 0x890, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA6__IPU_DIAGB_13			IOMUX_PAD(0x6f8, 0x294, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA7__ATA_DATA_7				IOMUX_PAD(0x6fc, 0x298, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA7__CAN1_RXCAN				IOMUX_PAD(0x6fc, 0x298, 1, 0x7c8, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA7__UART1_DSR				IOMUX_PAD(0x6fc, 0x298, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA7__AUDMUX_AUD6_RXD			IOMUX_PAD(0x6fc, 0x298, 3, 0x7b0, 0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA7__GPIO2_20				IOMUX_PAD(0x6fc, 0x298, 5, 0x898, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA7__IPU_DIAGB_14			IOMUX_PAD(0x6fc, 0x298, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA8__ATA_DATA_8				IOMUX_PAD(0x700, 0x29c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA8__UART3_RTS				IOMUX_PAD(0x700, 0x29c, 1, 0x99c, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA8__UART1_RI				IOMUX_PAD(0x700, 0x29c, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA8__AUDMUX_AUD6_TXC			IOMUX_PAD(0x700, 0x29c, 3, 0x7c0, 0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA8__GPIO2_21				IOMUX_PAD(0x700, 0x29c, 5, 0x89c, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA8__IPU_DIAGB_15			IOMUX_PAD(0x700, 0x29c, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA9__ATA_DATA_9				IOMUX_PAD(0x704, 0x2a0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA9__UART3_CTS				IOMUX_PAD(0x704, 0x2a0, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA9__UART1_DCD				IOMUX_PAD(0x704, 0x2a0, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA9__AUDMUX_AUD6_TXFS			IOMUX_PAD(0x704, 0x2a0, 3, 0x7c4, 0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA9__GPIO2_22				IOMUX_PAD(0x704, 0x2a0, 5, 0x8a0, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA9__IPU_DIAGB_16			IOMUX_PAD(0x704, 0x2a0, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA10__ATA_DATA_10			IOMUX_PAD(0x708, 0x2a4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA10__UART3_RXD_MUX			IOMUX_PAD(0x708, 0x2a4, 1, 0x9a0, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA10__AUDMUX_AUD6_RXC			IOMUX_PAD(0x708, 0x2a4, 3, 0x7b8, 0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA10__GPIO2_23				IOMUX_PAD(0x708, 0x2a4, 5, 0x8a4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA10__IPU_DIAGB_17			IOMUX_PAD(0x708, 0x2a4, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA11__ATA_DATA_11			IOMUX_PAD(0x70c, 0x2a8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA11__UART3_TXD_MUX			IOMUX_PAD(0x70c, 0x2a8, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA11__AUDMUX_AUD6_RXFS			IOMUX_PAD(0x70c, 0x2a8, 3, 0x7bc, 0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA11__GPIO2_24				IOMUX_PAD(0x70c, 0x2a8, 5, 0x8a8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA11__IPU_DIAGB_18			IOMUX_PAD(0x70c, 0x2a8, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA12__ATA_DATA_12			IOMUX_PAD(0x710, 0x2ac, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA12__I2C3_SCL				IOMUX_PAD(0x710, 0x2ac, 1, 0x91c, 3, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA12__GPIO2_25				IOMUX_PAD(0x710, 0x2ac, 5, 0x8ac, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA12__IPU_DIAGB_19			IOMUX_PAD(0x710, 0x2ac, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA13__ATA_DATA_13			IOMUX_PAD(0x714, 0x2b0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA13__I2C3_SDA				IOMUX_PAD(0x714, 0x2b0, 1, 0x920, 3, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA13__GPIO2_26				IOMUX_PAD(0x714, 0x2b0, 5, 0x8b0, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA13__IPU_DIAGB_20			IOMUX_PAD(0x714, 0x2b0, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA14__ATA_DATA_14			IOMUX_PAD(0x718, 0x2b4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA14__IPU_CSI_D_0			IOMUX_PAD(0x718, 0x2b4, 1, 0x930, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA14__KPP_ROW_0				IOMUX_PAD(0x718, 0x2b4, 3, 0x970, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA14__GPIO2_27				IOMUX_PAD(0x718, 0x2b4, 5, 0x8b4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA14__IPU_DIAGB_21			IOMUX_PAD(0x718, 0x2b4, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DATA15__ATA_DATA_15			IOMUX_PAD(0x71c, 0x2b8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA15__IPU_CSI_D_1			IOMUX_PAD(0x71c, 0x2b8, 1, 0x934, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA15__KPP_ROW_1				IOMUX_PAD(0x71c, 0x2b8, 3, 0x974, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA15__GPIO2_28				IOMUX_PAD(0x71c, 0x2b8, 5, 0x8b8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DATA15__IPU_DIAGB_22			IOMUX_PAD(0x71c, 0x2b8, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_INTRQ__ATA_INTRQ				IOMUX_PAD(0x720, 0x2bc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_INTRQ__IPU_CSI_D_2				IOMUX_PAD(0x720, 0x2bc, 1, 0x938, 3, NO_PAD_CTRL)
#define MX35_PAD_ATA_INTRQ__KPP_ROW_2				IOMUX_PAD(0x720, 0x2bc, 3, 0x978, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_INTRQ__GPIO2_29				IOMUX_PAD(0x720, 0x2bc, 5, 0x8bc, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_INTRQ__IPU_DIAGB_23			IOMUX_PAD(0x720, 0x2bc, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_BUFF_EN__ATA_BUFFER_EN			IOMUX_PAD(0x724, 0x2c0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_BUFF_EN__IPU_CSI_D_3			IOMUX_PAD(0x724, 0x2c0, 1, 0x93c, 3, NO_PAD_CTRL)
#define MX35_PAD_ATA_BUFF_EN__KPP_ROW_3				IOMUX_PAD(0x724, 0x2c0, 3, 0x97c, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_BUFF_EN__GPIO2_30				IOMUX_PAD(0x724, 0x2c0, 5, 0x8c4, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_BUFF_EN__IPU_DIAGB_24			IOMUX_PAD(0x724, 0x2c0, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DMARQ__ATA_DMARQ				IOMUX_PAD(0x728, 0x2c4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMARQ__IPU_CSI_D_4				IOMUX_PAD(0x728, 0x2c4, 1, 0x940, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMARQ__KPP_COL_0				IOMUX_PAD(0x728, 0x2c4, 3, 0x950, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMARQ__GPIO2_31				IOMUX_PAD(0x728, 0x2c4, 5, 0x8c8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMARQ__IPU_DIAGB_25			IOMUX_PAD(0x728, 0x2c4, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DMARQ__ECT_CTI_TRIG_IN1_4			IOMUX_PAD(0x728, 0x2c4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DA0__ATA_DA_0				IOMUX_PAD(0x72c, 0x2c8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA0__IPU_CSI_D_5				IOMUX_PAD(0x72c, 0x2c8, 1, 0x944, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA0__KPP_COL_1				IOMUX_PAD(0x72c, 0x2c8, 3, 0x954, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA0__GPIO3_0				IOMUX_PAD(0x72c, 0x2c8, 5, 0x8e8, 1, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA0__IPU_DIAGB_26				IOMUX_PAD(0x72c, 0x2c8, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA0__ECT_CTI_TRIG_IN1_5			IOMUX_PAD(0x72c, 0x2c8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DA1__ATA_DA_1				IOMUX_PAD(0x730, 0x2cc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA1__IPU_CSI_D_6				IOMUX_PAD(0x730, 0x2cc, 1, 0x948, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA1__KPP_COL_2				IOMUX_PAD(0x730, 0x2cc, 3, 0x958, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA1__GPIO3_1				IOMUX_PAD(0x730, 0x2cc, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA1__IPU_DIAGB_27				IOMUX_PAD(0x730, 0x2cc, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA1__ECT_CTI_TRIG_IN1_6			IOMUX_PAD(0x730, 0x2cc, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_ATA_DA2__ATA_DA_2				IOMUX_PAD(0x734, 0x2d0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA2__IPU_CSI_D_7				IOMUX_PAD(0x734, 0x2d0, 1, 0x94c, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA2__KPP_COL_3				IOMUX_PAD(0x734, 0x2d0, 3, 0x95c, 2, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA2__GPIO3_2				IOMUX_PAD(0x734, 0x2d0, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA2__IPU_DIAGB_28				IOMUX_PAD(0x734, 0x2d0, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_ATA_DA2__ECT_CTI_TRIG_IN1_7			IOMUX_PAD(0x734, 0x2d0, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_MLB_CLK__MLB_MLBCLK				IOMUX_PAD(0x738, 0x2d4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_MLB_CLK__GPIO3_3				IOMUX_PAD(0x738, 0x2d4, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_MLB_DAT__MLB_MLBDAT				IOMUX_PAD(0x73c, 0x2d8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_MLB_DAT__GPIO3_4				IOMUX_PAD(0x73c, 0x2d8, 5, 0x904, 1, NO_PAD_CTRL)

#define MX35_PAD_MLB_SIG__MLB_MLBSIG				IOMUX_PAD(0x740, 0x2dc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_MLB_SIG__GPIO3_5				IOMUX_PAD(0x740, 0x2dc, 5, 0x908, 1, NO_PAD_CTRL)

#define MX35_PAD_FEC_TX_CLK__FEC_TX_CLK				IOMUX_PAD(0x744, 0x2e0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_CLK__ESDHC1_DAT4			IOMUX_PAD(0x744, 0x2e0, 1, 0x804, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_CLK__UART3_RXD_MUX			IOMUX_PAD(0x744, 0x2e0, 2, 0x9a0, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_CLK__USB_TOP_USBH2_DIR			IOMUX_PAD(0x744, 0x2e0, 3, 0x9ec, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_CLK__CSPI2_MOSI				IOMUX_PAD(0x744, 0x2e0, 4, 0x7ec, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_CLK__GPIO3_6				IOMUX_PAD(0x744, 0x2e0, 5, 0x90c, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_CLK__IPU_DISPB_D12_VSYNC		IOMUX_PAD(0x744, 0x2e0, 6, 0x928, 5, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_CLK__ARM11P_TOP_EVNTBUS_0		IOMUX_PAD(0x744, 0x2e0, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_RX_CLK__FEC_RX_CLK				IOMUX_PAD(0x748, 0x2e4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_CLK__ESDHC1_DAT5			IOMUX_PAD(0x748, 0x2e4, 1, 0x808, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_CLK__UART3_TXD_MUX			IOMUX_PAD(0x748, 0x2e4, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_CLK__USB_TOP_USBH2_STP			IOMUX_PAD(0x748, 0x2e4, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_CLK__CSPI2_MISO				IOMUX_PAD(0x748, 0x2e4, 4, 0x7e8, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_CLK__GPIO3_7				IOMUX_PAD(0x748, 0x2e4, 5, 0x910, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_CLK__IPU_DISPB_SD_D_I			IOMUX_PAD(0x748, 0x2e4, 6, 0x92c, 4, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_CLK__ARM11P_TOP_EVNTBUS_1		IOMUX_PAD(0x748, 0x2e4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_RX_DV__FEC_RX_DV				IOMUX_PAD(0x74c, 0x2e8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_DV__ESDHC1_DAT6				IOMUX_PAD(0x74c, 0x2e8, 1, 0x80c, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_DV__UART3_RTS				IOMUX_PAD(0x74c, 0x2e8, 2, 0x99c, 2, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_DV__USB_TOP_USBH2_NXT			IOMUX_PAD(0x74c, 0x2e8, 3, 0x9f0, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_DV__CSPI2_SCLK				IOMUX_PAD(0x74c, 0x2e8, 4, 0x7e0, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_DV__GPIO3_8				IOMUX_PAD(0x74c, 0x2e8, 5, 0x914, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_DV__IPU_DISPB_SD_CLK			IOMUX_PAD(0x74c, 0x2e8, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_DV__ARM11P_TOP_EVNTBUS_2		IOMUX_PAD(0x74c, 0x2e8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_COL__FEC_COL				IOMUX_PAD(0x750, 0x2ec, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_COL__ESDHC1_DAT7				IOMUX_PAD(0x750, 0x2ec, 1, 0x810, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_COL__UART3_CTS				IOMUX_PAD(0x750, 0x2ec, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_COL__USB_TOP_USBH2_DATA_0			IOMUX_PAD(0x750, 0x2ec, 3, 0x9cc, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_COL__CSPI2_RDY				IOMUX_PAD(0x750, 0x2ec, 4, 0x7e4, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_COL__GPIO3_9				IOMUX_PAD(0x750, 0x2ec, 5, 0x918, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_COL__IPU_DISPB_SER_RS			IOMUX_PAD(0x750, 0x2ec, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_COL__ARM11P_TOP_EVNTBUS_3			IOMUX_PAD(0x750, 0x2ec, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_RDATA0__FEC_RDATA_0			IOMUX_PAD(0x754, 0x2f0, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA0__PWM_PWMO				IOMUX_PAD(0x754, 0x2f0, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA0__UART3_DTR				IOMUX_PAD(0x754, 0x2f0, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA0__USB_TOP_USBH2_DATA_1		IOMUX_PAD(0x754, 0x2f0, 3, 0x9d0, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA0__CSPI2_SS0				IOMUX_PAD(0x754, 0x2f0, 4, 0x7f0, 2, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA0__GPIO3_10				IOMUX_PAD(0x754, 0x2f0, 5, 0x8ec, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA0__IPU_DISPB_CS1			IOMUX_PAD(0x754, 0x2f0, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA0__ARM11P_TOP_EVNTBUS_4		IOMUX_PAD(0x754, 0x2f0, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_TDATA0__FEC_TDATA_0			IOMUX_PAD(0x758, 0x2f4, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA0__SPDIF_SPDIF_OUT1			IOMUX_PAD(0x758, 0x2f4, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA0__UART3_DSR				IOMUX_PAD(0x758, 0x2f4, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA0__USB_TOP_USBH2_DATA_2		IOMUX_PAD(0x758, 0x2f4, 3, 0x9d4, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA0__CSPI2_SS1				IOMUX_PAD(0x758, 0x2f4, 4, 0x7f4, 2, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA0__GPIO3_11				IOMUX_PAD(0x758, 0x2f4, 5, 0x8f0, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA0__IPU_DISPB_CS0			IOMUX_PAD(0x758, 0x2f4, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA0__ARM11P_TOP_EVNTBUS_5		IOMUX_PAD(0x758, 0x2f4, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_TX_EN__FEC_TX_EN				IOMUX_PAD(0x75c, 0x2f8, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_EN__SPDIF_SPDIF_IN1			IOMUX_PAD(0x75c, 0x2f8, 1, 0x998, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_EN__UART3_RI				IOMUX_PAD(0x75c, 0x2f8, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_EN__USB_TOP_USBH2_DATA_3		IOMUX_PAD(0x75c, 0x2f8, 3, 0x9d8, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_EN__GPIO3_12				IOMUX_PAD(0x75c, 0x2f8, 5, 0x8f4, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_EN__IPU_DISPB_PAR_RS			IOMUX_PAD(0x75c, 0x2f8, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_EN__ARM11P_TOP_EVNTBUS_6		IOMUX_PAD(0x75c, 0x2f8, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_MDC__FEC_MDC				IOMUX_PAD(0x760, 0x2fc, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDC__CAN2_TXCAN				IOMUX_PAD(0x760, 0x2fc, 1, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDC__UART3_DCD				IOMUX_PAD(0x760, 0x2fc, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDC__USB_TOP_USBH2_DATA_4			IOMUX_PAD(0x760, 0x2fc, 3, 0x9dc, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDC__GPIO3_13				IOMUX_PAD(0x760, 0x2fc, 5, 0x8f8, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDC__IPU_DISPB_WR				IOMUX_PAD(0x760, 0x2fc, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDC__ARM11P_TOP_EVNTBUS_7			IOMUX_PAD(0x760, 0x2fc, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_MDIO__FEC_MDIO				IOMUX_PAD(0x764, 0x300, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDIO__CAN2_RXCAN				IOMUX_PAD(0x764, 0x300, 1, 0x7cc, 2, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDIO__USB_TOP_USBH2_DATA_5			IOMUX_PAD(0x764, 0x300, 3, 0x9e0, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDIO__GPIO3_14				IOMUX_PAD(0x764, 0x300, 5, 0x8fc, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDIO__IPU_DISPB_RD				IOMUX_PAD(0x764, 0x300, 6, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_MDIO__ARM11P_TOP_EVNTBUS_8			IOMUX_PAD(0x764, 0x300, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_TX_ERR__FEC_TX_ERR				IOMUX_PAD(0x768, 0x304, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_ERR__OWIRE_LINE				IOMUX_PAD(0x768, 0x304, 1, 0x990, 2, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_ERR__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x768, 0x304, 2, 0x994, 4, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_ERR__USB_TOP_USBH2_DATA_6		IOMUX_PAD(0x768, 0x304, 3, 0x9e4, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_ERR__GPIO3_15				IOMUX_PAD(0x768, 0x304, 5, 0x900, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_ERR__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x768, 0x304, 6, 0x924, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_TX_ERR__ARM11P_TOP_EVNTBUS_9		IOMUX_PAD(0x768, 0x304, 7, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_RX_ERR__FEC_RX_ERR				IOMUX_PAD(0x76c, 0x308, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_ERR__IPU_CSI_D_0			IOMUX_PAD(0x76c, 0x308, 1, 0x930, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_ERR__USB_TOP_USBH2_DATA_7		IOMUX_PAD(0x76c, 0x308, 3, 0x9e8, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_ERR__KPP_COL_4				IOMUX_PAD(0x76c, 0x308, 4, 0x960, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_ERR__GPIO3_16				IOMUX_PAD(0x76c, 0x308, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RX_ERR__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x76c, 0x308, 6, 0x92c, 5, NO_PAD_CTRL)

#define MX35_PAD_FEC_CRS__FEC_CRS				IOMUX_PAD(0x770, 0x30c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_CRS__IPU_CSI_D_1				IOMUX_PAD(0x770, 0x30c, 1, 0x934, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_CRS__USB_TOP_USBH2_PWR			IOMUX_PAD(0x770, 0x30c, 3, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_CRS__KPP_COL_5				IOMUX_PAD(0x770, 0x30c, 4, 0x964, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_CRS__GPIO3_17				IOMUX_PAD(0x770, 0x30c, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_CRS__IPU_FLASH_STROBE			IOMUX_PAD(0x770, 0x30c, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_RDATA1__FEC_RDATA_1			IOMUX_PAD(0x774, 0x310, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA1__IPU_CSI_D_2			IOMUX_PAD(0x774, 0x310, 1, 0x938, 4, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA1__AUDMUX_AUD6_RXC			IOMUX_PAD(0x774, 0x310, 2, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA1__USB_TOP_USBH2_OC			IOMUX_PAD(0x774, 0x310, 3, 0x9f4, 2, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA1__KPP_COL_6				IOMUX_PAD(0x774, 0x310, 4, 0x968, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA1__GPIO3_18				IOMUX_PAD(0x774, 0x310, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA1__IPU_DISPB_BE0			IOMUX_PAD(0x774, 0x310, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_TDATA1__FEC_TDATA_1			IOMUX_PAD(0x778, 0x314, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA1__IPU_CSI_D_3			IOMUX_PAD(0x778, 0x314, 1, 0x93c, 4, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA1__AUDMUX_AUD6_RXFS			IOMUX_PAD(0x778, 0x314, 2, 0x7bc, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA1__KPP_COL_7				IOMUX_PAD(0x778, 0x314, 4, 0x96c, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA1__GPIO3_19				IOMUX_PAD(0x778, 0x314, 5, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA1__IPU_DISPB_BE1			IOMUX_PAD(0x778, 0x314, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_RDATA2__FEC_RDATA_2			IOMUX_PAD(0x77c, 0x318, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA2__IPU_CSI_D_4			IOMUX_PAD(0x77c, 0x318, 1, 0x940, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA2__AUDMUX_AUD6_TXD			IOMUX_PAD(0x77c, 0x318, 2, 0x7b4, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA2__KPP_ROW_4				IOMUX_PAD(0x77c, 0x318, 4, 0x980, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA2__GPIO3_20				IOMUX_PAD(0x77c, 0x318, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_TDATA2__FEC_TDATA_2			IOMUX_PAD(0x780, 0x31c, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA2__IPU_CSI_D_5			IOMUX_PAD(0x780, 0x31c, 1, 0x944, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA2__AUDMUX_AUD6_RXD			IOMUX_PAD(0x780, 0x31c, 2, 0x7b0, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA2__KPP_ROW_5				IOMUX_PAD(0x780, 0x31c, 4, 0x984, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA2__GPIO3_21				IOMUX_PAD(0x780, 0x31c, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_RDATA3__FEC_RDATA_3			IOMUX_PAD(0x784, 0x320, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA3__IPU_CSI_D_6			IOMUX_PAD(0x784, 0x320, 1, 0x948, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA3__AUDMUX_AUD6_TXC			IOMUX_PAD(0x784, 0x320, 2, 0x7c0, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA3__KPP_ROW_6				IOMUX_PAD(0x784, 0x320, 4, 0x988, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_RDATA3__GPIO3_22				IOMUX_PAD(0x784, 0x320, 6, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_FEC_TDATA3__FEC_TDATA_3			IOMUX_PAD(0x788, 0x324, 0, 0x0,   0, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA3__IPU_CSI_D_7			IOMUX_PAD(0x788, 0x324, 1, 0x94c, 3, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA3__AUDMUX_AUD6_TXFS			IOMUX_PAD(0x788, 0x324, 2, 0x7c4, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA3__KPP_ROW_7				IOMUX_PAD(0x788, 0x324, 4, 0x98c, 1, NO_PAD_CTRL)
#define MX35_PAD_FEC_TDATA3__GPIO3_23				IOMUX_PAD(0x788, 0x324, 5, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_EXT_ARMCLK__CCM_EXT_ARMCLK			IOMUX_PAD(0x78c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)

#define MX35_PAD_TEST_MODE__TCU_TEST_MODE			IOMUX_PAD(0x790, 0x0,   0, 0x0,   0, NO_PAD_CTRL)


#endif /* __MACH_IOMUX_MX35_H__ */
#ifndef _ASM_POWERPC_IOCTLS_H
#define _ASM_POWERPC_IOCTLS_H

#include <asm/ioctl.h>

#define FIOCLEX		_IO('f', 1)
#define FIONCLEX	_IO('f', 2)
#define FIOASYNC	_IOW('f', 125, int)
#define FIONBIO		_IOW('f', 126, int)
#define FIONREAD	_IOR('f', 127, int)
#define TIOCINQ		FIONREAD
#define FIOQSIZE	_IOR('f', 128, loff_t)

#define TIOCGETP	_IOR('t', 8, struct sgttyb)
#define TIOCSETP	_IOW('t', 9, struct sgttyb)
#define TIOCSETN	_IOW('t', 10, struct sgttyb)	/* TIOCSETP wo flush */

#define TIOCSETC	_IOW('t', 17, struct tchars)
#define TIOCGETC	_IOR('t', 18, struct tchars)
#define TCGETS		_IOR('t', 19, struct termios)
#define TCSETS		_IOW('t', 20, struct termios)
#define TCSETSW		_IOW('t', 21, struct termios)
#define TCSETSF		_IOW('t', 22, struct termios)

#define TCGETA		_IOR('t', 23, struct termio)
#define TCSETA		_IOW('t', 24, struct termio)
#define TCSETAW		_IOW('t', 25, struct termio)
#define TCSETAF		_IOW('t', 28, struct termio)

#define TCSBRK		_IO('t', 29)
#define TCXONC		_IO('t', 30)
#define TCFLSH		_IO('t', 31)

#define TIOCSWINSZ	_IOW('t', 103, struct winsize)
#define TIOCGWINSZ	_IOR('t', 104, struct winsize)
#define	TIOCSTART	_IO('t', 110)		/* start output, like ^Q */
#define	TIOCSTOP	_IO('t', 111)		/* stop output, like ^S */
#define TIOCOUTQ        _IOR('t', 115, int)     /* output queue size */

#define TIOCGLTC	_IOR('t', 116, struct ltchars)
#define TIOCSLTC	_IOW('t', 117, struct ltchars)
#define TIOCSPGRP	_IOW('t', 118, int)
#define TIOCGPGRP	_IOR('t', 119, int)

#define TIOCEXCL	0x540C
#define TIOCNXCL	0x540D
#define TIOCSCTTY	0x540E

#define TIOCSTI		0x5412
#define TIOCMGET	0x5415
#define TIOCMBIS	0x5416
#define TIOCMBIC	0x5417
#define TIOCMSET	0x5418
# define TIOCM_LE	0x001
# define TIOCM_DTR	0x002
# define TIOCM_RTS	0x004
# define TIOCM_ST	0x008
# define TIOCM_SR	0x010
# define TIOCM_CTS	0x020
# define TIOCM_CAR	0x040
# define TIOCM_RNG	0x080
# define TIOCM_DSR	0x100
# define TIOCM_CD	TIOCM_CAR
# define TIOCM_RI	TIOCM_RNG
#define TIOCM_OUT1	0x2000
#define TIOCM_OUT2	0x4000
#define TIOCM_LOOP	0x8000

#define TIOCGSOFTCAR	0x5419
#define TIOCSSOFTCAR	0x541A
#define TIOCLINUX	0x541C
#define TIOCCONS	0x541D
#define TIOCGSERIAL	0x541E
#define TIOCSSERIAL	0x541F
#define TIOCPKT		0x5420
# define TIOCPKT_DATA		 0
# define TIOCPKT_FLUSHREAD	 1
# define TIOCPKT_FLUSHWRITE	 2
# define TIOCPKT_STOP		 4
# define TIOCPKT_START		 8
# define TIOCPKT_NOSTOP		16
# define TIOCPKT_DOSTOP		32
# define TIOCPKT_IOCTL		64


#define TIOCNOTTY	0x5422
#define TIOCSETD	0x5423
#define TIOCGETD	0x5424
#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
#define TIOCSBRK	0x5427  /* BSD compatibility */
#define TIOCCBRK	0x5428  /* BSD compatibility */
#define TIOCGSID	0x5429  /* Return the session ID of FD */
#define TIOCGRS485	0x542e
#define TIOCSRS485	0x542f
#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
#define TIOCSIG		_IOW('T',0x36, int)  /* Generate signal on Pty slave */

#define TIOCSERCONFIG	0x5453
#define TIOCSERGWILD	0x5454
#define TIOCSERSWILD	0x5455
#define TIOCGLCKTRMIOS	0x5456
#define TIOCSLCKTRMIOS	0x5457
#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
#define TIOCSERGETLSR   0x5459 /* Get line status register */
  /* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
# define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
#define TIOCSERSETMULTI 0x545B /* Set multiport config */

#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */

#endif	/* _ASM_POWERPC_IOCTLS_H */
// Copyright 2010 Tilera Corporation. All Rights Reserved.
//
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License
//   as published by the Free Software Foundation, version 2.
//
//   This program is distributed in the hope that it will be useful, but
//   WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
//   NON INFRINGEMENT.  See the GNU General Public License for
//   more details.

//! @file
//!
//! Some low-level simulator definitions.
//!

#ifndef __ARCH_SIM_DEF_H__
#define __ARCH_SIM_DEF_H__


//! Internal: the low bits of the SIM_CONTROL_* SPR values specify
//! the operation to perform, and the remaining bits are
//! an operation-specific parameter (often unused).
//!
#define _SIM_CONTROL_OPERATOR_BITS 8


//== Values which can be written to SPR_SIM_CONTROL.

//! If written to SPR_SIM_CONTROL, stops profiling.
//!
#define SIM_CONTROL_PROFILER_DISABLE 0

//! If written to SPR_SIM_CONTROL, starts profiling.
//!
#define SIM_CONTROL_PROFILER_ENABLE 1

//! If written to SPR_SIM_CONTROL, clears profiling counters.
//!
#define SIM_CONTROL_PROFILER_CLEAR 2

//! If written to SPR_SIM_CONTROL, checkpoints the simulator.
//!
#define SIM_CONTROL_CHECKPOINT 3

//! If written to SPR_SIM_CONTROL, combined with a mask (shifted by 8),
//! sets the tracing mask to the given mask. See "sim_set_tracing()".
//!
#define SIM_CONTROL_SET_TRACING 4

//! If written to SPR_SIM_CONTROL, combined with a mask (shifted by 8),
//! dumps the requested items of machine state to the log.
//!
#define SIM_CONTROL_DUMP 5

//! If written to SPR_SIM_CONTROL, clears chip-level profiling counters.
//!
#define SIM_CONTROL_PROFILER_CHIP_CLEAR 6

//! If written to SPR_SIM_CONTROL, disables chip-level profiling.
//!
#define SIM_CONTROL_PROFILER_CHIP_DISABLE 7

//! If written to SPR_SIM_CONTROL, enables chip-level profiling.
//!
#define SIM_CONTROL_PROFILER_CHIP_ENABLE 8

//! If written to SPR_SIM_CONTROL, enables chip-level functional mode
//!
#define SIM_CONTROL_ENABLE_FUNCTIONAL 9

//! If written to SPR_SIM_CONTROL, disables chip-level functional mode.
//!
#define SIM_CONTROL_DISABLE_FUNCTIONAL 10

//! If written to SPR_SIM_CONTROL, enables chip-level functional mode.
//! All tiles must perform this write for functional mode to be enabled.
//! Ignored in naked boot mode unless --functional is specified.
//! WARNING: Only the hypervisor startup code should use this!
//!
#define SIM_CONTROL_ENABLE_FUNCTIONAL_BARRIER 11

//! If written to SPR_SIM_CONTROL, combined with a character (shifted by 8),
//! writes a string directly to the simulator output.  Written to once for
//! each character in the string, plus a final NUL.  Instead of NUL,
//! you can also use "SIM_PUTC_FLUSH_STRING" or "SIM_PUTC_FLUSH_BINARY".
//!
// ISSUE: Document the meaning of "newline", and the handling of NUL.
//
#define SIM_CONTROL_PUTC 12

//! If written to SPR_SIM_CONTROL, clears the --grind-coherence state for
//! this core.  This is intended to be used before a loop that will
//! invalidate the cache by loading new data and evicting all current data.
//! Generally speaking, this API should only be used by system code.
//!
#define SIM_CONTROL_GRINDER_CLEAR 13

//! If written to SPR_SIM_CONTROL, shuts down the simulator.
//!
#define SIM_CONTROL_SHUTDOWN 14

//! If written to SPR_SIM_CONTROL, combined with a pid (shifted by 8),
//! indicates that a fork syscall just created the given process.
//!
#define SIM_CONTROL_OS_FORK 15

//! If written to SPR_SIM_CONTROL, combined with a pid (shifted by 8),
//! indicates that an exit syscall was just executed by the given process.
//!
#define SIM_CONTROL_OS_EXIT 16

//! If written to SPR_SIM_CONTROL, combined with a pid (shifted by 8),
//! indicates that the OS just switched to the given process.
//!
#define SIM_CONTROL_OS_SWITCH 17

//! If written to SPR_SIM_CONTROL, combined with a character (shifted by 8),
//! indicates that an exec syscall was just executed. Written to once for
//! each character in the executable name, plus a final NUL.
//!
#define SIM_CONTROL_OS_EXEC 18

//! If written to SPR_SIM_CONTROL, combined with a character (shifted by 8),
//! indicates that an interpreter (PT_INTERP) was loaded.  Written to once
//! for each character in "ADDR:PATH", plus a final NUL, where "ADDR" is a
//! hex load address starting with "0x", and "PATH" is the executable name.
//!
#define SIM_CONTROL_OS_INTERP 19

//! If written to SPR_SIM_CONTROL, combined with a character (shifted by 8),
//! indicates that a dll was loaded.  Written to once for each character
//! in "ADDR:PATH", plus a final NUL, where "ADDR" is a hexadecimal load
//! address starting with "0x", and "PATH" is the executable name.
//!
#define SIM_CONTROL_DLOPEN 20

//! If written to SPR_SIM_CONTROL, combined with a character (shifted by 8),
//! indicates that a dll was unloaded.  Written to once for each character
//! in "ADDR", plus a final NUL, where "ADDR" is a hexadecimal load
//! address starting with "0x".
//!
#define SIM_CONTROL_DLCLOSE 21

//! If written to SPR_SIM_CONTROL, combined with a flag (shifted by 8),
//! indicates whether to allow data reads to remotely-cached
//! dirty cache lines to be cached locally without grinder warnings or
//! assertions (used by Linux kernel fast memcpy).
//!
#define SIM_CONTROL_ALLOW_MULTIPLE_CACHING 22

//! If written to SPR_SIM_CONTROL, enables memory tracing.
//!
#define SIM_CONTROL_ENABLE_MEM_LOGGING 23

//! If written to SPR_SIM_CONTROL, disables memory tracing.
//!
#define SIM_CONTROL_DISABLE_MEM_LOGGING 24

//! If written to SPR_SIM_CONTROL, changes the shaping parameters of one of
//! the gbe or xgbe shims. Must specify the shim id, the type, the units, and
//! the rate, as defined in SIM_SHAPING_SPR_ARG.
//!
#define SIM_CONTROL_SHAPING 25

//! If written to SPR_SIM_CONTROL, combined with character (shifted by 8),
//! requests that a simulator command be executed.  Written to once for each
//! character in the command, plus a final NUL.
//!
#define SIM_CONTROL_COMMAND 26

//! If written to SPR_SIM_CONTROL, indicates that the simulated system
//! is panicking, to allow debugging via --debug-on-panic.
//!
#define SIM_CONTROL_PANIC 27

//! If written to SPR_SIM_CONTROL, triggers a simulator syscall.
//! See "sim_syscall()" for more info.
//!
#define SIM_CONTROL_SYSCALL 32

//! If written to SPR_SIM_CONTROL, combined with a pid (shifted by 8),
//! provides the pid that subsequent SIM_CONTROL_OS_FORK writes should
//! use as the pid, rather than the default previous SIM_CONTROL_OS_SWITCH.
//!
#define SIM_CONTROL_OS_FORK_PARENT 33

//! If written to SPR_SIM_CONTROL, combined with a mPIPE shim number
//! (shifted by 8), clears the pending magic data section.  The cleared
//! pending magic data section and any subsequently appended magic bytes
//! will only take effect when the classifier blast programmer is run.
#define SIM_CONTROL_CLEAR_MPIPE_MAGIC_BYTES 34

//! If written to SPR_SIM_CONTROL, combined with a mPIPE shim number
//! (shifted by 8) and a byte of data (shifted by 16), appends that byte
//! to the shim's pending magic data section.  The pending magic data
//! section takes effect when the classifier blast programmer is run.
#define SIM_CONTROL_APPEND_MPIPE_MAGIC_BYTE 35

//! If written to SPR_SIM_CONTROL, combined with a mPIPE shim number
//! (shifted by 8), an enable=1/disable=0 bit (shifted by 16), and a
//! mask of links (shifted by 32), enable or disable the corresponding
//! mPIPE links.
#define SIM_CONTROL_ENABLE_MPIPE_LINK_MAGIC_BYTE 36

//== Syscall numbers for use with "sim_syscall()".

//! Syscall number for sim_add_watchpoint().
//!
#define SIM_SYSCALL_ADD_WATCHPOINT 2

//! Syscall number for sim_remove_watchpoint().
//!
#define SIM_SYSCALL_REMOVE_WATCHPOINT 3

//! Syscall number for sim_query_watchpoint().
//!
#define SIM_SYSCALL_QUERY_WATCHPOINT 4

//! Syscall number that asserts that the cache lines whose 64-bit PA
//! is passed as the second argument to sim_syscall(), and over a
//! range passed as the third argument, are no longer in cache.
//! The simulator raises an error if this is not the case.
//!
#define SIM_SYSCALL_VALIDATE_LINES_EVICTED 5


//== Bit masks which can be shifted by 8, combined with
//== SIM_CONTROL_SET_TRACING, and written to SPR_SIM_CONTROL.

//! @addtogroup arch_sim
//! @{

//! Enable --trace-cycle when passed to simulator_set_tracing().
//!
#define SIM_TRACE_CYCLES          0x01

//! Enable --trace-router when passed to simulator_set_tracing().
//!
#define SIM_TRACE_ROUTER          0x02

//! Enable --trace-register-writes when passed to simulator_set_tracing().
//!
#define SIM_TRACE_REGISTER_WRITES 0x04

//! Enable --trace-disasm when passed to simulator_set_tracing().
//!
#define SIM_TRACE_DISASM          0x08

//! Enable --trace-stall-info when passed to simulator_set_tracing().
//!
#define SIM_TRACE_STALL_INFO      0x10

//! Enable --trace-memory-controller when passed to simulator_set_tracing().
//!
#define SIM_TRACE_MEMORY_CONTROLLER 0x20

//! Enable --trace-l2 when passed to simulator_set_tracing().
//!
#define SIM_TRACE_L2_CACHE 0x40

//! Enable --trace-lines when passed to simulator_set_tracing().
//!
#define SIM_TRACE_LINES 0x80

//! Turn off all tracing when passed to simulator_set_tracing().
//!
#define SIM_TRACE_NONE 0

//! Turn on all tracing when passed to simulator_set_tracing().
//!
#define SIM_TRACE_ALL (-1)

//! @}

//! Computes the value to write to SPR_SIM_CONTROL to set tracing flags.
//!
#define SIM_TRACE_SPR_ARG(mask) \
  (SIM_CONTROL_SET_TRACING | ((mask) << _SIM_CONTROL_OPERATOR_BITS))


//== Bit masks which can be shifted by 8, combined with
//== SIM_CONTROL_DUMP, and written to SPR_SIM_CONTROL.

//! @addtogroup arch_sim
//! @{

//! Dump the general-purpose registers.
//!
#define SIM_DUMP_REGS          0x001

//! Dump the SPRs.
//!
#define SIM_DUMP_SPRS          0x002

//! Dump the ITLB.
//!
#define SIM_DUMP_ITLB          0x004

//! Dump the DTLB.
//!
#define SIM_DUMP_DTLB          0x008

//! Dump the L1 I-cache.
//!
#define SIM_DUMP_L1I           0x010

//! Dump the L1 D-cache.
//!
#define SIM_DUMP_L1D           0x020

//! Dump the L2 cache.
//!
#define SIM_DUMP_L2            0x040

//! Dump the switch registers.
//!
#define SIM_DUMP_SNREGS        0x080

//! Dump the switch ITLB.
//!
#define SIM_DUMP_SNITLB        0x100

//! Dump the switch L1 I-cache.
//!
#define SIM_DUMP_SNL1I         0x200

//! Dump the current backtrace.
//!
#define SIM_DUMP_BACKTRACE     0x400

//! Only dump valid lines in caches.
//!
#define SIM_DUMP_VALID_LINES   0x800

//! Dump everything that is dumpable.
//!
#define SIM_DUMP_ALL (-1 & ~SIM_DUMP_VALID_LINES)

// @}

//! Computes the value to write to SPR_SIM_CONTROL to dump machine state.
//!
#define SIM_DUMP_SPR_ARG(mask) \
  (SIM_CONTROL_DUMP | ((mask) << _SIM_CONTROL_OPERATOR_BITS))


//== Bit masks which can be shifted by 8, combined with
//== SIM_CONTROL_PROFILER_CHIP_xxx, and written to SPR_SIM_CONTROL.

//! @addtogroup arch_sim
//! @{

//! Use with with SIM_PROFILER_CHIP_xxx to control the memory controllers.
//!
#define SIM_CHIP_MEMCTL        0x001

//! Use with with SIM_PROFILER_CHIP_xxx to control the XAUI interface.
//!
#define SIM_CHIP_XAUI          0x002

//! Use with with SIM_PROFILER_CHIP_xxx to control the PCIe interface.
//!
#define SIM_CHIP_PCIE          0x004

//! Use with with SIM_PROFILER_CHIP_xxx to control the MPIPE interface.
//!
#define SIM_CHIP_MPIPE         0x008

//! Reference all chip devices.
//!
#define SIM_CHIP_ALL (-1)

//! @}

//! Computes the value to write to SPR_SIM_CONTROL to clear chip statistics.
//!
#define SIM_PROFILER_CHIP_CLEAR_SPR_ARG(mask) \
  (SIM_CONTROL_PROFILER_CHIP_CLEAR | ((mask) << _SIM_CONTROL_OPERATOR_BITS))

//! Computes the value to write to SPR_SIM_CONTROL to disable chip statistics.
//!
#define SIM_PROFILER_CHIP_DISABLE_SPR_ARG(mask) \
  (SIM_CONTROL_PROFILER_CHIP_DISABLE | ((mask) << _SIM_CONTROL_OPERATOR_BITS))

//! Computes the value to write to SPR_SIM_CONTROL to enable chip statistics.
//!
#define SIM_PROFILER_CHIP_ENABLE_SPR_ARG(mask) \
  (SIM_CONTROL_PROFILER_CHIP_ENABLE | ((mask) << _SIM_CONTROL_OPERATOR_BITS))



// Shim bitrate controls.

//! The number of bits used to store the shim id.
//!
#define SIM_CONTROL_SHAPING_SHIM_ID_BITS 3

//! @addtogroup arch_sim
//! @{

//! Change the gbe 0 bitrate.
//!
#define SIM_CONTROL_SHAPING_GBE_0 0x0

//! Change the gbe 1 bitrate.
//!
#define SIM_CONTROL_SHAPING_GBE_1 0x1

//! Change the gbe 2 bitrate.
//!
#define SIM_CONTROL_SHAPING_GBE_2 0x2

//! Change the gbe 3 bitrate.
//!
#define SIM_CONTROL_SHAPING_GBE_3 0x3

//! Change the xgbe 0 bitrate.
//!
#define SIM_CONTROL_SHAPING_XGBE_0 0x4

//! Change the xgbe 1 bitrate.
//!
#define SIM_CONTROL_SHAPING_XGBE_1 0x5

//! The type of shaping to do.
//!
#define SIM_CONTROL_SHAPING_TYPE_BITS 2

//! Control the multiplier.
//!
#define SIM_CONTROL_SHAPING_MULTIPLIER 0

//! Control the PPS.
//!
#define SIM_CONTROL_SHAPING_PPS 1

//! Control the BPS.
//!
#define SIM_CONTROL_SHAPING_BPS 2

//! The number of bits for the units for the shaping parameter.
//!
#define SIM_CONTROL_SHAPING_UNITS_BITS 2

//! Provide a number in single units.
//!
#define SIM_CONTROL_SHAPING_UNITS_SINGLE 0

//! Provide a number in kilo units.
//!
#define SIM_CONTROL_SHAPING_UNITS_KILO 1

//! Provide a number in mega units.
//!
#define SIM_CONTROL_SHAPING_UNITS_MEGA 2

//! Provide a number in giga units.
//!
#define SIM_CONTROL_SHAPING_UNITS_GIGA 3

// @}

//! How many bits are available for the rate.
//!
#define SIM_CONTROL_SHAPING_RATE_BITS \
  (32 - (_SIM_CONTROL_OPERATOR_BITS + \
         SIM_CONTROL_SHAPING_SHIM_ID_BITS + \
         SIM_CONTROL_SHAPING_TYPE_BITS + \
         SIM_CONTROL_SHAPING_UNITS_BITS))

//! Computes the value to write to SPR_SIM_CONTROL to change a bitrate.
//!
#define SIM_SHAPING_SPR_ARG(shim, type, units, rate) \
  (SIM_CONTROL_SHAPING | \
   ((shim) | \
   ((type) << (SIM_CONTROL_SHAPING_SHIM_ID_BITS)) | \
   ((units) << (SIM_CONTROL_SHAPING_SHIM_ID_BITS + \
                SIM_CONTROL_SHAPING_TYPE_BITS)) | \
   ((rate) << (SIM_CONTROL_SHAPING_SHIM_ID_BITS + \
               SIM_CONTROL_SHAPING_TYPE_BITS + \
               SIM_CONTROL_SHAPING_UNITS_BITS))) << _SIM_CONTROL_OPERATOR_BITS)


//== Values returned when reading SPR_SIM_CONTROL.
// ISSUE: These names should share a longer common prefix.

//! When reading SPR_SIM_CONTROL, the mask of simulator tracing bits
//! (SIM_TRACE_xxx values).
//!
#define SIM_TRACE_FLAG_MASK 0xFFFF

//! When reading SPR_SIM_CONTROL, the mask for whether profiling is enabled.
//!
#define SIM_PROFILER_ENABLED_MASK 0x10000


//== Special arguments for "SIM_CONTROL_PUTC".

//! Flag value for forcing a PUTC string-flush, including
//! coordinate/cycle prefix and newline.
//!
#define SIM_PUTC_FLUSH_STRING 0x100

//! Flag value for forcing a PUTC binary-data-flush, which skips the
//! prefix and does not append a newline.
//!
#define SIM_PUTC_FLUSH_BINARY 0x101


#endif //__ARCH_SIM_DEF_H__
#ifndef _ASM_EMERGENCY_RESTART_H
#define _ASM_EMERGENCY_RESTART_H

#include <asm-generic/emergency-restart.h>

#endif /* _ASM_EMERGENCY_RESTART_H */
/*
 *	Declarations of AX.25 type objects.
 *
 *	Alan Cox (GW4PTS) 	10/11/93
 */
#ifndef _AX25_H
#define _AX25_H 

#include <linux/ax25.h>
#include <linux/spinlock.h>
#include <linux/timer.h>
#include <linux/list.h>
#include <linux/slab.h>
#include <asm/atomic.h>

#define	AX25_T1CLAMPLO  		1
#define	AX25_T1CLAMPHI 			(30 * HZ)

#define	AX25_BPQ_HEADER_LEN		16
#define	AX25_KISS_HEADER_LEN		1

#define	AX25_HEADER_LEN			17
#define	AX25_ADDR_LEN			7
#define	AX25_DIGI_HEADER_LEN		(AX25_MAX_DIGIS * AX25_ADDR_LEN)
#define	AX25_MAX_HEADER_LEN		(AX25_HEADER_LEN + AX25_DIGI_HEADER_LEN)

/* AX.25 Protocol IDs */
#define AX25_P_ROSE			0x01
#define AX25_P_VJCOMP			0x06	/* Compressed TCP/IP packet   */
						/* Van Jacobsen (RFC 1144)    */
#define AX25_P_VJUNCOMP			0x07	/* Uncompressed TCP/IP packet */
						/* Van Jacobsen (RFC 1144)    */
#define	AX25_P_SEGMENT			0x08	/* Segmentation fragment      */
#define AX25_P_TEXNET			0xc3	/* TEXTNET datagram protocol  */
#define AX25_P_LQ			0xc4	/* Link Quality Protocol      */
#define AX25_P_ATALK			0xca	/* Appletalk                  */
#define AX25_P_ATALK_ARP		0xcb	/* Appletalk ARP              */
#define AX25_P_IP			0xcc	/* ARPA Internet Protocol     */
#define AX25_P_ARP			0xcd	/* ARPA Address Resolution    */
#define AX25_P_FLEXNET			0xce	/* FlexNet                    */
#define AX25_P_NETROM 			0xcf	/* NET/ROM                    */
#define AX25_P_TEXT 			0xF0	/* No layer 3 protocol impl.  */

/* AX.25 Segment control values */
#define	AX25_SEG_REM			0x7F
#define	AX25_SEG_FIRST			0x80

#define AX25_CBIT			0x80	/* Command/Response bit */
#define AX25_EBIT			0x01	/* HDLC Address Extension bit */
#define AX25_HBIT			0x80	/* Has been repeated bit */

#define AX25_SSSID_SPARE		0x60	/* Unused bits in SSID for standard AX.25 */
#define AX25_ESSID_SPARE		0x20	/* Unused bits in SSID for extended AX.25 */
#define AX25_DAMA_FLAG			0x20	/* Well, it is *NOT* unused! (dl1bke 951121 */

#define	AX25_COND_ACK_PENDING		0x01
#define	AX25_COND_REJECT		0x02
#define	AX25_COND_PEER_RX_BUSY		0x04
#define	AX25_COND_OWN_RX_BUSY		0x08
#define	AX25_COND_DAMA_MODE		0x10

#ifndef _LINUX_NETDEVICE_H
#include <linux/netdevice.h>
#endif

/* Upper sub-layer (LAPB) definitions */

/* Control field templates */
#define	AX25_I			0x00	/* Information frames */
#define	AX25_S			0x01	/* Supervisory frames */
#define	AX25_RR			0x01	/* Receiver ready */
#define	AX25_RNR		0x05	/* Receiver not ready */
#define	AX25_REJ		0x09	/* Reject */
#define	AX25_U			0x03	/* Unnumbered frames */
#define	AX25_SABM		0x2f	/* Set Asynchronous Balanced Mode */
#define	AX25_SABME		0x6f	/* Set Asynchronous Balanced Mode Extended */
#define	AX25_DISC		0x43	/* Disconnect */
#define	AX25_DM			0x0f	/* Disconnected mode */
#define	AX25_UA			0x63	/* Unnumbered acknowledge */
#define	AX25_FRMR		0x87	/* Frame reject */
#define	AX25_UI			0x03	/* Unnumbered information */
#define	AX25_XID		0xaf	/* Exchange information */
#define	AX25_TEST		0xe3	/* Test */

#define	AX25_PF			0x10	/* Poll/final bit for standard AX.25 */
#define	AX25_EPF		0x01	/* Poll/final bit for extended AX.25 */

#define AX25_ILLEGAL		0x100	/* Impossible to be a real frame type */

#define	AX25_POLLOFF		0
#define	AX25_POLLON		1

/* AX25 L2 C-bit */
#define AX25_COMMAND		1
#define AX25_RESPONSE		2

/* Define Link State constants. */

enum { 
	AX25_STATE_0,			/* Listening */
	AX25_STATE_1,			/* SABM sent */
	AX25_STATE_2,			/* DISC sent */
	AX25_STATE_3,			/* Established */
	AX25_STATE_4			/* Recovery */
};

#define AX25_MODULUS 		8	/*  Standard AX.25 modulus */
#define	AX25_EMODULUS		128	/*  Extended AX.25 modulus */

enum {
	AX25_PROTO_STD_SIMPLEX,
	AX25_PROTO_STD_DUPLEX,
#ifdef CONFIG_AX25_DAMA_SLAVE
	AX25_PROTO_DAMA_SLAVE,
#ifdef CONFIG_AX25_DAMA_MASTER
	AX25_PROTO_DAMA_MASTER,
#define AX25_PROTO_MAX AX25_PROTO_DAMA_MASTER
#endif
#endif
	__AX25_PROTO_MAX,
	AX25_PROTO_MAX = __AX25_PROTO_MAX -1
};

enum {
	AX25_VALUES_IPDEFMODE,	/* 0=DG 1=VC */
	AX25_VALUES_AXDEFMODE,	/* 0=Normal 1=Extended Seq Nos */
	AX25_VALUES_BACKOFF,	/* 0=None 1=Linear 2=Exponential */
	AX25_VALUES_CONMODE,	/* Allow connected modes - 0=No 1=no "PID text" 2=all PIDs */
	AX25_VALUES_WINDOW,	/* Default window size for standard AX.25 */
	AX25_VALUES_EWINDOW,	/* Default window size for extended AX.25 */
	AX25_VALUES_T1,		/* Default T1 timeout value */
	AX25_VALUES_T2,		/* Default T2 timeout value */
	AX25_VALUES_T3,		/* Default T3 timeout value */
	AX25_VALUES_IDLE,	/* Connected mode idle timer */
	AX25_VALUES_N2,		/* Default N2 value */
	AX25_VALUES_PACLEN,	/* AX.25 MTU */
	AX25_VALUES_PROTOCOL,	/* Std AX.25, DAMA Slave, DAMA Master */
	AX25_VALUES_DS_TIMEOUT,	/* DAMA Slave timeout */
	AX25_MAX_VALUES		/* THIS MUST REMAIN THE LAST ENTRY OF THIS LIST */
};

#define	AX25_DEF_IPDEFMODE	0			/* Datagram */
#define	AX25_DEF_AXDEFMODE	0			/* Normal */
#define	AX25_DEF_BACKOFF	1			/* Linear backoff */
#define	AX25_DEF_CONMODE	2			/* Connected mode allowed */
#define	AX25_DEF_WINDOW		2			/* Window=2 */
#define	AX25_DEF_EWINDOW	32			/* Module-128 Window=32 */
#define	AX25_DEF_T1		10000			/* T1=10s */
#define	AX25_DEF_T2		3000			/* T2=3s  */
#define	AX25_DEF_T3		300000			/* T3=300s */
#define	AX25_DEF_N2		10			/* N2=10 */
#define AX25_DEF_IDLE		0			/* Idle=None */
#define AX25_DEF_PACLEN		256			/* Paclen=256 */
#define	AX25_DEF_PROTOCOL	AX25_PROTO_STD_SIMPLEX	/* Standard AX.25 */
#define AX25_DEF_DS_TIMEOUT	180000			/* DAMA timeout 3 minutes */

typedef struct ax25_uid_assoc {
	struct hlist_node	uid_node;
	atomic_t		refcount;
	uid_t			uid;
	ax25_address		call;
} ax25_uid_assoc;

#define ax25_uid_for_each(__ax25, node, list) \
	hlist_for_each_entry(__ax25, node, list, uid_node)

#define ax25_uid_hold(ax25) \
	atomic_inc(&((ax25)->refcount))

static inline void ax25_uid_put(ax25_uid_assoc *assoc)
{
	if (atomic_dec_and_test(&assoc->refcount)) {
		kfree(assoc);
	}
}

typedef struct {
	ax25_address		calls[AX25_MAX_DIGIS];
	unsigned char		repeated[AX25_MAX_DIGIS];
	unsigned char		ndigi;
	signed char		lastrepeat;
} ax25_digi;

typedef struct ax25_route {
	struct ax25_route	*next;
	atomic_t		refcount;
	ax25_address		callsign;
	struct net_device	*dev;
	ax25_digi		*digipeat;
	char			ip_mode;
} ax25_route;

static inline void ax25_hold_route(ax25_route *ax25_rt)
{
	atomic_inc(&ax25_rt->refcount);
}

extern void __ax25_put_route(ax25_route *ax25_rt);

static inline void ax25_put_route(ax25_route *ax25_rt)
{
	if (atomic_dec_and_test(&ax25_rt->refcount))
		__ax25_put_route(ax25_rt);
}

typedef struct {
	char			slave;			/* slave_mode?   */
	struct timer_list	slave_timer;		/* timeout timer */
	unsigned short		slave_timeout;		/* when? */
} ax25_dama_info;

struct ctl_table;

typedef struct ax25_dev {
	struct ax25_dev		*next;
	struct net_device	*dev;
	struct net_device	*forward;
	struct ctl_table	*systable;
	int			values[AX25_MAX_VALUES];
#if defined(CONFIG_AX25_DAMA_SLAVE) || defined(CONFIG_AX25_DAMA_MASTER)
	ax25_dama_info		dama;
#endif
} ax25_dev;

typedef struct ax25_cb {
	struct hlist_node	ax25_node;
	ax25_address		source_addr, dest_addr;
	ax25_digi		*digipeat;
	ax25_dev		*ax25_dev;
	unsigned char		iamdigi;
	unsigned char		state, modulus, pidincl;
	unsigned short		vs, vr, va;
	unsigned char		condition, backoff;
	unsigned char		n2, n2count;
	struct timer_list	t1timer, t2timer, t3timer, idletimer;
	unsigned long		t1, t2, t3, idle, rtt;
	unsigned short		paclen, fragno, fraglen;
	struct sk_buff_head	write_queue;
	struct sk_buff_head	reseq_queue;
	struct sk_buff_head	ack_queue;
	struct sk_buff_head	frag_queue;
	unsigned char		window;
	struct timer_list	timer, dtimer;
	struct sock		*sk;		/* Backlink to socket */
	atomic_t		refcount;
} ax25_cb;

#define ax25_sk(__sk) ((ax25_cb *)(__sk)->sk_protinfo)

#define ax25_for_each(__ax25, node, list) \
	hlist_for_each_entry(__ax25, node, list, ax25_node)

#define ax25_cb_hold(__ax25) \
	atomic_inc(&((__ax25)->refcount))

static __inline__ void ax25_cb_put(ax25_cb *ax25)
{
	if (atomic_dec_and_test(&ax25->refcount)) {
		kfree(ax25->digipeat);
		kfree(ax25);
	}
}

static inline __be16 ax25_type_trans(struct sk_buff *skb, struct net_device *dev)
{
	skb->dev      = dev;
	skb_reset_mac_header(skb);
	skb->pkt_type = PACKET_HOST;
	return htons(ETH_P_AX25);
}

/* af_ax25.c */
extern struct hlist_head ax25_list;
extern spinlock_t ax25_list_lock;
extern void ax25_cb_add(ax25_cb *);
struct sock *ax25_find_listener(ax25_address *, int, struct net_device *, int);
struct sock *ax25_get_socket(ax25_address *, ax25_address *, int);
extern ax25_cb *ax25_find_cb(ax25_address *, ax25_address *, ax25_digi *, struct net_device *);
extern void ax25_send_to_raw(ax25_address *, struct sk_buff *, int);
extern void ax25_destroy_socket(ax25_cb *);
extern ax25_cb * __must_check ax25_create_cb(void);
extern void ax25_fillin_cb(ax25_cb *, ax25_dev *);
extern struct sock *ax25_make_new(struct sock *, struct ax25_dev *);

/* ax25_addr.c */
extern const ax25_address ax25_bcast;
extern const ax25_address ax25_defaddr;
extern const ax25_address null_ax25_address;
extern char *ax2asc(char *buf, const ax25_address *);
extern void asc2ax(ax25_address *addr, const char *callsign);
extern int ax25cmp(const ax25_address *, const ax25_address *);
extern int ax25digicmp(const ax25_digi *, const ax25_digi *);
extern const unsigned char *ax25_addr_parse(const unsigned char *, int,
	ax25_address *, ax25_address *, ax25_digi *, int *, int *);
extern int  ax25_addr_build(unsigned char *, const ax25_address *,
	const ax25_address *, const ax25_digi *, int, int);
extern int  ax25_addr_size(const ax25_digi *);
extern void ax25_digi_invert(const ax25_digi *, ax25_digi *);

/* ax25_dev.c */
extern ax25_dev *ax25_dev_list;
extern spinlock_t ax25_dev_lock;

static inline ax25_dev *ax25_dev_ax25dev(struct net_device *dev)
{
	return dev->ax25_ptr;
}

extern ax25_dev *ax25_addr_ax25dev(ax25_address *);
extern void ax25_dev_device_up(struct net_device *);
extern void ax25_dev_device_down(struct net_device *);
extern int  ax25_fwd_ioctl(unsigned int, struct ax25_fwd_struct *);
extern struct net_device *ax25_fwd_dev(struct net_device *);
extern void ax25_dev_free(void);

/* ax25_ds_in.c */
extern int  ax25_ds_frame_in(ax25_cb *, struct sk_buff *, int);

/* ax25_ds_subr.c */
extern void ax25_ds_nr_error_recovery(ax25_cb *);
extern void ax25_ds_enquiry_response(ax25_cb *);
extern void ax25_ds_establish_data_link(ax25_cb *);
extern void ax25_dev_dama_off(ax25_dev *);
extern void ax25_dama_on(ax25_cb *);
extern void ax25_dama_off(ax25_cb *);

/* ax25_ds_timer.c */
extern void ax25_ds_setup_timer(ax25_dev *);
extern void ax25_ds_set_timer(ax25_dev *);
extern void ax25_ds_del_timer(ax25_dev *);
extern void ax25_ds_timer(ax25_cb *);
extern void ax25_ds_t1_timeout(ax25_cb *);
extern void ax25_ds_heartbeat_expiry(ax25_cb *);
extern void ax25_ds_t3timer_expiry(ax25_cb *);
extern void ax25_ds_idletimer_expiry(ax25_cb *);

/* ax25_iface.c */

struct ax25_protocol {
	struct ax25_protocol *next;
	unsigned int pid;
	int (*func)(struct sk_buff *, ax25_cb *);
};

extern void ax25_register_pid(struct ax25_protocol *ap);
extern void ax25_protocol_release(unsigned int);

struct ax25_linkfail {
	struct hlist_node lf_node;
	void (*func)(ax25_cb *, int);
};

extern void ax25_linkfail_register(struct ax25_linkfail *lf);
extern void ax25_linkfail_release(struct ax25_linkfail *lf);
extern int __must_check ax25_listen_register(ax25_address *,
	struct net_device *);
extern void ax25_listen_release(ax25_address *, struct net_device *);
extern int  (*ax25_protocol_function(unsigned int))(struct sk_buff *, ax25_cb *);
extern int  ax25_listen_mine(ax25_address *, struct net_device *);
extern void ax25_link_failed(ax25_cb *, int);
extern int  ax25_protocol_is_registered(unsigned int);

/* ax25_in.c */
extern int  ax25_rx_iframe(ax25_cb *, struct sk_buff *);
extern int  ax25_kiss_rcv(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);

/* ax25_ip.c */
extern int ax25_hard_header(struct sk_buff *, struct net_device *,
			    unsigned short, const void *,
			    const void *, unsigned int);
extern int  ax25_rebuild_header(struct sk_buff *);
extern const struct header_ops ax25_header_ops;

/* ax25_out.c */
extern ax25_cb *ax25_send_frame(struct sk_buff *, int, ax25_address *, ax25_address *, ax25_digi *, struct net_device *);
extern void ax25_output(ax25_cb *, int, struct sk_buff *);
extern void ax25_kick(ax25_cb *);
extern void ax25_transmit_buffer(ax25_cb *, struct sk_buff *, int);
extern void ax25_queue_xmit(struct sk_buff *skb, struct net_device *dev);
extern int  ax25_check_iframes_acked(ax25_cb *, unsigned short);

/* ax25_route.c */
extern void ax25_rt_device_down(struct net_device *);
extern int  ax25_rt_ioctl(unsigned int, void __user *);
extern const struct file_operations ax25_route_fops;
extern ax25_route *ax25_get_route(ax25_address *addr, struct net_device *dev);
extern int  ax25_rt_autobind(ax25_cb *, ax25_address *);
extern struct sk_buff *ax25_rt_build_path(struct sk_buff *, ax25_address *, ax25_address *, ax25_digi *);
extern void ax25_rt_free(void);

/* ax25_std_in.c */
extern int  ax25_std_frame_in(ax25_cb *, struct sk_buff *, int);

/* ax25_std_subr.c */
extern void ax25_std_nr_error_recovery(ax25_cb *);
extern void ax25_std_establish_data_link(ax25_cb *);
extern void ax25_std_transmit_enquiry(ax25_cb *);
extern void ax25_std_enquiry_response(ax25_cb *);
extern void ax25_std_timeout_response(ax25_cb *);

/* ax25_std_timer.c */
extern void ax25_std_heartbeat_expiry(ax25_cb *);
extern void ax25_std_t1timer_expiry(ax25_cb *);
extern void ax25_std_t2timer_expiry(ax25_cb *);
extern void ax25_std_t3timer_expiry(ax25_cb *);
extern void ax25_std_idletimer_expiry(ax25_cb *);

/* ax25_subr.c */
extern void ax25_clear_queues(ax25_cb *);
extern void ax25_frames_acked(ax25_cb *, unsigned short);
extern void ax25_requeue_frames(ax25_cb *);
extern int  ax25_validate_nr(ax25_cb *, unsigned short);
extern int  ax25_decode(ax25_cb *, struct sk_buff *, int *, int *, int *);
extern void ax25_send_control(ax25_cb *, int, int, int);
extern void ax25_return_dm(struct net_device *, ax25_address *, ax25_address *, ax25_digi *);
extern void ax25_calculate_t1(ax25_cb *);
extern void ax25_calculate_rtt(ax25_cb *);
extern void ax25_disconnect(ax25_cb *, int);

/* ax25_timer.c */
extern void ax25_setup_timers(ax25_cb *);
extern void ax25_start_heartbeat(ax25_cb *);
extern void ax25_start_t1timer(ax25_cb *);
extern void ax25_start_t2timer(ax25_cb *);
extern void ax25_start_t3timer(ax25_cb *);
extern void ax25_start_idletimer(ax25_cb *);
extern void ax25_stop_heartbeat(ax25_cb *);
extern void ax25_stop_t1timer(ax25_cb *);
extern void ax25_stop_t2timer(ax25_cb *);
extern void ax25_stop_t3timer(ax25_cb *);
extern void ax25_stop_idletimer(ax25_cb *);
extern int  ax25_t1timer_running(ax25_cb *);
extern unsigned long ax25_display_timer(struct timer_list *);

/* ax25_uid.c */
extern int  ax25_uid_policy;
extern ax25_uid_assoc *ax25_findbyuid(uid_t);
extern int __must_check ax25_uid_ioctl(int, struct sockaddr_ax25 *);
extern const struct file_operations ax25_uid_fops;
extern void ax25_uid_free(void);

/* sysctl_net_ax25.c */
#ifdef CONFIG_SYSCTL
extern void ax25_register_sysctl(void);
extern void ax25_unregister_sysctl(void);
#else
static inline void ax25_register_sysctl(void) {};
static inline void ax25_unregister_sysctl(void) {};
#endif /* CONFIG_SYSCTL */

#endif
cmd_fs/sysfs/symlink.o := gcc -Wp,-MD,fs/sysfs/.symlink.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(symlink)"  -D"KBUILD_MODNAME=KBUILD_STR(symlink)"  -c -o fs/sysfs/.tmp_symlink.o fs/sysfs/symlink.c

deps_fs/sysfs/symlink.o := \
  fs/sysfs/symlink.c \
  include/linux/fs.h \
    $(wildcard include/config/sysfs.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/security.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/preempt.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  include/linux/wait.h \
    $(wildcard include/config/lockdep.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/rculist.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/seqlock.h \
  include/linux/completion.h \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  include/linux/path.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/radix-tree.h \
  include/linux/prio_tree.h \
  include/linux/pid.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/capability.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/percpu_counter.h \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/nodes/shift.h) \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  include/linux/nodemask.h \
    $(wildcard include/config/highmem.h) \
  include/linux/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/gfp.h \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/mount.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
  include/linux/kmod.h \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/namei.h \
  include/linux/security.h \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/security/path.h) \
    $(wildcard include/config/security/network.h) \
    $(wildcard include/config/security/network/xfrm.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/securityfs.h) \
  include/linux/fsnotify.h \
  include/linux/fsnotify_backend.h \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/fanotify.h) \
    $(wildcard include/config/fanotify/access/permissions.h) \
  include/linux/idr.h \
  include/linux/audit.h \
    $(wildcard include/config/change.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/virt/cpu/accounting.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  include/linux/rbtree.h \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/proportions.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/linux/binfmts.h \
  include/linux/shm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/shmparam.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/shmbuf.h \
  include/asm-generic/shmbuf.h \
  include/linux/mm.h \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/s390.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  include/linux/msg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msgbuf.h \
  include/asm-generic/msgbuf.h \
  include/linux/xfrm.h \
  include/net/flow.h \
  include/linux/in6.h \
  fs/sysfs/sysfs.h \

fs/sysfs/symlink.o: $(deps_fs/sysfs/symlink.o)

$(deps_fs/sysfs/symlink.o):
/*
 * Compaq Hot Plug Controller Driver
 *
 * Copyright (C) 1995,2001 Compaq Computer Corporation
 * Copyright (C) 2001 Greg Kroah-Hartman <greg@kroah.com>
 * Copyright (C) 2001 IBM Corp.
 *
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
 * NON INFRINGEMENT.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Send feedback to <greg@kroah.com>
 *
 * Jan 12, 2003 -	Added 66/100/133MHz PCI-X support,
 *			Torben Mathiasen <torben.mathiasen@hp.com>
 */

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/proc_fs.h>
#include <linux/slab.h>
#include <linux/workqueue.h>
#include <linux/pci.h>
#include <linux/pci_hotplug.h>
#include <linux/init.h>
#include <linux/interrupt.h>

#include <asm/uaccess.h>

#include "cpqphp.h"
#include "cpqphp_nvram.h"


/* Global variables */
int cpqhp_debug;
int cpqhp_legacy_mode;
struct controller *cpqhp_ctrl_list;	/* = NULL */
struct pci_func *cpqhp_slot_list[256];
struct irq_routing_table *cpqhp_routing_table;

/* local variables */
static void __iomem *smbios_table;
static void __iomem *smbios_start;
static void __iomem *cpqhp_rom_start;
static int power_mode;
static int debug;
static int initialized;

#define DRIVER_VERSION	"0.9.8"
#define DRIVER_AUTHOR	"Dan Zink <dan.zink@compaq.com>, Greg Kroah-Hartman <greg@kroah.com>"
#define DRIVER_DESC	"Compaq Hot Plug PCI Controller Driver"

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_LICENSE("GPL");

module_param(power_mode, bool, 0644);
MODULE_PARM_DESC(power_mode, "Power mode enabled or not");

module_param(debug, bool, 0644);
MODULE_PARM_DESC(debug, "Debugging mode enabled or not");

#define CPQHPC_MODULE_MINOR 208

static inline int is_slot64bit(struct slot *slot)
{
	return (readb(slot->p_sm_slot + SMBIOS_SLOT_WIDTH) == 0x06) ? 1 : 0;
}

static inline int is_slot66mhz(struct slot *slot)
{
	return (readb(slot->p_sm_slot + SMBIOS_SLOT_TYPE) == 0x0E) ? 1 : 0;
}

/**
 * detect_SMBIOS_pointer - find the System Management BIOS Table in mem region.
 * @begin: begin pointer for region to be scanned.
 * @end: end pointer for region to be scanned.
 *
 * Returns pointer to the head of the SMBIOS tables (or %NULL).
 */
static void __iomem * detect_SMBIOS_pointer(void __iomem *begin, void __iomem *end)
{
	void __iomem *fp;
	void __iomem *endp;
	u8 temp1, temp2, temp3, temp4;
	int status = 0;

	endp = (end - sizeof(u32) + 1);

	for (fp = begin; fp <= endp; fp += 16) {
		temp1 = readb(fp);
		temp2 = readb(fp+1);
		temp3 = readb(fp+2);
		temp4 = readb(fp+3);
		if (temp1 == '_' &&
		    temp2 == 'S' &&
		    temp3 == 'M' &&
		    temp4 == '_') {
			status = 1;
			break;
		}
	}

	if (!status)
		fp = NULL;

	dbg("Discovered SMBIOS Entry point at %p\n", fp);

	return fp;
}

/**
 * init_SERR - Initializes the per slot SERR generation.
 * @ctrl: controller to use
 *
 * For unexpected switch opens
 */
static int init_SERR(struct controller * ctrl)
{
	u32 tempdword;
	u32 number_of_slots;
	u8 physical_slot;

	if (!ctrl)
		return 1;

	tempdword = ctrl->first_slot;

	number_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;
	/* Loop through slots */
	while (number_of_slots) {
		physical_slot = tempdword;
		writeb(0, ctrl->hpc_reg + SLOT_SERR);
		tempdword++;
		number_of_slots--;
	}

	return 0;
}

static int init_cpqhp_routing_table(void)
{
	int len;

	cpqhp_routing_table = pcibios_get_irq_routing_table();
	if (cpqhp_routing_table == NULL)
		return -ENOMEM;

	len = cpqhp_routing_table_length();
	if (len == 0) {
		kfree(cpqhp_routing_table);
		cpqhp_routing_table = NULL;
		return -1;
	}

	return 0;
}

/* nice debugging output */
static void pci_print_IRQ_route(void)
{
	int len;
	int loop;
	u8 tbus, tdevice, tslot;

	len = cpqhp_routing_table_length();

	dbg("bus dev func slot\n");
	for (loop = 0; loop < len; ++loop) {
		tbus = cpqhp_routing_table->slots[loop].bus;
		tdevice = cpqhp_routing_table->slots[loop].devfn;
		tslot = cpqhp_routing_table->slots[loop].slot;
		dbg("%d %d %d %d\n", tbus, tdevice >> 3, tdevice & 0x7, tslot);

	}
	return;
}


/**
 * get_subsequent_smbios_entry: get the next entry from bios table.
 * @smbios_start: where to start in the SMBIOS table
 * @smbios_table: location of the SMBIOS table
 * @curr: %NULL or pointer to previously returned structure
 *
 * Gets the first entry if previous == NULL;
 * otherwise, returns the next entry.
 * Uses global SMBIOS Table pointer.
 *
 * Returns a pointer to an SMBIOS structure or NULL if none found.
 */
static void __iomem *get_subsequent_smbios_entry(void __iomem *smbios_start,
						void __iomem *smbios_table,
						void __iomem *curr)
{
	u8 bail = 0;
	u8 previous_byte = 1;
	void __iomem *p_temp;
	void __iomem *p_max;

	if (!smbios_table || !curr)
		return NULL;

	/* set p_max to the end of the table */
	p_max = smbios_start + readw(smbios_table + ST_LENGTH);

	p_temp = curr;
	p_temp += readb(curr + SMBIOS_GENERIC_LENGTH);

	while ((p_temp < p_max) && !bail) {
		/* Look for the double NULL terminator
		 * The first condition is the previous byte
		 * and the second is the curr
		 */
		if (!previous_byte && !(readb(p_temp)))
			bail = 1;

		previous_byte = readb(p_temp);
		p_temp++;
	}

	if (p_temp < p_max)
		return p_temp;
	else
		return NULL;
}


/**
 * get_SMBIOS_entry - return the requested SMBIOS entry or %NULL
 * @smbios_start: where to start in the SMBIOS table
 * @smbios_table: location of the SMBIOS table
 * @type: SMBIOS structure type to be returned
 * @previous: %NULL or pointer to previously returned structure
 *
 * Gets the first entry of the specified type if previous == %NULL;
 * Otherwise, returns the next entry of the given type.
 * Uses global SMBIOS Table pointer.
 * Uses get_subsequent_smbios_entry.
 *
 * Returns a pointer to an SMBIOS structure or %NULL if none found.
 */
static void __iomem *get_SMBIOS_entry(void __iomem *smbios_start,
					void __iomem *smbios_table,
					u8 type,
					void __iomem *previous)
{
	if (!smbios_table)
		return NULL;

	if (!previous)
		previous = smbios_start;
	else
		previous = get_subsequent_smbios_entry(smbios_start,
					smbios_table, previous);

	while (previous)
		if (readb(previous + SMBIOS_GENERIC_TYPE) != type)
			previous = get_subsequent_smbios_entry(smbios_start,
						smbios_table, previous);
		else
			break;

	return previous;
}

static void release_slot(struct hotplug_slot *hotplug_slot)
{
	struct slot *slot = hotplug_slot->private;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	kfree(slot->hotplug_slot->info);
	kfree(slot->hotplug_slot);
	kfree(slot);
}

static int ctrl_slot_cleanup (struct controller * ctrl)
{
	struct slot *old_slot, *next_slot;

	old_slot = ctrl->slot;
	ctrl->slot = NULL;

	while (old_slot) {
		/* memory will be freed by the release_slot callback */
		next_slot = old_slot->next;
		pci_hp_deregister (old_slot->hotplug_slot);
		old_slot = next_slot;
	}

	cpqhp_remove_debugfs_files(ctrl);

	/* Free IRQ associated with hot plug device */
	free_irq(ctrl->interrupt, ctrl);
	/* Unmap the memory */
	iounmap(ctrl->hpc_reg);
	/* Finally reclaim PCI mem */
	release_mem_region(pci_resource_start(ctrl->pci_dev, 0),
			   pci_resource_len(ctrl->pci_dev, 0));

	return 0;
}


/**
 * get_slot_mapping - determine logical slot mapping for PCI device
 *
 * Won't work for more than one PCI-PCI bridge in a slot.
 *
 * @bus_num - bus number of PCI device
 * @dev_num - device number of PCI device
 * @slot - Pointer to u8 where slot number will	be returned
 *
 * Output:	SUCCESS or FAILURE
 */
static int
get_slot_mapping(struct pci_bus *bus, u8 bus_num, u8 dev_num, u8 *slot)
{
	u32 work;
	long len;
	long loop;

	u8 tbus, tdevice, tslot, bridgeSlot;

	dbg("%s: %p, %d, %d, %p\n", __func__, bus, bus_num, dev_num, slot);

	bridgeSlot = 0xFF;

	len = cpqhp_routing_table_length();
	for (loop = 0; loop < len; ++loop) {
		tbus = cpqhp_routing_table->slots[loop].bus;
		tdevice = cpqhp_routing_table->slots[loop].devfn >> 3;
		tslot = cpqhp_routing_table->slots[loop].slot;

		if ((tbus == bus_num) && (tdevice == dev_num)) {
			*slot = tslot;
			return 0;
		} else {
			/* Did not get a match on the target PCI device. Check
			 * if the current IRQ table entry is a PCI-to-PCI
			 * bridge device.  If so, and it's secondary bus
			 * matches the bus number for the target device, I need
			 * to save the bridge's slot number.  If I can not find
			 * an entry for the target device, I will have to
			 * assume it's on the other side of the bridge, and
			 * assign it the bridge's slot.
			 */
			bus->number = tbus;
			pci_bus_read_config_dword(bus, PCI_DEVFN(tdevice, 0),
						PCI_CLASS_REVISION, &work);

			if ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {
				pci_bus_read_config_dword(bus,
							PCI_DEVFN(tdevice, 0),
							PCI_PRIMARY_BUS, &work);
				// See if bridge's secondary bus matches target bus.
				if (((work >> 8) & 0x000000FF) == (long) bus_num)
					bridgeSlot = tslot;
			}
		}

	}

	/* If we got here, we didn't find an entry in the IRQ mapping table for
	 * the target PCI device.  If we did determine that the target device
	 * is on the other side of a PCI-to-PCI bridge, return the slot number
	 * for the bridge.
	 */
	if (bridgeSlot != 0xFF) {
		*slot = bridgeSlot;
		return 0;
	}
	/* Couldn't find an entry in the routing table for this PCI device */
	return -1;
}


/**
 * cpqhp_set_attention_status - Turns the Amber LED for a slot on or off
 * @ctrl: struct controller to use
 * @func: PCI device/function info
 * @status: LED control flag: 1 = LED on, 0 = LED off
 */
static int
cpqhp_set_attention_status(struct controller *ctrl, struct pci_func *func,
				u32 status)
{
	u8 hp_slot;

	if (func == NULL)
		return 1;

	hp_slot = func->device - ctrl->slot_device_offset;

	/* Wait for exclusive access to hardware */
	mutex_lock(&ctrl->crit_sect);

	if (status == 1)
		amber_LED_on (ctrl, hp_slot);
	else if (status == 0)
		amber_LED_off (ctrl, hp_slot);
	else {
		/* Done with exclusive hardware access */
		mutex_unlock(&ctrl->crit_sect);
		return 1;
	}

	set_SOGO(ctrl);

	/* Wait for SOBS to be unset */
	wait_for_ctrl_irq (ctrl);

	/* Done with exclusive hardware access */
	mutex_unlock(&ctrl->crit_sect);

	return 0;
}


/**
 * set_attention_status - Turns the Amber LED for a slot on or off
 * @hotplug_slot: slot to change LED on
 * @status: LED control flag
 */
static int set_attention_status (struct hotplug_slot *hotplug_slot, u8 status)
{
	struct pci_func *slot_func;
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;
	u8 bus;
	u8 devfn;
	u8 device;
	u8 function;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	if (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)
		return -ENODEV;

	device = devfn >> 3;
	function = devfn & 0x7;
	dbg("bus, dev, fn = %d, %d, %d\n", bus, device, function);

	slot_func = cpqhp_slot_find(bus, device, function);
	if (!slot_func)
		return -ENODEV;

	return cpqhp_set_attention_status(ctrl, slot_func, status);
}


static int process_SI(struct hotplug_slot *hotplug_slot)
{
	struct pci_func *slot_func;
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;
	u8 bus;
	u8 devfn;
	u8 device;
	u8 function;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	if (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)
		return -ENODEV;

	device = devfn >> 3;
	function = devfn & 0x7;
	dbg("bus, dev, fn = %d, %d, %d\n", bus, device, function);

	slot_func = cpqhp_slot_find(bus, device, function);
	if (!slot_func)
		return -ENODEV;

	slot_func->bus = bus;
	slot_func->device = device;
	slot_func->function = function;
	slot_func->configured = 0;
	dbg("board_added(%p, %p)\n", slot_func, ctrl);
	return cpqhp_process_SI(ctrl, slot_func);
}


static int process_SS(struct hotplug_slot *hotplug_slot)
{
	struct pci_func *slot_func;
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;
	u8 bus;
	u8 devfn;
	u8 device;
	u8 function;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	if (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)
		return -ENODEV;

	device = devfn >> 3;
	function = devfn & 0x7;
	dbg("bus, dev, fn = %d, %d, %d\n", bus, device, function);

	slot_func = cpqhp_slot_find(bus, device, function);
	if (!slot_func)
		return -ENODEV;

	dbg("In %s, slot_func = %p, ctrl = %p\n", __func__, slot_func, ctrl);
	return cpqhp_process_SS(ctrl, slot_func);
}


static int hardware_test(struct hotplug_slot *hotplug_slot, u32 value)
{
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	return cpqhp_hardware_test(ctrl, value);
}


static int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)
{
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	*value = get_slot_enabled(ctrl, slot);
	return 0;
}

static int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)
{
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	*value = cpq_get_attention_status(ctrl, slot);
	return 0;
}

static int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)
{
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	*value = cpq_get_latch_status(ctrl, slot);

	return 0;
}

static int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)
{
	struct slot *slot = hotplug_slot->private;
	struct controller *ctrl = slot->ctrl;

	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));

	*value = get_presence_status(ctrl, slot);

	return 0;
}

static struct hotplug_slot_ops cpqphp_hotplug_slot_ops = {
	.set_attention_status =	set_attention_status,
	.enable_slot =		process_SI,
	.disable_slot =		process_SS,
	.hardware_test =	hardware_test,
	.get_power_status =	get_power_status,
	.get_attention_status =	get_attention_status,
	.get_latch_status =	get_latch_status,
	.get_adapter_status =	get_adapter_status,
};

#define SLOT_NAME_SIZE 10

static int ctrl_slot_setup(struct controller *ctrl,
			void __iomem *smbios_start,
			void __iomem *smbios_table)
{
	struct slot *slot;
	struct hotplug_slot *hotplug_slot;
	struct hotplug_slot_info *hotplug_slot_info;
	struct pci_bus *bus = ctrl->pci_bus;
	u8 number_of_slots;
	u8 slot_device;
	u8 slot_number;
	u8 ctrl_slot;
	u32 tempdword;
	char name[SLOT_NAME_SIZE];
	void __iomem *slot_entry= NULL;
	int result = -ENOMEM;

	dbg("%s\n", __func__);

	tempdword = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);

	number_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;
	slot_device = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;
	slot_number = ctrl->first_slot;

	while (number_of_slots) {
		slot = kzalloc(sizeof(*slot), GFP_KERNEL);
		if (!slot)
			goto error;

		slot->hotplug_slot = kzalloc(sizeof(*(slot->hotplug_slot)),
						GFP_KERNEL);
		if (!slot->hotplug_slot)
			goto error_slot;
		hotplug_slot = slot->hotplug_slot;

		hotplug_slot->info = kzalloc(sizeof(*(hotplug_slot->info)),
							GFP_KERNEL);
		if (!hotplug_slot->info)
			goto error_hpslot;
		hotplug_slot_info = hotplug_slot->info;

		slot->ctrl = ctrl;
		slot->bus = ctrl->bus;
		slot->device = slot_device;
		slot->number = slot_number;
		dbg("slot->number = %u\n", slot->number);

		slot_entry = get_SMBIOS_entry(smbios_start, smbios_table, 9,
					slot_entry);

		while (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=
				slot->number)) {
			slot_entry = get_SMBIOS_entry(smbios_start,
						smbios_table, 9, slot_entry);
		}

		slot->p_sm_slot = slot_entry;

		init_timer(&slot->task_event);
		slot->task_event.expires = jiffies + 5 * HZ;
		slot->task_event.function = cpqhp_pushbutton_thread;

		/*FIXME: these capabilities aren't used but if they are
		 *	 they need to be correctly implemented
		 */
		slot->capabilities |= PCISLOT_REPLACE_SUPPORTED;
		slot->capabilities |= PCISLOT_INTERLOCK_SUPPORTED;

		if (is_slot64bit(slot))
			slot->capabilities |= PCISLOT_64_BIT_SUPPORTED;
		if (is_slot66mhz(slot))
			slot->capabilities |= PCISLOT_66_MHZ_SUPPORTED;
		if (bus->cur_bus_speed == PCI_SPEED_66MHz)
			slot->capabilities |= PCISLOT_66_MHZ_OPERATION;

		ctrl_slot =
			slot_device - (readb(ctrl->hpc_reg + SLOT_MASK) >> 4);

		/* Check presence */
		slot->capabilities |=
			((((~tempdword) >> 23) |
			 ((~tempdword) >> 15)) >> ctrl_slot) & 0x02;
		/* Check the switch state */
		slot->capabilities |=
			((~tempdword & 0xFF) >> ctrl_slot) & 0x01;
		/* Check the slot enable */
		slot->capabilities |=
			((read_slot_enable(ctrl) << 2) >> ctrl_slot) & 0x04;

		/* register this slot with the hotplug pci core */
		hotplug_slot->release = &release_slot;
		hotplug_slot->private = slot;
		snprintf(name, SLOT_NAME_SIZE, "%u", slot->number);
		hotplug_slot->ops = &cpqphp_hotplug_slot_ops;

		hotplug_slot_info->power_status = get_slot_enabled(ctrl, slot);
		hotplug_slot_info->attention_status =
			cpq_get_attention_status(ctrl, slot);
		hotplug_slot_info->latch_status =
			cpq_get_latch_status(ctrl, slot);
		hotplug_slot_info->adapter_status =
			get_presence_status(ctrl, slot);

		dbg("registering bus %d, dev %d, number %d, "
				"ctrl->slot_device_offset %d, slot %d\n",
				slot->bus, slot->device,
				slot->number, ctrl->slot_device_offset,
				slot_number);
		result = pci_hp_register(hotplug_slot,
					 ctrl->pci_dev->bus,
					 slot->device,
					 name);
		if (result) {
			err("pci_hp_register failed with error %d\n", result);
			goto error_info;
		}

		slot->next = ctrl->slot;
		ctrl->slot = slot;

		number_of_slots--;
		slot_device++;
		slot_number++;
	}

	return 0;
error_info:
	kfree(hotplug_slot_info);
error_hpslot:
	kfree(hotplug_slot);
error_slot:
	kfree(slot);
error:
	return result;
}

static int one_time_init(void)
{
	int loop;
	int retval = 0;

	if (initialized)
		return 0;

	power_mode = 0;

	retval = init_cpqhp_routing_table();
	if (retval)
		goto error;

	if (cpqhp_debug)
		pci_print_IRQ_route();

	dbg("Initialize + Start the notification mechanism \n");

	retval = cpqhp_event_start_thread();
	if (retval)
		goto error;

	dbg("Initialize slot lists\n");
	for (loop = 0; loop < 256; loop++)
		cpqhp_slot_list[loop] = NULL;

	/* FIXME: We also need to hook the NMI handler eventually.
	 * this also needs to be worked with Christoph
	 * register_NMI_handler();
	 */
	/* Map rom address */
	cpqhp_rom_start = ioremap(ROM_PHY_ADDR, ROM_PHY_LEN);
	if (!cpqhp_rom_start) {
		err ("Could not ioremap memory region for ROM\n");
		retval = -EIO;
		goto error;
	}

	/* Now, map the int15 entry point if we are on compaq specific
	 * hardware
	 */
	compaq_nvram_init(cpqhp_rom_start);

	/* Map smbios table entry point structure */
	smbios_table = detect_SMBIOS_pointer(cpqhp_rom_start,
					cpqhp_rom_start + ROM_PHY_LEN);
	if (!smbios_table) {
		err ("Could not find the SMBIOS pointer in memory\n");
		retval = -EIO;
		goto error_rom_start;
	}

	smbios_start = ioremap(readl(smbios_table + ST_ADDRESS),
					readw(smbios_table + ST_LENGTH));
	if (!smbios_start) {
		err ("Could not ioremap memory region taken from SMBIOS values\n");
		retval = -EIO;
		goto error_smbios_start;
	}

	initialized = 1;

	return retval;

error_smbios_start:
	iounmap(smbios_start);
error_rom_start:
	iounmap(cpqhp_rom_start);
error:
	return retval;
}

static int cpqhpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	u8 num_of_slots = 0;
	u8 hp_slot = 0;
	u8 device;
	u8 bus_cap;
	u16 temp_word;
	u16 vendor_id;
	u16 subsystem_vid;
	u16 subsystem_deviceid;
	u32 rc;
	struct controller *ctrl;
	struct pci_func *func;
	struct pci_bus *bus;
	int err;

	err = pci_enable_device(pdev);
	if (err) {
		printk(KERN_ERR MY_NAME ": cannot enable PCI device %s (%d)\n",
			pci_name(pdev), err);
		return err;
	}

	bus = pdev->subordinate;
	if (!bus) {
		dev_notice(&pdev->dev, "the device is not a bridge, "
				"skipping\n");
		rc = -ENODEV;
		goto err_disable_device;
	}

	/* Need to read VID early b/c it's used to differentiate CPQ and INTC
	 * discovery
	 */
	rc = pci_read_config_word(pdev, PCI_VENDOR_ID, &vendor_id);
	if (rc || ((vendor_id != PCI_VENDOR_ID_COMPAQ) && (vendor_id != PCI_VENDOR_ID_INTEL))) {
		err(msg_HPC_non_compaq_or_intel);
		rc = -ENODEV;
		goto err_disable_device;
	}
	dbg("Vendor ID: %x\n", vendor_id);

	dbg("revision: %d\n", pdev->revision);
	if ((vendor_id == PCI_VENDOR_ID_COMPAQ) && (!pdev->revision)) {
		err(msg_HPC_rev_error);
		rc = -ENODEV;
		goto err_disable_device;
	}

	/* Check for the proper subsystem ID's
	 * Intel uses a different SSID programming model than Compaq.
	 * For Intel, each SSID bit identifies a PHP capability.
	 * Also Intel HPC's may have RID=0.
	 */
	if ((pdev->revision <= 2) && (vendor_id != PCI_VENDOR_ID_INTEL)) {
		err(msg_HPC_not_supported);
		return -ENODEV;
	}

	/* TODO: This code can be made to support non-Compaq or Intel
	 * subsystem IDs
	 */
	rc = pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vid);
	if (rc) {
		err("%s : pci_read_config_word failed\n", __func__);
		goto err_disable_device;
	}
	dbg("Subsystem Vendor ID: %x\n", subsystem_vid);
	if ((subsystem_vid != PCI_VENDOR_ID_COMPAQ) && (subsystem_vid != PCI_VENDOR_ID_INTEL)) {
		err(msg_HPC_non_compaq_or_intel);
		rc = -ENODEV;
		goto err_disable_device;
	}

	ctrl = kzalloc(sizeof(struct controller), GFP_KERNEL);
	if (!ctrl) {
		err("%s : out of memory\n", __func__);
		rc = -ENOMEM;
		goto err_disable_device;
	}

	rc = pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &subsystem_deviceid);
	if (rc) {
		err("%s : pci_read_config_word failed\n", __func__);
		goto err_free_ctrl;
	}

	info("Hot Plug Subsystem Device ID: %x\n", subsystem_deviceid);

	/* Set Vendor ID, so it can be accessed later from other
	 * functions
	 */
	ctrl->vendor_id = vendor_id;

	switch (subsystem_vid) {
	case PCI_VENDOR_ID_COMPAQ:
		if (pdev->revision >= 0x13) { /* CIOBX */
			ctrl->push_flag = 1;
			ctrl->slot_switch_type = 1;
			ctrl->push_button = 1;
			ctrl->pci_config_space = 1;
			ctrl->defeature_PHP = 1;
			ctrl->pcix_support = 1;
			ctrl->pcix_speed_capability = 1;
			pci_read_config_byte(pdev, 0x41, &bus_cap);
			if (bus_cap & 0x80) {
				dbg("bus max supports 133MHz PCI-X\n");
				bus->max_bus_speed = PCI_SPEED_133MHz_PCIX;
				break;
			}
			if (bus_cap & 0x40) {
				dbg("bus max supports 100MHz PCI-X\n");
				bus->max_bus_speed = PCI_SPEED_100MHz_PCIX;
				break;
			}
			if (bus_cap & 20) {
				dbg("bus max supports 66MHz PCI-X\n");
				bus->max_bus_speed = PCI_SPEED_66MHz_PCIX;
				break;
			}
			if (bus_cap & 10) {
				dbg("bus max supports 66MHz PCI\n");
				bus->max_bus_speed = PCI_SPEED_66MHz;
				break;
			}

			break;
		}

		switch (subsystem_deviceid) {
		case PCI_SUB_HPC_ID:
			/* Original 6500/7000 implementation */
			ctrl->slot_switch_type = 1;
			bus->max_bus_speed = PCI_SPEED_33MHz;
			ctrl->push_button = 0;
			ctrl->pci_config_space = 1;
			ctrl->defeature_PHP = 1;
			ctrl->pcix_support = 0;
			ctrl->pcix_speed_capability = 0;
			break;
		case PCI_SUB_HPC_ID2:
			/* First Pushbutton implementation */
			ctrl->push_flag = 1;
			ctrl->slot_switch_type = 1;
			bus->max_bus_speed = PCI_SPEED_33MHz;
			ctrl->push_button = 1;
			ctrl->pci_config_space = 1;
			ctrl->defeature_PHP = 1;
			ctrl->pcix_support = 0;
			ctrl->pcix_speed_capability = 0;
			break;
		case PCI_SUB_HPC_ID_INTC:
			/* Third party (6500/7000) */
			ctrl->slot_switch_type = 1;
			bus->max_bus_speed = PCI_SPEED_33MHz;
			ctrl->push_button = 0;
			ctrl->pci_config_space = 1;
			ctrl->defeature_PHP = 1;
			ctrl->pcix_support = 0;
			ctrl->pcix_speed_capability = 0;
			break;
		case PCI_SUB_HPC_ID3:
			/* First 66 Mhz implementation */
			ctrl->push_flag = 1;
			ctrl->slot_switch_type = 1;
			bus->max_bus_speed = PCI_SPEED_66MHz;
			ctrl->push_button = 1;
			ctrl->pci_config_space = 1;
			ctrl->defeature_PHP = 1;
			ctrl->pcix_support = 0;
			ctrl->pcix_speed_capability = 0;
			break;
		case PCI_SUB_HPC_ID4:
			/* First PCI-X implementation, 100MHz */
			ctrl->push_flag = 1;
			ctrl->slot_switch_type = 1;
			bus->max_bus_speed = PCI_SPEED_100MHz_PCIX;
			ctrl->push_button = 1;
			ctrl->pci_config_space = 1;
			ctrl->defeature_PHP = 1;
			ctrl->pcix_support = 1;
			ctrl->pcix_speed_capability = 0;
			break;
		default:
			err(msg_HPC_not_supported);
			rc = -ENODEV;
			goto err_free_ctrl;
		}
		break;

	case PCI_VENDOR_ID_INTEL:
		/* Check for speed capability (0=33, 1=66) */
		if (subsystem_deviceid & 0x0001)
			bus->max_bus_speed = PCI_SPEED_66MHz;
		else
			bus->max_bus_speed = PCI_SPEED_33MHz;

		/* Check for push button */
		if (subsystem_deviceid & 0x0002)
			ctrl->push_button = 0;
		else
			ctrl->push_button = 1;

		/* Check for slot switch type (0=mechanical, 1=not mechanical) */
		if (subsystem_deviceid & 0x0004)
			ctrl->slot_switch_type = 0;
		else
			ctrl->slot_switch_type = 1;

		/* PHP Status (0=De-feature PHP, 1=Normal operation) */
		if (subsystem_deviceid & 0x0008)
			ctrl->defeature_PHP = 1;	/* PHP supported */
		else
			ctrl->defeature_PHP = 0;	/* PHP not supported */

		/* Alternate Base Address Register Interface
		 * (0=not supported, 1=supported)
		 */
		if (subsystem_deviceid & 0x0010)
			ctrl->alternate_base_address = 1;
		else
			ctrl->alternate_base_address = 0;

		/* PCI Config Space Index (0=not supported, 1=supported) */
		if (subsystem_deviceid & 0x0020)
			ctrl->pci_config_space = 1;
		else
			ctrl->pci_config_space = 0;

		/* PCI-X support */
		if (subsystem_deviceid & 0x0080) {
			ctrl->pcix_support = 1;
			if (subsystem_deviceid & 0x0040)
				/* 133MHz PCI-X if bit 7 is 1 */
				ctrl->pcix_speed_capability = 1;
			else
				/* 100MHz PCI-X if bit 7 is 1 and bit 0 is 0, */
				/* 66MHz PCI-X if bit 7 is 1 and bit 0 is 1 */
				ctrl->pcix_speed_capability = 0;
		} else {
			/* Conventional PCI */
			ctrl->pcix_support = 0;
			ctrl->pcix_speed_capability = 0;
		}
		break;

	default:
		err(msg_HPC_not_supported);
		rc = -ENODEV;
		goto err_free_ctrl;
	}

	/* Tell the user that we found one. */
	info("Initializing the PCI hot plug controller residing on PCI bus %d\n",
					pdev->bus->number);

	dbg("Hotplug controller capabilities:\n");
	dbg("    speed_capability       %d\n", bus->max_bus_speed);
	dbg("    slot_switch_type       %s\n", ctrl->slot_switch_type ?
					"switch present" : "no switch");
	dbg("    defeature_PHP          %s\n", ctrl->defeature_PHP ?
					"PHP supported" : "PHP not supported");
	dbg("    alternate_base_address %s\n", ctrl->alternate_base_address ?
					"supported" : "not supported");
	dbg("    pci_config_space       %s\n", ctrl->pci_config_space ?
					"supported" : "not supported");
	dbg("    pcix_speed_capability  %s\n", ctrl->pcix_speed_capability ?
					"supported" : "not supported");
	dbg("    pcix_support           %s\n", ctrl->pcix_support ?
					"supported" : "not supported");

	ctrl->pci_dev = pdev;
	pci_set_drvdata(pdev, ctrl);

	/* make our own copy of the pci bus structure,
	 * as we like tweaking it a lot */
	ctrl->pci_bus = kmemdup(pdev->bus, sizeof(*ctrl->pci_bus), GFP_KERNEL);
	if (!ctrl->pci_bus) {
		err("out of memory\n");
		rc = -ENOMEM;
		goto err_free_ctrl;
	}

	ctrl->bus = pdev->bus->number;
	ctrl->rev = pdev->revision;
	dbg("bus device function rev: %d %d %d %d\n", ctrl->bus,
		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), ctrl->rev);

	mutex_init(&ctrl->crit_sect);
	init_waitqueue_head(&ctrl->queue);

	/* initialize our threads if they haven't already been started up */
	rc = one_time_init();
	if (rc) {
		goto err_free_bus;
	}

	dbg("pdev = %p\n", pdev);
	dbg("pci resource start %llx\n", (unsigned long long)pci_resource_start(pdev, 0));
	dbg("pci resource len %llx\n", (unsigned long long)pci_resource_len(pdev, 0));

	if (!request_mem_region(pci_resource_start(pdev, 0),
				pci_resource_len(pdev, 0), MY_NAME)) {
		err("cannot reserve MMIO region\n");
		rc = -ENOMEM;
		goto err_free_bus;
	}

	ctrl->hpc_reg = ioremap(pci_resource_start(pdev, 0),
					pci_resource_len(pdev, 0));
	if (!ctrl->hpc_reg) {
		err("cannot remap MMIO region %llx @ %llx\n",
		    (unsigned long long)pci_resource_len(pdev, 0),
		    (unsigned long long)pci_resource_start(pdev, 0));
		rc = -ENODEV;
		goto err_free_mem_region;
	}

	/* Check for 66Mhz operation */
	bus->cur_bus_speed = get_controller_speed(ctrl);


	/********************************************************
	 *
	 *              Save configuration headers for this and
	 *              subordinate PCI buses
	 *
	 ********************************************************/

	/* find the physical slot number of the first hot plug slot */

	/* Get slot won't work for devices behind bridges, but
	 * in this case it will always be called for the "base"
	 * bus/dev/func of a slot.
	 * CS: this is leveraging the PCIIRQ routing code from the kernel
	 * (pci-pc.c: get_irq_routing_table) */
	rc = get_slot_mapping(ctrl->pci_bus, pdev->bus->number,
				(readb(ctrl->hpc_reg + SLOT_MASK) >> 4),
				&(ctrl->first_slot));
	dbg("get_slot_mapping: first_slot = %d, returned = %d\n",
				ctrl->first_slot, rc);
	if (rc) {
		err(msg_initialization_err, rc);
		goto err_iounmap;
	}

	/* Store PCI Config Space for all devices on this bus */
	rc = cpqhp_save_config(ctrl, ctrl->bus, readb(ctrl->hpc_reg + SLOT_MASK));
	if (rc) {
		err("%s: unable to save PCI configuration data, error %d\n",
				__func__, rc);
		goto err_iounmap;
	}

	/*
	 * Get IO, memory, and IRQ resources for new devices
	 */
	/* The next line is required for cpqhp_find_available_resources */
	ctrl->interrupt = pdev->irq;
	if (ctrl->interrupt < 0x10) {
		cpqhp_legacy_mode = 1;
		dbg("System seems to be configured for Full Table Mapped MPS mode\n");
	}

	ctrl->cfgspc_irq = 0;
	pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &ctrl->cfgspc_irq);

	rc = cpqhp_find_available_resources(ctrl, cpqhp_rom_start);
	ctrl->add_support = !rc;
	if (rc) {
		dbg("cpqhp_find_available_resources = 0x%x\n", rc);
		err("unable to locate PCI configuration resources for hot plug add.\n");
		goto err_iounmap;
	}

	/*
	 * Finish setting up the hot plug ctrl device
	 */
	ctrl->slot_device_offset = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;
	dbg("NumSlots %d \n", ctrl->slot_device_offset);

	ctrl->next_event = 0;

	/* Setup the slot information structures */
	rc = ctrl_slot_setup(ctrl, smbios_start, smbios_table);
	if (rc) {
		err(msg_initialization_err, 6);
		err("%s: unable to save PCI configuration data, error %d\n",
			__func__, rc);
		goto err_iounmap;
	}

	/* Mask all general input interrupts */
	writel(0xFFFFFFFFL, ctrl->hpc_reg + INT_MASK);

	/* set up the interrupt */
	dbg("HPC interrupt = %d \n", ctrl->interrupt);
	if (request_irq(ctrl->interrupt, cpqhp_ctrl_intr,
			IRQF_SHARED, MY_NAME, ctrl)) {
		err("Can't get irq %d for the hotplug pci controller\n",
			ctrl->interrupt);
		rc = -ENODEV;
		goto err_iounmap;
	}

	/* Enable Shift Out interrupt and clear it, also enable SERR on power
	 * fault
	 */
	temp_word = readw(ctrl->hpc_reg + MISC);
	temp_word |= 0x4006;
	writew(temp_word, ctrl->hpc_reg + MISC);

	/* Changed 05/05/97 to clear all interrupts at start */
	writel(0xFFFFFFFFL, ctrl->hpc_reg + INT_INPUT_CLEAR);

	ctrl->ctrl_int_comp = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);

	writel(0x0L, ctrl->hpc_reg + INT_MASK);

	if (!cpqhp_ctrl_list) {
		cpqhp_ctrl_list = ctrl;
		ctrl->next = NULL;
	} else {
		ctrl->next = cpqhp_ctrl_list;
		cpqhp_ctrl_list = ctrl;
	}

	/* turn off empty slots here unless command line option "ON" set
	 * Wait for exclusive access to hardware
	 */
	mutex_lock(&ctrl->crit_sect);

	num_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;

	/* find first device number for the ctrl */
	device = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;

	while (num_of_slots) {
		dbg("num_of_slots: %d\n", num_of_slots);
		func = cpqhp_slot_find(ctrl->bus, device, 0);
		if (!func)
			break;

		hp_slot = func->device - ctrl->slot_device_offset;
		dbg("hp_slot: %d\n", hp_slot);

		/* We have to save the presence info for these slots */
		temp_word = ctrl->ctrl_int_comp >> 16;
		func->presence_save = (temp_word >> hp_slot) & 0x01;
		func->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;

		if (ctrl->ctrl_int_comp & (0x1L << hp_slot))
			func->switch_save = 0;
		else
			func->switch_save = 0x10;

		if (!power_mode)
			if (!func->is_a_board) {
				green_LED_off(ctrl, hp_slot);
				slot_disable(ctrl, hp_slot);
			}

		device++;
		num_of_slots--;
	}

	if (!power_mode) {
		set_SOGO(ctrl);
		/* Wait for SOBS to be unset */
		wait_for_ctrl_irq(ctrl);
	}

	rc = init_SERR(ctrl);
	if (rc) {
		err("init_SERR failed\n");
		mutex_unlock(&ctrl->crit_sect);
		goto err_free_irq;
	}

	/* Done with exclusive hardware access */
	mutex_unlock(&ctrl->crit_sect);

	cpqhp_create_debugfs_files(ctrl);

	return 0;

err_free_irq:
	free_irq(ctrl->interrupt, ctrl);
err_iounmap:
	iounmap(ctrl->hpc_reg);
err_free_mem_region:
	release_mem_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
err_free_bus:
	kfree(ctrl->pci_bus);
err_free_ctrl:
	kfree(ctrl);
err_disable_device:
	pci_disable_device(pdev);
	return rc;
}

static void __exit unload_cpqphpd(void)
{
	struct pci_func *next;
	struct pci_func *TempSlot;
	int loop;
	u32 rc;
	struct controller *ctrl;
	struct controller *tctrl;
	struct pci_resource *res;
	struct pci_resource *tres;

	rc = compaq_nvram_store(cpqhp_rom_start);

	ctrl = cpqhp_ctrl_list;

	while (ctrl) {
		if (ctrl->hpc_reg) {
			u16 misc;
			rc = read_slot_enable (ctrl);

			writeb(0, ctrl->hpc_reg + SLOT_SERR);
			writel(0xFFFFFFC0L | ~rc, ctrl->hpc_reg + INT_MASK);

			misc = readw(ctrl->hpc_reg + MISC);
			misc &= 0xFFFD;
			writew(misc, ctrl->hpc_reg + MISC);
		}

		ctrl_slot_cleanup(ctrl);

		res = ctrl->io_head;
		while (res) {
			tres = res;
			res = res->next;
			kfree(tres);
		}

		res = ctrl->mem_head;
		while (res) {
			tres = res;
			res = res->next;
			kfree(tres);
		}

		res = ctrl->p_mem_head;
		while (res) {
			tres = res;
			res = res->next;
			kfree(tres);
		}

		res = ctrl->bus_head;
		while (res) {
			tres = res;
			res = res->next;
			kfree(tres);
		}

		kfree (ctrl->pci_bus);

		tctrl = ctrl;
		ctrl = ctrl->next;
		kfree(tctrl);
	}

	for (loop = 0; loop < 256; loop++) {
		next = cpqhp_slot_list[loop];
		while (next != NULL) {
			res = next->io_head;
			while (res) {
				tres = res;
				res = res->next;
				kfree(tres);
			}

			res = next->mem_head;
			while (res) {
				tres = res;
				res = res->next;
				kfree(tres);
			}

			res = next->p_mem_head;
			while (res) {
				tres = res;
				res = res->next;
				kfree(tres);
			}

			res = next->bus_head;
			while (res) {
				tres = res;
				res = res->next;
				kfree(tres);
			}

			TempSlot = next;
			next = next->next;
			kfree(TempSlot);
		}
	}

	/* Stop the notification mechanism */
	if (initialized)
		cpqhp_event_stop_thread();

	/* unmap the rom address */
	if (cpqhp_rom_start)
		iounmap(cpqhp_rom_start);
	if (smbios_start)
		iounmap(smbios_start);
}

static struct pci_device_id hpcd_pci_tbl[] = {
	{
	/* handle any PCI Hotplug controller */
	.class =        ((PCI_CLASS_SYSTEM_PCI_HOTPLUG << 8) | 0x00),
	.class_mask =   ~0,

	/* no matter who makes it */
	.vendor =       PCI_ANY_ID,
	.device =       PCI_ANY_ID,
	.subvendor =    PCI_ANY_ID,
	.subdevice =    PCI_ANY_ID,

	}, { /* end: all zeroes */ }
};

MODULE_DEVICE_TABLE(pci, hpcd_pci_tbl);

static struct pci_driver cpqhpc_driver = {
	.name =		"compaq_pci_hotplug",
	.id_table =	hpcd_pci_tbl,
	.probe =	cpqhpc_probe,
	/* remove:	cpqhpc_remove_one, */
};

static int __init cpqhpc_init(void)
{
	int result;

	cpqhp_debug = debug;

	info (DRIVER_DESC " version: " DRIVER_VERSION "\n");
	cpqhp_initialize_debugfs();
	result = pci_register_driver(&cpqhpc_driver);
	dbg("pci_register_driver = %d\n", result);
	return result;
}

static void __exit cpqhpc_cleanup(void)
{
	dbg("unload_cpqphpd()\n");
	unload_cpqphpd();

	dbg("pci_unregister_driver\n");
	pci_unregister_driver(&cpqhpc_driver);
	cpqhp_shutdown_debugfs();
}

module_init(cpqhpc_init);
module_exit(cpqhpc_cleanup);
/*
 * f_hid.c -- USB HID function driver
 *
 * Copyright (C) 2010 Fabien Chouteau <fabien.chouteau@barco.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <linux/kernel.h>
#include <linux/utsname.h>
#include <linux/module.h>
#include <linux/hid.h>
#include <linux/cdev.h>
#include <linux/mutex.h>
#include <linux/poll.h>
#include <linux/smp_lock.h>
#include <linux/uaccess.h>
#include <linux/wait.h>
#include <linux/usb/g_hid.h>

static int major, minors;
static struct class *hidg_class;

/*-------------------------------------------------------------------------*/
/*                            HID gadget struct                            */

struct f_hidg {
	/* configuration */
	unsigned char			bInterfaceSubClass;
	unsigned char			bInterfaceProtocol;
	unsigned short			report_desc_length;
	char				*report_desc;
	unsigned short			report_length;

	/* recv report */
	char				*set_report_buff;
	unsigned short			set_report_length;
	spinlock_t			spinlock;
	wait_queue_head_t		read_queue;

	/* send report */
	struct mutex			lock;
	bool				write_pending;
	wait_queue_head_t		write_queue;
	struct usb_request		*req;

	int				minor;
	struct cdev			cdev;
	struct usb_function		func;
	struct usb_ep			*in_ep;
	struct usb_endpoint_descriptor	*fs_in_ep_desc;
	struct usb_endpoint_descriptor	*hs_in_ep_desc;
};

static inline struct f_hidg *func_to_hidg(struct usb_function *f)
{
	return container_of(f, struct f_hidg, func);
}

/*-------------------------------------------------------------------------*/
/*                           Static descriptors                            */

static struct usb_interface_descriptor hidg_interface_desc = {
	.bLength		= sizeof hidg_interface_desc,
	.bDescriptorType	= USB_DT_INTERFACE,
	/* .bInterfaceNumber	= DYNAMIC */
	.bAlternateSetting	= 0,
	.bNumEndpoints		= 1,
	.bInterfaceClass	= USB_CLASS_HID,
	/* .bInterfaceSubClass	= DYNAMIC */
	/* .bInterfaceProtocol	= DYNAMIC */
	/* .iInterface		= DYNAMIC */
};

static struct hid_descriptor hidg_desc = {
	.bLength			= sizeof hidg_desc,
	.bDescriptorType		= HID_DT_HID,
	.bcdHID				= 0x0101,
	.bCountryCode			= 0x00,
	.bNumDescriptors		= 0x1,
	/*.desc[0].bDescriptorType	= DYNAMIC */
	/*.desc[0].wDescriptorLenght	= DYNAMIC */
};

/* High-Speed Support */

static struct usb_endpoint_descriptor hidg_hs_in_ep_desc = {
	.bLength		= USB_DT_ENDPOINT_SIZE,
	.bDescriptorType	= USB_DT_ENDPOINT,
	.bEndpointAddress	= USB_DIR_IN,
	.bmAttributes		= USB_ENDPOINT_XFER_INT,
	/*.wMaxPacketSize	= DYNAMIC */
	.bInterval		= 4, /* FIXME: Add this field in the
				      * HID gadget configuration?
				      * (struct hidg_func_descriptor)
				      */
};

static struct usb_descriptor_header *hidg_hs_descriptors[] = {
	(struct usb_descriptor_header *)&hidg_interface_desc,
	(struct usb_descriptor_header *)&hidg_desc,
	(struct usb_descriptor_header *)&hidg_hs_in_ep_desc,
	NULL,
};

/* Full-Speed Support */

static struct usb_endpoint_descriptor hidg_fs_in_ep_desc = {
	.bLength		= USB_DT_ENDPOINT_SIZE,
	.bDescriptorType	= USB_DT_ENDPOINT,
	.bEndpointAddress	= USB_DIR_IN,
	.bmAttributes		= USB_ENDPOINT_XFER_INT,
	/*.wMaxPacketSize	= DYNAMIC */
	.bInterval		= 10, /* FIXME: Add this field in the
				       * HID gadget configuration?
				       * (struct hidg_func_descriptor)
				       */
};

static struct usb_descriptor_header *hidg_fs_descriptors[] = {
	(struct usb_descriptor_header *)&hidg_interface_desc,
	(struct usb_descriptor_header *)&hidg_desc,
	(struct usb_descriptor_header *)&hidg_fs_in_ep_desc,
	NULL,
};

/*-------------------------------------------------------------------------*/
/*                              Char Device                                */

static ssize_t f_hidg_read(struct file *file, char __user *buffer,
			size_t count, loff_t *ptr)
{
	struct f_hidg	*hidg     = file->private_data;
	char		*tmp_buff = NULL;
	unsigned long	flags;

	if (!count)
		return 0;

	if (!access_ok(VERIFY_WRITE, buffer, count))
		return -EFAULT;

	spin_lock_irqsave(&hidg->spinlock, flags);

#define READ_COND (hidg->set_report_buff != NULL)

	while (!READ_COND) {
		spin_unlock_irqrestore(&hidg->spinlock, flags);
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;

		if (wait_event_interruptible(hidg->read_queue, READ_COND))
			return -ERESTARTSYS;

		spin_lock_irqsave(&hidg->spinlock, flags);
	}


	count = min_t(unsigned, count, hidg->set_report_length);
	tmp_buff = hidg->set_report_buff;
	hidg->set_report_buff = NULL;

	spin_unlock_irqrestore(&hidg->spinlock, flags);

	if (tmp_buff != NULL) {
		/* copy to user outside spinlock */
		count -= copy_to_user(buffer, tmp_buff, count);
		kfree(tmp_buff);
	} else
		count = -ENOMEM;

	return count;
}

static void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)
{
	struct f_hidg *hidg = (struct f_hidg *)ep->driver_data;

	if (req->status != 0) {
		ERROR(hidg->func.config->cdev,
			"End Point Request ERROR: %d\n", req->status);
	}

	hidg->write_pending = 0;
	wake_up(&hidg->write_queue);
}

static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
			    size_t count, loff_t *offp)
{
	struct f_hidg *hidg  = file->private_data;
	ssize_t status = -ENOMEM;

	if (!access_ok(VERIFY_READ, buffer, count))
		return -EFAULT;

	mutex_lock(&hidg->lock);

#define WRITE_COND (!hidg->write_pending)

	/* write queue */
	while (!WRITE_COND) {
		mutex_unlock(&hidg->lock);
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;

		if (wait_event_interruptible_exclusive(
				hidg->write_queue, WRITE_COND))
			return -ERESTARTSYS;

		mutex_lock(&hidg->lock);
	}

	count  = min_t(unsigned, count, hidg->report_length);
	status = copy_from_user(hidg->req->buf, buffer, count);

	if (status != 0) {
		ERROR(hidg->func.config->cdev,
			"copy_from_user error\n");
		mutex_unlock(&hidg->lock);
		return -EINVAL;
	}

	hidg->req->status   = 0;
	hidg->req->zero     = 0;
	hidg->req->length   = count;
	hidg->req->complete = f_hidg_req_complete;
	hidg->req->context  = hidg;
	hidg->write_pending = 1;

	status = usb_ep_queue(hidg->in_ep, hidg->req, GFP_ATOMIC);
	if (status < 0) {
		ERROR(hidg->func.config->cdev,
			"usb_ep_queue error on int endpoint %zd\n", status);
		hidg->write_pending = 0;
		wake_up(&hidg->write_queue);
	} else {
		status = count;
	}

	mutex_unlock(&hidg->lock);

	return status;
}

static unsigned int f_hidg_poll(struct file *file, poll_table *wait)
{
	struct f_hidg	*hidg  = file->private_data;
	unsigned int	ret = 0;

	poll_wait(file, &hidg->read_queue, wait);
	poll_wait(file, &hidg->write_queue, wait);

	if (WRITE_COND)
		ret |= POLLOUT | POLLWRNORM;

	if (READ_COND)
		ret |= POLLIN | POLLRDNORM;

	return ret;
}

#undef WRITE_COND
#undef READ_COND

static int f_hidg_release(struct inode *inode, struct file *fd)
{
	fd->private_data = NULL;
	return 0;
}

static int f_hidg_open(struct inode *inode, struct file *fd)
{
	struct f_hidg *hidg =
		container_of(inode->i_cdev, struct f_hidg, cdev);

	fd->private_data = hidg;

	return 0;
}

/*-------------------------------------------------------------------------*/
/*                                usb_function                             */

static void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)
{
	struct f_hidg *hidg = (struct f_hidg *)req->context;

	if (req->status != 0 || req->buf == NULL || req->actual == 0) {
		ERROR(hidg->func.config->cdev, "%s FAILED\n", __func__);
		return;
	}

	spin_lock(&hidg->spinlock);

	hidg->set_report_buff = krealloc(hidg->set_report_buff,
					 req->actual, GFP_ATOMIC);

	if (hidg->set_report_buff == NULL) {
		spin_unlock(&hidg->spinlock);
		return;
	}
	hidg->set_report_length = req->actual;
	memcpy(hidg->set_report_buff, req->buf, req->actual);

	spin_unlock(&hidg->spinlock);

	wake_up(&hidg->read_queue);

	return;
}

static int hidg_setup(struct usb_function *f,
		const struct usb_ctrlrequest *ctrl)
{
	struct f_hidg			*hidg = func_to_hidg(f);
	struct usb_composite_dev	*cdev = f->config->cdev;
	struct usb_request		*req  = cdev->req;
	int status = 0;
	__u16 value, length;

	value	= __le16_to_cpu(ctrl->wValue);
	length	= __le16_to_cpu(ctrl->wLength);

	VDBG(cdev, "hid_setup crtl_request : bRequestType:0x%x bRequest:0x%x "
		"Value:0x%x\n", ctrl->bRequestType, ctrl->bRequest, value);

	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
		  | HID_REQ_GET_REPORT):
		VDBG(cdev, "get_report\n");

		/* send an empty report */
		length = min_t(unsigned, length, hidg->report_length);
		memset(req->buf, 0x0, length);

		goto respond;
		break;

	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
		  | HID_REQ_GET_PROTOCOL):
		VDBG(cdev, "get_protocol\n");
		goto stall;
		break;

	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
		  | HID_REQ_SET_REPORT):
		VDBG(cdev, "set_report | wLenght=%d\n", ctrl->wLength);
		req->context  = hidg;
		req->complete = hidg_set_report_complete;
		goto respond;
		break;

	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
		  | HID_REQ_SET_PROTOCOL):
		VDBG(cdev, "set_protocol\n");
		goto stall;
		break;

	case ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8
		  | USB_REQ_GET_DESCRIPTOR):
		switch (value >> 8) {
		case HID_DT_REPORT:
			VDBG(cdev, "USB_REQ_GET_DESCRIPTOR: REPORT\n");
			length = min_t(unsigned short, length,
						   hidg->report_desc_length);
			memcpy(req->buf, hidg->report_desc, length);
			goto respond;
			break;

		default:
			VDBG(cdev, "Unknown decriptor request 0x%x\n",
				 value >> 8);
			goto stall;
			break;
		}
		break;

	default:
		VDBG(cdev, "Unknown request 0x%x\n",
			 ctrl->bRequest);
		goto stall;
		break;
	}

stall:
	return -EOPNOTSUPP;

respond:
	req->zero = 0;
	req->length = length;
	status = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
	if (status < 0)
		ERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);
	return status;
}

static void hidg_disable(struct usb_function *f)
{
	struct f_hidg *hidg = func_to_hidg(f);

	usb_ep_disable(hidg->in_ep);
	hidg->in_ep->driver_data = NULL;

	return;
}

static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
{
	struct usb_composite_dev		*cdev = f->config->cdev;
	struct f_hidg				*hidg = func_to_hidg(f);
	const struct usb_endpoint_descriptor	*ep_desc;
	int status = 0;

	VDBG(cdev, "hidg_set_alt intf:%d alt:%d\n", intf, alt);

	if (hidg->in_ep != NULL) {
		/* restart endpoint */
		if (hidg->in_ep->driver_data != NULL)
			usb_ep_disable(hidg->in_ep);

		ep_desc = ep_choose(f->config->cdev->gadget,
				hidg->hs_in_ep_desc, hidg->fs_in_ep_desc);
		status = usb_ep_enable(hidg->in_ep, ep_desc);
		if (status < 0) {
			ERROR(cdev, "Enable endpoint FAILED!\n");
			goto fail;
		}
		hidg->in_ep->driver_data = hidg;
	}
fail:
	return status;
}

const struct file_operations f_hidg_fops = {
	.owner		= THIS_MODULE,
	.open		= f_hidg_open,
	.release	= f_hidg_release,
	.write		= f_hidg_write,
	.read		= f_hidg_read,
	.poll		= f_hidg_poll,
};

static int __init hidg_bind(struct usb_configuration *c, struct usb_function *f)
{
	struct usb_ep		*ep;
	struct f_hidg		*hidg = func_to_hidg(f);
	int			status;
	dev_t			dev;

	/* allocate instance-specific interface IDs, and patch descriptors */
	status = usb_interface_id(c, f);
	if (status < 0)
		goto fail;
	hidg_interface_desc.bInterfaceNumber = status;


	/* allocate instance-specific endpoints */
	status = -ENODEV;
	ep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_in_ep_desc);
	if (!ep)
		goto fail;
	ep->driver_data = c->cdev;	/* claim */
	hidg->in_ep = ep;

	/* preallocate request and buffer */
	status = -ENOMEM;
	hidg->req = usb_ep_alloc_request(hidg->in_ep, GFP_KERNEL);
	if (!hidg->req)
		goto fail;


	hidg->req->buf = kmalloc(hidg->report_length, GFP_KERNEL);
	if (!hidg->req->buf)
		goto fail;

	/* set descriptor dynamic values */
	hidg_interface_desc.bInterfaceSubClass = hidg->bInterfaceSubClass;
	hidg_interface_desc.bInterfaceProtocol = hidg->bInterfaceProtocol;
	hidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
	hidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
	hidg_desc.desc[0].bDescriptorType = HID_DT_REPORT;
	hidg_desc.desc[0].wDescriptorLength =
		cpu_to_le16(hidg->report_desc_length);

	hidg->set_report_buff = NULL;

	/* copy descriptors */
	f->descriptors = usb_copy_descriptors(hidg_fs_descriptors);
	if (!f->descriptors)
		goto fail;

	hidg->fs_in_ep_desc = usb_find_endpoint(hidg_fs_descriptors,
						f->descriptors,
						&hidg_fs_in_ep_desc);

	if (gadget_is_dualspeed(c->cdev->gadget)) {
		hidg_hs_in_ep_desc.bEndpointAddress =
			hidg_fs_in_ep_desc.bEndpointAddress;
		f->hs_descriptors = usb_copy_descriptors(hidg_hs_descriptors);
		if (!f->hs_descriptors)
			goto fail;
		hidg->hs_in_ep_desc = usb_find_endpoint(hidg_hs_descriptors,
							f->hs_descriptors,
							&hidg_hs_in_ep_desc);
	} else {
		hidg->hs_in_ep_desc = NULL;
	}

	mutex_init(&hidg->lock);
	spin_lock_init(&hidg->spinlock);
	init_waitqueue_head(&hidg->write_queue);
	init_waitqueue_head(&hidg->read_queue);

	/* create char device */
	cdev_init(&hidg->cdev, &f_hidg_fops);
	dev = MKDEV(major, hidg->minor);
	status = cdev_add(&hidg->cdev, dev, 1);
	if (status)
		goto fail;

	device_create(hidg_class, NULL, dev, NULL, "%s%d", "hidg", hidg->minor);

	return 0;

fail:
	ERROR(f->config->cdev, "hidg_bind FAILED\n");
	if (hidg->req != NULL) {
		kfree(hidg->req->buf);
		if (hidg->in_ep != NULL)
			usb_ep_free_request(hidg->in_ep, hidg->req);
	}

	usb_free_descriptors(f->hs_descriptors);
	usb_free_descriptors(f->descriptors);

	return status;
}

static void hidg_unbind(struct usb_configuration *c, struct usb_function *f)
{
	struct f_hidg *hidg = func_to_hidg(f);

	device_destroy(hidg_class, MKDEV(major, hidg->minor));
	cdev_del(&hidg->cdev);

	/* disable/free request and end point */
	usb_ep_disable(hidg->in_ep);
	usb_ep_dequeue(hidg->in_ep, hidg->req);
	kfree(hidg->req->buf);
	usb_ep_free_request(hidg->in_ep, hidg->req);

	/* free descriptors copies */
	usb_free_descriptors(f->hs_descriptors);
	usb_free_descriptors(f->descriptors);

	kfree(hidg->report_desc);
	kfree(hidg->set_report_buff);
	kfree(hidg);
}

/*-------------------------------------------------------------------------*/
/*                                 Strings                                 */

#define CT_FUNC_HID_IDX	0

static struct usb_string ct_func_string_defs[] = {
	[CT_FUNC_HID_IDX].s	= "HID Interface",
	{},			/* end of list */
};

static struct usb_gadget_strings ct_func_string_table = {
	.language	= 0x0409,	/* en-US */
	.strings	= ct_func_string_defs,
};

static struct usb_gadget_strings *ct_func_strings[] = {
	&ct_func_string_table,
	NULL,
};

/*-------------------------------------------------------------------------*/
/*                             usb_configuration                           */

int __init hidg_bind_config(struct usb_configuration *c,
			    struct hidg_func_descriptor *fdesc, int index)
{
	struct f_hidg *hidg;
	int status;

	if (index >= minors)
		return -ENOENT;

	/* maybe allocate device-global string IDs, and patch descriptors */
	if (ct_func_string_defs[CT_FUNC_HID_IDX].id == 0) {
		status = usb_string_id(c->cdev);
		if (status < 0)
			return status;
		ct_func_string_defs[CT_FUNC_HID_IDX].id = status;
		hidg_interface_desc.iInterface = status;
	}

	/* allocate and initialize one new instance */
	hidg = kzalloc(sizeof *hidg, GFP_KERNEL);
	if (!hidg)
		return -ENOMEM;

	hidg->minor = index;
	hidg->bInterfaceSubClass = fdesc->subclass;
	hidg->bInterfaceProtocol = fdesc->protocol;
	hidg->report_length = fdesc->report_length;
	hidg->report_desc_length = fdesc->report_desc_length;
	hidg->report_desc = kmemdup(fdesc->report_desc,
				    fdesc->report_desc_length,
				    GFP_KERNEL);
	if (!hidg->report_desc) {
		kfree(hidg);
		return -ENOMEM;
	}

	hidg->func.name    = "hid";
	hidg->func.strings = ct_func_strings;
	hidg->func.bind    = hidg_bind;
	hidg->func.unbind  = hidg_unbind;
	hidg->func.set_alt = hidg_set_alt;
	hidg->func.disable = hidg_disable;
	hidg->func.setup   = hidg_setup;

	status = usb_add_function(c, &hidg->func);
	if (status)
		kfree(hidg);

	return status;
}

int __init ghid_setup(struct usb_gadget *g, int count)
{
	int status;
	dev_t dev;

	hidg_class = class_create(THIS_MODULE, "hidg");

	status = alloc_chrdev_region(&dev, 0, count, "hidg");
	if (!status) {
		major = MAJOR(dev);
		minors = count;
	}

	return status;
}

void ghid_cleanup(void)
{
	if (major) {
		unregister_chrdev_region(MKDEV(major, 0), minors);
		major = minors = 0;
	}

	class_destroy(hidg_class);
	hidg_class = NULL;
}
/*
 * Copyright(c) 2009 Intel Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Maintained at www.Open-FCoE.org
 */

#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/scatterlist.h>
#include <linux/crc32.h>

#include <scsi/libfc.h>
#include <scsi/fc_encode.h>

#include "fc_libfc.h"

MODULE_AUTHOR("Open-FCoE.org");
MODULE_DESCRIPTION("libfc");
MODULE_LICENSE("GPL v2");

unsigned int fc_debug_logging;
module_param_named(debug_logging, fc_debug_logging, int, S_IRUGO|S_IWUSR);
MODULE_PARM_DESC(debug_logging, "a bit mask of logging levels");

/**
 * libfc_init() - Initialize libfc.ko
 */
static int __init libfc_init(void)
{
	int rc = 0;

	rc = fc_setup_fcp();
	if (rc)
		return rc;

	rc = fc_setup_exch_mgr();
	if (rc)
		goto destroy_pkt_cache;

	rc = fc_setup_rport();
	if (rc)
		goto destroy_em;

	return rc;
destroy_em:
	fc_destroy_exch_mgr();
destroy_pkt_cache:
	fc_destroy_fcp();
	return rc;
}
module_init(libfc_init);

/**
 * libfc_exit() - Tear down libfc.ko
 */
static void __exit libfc_exit(void)
{
	fc_destroy_fcp();
	fc_destroy_exch_mgr();
	fc_destroy_rport();
}
module_exit(libfc_exit);

/**
 * fc_copy_buffer_to_sglist() - This routine copies the data of a buffer
 *				into a scatter-gather list (SG list).
 *
 * @buf: pointer to the data buffer.
 * @len: the byte-length of the data buffer.
 * @sg: pointer to the pointer of the SG list.
 * @nents: pointer to the remaining number of entries in the SG list.
 * @offset: pointer to the current offset in the SG list.
 * @km_type: dedicated page table slot type for kmap_atomic.
 * @crc: pointer to the 32-bit crc value.
 *	 If crc is NULL, CRC is not calculated.
 */
u32 fc_copy_buffer_to_sglist(void *buf, size_t len,
			     struct scatterlist *sg,
			     u32 *nents, size_t *offset,
			     enum km_type km_type, u32 *crc)
{
	size_t remaining = len;
	u32 copy_len = 0;

	while (remaining > 0 && sg) {
		size_t off, sg_bytes;
		void *page_addr;

		if (*offset >= sg->length) {
			/*
			 * Check for end and drop resources
			 * from the last iteration.
			 */
			if (!(*nents))
				break;
			--(*nents);
			*offset -= sg->length;
			sg = sg_next(sg);
			continue;
		}
		sg_bytes = min(remaining, sg->length - *offset);

		/*
		 * The scatterlist item may be bigger than PAGE_SIZE,
		 * but we are limited to mapping PAGE_SIZE at a time.
		 */
		off = *offset + sg->offset;
		sg_bytes = min(sg_bytes,
			       (size_t)(PAGE_SIZE - (off & ~PAGE_MASK)));
		page_addr = kmap_atomic(sg_page(sg) + (off >> PAGE_SHIFT),
					km_type);
		if (crc)
			*crc = crc32(*crc, buf, sg_bytes);
		memcpy((char *)page_addr + (off & ~PAGE_MASK), buf, sg_bytes);
		kunmap_atomic(page_addr, km_type);
		buf += sg_bytes;
		*offset += sg_bytes;
		remaining -= sg_bytes;
		copy_len += sg_bytes;
	}
	return copy_len;
}

/**
 * fc_fill_hdr() -  fill FC header fields based on request
 * @fp: reply frame containing header to be filled in
 * @in_fp: request frame containing header to use in filling in reply
 * @r_ctl: R_CTL value for header
 * @f_ctl: F_CTL value for header, with 0 pad
 * @seq_cnt: sequence count for the header, ignored if frame has a sequence
 * @parm_offset: parameter / offset value
 */
void fc_fill_hdr(struct fc_frame *fp, const struct fc_frame *in_fp,
		 enum fc_rctl r_ctl, u32 f_ctl, u16 seq_cnt, u32 parm_offset)
{
	struct fc_frame_header *fh;
	struct fc_frame_header *in_fh;
	struct fc_seq *sp;
	u32 fill;

	fh = __fc_frame_header_get(fp);
	in_fh = __fc_frame_header_get(in_fp);

	if (f_ctl & FC_FC_END_SEQ) {
		fill = -fr_len(fp) & 3;
		if (fill) {
			/* TODO, this may be a problem with fragmented skb */
			memset(skb_put(fp_skb(fp), fill), 0, fill);
			f_ctl |= fill;
		}
		fr_eof(fp) = FC_EOF_T;
	} else {
		WARN_ON(fr_len(fp) % 4 != 0);	/* no pad to non last frame */
		fr_eof(fp) = FC_EOF_N;
	}

	fh->fh_r_ctl = r_ctl;
	memcpy(fh->fh_d_id, in_fh->fh_s_id, sizeof(fh->fh_d_id));
	memcpy(fh->fh_s_id, in_fh->fh_d_id, sizeof(fh->fh_s_id));
	fh->fh_type = in_fh->fh_type;
	hton24(fh->fh_f_ctl, f_ctl);
	fh->fh_ox_id = in_fh->fh_ox_id;
	fh->fh_rx_id = in_fh->fh_rx_id;
	fh->fh_cs_ctl = 0;
	fh->fh_df_ctl = 0;
	fh->fh_parm_offset = htonl(parm_offset);

	sp = fr_seq(in_fp);
	if (sp) {
		fr_seq(fp) = sp;
		fh->fh_seq_id = sp->id;
		seq_cnt = sp->cnt;
	} else {
		fh->fh_seq_id = 0;
	}
	fh->fh_seq_cnt = ntohs(seq_cnt);
	fr_sof(fp) = seq_cnt ? FC_SOF_N3 : FC_SOF_I3;
	fr_encaps(fp) = fr_encaps(in_fp);
}
EXPORT_SYMBOL(fc_fill_hdr);

/**
 * fc_fill_reply_hdr() -  fill FC reply header fields based on request
 * @fp: reply frame containing header to be filled in
 * @in_fp: request frame containing header to use in filling in reply
 * @r_ctl: R_CTL value for reply
 * @parm_offset: parameter / offset value
 */
void fc_fill_reply_hdr(struct fc_frame *fp, const struct fc_frame *in_fp,
		       enum fc_rctl r_ctl, u32 parm_offset)
{
	struct fc_seq *sp;

	sp = fr_seq(in_fp);
	if (sp)
		fr_seq(fp) = fr_dev(in_fp)->tt.seq_start_next(sp);
	fc_fill_hdr(fp, in_fp, r_ctl, FC_FCTL_RESP, 0, parm_offset);
}
EXPORT_SYMBOL(fc_fill_reply_hdr);
/*
 * arch/arm/mach-pnx4008/include/mach/hardware.h
 *
 * Copyright (c) 2005 MontaVista Software, Inc. <source@mvista.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#ifndef __ASM_ARCH_HARDWARE_H
#define __ASM_ARCH_HARDWARE_H

#include <asm/sizes.h>
#include <mach/platform.h>

/* Start of virtual addresses for IO devices */
#define IO_BASE         0xF0000000

/* This macro relies on fact that for all HW i/o addresses bits 20-23 are 0 */
#define IO_ADDRESS(x)  (((((x) & 0xff000000) >> 4) | ((x) & 0xfffff)) | IO_BASE)

#endif
cmd_drivers/net/e1000e/es2lan.o := gcc -Wp,-MD,drivers/net/e1000e/.es2lan.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(es2lan)"  -D"KBUILD_MODNAME=KBUILD_STR(e1000e)"  -c -o drivers/net/e1000e/.tmp_es2lan.o drivers/net/e1000e/es2lan.c

deps_drivers/net/e1000e/es2lan.o := \
  drivers/net/e1000e/es2lan.c \
  drivers/net/e1000e/e1000.h \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/debug/objects/timers.h) \
    $(wildcard include/config/smp.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/io.h \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/has/ioport.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/tr.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/net/dsa/tag/dsa.h) \
    $(wildcard include/config/net/dsa/tag/trailer.h) \
    $(wildcard include/config/netpoll/trap.h) \
  include/linux/if.h \
  include/linux/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/socket.h \
  include/asm-generic/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sockios.h \
  include/asm-generic/sockios.h \
  include/linux/sockios.h \
  include/linux/uio.h \
  include/linux/hdlc/ioctl.h \
  include/linux/if_ether.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/dma.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
  include/linux/kmemcheck.h \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mm/owner.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  include/linux/prio_tree.h \
  include/linux/rbtree.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/completion.h \
  include/linux/wait.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/net.h \
  include/linux/random.h \
  include/linux/irqnr.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  include/linux/sysctl.h \
  include/linux/ratelimit.h \
  include/linux/textsearch.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/net/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum_64.h \
  include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/disable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  include/linux/dma-attrs.h \
  include/linux/bug.h \
  include/linux/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/scatterlist.h \
  include/asm-generic/scatterlist.h \
    $(wildcard include/config/need/sg/dma/length.h) \
  include/linux/mm.h \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/s390.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/dma-mapping.h \
    $(wildcard include/config/isa.h) \
  include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swiotlb.h \
    $(wildcard include/config/swiotlb.h) \
  include/linux/swiotlb.h \
  include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  include/asm-generic/dma-mapping-common.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/if_packet.h \
  include/linux/if_link.h \
  include/linux/netlink.h \
  include/linux/capability.h \
  include/linux/pm_qos_params.h \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/miscdevice.h \
  include/linux/major.h \
  include/linux/rculist.h \
  include/linux/ethtool.h \
  include/net/net_namespace.h \
    $(wildcard include/config/ipv6.h) \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/wext/core.h) \
    $(wildcard include/config/net.h) \
  include/net/netns/core.h \
  include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  include/net/snmp.h \
  include/linux/snmp.h \
  include/linux/u64_stats_sync.h \
  include/net/netns/unix.h \
  include/net/netns/packet.h \
  include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/security.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  include/net/inet_frag.h \
  include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  include/net/dst_ops.h \
  include/net/netns/dccp.h \
  include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  include/linux/netfilter.h \
    $(wildcard include/config/netfilter/debug.h) \
    $(wildcard include/config/nf/nat/needed.h) \
  include/linux/in.h \
  include/linux/in6.h \
  include/net/flow.h \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/path.h \
  include/linux/radix-tree.h \
  include/linux/pid.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/percpu_counter.h \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/magic.h \
  include/net/netns/conntrack.h \
  include/linux/list_nulls.h \
  include/net/netns/xfrm.h \
  include/linux/xfrm.h \
  include/linux/seq_file_net.h \
  include/linux/seq_file.h \
  include/net/dsa.h \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/irqreturn.h \
  include/linux/hardirq.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/cgroup/sched.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/proportions.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
  include/linux/key.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  include/linux/pci.h \
    $(wildcard include/config/pci/iov.h) \
    $(wildcard include/config/pcieaspm.h) \
    $(wildcard include/config/pci/msi.h) \
    $(wildcard include/config/pci.h) \
    $(wildcard include/config/pcie/ecrc.h) \
    $(wildcard include/config/ht/irq.h) \
    $(wildcard include/config/pci/domains.h) \
    $(wildcard include/config/pci/quirks.h) \
    $(wildcard include/config/hotplug/pci.h) \
  include/linux/pci_regs.h \
  include/linux/mod_devicetable.h \
  include/linux/pci_ids.h \
  include/linux/pci-dma.h \
  include/linux/dmapool.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci_64.h \
    $(wildcard include/config/calgary/iommu.h) \
  include/asm-generic/pci-dma-compat.h \
  include/asm-generic/pci.h \
  include/linux/pci-aspm.h \
    $(wildcard include/config/pcieaspm/debug.h) \
  drivers/net/e1000e/hw.h \
  drivers/net/e1000e/defines.h \

drivers/net/e1000e/es2lan.o: $(deps_drivers/net/e1000e/es2lan.o)

$(deps_drivers/net/e1000e/es2lan.o):
/*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2006 Silicon Graphics, Inc. All rights reserved.
 */

#include <linux/bootmem.h>
#include <linux/slab.h>
#include <asm/sn/types.h>
#include <asm/sn/addrs.h>
#include <asm/sn/sn_feature_sets.h>
#include <asm/sn/geo.h>
#include <asm/sn/io.h>
#include <asm/sn/l1.h>
#include <asm/sn/module.h>
#include <asm/sn/pcibr_provider.h>
#include <asm/sn/pcibus_provider_defs.h>
#include <asm/sn/pcidev.h>
#include <asm/sn/simulator.h>
#include <asm/sn/sn_sal.h>
#include <asm/sn/tioca_provider.h>
#include <asm/sn/tioce_provider.h>
#include "xtalk/hubdev.h"
#include "xtalk/xwidgetdev.h"
#include <linux/acpi.h>
#include <asm/sn/sn2/sn_hwperf.h>
#include <asm/sn/acpi.h>

extern void sn_init_cpei_timer(void);
extern void register_sn_procfs(void);
extern void sn_io_acpi_init(void);
extern void sn_io_init(void);


static struct list_head sn_sysdata_list;

/* sysdata list struct */
struct sysdata_el {
	struct list_head entry;
	void *sysdata;
};

int sn_ioif_inited;		/* SN I/O infrastructure initialized? */

int sn_acpi_rev;		/* SN ACPI revision */
EXPORT_SYMBOL_GPL(sn_acpi_rev);

struct sn_pcibus_provider *sn_pci_provider[PCIIO_ASIC_MAX_TYPES];	/* indexed by asic type */

/*
 * Hooks and struct for unsupported pci providers
 */

static dma_addr_t
sn_default_pci_map(struct pci_dev *pdev, unsigned long paddr, size_t size, int type)
{
	return 0;
}

static void
sn_default_pci_unmap(struct pci_dev *pdev, dma_addr_t addr, int direction)
{
	return;
}

static void *
sn_default_pci_bus_fixup(struct pcibus_bussoft *soft, struct pci_controller *controller)
{
	return NULL;
}

static struct sn_pcibus_provider sn_pci_default_provider = {
	.dma_map = sn_default_pci_map,
	.dma_map_consistent = sn_default_pci_map,
	.dma_unmap = sn_default_pci_unmap,
	.bus_fixup = sn_default_pci_bus_fixup,
};

/*
 * Retrieve the DMA Flush List given nasid, widget, and device.
 * This list is needed to implement the WAR - Flush DMA data on PIO Reads.
 */
static inline u64
sal_get_device_dmaflush_list(u64 nasid, u64 widget_num, u64 device_num,
			     u64 address)
{
	struct ia64_sal_retval ret_stuff;
	ret_stuff.status = 0;
	ret_stuff.v0 = 0;

	SAL_CALL_NOLOCK(ret_stuff,
			(u64) SN_SAL_IOIF_GET_DEVICE_DMAFLUSH_LIST,
			(u64) nasid, (u64) widget_num,
			(u64) device_num, (u64) address, 0, 0, 0);
	return ret_stuff.status;
}

/*
 * sn_pcidev_info_get() - Retrieve the pcidev_info struct for the specified
 *			  device.
 */
inline struct pcidev_info *
sn_pcidev_info_get(struct pci_dev *dev)
{
	struct pcidev_info *pcidev;

	list_for_each_entry(pcidev,
			    &(SN_PLATFORM_DATA(dev)->pcidev_info), pdi_list) {
		if (pcidev->pdi_linux_pcidev == dev)
			return pcidev;
	}
	return NULL;
}

/* Older PROM flush WAR
 *
 * 01/16/06 -- This war will be in place until a new official PROM is released.
 * Additionally note that the struct sn_flush_device_war also has to be
 * removed from arch/ia64/sn/include/xtalk/hubdev.h
 */

static s64 sn_device_fixup_war(u64 nasid, u64 widget, int device,
			       struct sn_flush_device_common *common)
{
	struct sn_flush_device_war *war_list;
	struct sn_flush_device_war *dev_entry;
	struct ia64_sal_retval isrv = {0,0,0,0};

	printk_once(KERN_WARNING
		"PROM version < 4.50 -- implementing old PROM flush WAR\n");

	war_list = kzalloc(DEV_PER_WIDGET * sizeof(*war_list), GFP_KERNEL);
	BUG_ON(!war_list);

	SAL_CALL_NOLOCK(isrv, SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST,
			nasid, widget, __pa(war_list), 0, 0, 0 ,0);
	if (isrv.status)
		panic("sn_device_fixup_war failed: %s\n",
		      ia64_sal_strerror(isrv.status));

	dev_entry = war_list + device;
	memcpy(common,dev_entry, sizeof(*common));
	kfree(war_list);

	return isrv.status;
}

/*
 * sn_common_hubdev_init() - This routine is called to initialize the HUB data
 *			     structure for each node in the system.
 */
void __init
sn_common_hubdev_init(struct hubdev_info *hubdev)
{

	struct sn_flush_device_kernel *sn_flush_device_kernel;
	struct sn_flush_device_kernel *dev_entry;
	s64 status;
	int widget, device, size;

	/* Attach the error interrupt handlers */
	if (hubdev->hdi_nasid & 1)	/* If TIO */
		ice_error_init(hubdev);
	else
		hub_error_init(hubdev);

	for (widget = 0; widget <= HUB_WIDGET_ID_MAX; widget++)
		hubdev->hdi_xwidget_info[widget].xwi_hubinfo = hubdev;

	if (!hubdev->hdi_flush_nasid_list.widget_p)
		return;

	size = (HUB_WIDGET_ID_MAX + 1) *
		sizeof(struct sn_flush_device_kernel *);
	hubdev->hdi_flush_nasid_list.widget_p =
		kzalloc(size, GFP_KERNEL);
	BUG_ON(!hubdev->hdi_flush_nasid_list.widget_p);

	for (widget = 0; widget <= HUB_WIDGET_ID_MAX; widget++) {
		size = DEV_PER_WIDGET *
			sizeof(struct sn_flush_device_kernel);
		sn_flush_device_kernel = kzalloc(size, GFP_KERNEL);
		BUG_ON(!sn_flush_device_kernel);

		dev_entry = sn_flush_device_kernel;
		for (device = 0; device < DEV_PER_WIDGET;
		     device++, dev_entry++) {
			size = sizeof(struct sn_flush_device_common);
			dev_entry->common = kzalloc(size, GFP_KERNEL);
			BUG_ON(!dev_entry->common);
			if (sn_prom_feature_available(PRF_DEVICE_FLUSH_LIST))
				status = sal_get_device_dmaflush_list(
					     hubdev->hdi_nasid, widget, device,
					     (u64)(dev_entry->common));
			else
				status = sn_device_fixup_war(hubdev->hdi_nasid,
							     widget, device,
							     dev_entry->common);
			if (status != SALRET_OK)
				panic("SAL call failed: %s\n",
				      ia64_sal_strerror(status));

			spin_lock_init(&dev_entry->sfdl_flush_lock);
		}

		if (sn_flush_device_kernel)
			hubdev->hdi_flush_nasid_list.widget_p[widget] =
							 sn_flush_device_kernel;
	}
}

void sn_pci_unfixup_slot(struct pci_dev *dev)
{
	struct pci_dev *host_pci_dev = SN_PCIDEV_INFO(dev)->host_pci_dev;

	sn_irq_unfixup(dev);
	pci_dev_put(host_pci_dev);
	pci_dev_put(dev);
}

/*
 * sn_pci_fixup_slot()
 */
void sn_pci_fixup_slot(struct pci_dev *dev, struct pcidev_info *pcidev_info,
		       struct sn_irq_info *sn_irq_info)
{
	int segment = pci_domain_nr(dev->bus);
	struct pcibus_bussoft *bs;
	struct pci_bus *host_pci_bus;
	struct pci_dev *host_pci_dev;
	unsigned int bus_no, devfn;

	pci_dev_get(dev); /* for the sysdata pointer */

	/* Add pcidev_info to list in pci_controller.platform_data */
	list_add_tail(&pcidev_info->pdi_list,
		      &(SN_PLATFORM_DATA(dev->bus)->pcidev_info));
	/*
	 * Using the PROMs values for the PCI host bus, get the Linux
	 * PCI host_pci_dev struct and set up host bus linkages
 	 */

	bus_no = (pcidev_info->pdi_slot_host_handle >> 32) & 0xff;
	devfn = pcidev_info->pdi_slot_host_handle & 0xffffffff;
 	host_pci_bus = pci_find_bus(segment, bus_no);
 	host_pci_dev = pci_get_slot(host_pci_bus, devfn);

	pcidev_info->host_pci_dev = host_pci_dev;
	pcidev_info->pdi_linux_pcidev = dev;
	pcidev_info->pdi_host_pcidev_info = SN_PCIDEV_INFO(host_pci_dev);
	bs = SN_PCIBUS_BUSSOFT(dev->bus);
	pcidev_info->pdi_pcibus_info = bs;

	if (bs && bs->bs_asic_type < PCIIO_ASIC_MAX_TYPES) {
		SN_PCIDEV_BUSPROVIDER(dev) = sn_pci_provider[bs->bs_asic_type];
	} else {
		SN_PCIDEV_BUSPROVIDER(dev) = &sn_pci_default_provider;
	}

	/* Only set up IRQ stuff if this device has a host bus context */
	if (bs && sn_irq_info->irq_irq) {
		pcidev_info->pdi_sn_irq_info = sn_irq_info;
		dev->irq = pcidev_info->pdi_sn_irq_info->irq_irq;
		sn_irq_fixup(dev, sn_irq_info);
	} else {
		pcidev_info->pdi_sn_irq_info = NULL;
		kfree(sn_irq_info);
	}
}

/*
 * sn_common_bus_fixup - Perform platform specific bus fixup.
 *			 Execute the ASIC specific fixup routine
 *			 for this bus.
 */
void
sn_common_bus_fixup(struct pci_bus *bus,
		    struct pcibus_bussoft *prom_bussoft_ptr)
{
	int cnode;
	struct pci_controller *controller;
	struct hubdev_info *hubdev_info;
	int nasid;
	void *provider_soft;
	struct sn_pcibus_provider *provider;
	struct sn_platform_data *sn_platform_data;

	controller = PCI_CONTROLLER(bus);
	/*
	 * Per-provider fixup.  Copies the bus soft structure from prom
	 * to local area and links SN_PCIBUS_BUSSOFT().
	 */

	if (prom_bussoft_ptr->bs_asic_type >= PCIIO_ASIC_MAX_TYPES) {
		printk(KERN_WARNING "sn_common_bus_fixup: Unsupported asic type, %d",
		       prom_bussoft_ptr->bs_asic_type);
		return;
	}

	if (prom_bussoft_ptr->bs_asic_type == PCIIO_ASIC_TYPE_PPB)
		return;	/* no further fixup necessary */

	provider = sn_pci_provider[prom_bussoft_ptr->bs_asic_type];
	if (provider == NULL)
		panic("sn_common_bus_fixup: No provider registered for this asic type, %d",
		      prom_bussoft_ptr->bs_asic_type);

	if (provider->bus_fixup)
		provider_soft = (*provider->bus_fixup) (prom_bussoft_ptr,
				 controller);
	else
		provider_soft = NULL;

	/*
	 * Generic bus fixup goes here.  Don't reference prom_bussoft_ptr
	 * after this point.
	 */
	controller->platform_data = kzalloc(sizeof(struct sn_platform_data),
					    GFP_KERNEL);
	BUG_ON(controller->platform_data == NULL);
	sn_platform_data =
			(struct sn_platform_data *) controller->platform_data;
	sn_platform_data->provider_soft = provider_soft;
	INIT_LIST_HEAD(&((struct sn_platform_data *)
			 controller->platform_data)->pcidev_info);
	nasid = NASID_GET(SN_PCIBUS_BUSSOFT(bus)->bs_base);
	cnode = nasid_to_cnodeid(nasid);
	hubdev_info = (struct hubdev_info *)(NODEPDA(cnode)->pdinfo);
	SN_PCIBUS_BUSSOFT(bus)->bs_xwidget_info =
	    &(hubdev_info->hdi_xwidget_info[SN_PCIBUS_BUSSOFT(bus)->bs_xid]);

	/*
	 * If the node information we obtained during the fixup phase is
	 * invalid then set controller->node to -1 (undetermined)
	 */
	if (controller->node >= num_online_nodes()) {
		struct pcibus_bussoft *b = SN_PCIBUS_BUSSOFT(bus);

		printk(KERN_WARNING "Device ASIC=%u XID=%u PBUSNUM=%u "
		       "L_IO=%llx L_MEM=%llx BASE=%llx\n",
		       b->bs_asic_type, b->bs_xid, b->bs_persist_busnum,
		       b->bs_legacy_io, b->bs_legacy_mem, b->bs_base);
		printk(KERN_WARNING "on node %d but only %d nodes online."
		       "Association set to undetermined.\n",
		       controller->node, num_online_nodes());
		controller->node = -1;
	}
}

void sn_bus_store_sysdata(struct pci_dev *dev)
{
	struct sysdata_el *element;

	element = kzalloc(sizeof(struct sysdata_el), GFP_KERNEL);
	if (!element) {
		dev_dbg(&dev->dev, "%s: out of memory!\n", __func__);
		return;
	}
	element->sysdata = SN_PCIDEV_INFO(dev);
	list_add(&element->entry, &sn_sysdata_list);
}

void sn_bus_free_sysdata(void)
{
	struct sysdata_el *element;
	struct list_head *list, *safe;

	list_for_each_safe(list, safe, &sn_sysdata_list) {
		element = list_entry(list, struct sysdata_el, entry);
		list_del(&element->entry);
		list_del(&(((struct pcidev_info *)
			     (element->sysdata))->pdi_list));
		kfree(element->sysdata);
		kfree(element);
	}
	return;
}

/*
 * hubdev_init_node() - Creates the HUB data structure and link them to it's
 *			own NODE specific data area.
 */
void __init hubdev_init_node(nodepda_t * npda, cnodeid_t node)
{
	struct hubdev_info *hubdev_info;
	int size;
	pg_data_t *pg;

	size = sizeof(struct hubdev_info);

	if (node >= num_online_nodes())	/* Headless/memless IO nodes */
		pg = NODE_DATA(0);
	else
		pg = NODE_DATA(node);

	hubdev_info = (struct hubdev_info *)alloc_bootmem_node(pg, size);

	npda->pdinfo = (void *)hubdev_info;
}

geoid_t
cnodeid_get_geoid(cnodeid_t cnode)
{
	struct hubdev_info *hubdev;

	hubdev = (struct hubdev_info *)(NODEPDA(cnode)->pdinfo);
	return hubdev->hdi_geoid;
}

void sn_generate_path(struct pci_bus *pci_bus, char *address)
{
	nasid_t nasid;
	cnodeid_t cnode;
	geoid_t geoid;
	moduleid_t moduleid;
	u16 bricktype;

	nasid = NASID_GET(SN_PCIBUS_BUSSOFT(pci_bus)->bs_base);
	cnode = nasid_to_cnodeid(nasid);
	geoid = cnodeid_get_geoid(cnode);
	moduleid = geo_module(geoid);

	sprintf(address, "module_%c%c%c%c%.2d",
		'0'+RACK_GET_CLASS(MODULE_GET_RACK(moduleid)),
		'0'+RACK_GET_GROUP(MODULE_GET_RACK(moduleid)),
		'0'+RACK_GET_NUM(MODULE_GET_RACK(moduleid)),
		MODULE_GET_BTCHAR(moduleid), MODULE_GET_BPOS(moduleid));

	/* Tollhouse requires slot id to be displayed */
	bricktype = MODULE_GET_BTYPE(moduleid);
	if ((bricktype == L1_BRICKTYPE_191010) ||
	    (bricktype == L1_BRICKTYPE_1932))
			sprintf(address + strlen(address), "^%d",
						geo_slot(geoid));
}

void __devinit
sn_pci_fixup_bus(struct pci_bus *bus)
{

	if (SN_ACPI_BASE_SUPPORT())
		sn_acpi_bus_fixup(bus);
	else
		sn_bus_fixup(bus);
}

/*
 * sn_io_early_init - Perform early IO (and some non-IO) initialization.
 *		      In particular, setup the sn_pci_provider[] array.
 *		      This needs to be done prior to any bus scanning
 *		      (acpi_scan_init()) in the ACPI case, as the SN
 *		      bus fixup code will reference the array.
 */
static int __init
sn_io_early_init(void)
{
	int i;

	if (!ia64_platform_is("sn2") || IS_RUNNING_ON_FAKE_PROM())
		return 0;

	/* we set the acpi revision to that of the DSDT table OEM rev. */
	{
		struct acpi_table_header *header = NULL;

		acpi_get_table(ACPI_SIG_DSDT, 1, &header);
		BUG_ON(header == NULL);
		sn_acpi_rev = header->oem_revision;
	}

	/*
	 * prime sn_pci_provider[].  Individual provider init routines will
	 * override their respective default entries.
	 */

	for (i = 0; i < PCIIO_ASIC_MAX_TYPES; i++)
		sn_pci_provider[i] = &sn_pci_default_provider;

	pcibr_init_provider();
	tioca_init_provider();
	tioce_init_provider();

	/*
	 * This is needed to avoid bounce limit checks in the blk layer
	 */
	ia64_max_iommu_merge_mask = ~PAGE_MASK;

	sn_irq_lh_init();
	INIT_LIST_HEAD(&sn_sysdata_list);
	sn_init_cpei_timer();

#ifdef CONFIG_PROC_FS
	register_sn_procfs();
#endif

	{
		struct acpi_table_header *header;
		(void)acpi_get_table(ACPI_SIG_DSDT, 1, &header);
		printk(KERN_INFO "ACPI  DSDT OEM Rev 0x%x\n",
			header->oem_revision);
	}
	if (SN_ACPI_BASE_SUPPORT())
		sn_io_acpi_init();
	else
		sn_io_init();
	return 0;
}

arch_initcall(sn_io_early_init);

/*
 * sn_io_late_init() - Perform any final platform specific IO initialization.
 */

int __init
sn_io_late_init(void)
{
	struct pci_bus *bus;
	struct pcibus_bussoft *bussoft;
	cnodeid_t cnode;
	nasid_t nasid;
	cnodeid_t near_cnode;

	if (!ia64_platform_is("sn2") || IS_RUNNING_ON_FAKE_PROM())
		return 0;

	/*
	 * Setup closest node in pci_controller->node for
	 * PIC, TIOCP, TIOCE (TIOCA does it during bus fixup using
	 * info from the PROM).
	 */
	bus = NULL;
	while ((bus = pci_find_next_bus(bus)) != NULL) {
		bussoft = SN_PCIBUS_BUSSOFT(bus);
		nasid = NASID_GET(bussoft->bs_base);
		cnode = nasid_to_cnodeid(nasid);
		if ((bussoft->bs_asic_type == PCIIO_ASIC_TYPE_TIOCP) ||
		    (bussoft->bs_asic_type == PCIIO_ASIC_TYPE_TIOCE) ||
		    (bussoft->bs_asic_type == PCIIO_ASIC_TYPE_PIC)) {
			/* PCI Bridge: find nearest node with CPUs */
			int e = sn_hwperf_get_nearest_node(cnode, NULL,
							   &near_cnode);
			if (e < 0) {
				near_cnode = (cnodeid_t)-1; /* use any node */
				printk(KERN_WARNING "sn_io_late_init: failed "
				       "to find near node with CPUs for "
				       "node %d, err=%d\n", cnode, e);
			}
			PCI_CONTROLLER(bus)->node = near_cnode;
		}
	}

	sn_ioif_inited = 1;	/* SN I/O infrastructure now initialized */

	return 0;
}

fs_initcall(sn_io_late_init);

EXPORT_SYMBOL(sn_pci_unfixup_slot);
EXPORT_SYMBOL(sn_bus_store_sysdata);
EXPORT_SYMBOL(sn_bus_free_sysdata);
EXPORT_SYMBOL(sn_generate_path);

cmd_drivers/hwmon/atxp1.mod.o := gcc -Wp,-MD,drivers/hwmon/.atxp1.mod.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(atxp1.mod)"  -D"KBUILD_MODNAME=KBUILD_STR(atxp1)"  -DMODULE  -c -o drivers/hwmon/atxp1.mod.o drivers/hwmon/atxp1.mod.c

deps_drivers/hwmon/atxp1.mod.o := \
  drivers/hwmon/atxp1.mod.c \
    $(wildcard include/config/module/unload.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/vermagic.h \
  include/generated/utsrelease.h \

drivers/hwmon/atxp1.mod.o: $(deps_drivers/hwmon/atxp1.mod.o)

$(deps_drivers/hwmon/atxp1.mod.o):
/*
 * wm8711.c  --  WM8711 ALSA SoC Audio driver
 *
 * Copyright 2006 Wolfson Microelectronics
 *
 * Author: Mike Arthur <linux@wolfsonmicro.com>
 *
 * Based on wm8731.c by Richard Purdie
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/spi/spi.h>
#include <linux/slab.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/soc-dapm.h>
#include <sound/tlv.h>
#include <sound/initval.h>

#include "wm8711.h"

static struct snd_soc_codec *wm8711_codec;

/* codec private data */
struct wm8711_priv {
	struct snd_soc_codec codec;
	u16 reg_cache[WM8711_CACHEREGNUM];
	unsigned int sysclk;
};

/*
 * wm8711 register cache
 * We can't read the WM8711 register space when we are
 * using 2 wire for device control, so we cache them instead.
 * There is no point in caching the reset register
 */
static const u16 wm8711_reg[WM8711_CACHEREGNUM] = {
	0x0079, 0x0079, 0x000a, 0x0008,
	0x009f, 0x000a, 0x0000, 0x0000
};

#define wm8711_reset(c)	snd_soc_write(c, WM8711_RESET, 0)

static const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);

static const struct snd_kcontrol_new wm8711_snd_controls[] = {

SOC_DOUBLE_R_TLV("Master Playback Volume", WM8711_LOUT1V, WM8711_ROUT1V,
		 0, 127, 0, out_tlv),
SOC_DOUBLE_R("Master Playback ZC Switch", WM8711_LOUT1V, WM8711_ROUT1V,
	7, 1, 0),

};

/* Output Mixer */
static const struct snd_kcontrol_new wm8711_output_mixer_controls[] = {
SOC_DAPM_SINGLE("Line Bypass Switch", WM8711_APANA, 3, 1, 0),
SOC_DAPM_SINGLE("HiFi Playback Switch", WM8711_APANA, 4, 1, 0),
};

static const struct snd_soc_dapm_widget wm8711_dapm_widgets[] = {
SND_SOC_DAPM_MIXER("Output Mixer", WM8711_PWR, 4, 1,
	&wm8711_output_mixer_controls[0],
	ARRAY_SIZE(wm8711_output_mixer_controls)),
SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8711_PWR, 3, 1),
SND_SOC_DAPM_OUTPUT("LOUT"),
SND_SOC_DAPM_OUTPUT("LHPOUT"),
SND_SOC_DAPM_OUTPUT("ROUT"),
SND_SOC_DAPM_OUTPUT("RHPOUT"),
};

static const struct snd_soc_dapm_route intercon[] = {
	/* output mixer */
	{"Output Mixer", "Line Bypass Switch", "Line Input"},
	{"Output Mixer", "HiFi Playback Switch", "DAC"},

	/* outputs */
	{"RHPOUT", NULL, "Output Mixer"},
	{"ROUT", NULL, "Output Mixer"},
	{"LHPOUT", NULL, "Output Mixer"},
	{"LOUT", NULL, "Output Mixer"},
};

static int wm8711_add_widgets(struct snd_soc_codec *codec)
{
	snd_soc_dapm_new_controls(codec, wm8711_dapm_widgets,
				  ARRAY_SIZE(wm8711_dapm_widgets));

	snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));

	return 0;
}

struct _coeff_div {
	u32 mclk;
	u32 rate;
	u16 fs;
	u8 sr:4;
	u8 bosr:1;
	u8 usb:1;
};

/* codec mclk clock divider coefficients */
static const struct _coeff_div coeff_div[] = {
	/* 48k */
	{12288000, 48000, 256, 0x0, 0x0, 0x0},
	{18432000, 48000, 384, 0x0, 0x1, 0x0},
	{12000000, 48000, 250, 0x0, 0x0, 0x1},

	/* 32k */
	{12288000, 32000, 384, 0x6, 0x0, 0x0},
	{18432000, 32000, 576, 0x6, 0x1, 0x0},
	{12000000, 32000, 375, 0x6, 0x0, 0x1},

	/* 8k */
	{12288000, 8000, 1536, 0x3, 0x0, 0x0},
	{18432000, 8000, 2304, 0x3, 0x1, 0x0},
	{11289600, 8000, 1408, 0xb, 0x0, 0x0},
	{16934400, 8000, 2112, 0xb, 0x1, 0x0},
	{12000000, 8000, 1500, 0x3, 0x0, 0x1},

	/* 96k */
	{12288000, 96000, 128, 0x7, 0x0, 0x0},
	{18432000, 96000, 192, 0x7, 0x1, 0x0},
	{12000000, 96000, 125, 0x7, 0x0, 0x1},

	/* 44.1k */
	{11289600, 44100, 256, 0x8, 0x0, 0x0},
	{16934400, 44100, 384, 0x8, 0x1, 0x0},
	{12000000, 44100, 272, 0x8, 0x1, 0x1},

	/* 88.2k */
	{11289600, 88200, 128, 0xf, 0x0, 0x0},
	{16934400, 88200, 192, 0xf, 0x1, 0x0},
	{12000000, 88200, 136, 0xf, 0x1, 0x1},
};

static inline int get_coeff(int mclk, int rate)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
			return i;
	}
	return 0;
}

static int wm8711_hw_params(struct snd_pcm_substream *substream,
	struct snd_pcm_hw_params *params,
	struct snd_soc_dai *dai)
{
	struct snd_soc_codec *codec = dai->codec;
	struct wm8711_priv *wm8711 = snd_soc_codec_get_drvdata(codec);
	u16 iface = snd_soc_read(codec, WM8711_IFACE) & 0xfffc;
	int i = get_coeff(wm8711->sysclk, params_rate(params));
	u16 srate = (coeff_div[i].sr << 2) |
		(coeff_div[i].bosr << 1) | coeff_div[i].usb;

	snd_soc_write(codec, WM8711_SRATE, srate);

	/* bit size */
	switch (params_format(params)) {
	case SNDRV_PCM_FORMAT_S16_LE:
		break;
	case SNDRV_PCM_FORMAT_S20_3LE:
		iface |= 0x0004;
		break;
	case SNDRV_PCM_FORMAT_S24_LE:
		iface |= 0x0008;
		break;
	}

	snd_soc_write(codec, WM8711_IFACE, iface);
	return 0;
}

static int wm8711_pcm_prepare(struct snd_pcm_substream *substream,
			      struct snd_soc_dai *dai)
{
	struct snd_soc_codec *codec = dai->codec;

	/* set active */
	snd_soc_write(codec, WM8711_ACTIVE, 0x0001);

	return 0;
}

static void wm8711_shutdown(struct snd_pcm_substream *substream,
			    struct snd_soc_dai *dai)
{
	struct snd_soc_codec *codec = dai->codec;

	/* deactivate */
	if (!codec->active) {
		udelay(50);
		snd_soc_write(codec, WM8711_ACTIVE, 0x0);
	}
}

static int wm8711_mute(struct snd_soc_dai *dai, int mute)
{
	struct snd_soc_codec *codec = dai->codec;
	u16 mute_reg = snd_soc_read(codec, WM8711_APDIGI) & 0xfff7;

	if (mute)
		snd_soc_write(codec, WM8711_APDIGI, mute_reg | 0x8);
	else
		snd_soc_write(codec, WM8711_APDIGI, mute_reg);

	return 0;
}

static int wm8711_set_dai_sysclk(struct snd_soc_dai *codec_dai,
		int clk_id, unsigned int freq, int dir)
{
	struct snd_soc_codec *codec = codec_dai->codec;
	struct wm8711_priv *wm8711 = snd_soc_codec_get_drvdata(codec);

	switch (freq) {
	case 11289600:
	case 12000000:
	case 12288000:
	case 16934400:
	case 18432000:
		wm8711->sysclk = freq;
		return 0;
	}
	return -EINVAL;
}

static int wm8711_set_dai_fmt(struct snd_soc_dai *codec_dai,
		unsigned int fmt)
{
	struct snd_soc_codec *codec = codec_dai->codec;
	u16 iface = 0;

	/* set master/slave audio interface */
	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
	case SND_SOC_DAIFMT_CBM_CFM:
		iface |= 0x0040;
		break;
	case SND_SOC_DAIFMT_CBS_CFS:
		break;
	default:
		return -EINVAL;
	}

	/* interface format */
	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
	case SND_SOC_DAIFMT_I2S:
		iface |= 0x0002;
		break;
	case SND_SOC_DAIFMT_RIGHT_J:
		break;
	case SND_SOC_DAIFMT_LEFT_J:
		iface |= 0x0001;
		break;
	case SND_SOC_DAIFMT_DSP_A:
		iface |= 0x0003;
		break;
	case SND_SOC_DAIFMT_DSP_B:
		iface |= 0x0013;
		break;
	default:
		return -EINVAL;
	}

	/* clock inversion */
	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
	case SND_SOC_DAIFMT_NB_NF:
		break;
	case SND_SOC_DAIFMT_IB_IF:
		iface |= 0x0090;
		break;
	case SND_SOC_DAIFMT_IB_NF:
		iface |= 0x0080;
		break;
	case SND_SOC_DAIFMT_NB_IF:
		iface |= 0x0010;
		break;
	default:
		return -EINVAL;
	}

	/* set iface */
	snd_soc_write(codec, WM8711_IFACE, iface);
	return 0;
}


static int wm8711_set_bias_level(struct snd_soc_codec *codec,
	enum snd_soc_bias_level level)
{
	u16 reg = snd_soc_read(codec, WM8711_PWR) & 0xff7f;

	switch (level) {
	case SND_SOC_BIAS_ON:
		snd_soc_write(codec, WM8711_PWR, reg);
		break;
	case SND_SOC_BIAS_PREPARE:
		break;
	case SND_SOC_BIAS_STANDBY:
		snd_soc_write(codec, WM8711_PWR, reg | 0x0040);
		break;
	case SND_SOC_BIAS_OFF:
		snd_soc_write(codec, WM8711_ACTIVE, 0x0);
		snd_soc_write(codec, WM8711_PWR, 0xffff);
		break;
	}
	codec->bias_level = level;
	return 0;
}

#define WM8711_RATES SNDRV_PCM_RATE_8000_96000

#define WM8711_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
	SNDRV_PCM_FMTBIT_S24_LE)

static struct snd_soc_dai_ops wm8711_ops = {
	.prepare = wm8711_pcm_prepare,
	.hw_params = wm8711_hw_params,
	.shutdown = wm8711_shutdown,
	.digital_mute = wm8711_mute,
	.set_sysclk = wm8711_set_dai_sysclk,
	.set_fmt = wm8711_set_dai_fmt,
};

struct snd_soc_dai wm8711_dai = {
	.name = "WM8711",
	.playback = {
		.stream_name = "Playback",
		.channels_min = 1,
		.channels_max = 2,
		.rates = WM8711_RATES,
		.formats = WM8711_FORMATS,
	},
	.ops = &wm8711_ops,
};
EXPORT_SYMBOL_GPL(wm8711_dai);

static int wm8711_suspend(struct platform_device *pdev, pm_message_t state)
{
	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
	struct snd_soc_codec *codec = socdev->card->codec;

	snd_soc_write(codec, WM8711_ACTIVE, 0x0);
	wm8711_set_bias_level(codec, SND_SOC_BIAS_OFF);
	return 0;
}

static int wm8711_resume(struct platform_device *pdev)
{
	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
	struct snd_soc_codec *codec = socdev->card->codec;
	int i;
	u8 data[2];
	u16 *cache = codec->reg_cache;

	/* Sync reg_cache with the hardware */
	for (i = 0; i < ARRAY_SIZE(wm8711_reg); i++) {
		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
		data[1] = cache[i] & 0x00ff;
		codec->hw_write(codec->control_data, data, 2);
	}
	wm8711_set_bias_level(codec, SND_SOC_BIAS_STANDBY);

	return 0;
}

static int wm8711_probe(struct platform_device *pdev)
{
	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
	struct snd_soc_codec *codec;
	int ret = 0;

	if (wm8711_codec == NULL) {
		dev_err(&pdev->dev, "Codec device not registered\n");
		return -ENODEV;
	}

	socdev->card->codec = wm8711_codec;
	codec = wm8711_codec;

	/* register pcms */
	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
	if (ret < 0) {
		dev_err(codec->dev, "failed to create pcms: %d\n", ret);
		goto pcm_err;
	}

	snd_soc_add_controls(codec, wm8711_snd_controls,
			     ARRAY_SIZE(wm8711_snd_controls));
	wm8711_add_widgets(codec);

	return ret;

pcm_err:
	return ret;
}

/* power down chip */
static int wm8711_remove(struct platform_device *pdev)
{
	struct snd_soc_device *socdev = platform_get_drvdata(pdev);

	snd_soc_free_pcms(socdev);
	snd_soc_dapm_free(socdev);

	return 0;
}

struct snd_soc_codec_device soc_codec_dev_wm8711 = {
	.probe = 	wm8711_probe,
	.remove = 	wm8711_remove,
	.suspend = 	wm8711_suspend,
	.resume =	wm8711_resume,
};
EXPORT_SYMBOL_GPL(soc_codec_dev_wm8711);

static int wm8711_register(struct wm8711_priv *wm8711,
			   enum snd_soc_control_type control)
{
	int ret;
	struct snd_soc_codec *codec = &wm8711->codec;
	u16 reg;

	if (wm8711_codec) {
		dev_err(codec->dev, "Another WM8711 is registered\n");
		ret = -EINVAL;
		goto err;
	}

	mutex_init(&codec->mutex);
	INIT_LIST_HEAD(&codec->dapm_widgets);
	INIT_LIST_HEAD(&codec->dapm_paths);

	snd_soc_codec_set_drvdata(codec, wm8711);
	codec->name = "WM8711";
	codec->owner = THIS_MODULE;
	codec->bias_level = SND_SOC_BIAS_OFF;
	codec->set_bias_level = wm8711_set_bias_level;
	codec->dai = &wm8711_dai;
	codec->num_dai = 1;
	codec->reg_cache_size = WM8711_CACHEREGNUM;
	codec->reg_cache = &wm8711->reg_cache;

	memcpy(codec->reg_cache, wm8711_reg, sizeof(wm8711_reg));

	ret = snd_soc_codec_set_cache_io(codec, 7, 9, control);
	if (ret < 0) {
		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
		goto err;
	}

	ret = wm8711_reset(codec);
	if (ret < 0) {
		dev_err(codec->dev, "Failed to issue reset\n");
		goto err;
	}

	wm8711_dai.dev = codec->dev;

	wm8711_set_bias_level(codec, SND_SOC_BIAS_STANDBY);

	/* Latch the update bits */
	reg = snd_soc_read(codec, WM8711_LOUT1V);
	snd_soc_write(codec, WM8711_LOUT1V, reg | 0x0100);
	reg = snd_soc_read(codec, WM8711_ROUT1V);
	snd_soc_write(codec, WM8711_ROUT1V, reg | 0x0100);

	wm8711_codec = codec;

	ret = snd_soc_register_codec(codec);
	if (ret != 0) {
		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
		goto err;
	}

	ret = snd_soc_register_dai(&wm8711_dai);
	if (ret != 0) {
		dev_err(codec->dev, "Failed to register DAI: %d\n", ret);
		goto err_codec;
	}

	return 0;

err_codec:
	snd_soc_unregister_codec(codec);
err:
	kfree(wm8711);
	return ret;
}

static void wm8711_unregister(struct wm8711_priv *wm8711)
{
	wm8711_set_bias_level(&wm8711->codec, SND_SOC_BIAS_OFF);
	snd_soc_unregister_dai(&wm8711_dai);
	snd_soc_unregister_codec(&wm8711->codec);
	kfree(wm8711);
	wm8711_codec = NULL;
}

#if defined(CONFIG_SPI_MASTER)
static int __devinit wm8711_spi_probe(struct spi_device *spi)
{
	struct snd_soc_codec *codec;
	struct wm8711_priv *wm8711;

	wm8711 = kzalloc(sizeof(struct wm8711_priv), GFP_KERNEL);
	if (wm8711 == NULL)
		return -ENOMEM;

	codec = &wm8711->codec;
	codec->control_data = spi;
	codec->dev = &spi->dev;

	dev_set_drvdata(&spi->dev, wm8711);

	return wm8711_register(wm8711, SND_SOC_SPI);
}

static int __devexit wm8711_spi_remove(struct spi_device *spi)
{
	struct wm8711_priv *wm8711 = dev_get_drvdata(&spi->dev);

	wm8711_unregister(wm8711);

	return 0;
}

static struct spi_driver wm8711_spi_driver = {
	.driver = {
		.name	= "wm8711",
		.bus	= &spi_bus_type,
		.owner	= THIS_MODULE,
	},
	.probe		= wm8711_spi_probe,
	.remove		= __devexit_p(wm8711_spi_remove),
};
#endif /* CONFIG_SPI_MASTER */

#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
static __devinit int wm8711_i2c_probe(struct i2c_client *i2c,
				      const struct i2c_device_id *id)
{
	struct wm8711_priv *wm8711;
	struct snd_soc_codec *codec;

	wm8711 = kzalloc(sizeof(struct wm8711_priv), GFP_KERNEL);
	if (wm8711 == NULL)
		return -ENOMEM;

	codec = &wm8711->codec;
	codec->hw_write = (hw_write_t)i2c_master_send;

	i2c_set_clientdata(i2c, wm8711);
	codec->control_data = i2c;

	codec->dev = &i2c->dev;

	return wm8711_register(wm8711, SND_SOC_I2C);
}

static __devexit int wm8711_i2c_remove(struct i2c_client *client)
{
	struct wm8711_priv *wm8711 = i2c_get_clientdata(client);
	wm8711_unregister(wm8711);
	return 0;
}

static const struct i2c_device_id wm8711_i2c_id[] = {
	{ "wm8711", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, wm8711_i2c_id);

static struct i2c_driver wm8711_i2c_driver = {
	.driver = {
		.name = "WM8711 I2C Codec",
		.owner = THIS_MODULE,
	},
	.probe =    wm8711_i2c_probe,
	.remove =   __devexit_p(wm8711_i2c_remove),
	.id_table = wm8711_i2c_id,
};
#endif

static int __init wm8711_modinit(void)
{
	int ret;
#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
	ret = i2c_add_driver(&wm8711_i2c_driver);
	if (ret != 0) {
		printk(KERN_ERR "Failed to register WM8711 I2C driver: %d\n",
		       ret);
	}
#endif
#if defined(CONFIG_SPI_MASTER)
	ret = spi_register_driver(&wm8711_spi_driver);
	if (ret != 0) {
		printk(KERN_ERR "Failed to register WM8711 SPI driver: %d\n",
		       ret);
	}
#endif
	return 0;
}
module_init(wm8711_modinit);

static void __exit wm8711_exit(void)
{
#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
	i2c_del_driver(&wm8711_i2c_driver);
#endif
#if defined(CONFIG_SPI_MASTER)
	spi_unregister_driver(&wm8711_spi_driver);
#endif
}
module_exit(wm8711_exit);

MODULE_DESCRIPTION("ASoC WM8711 driver");
MODULE_AUTHOR("Mike Arthur");
MODULE_LICENSE("GPL");
/*
 * File...........: linux/fs/partitions/ibm.c
 * Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 *                  Volker Sameske <sameske@de.ibm.com>
 * Bugreports.to..: <Linux390@de.ibm.com>
 * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
 */

#include <linux/buffer_head.h>
#include <linux/hdreg.h>
#include <linux/slab.h>
#include <asm/dasd.h>
#include <asm/ebcdic.h>
#include <asm/uaccess.h>
#include <asm/vtoc.h>

#include "check.h"
#include "ibm.h"

/*
 * compute the block number from a
 * cyl-cyl-head-head structure
 */
static sector_t
cchh2blk (struct vtoc_cchh *ptr, struct hd_geometry *geo) {

	sector_t cyl;
	__u16 head;

	/*decode cylinder and heads for large volumes */
	cyl = ptr->hh & 0xFFF0;
	cyl <<= 12;
	cyl |= ptr->cc;
	head = ptr->hh & 0x000F;
	return cyl * geo->heads * geo->sectors +
	       head * geo->sectors;
}

/*
 * compute the block number from a
 * cyl-cyl-head-head-block structure
 */
static sector_t
cchhb2blk (struct vtoc_cchhb *ptr, struct hd_geometry *geo) {

	sector_t cyl;
	__u16 head;

	/*decode cylinder and heads for large volumes */
	cyl = ptr->hh & 0xFFF0;
	cyl <<= 12;
	cyl |= ptr->cc;
	head = ptr->hh & 0x000F;
	return	cyl * geo->heads * geo->sectors +
		head * geo->sectors +
		ptr->b;
}

/*
 */
int ibm_partition(struct parsed_partitions *state)
{
	struct block_device *bdev = state->bdev;
	int blocksize, res;
	loff_t i_size, offset, size, fmt_size;
	dasd_information2_t *info;
	struct hd_geometry *geo;
	char type[5] = {0,};
	char name[7] = {0,};
	union label_t {
		struct vtoc_volume_label_cdl vol;
		struct vtoc_volume_label_ldl lnx;
		struct vtoc_cms_label cms;
	} *label;
	unsigned char *data;
	Sector sect;
	sector_t labelsect;
	char tmp[64];

	res = 0;
	blocksize = bdev_logical_block_size(bdev);
	if (blocksize <= 0)
		goto out_exit;
	i_size = i_size_read(bdev->bd_inode);
	if (i_size == 0)
		goto out_exit;

	info = kmalloc(sizeof(dasd_information2_t), GFP_KERNEL);
	if (info == NULL)
		goto out_exit;
	geo = kmalloc(sizeof(struct hd_geometry), GFP_KERNEL);
	if (geo == NULL)
		goto out_nogeo;
	label = kmalloc(sizeof(union label_t), GFP_KERNEL);
	if (label == NULL)
		goto out_nolab;

	if (ioctl_by_bdev(bdev, BIODASDINFO2, (unsigned long)info) != 0 ||
	    ioctl_by_bdev(bdev, HDIO_GETGEO, (unsigned long)geo) != 0)
		goto out_freeall;

	/*
	 * Special case for FBA disks: label sector does not depend on
	 * blocksize.
	 */
	if ((info->cu_type == 0x6310 && info->dev_type == 0x9336) ||
	    (info->cu_type == 0x3880 && info->dev_type == 0x3370))
		labelsect = info->label_block;
	else
		labelsect = info->label_block * (blocksize >> 9);

	/*
	 * Get volume label, extract name and type.
	 */
	data = read_part_sector(state, labelsect, &sect);
	if (data == NULL)
		goto out_readerr;

	memcpy(label, data, sizeof(union label_t));
	put_dev_sector(sect);

	if ((!info->FBA_layout) && (!strcmp(info->type, "ECKD"))) {
		strncpy(type, label->vol.vollbl, 4);
		strncpy(name, label->vol.volid, 6);
	} else {
		strncpy(type, label->lnx.vollbl, 4);
		strncpy(name, label->lnx.volid, 6);
	}
	EBCASC(type, 4);
	EBCASC(name, 6);

	res = 1;

	/*
	 * Three different formats: LDL, CDL and unformated disk
	 *
	 * identified by info->format
	 *
	 * unformated disks we do not have to care about
	 */
	if (info->format == DASD_FORMAT_LDL) {
		if (strncmp(type, "CMS1", 4) == 0) {
			/*
			 * VM style CMS1 labeled disk
			 */
			blocksize = label->cms.block_size;
			if (label->cms.disk_offset != 0) {
				snprintf(tmp, sizeof(tmp), "CMS1/%8s(MDSK):", name);
				strlcat(state->pp_buf, tmp, PAGE_SIZE);
				/* disk is reserved minidisk */
				offset = label->cms.disk_offset;
				size = (label->cms.block_count - 1)
					* (blocksize >> 9);
			} else {
				snprintf(tmp, sizeof(tmp), "CMS1/%8s:", name);
				strlcat(state->pp_buf, tmp, PAGE_SIZE);
				offset = (info->label_block + 1);
				size = label->cms.block_count
					* (blocksize >> 9);
			}
			put_partition(state, 1, offset*(blocksize >> 9),
				      size-offset*(blocksize >> 9));
		} else {
			if (strncmp(type, "LNX1", 4) == 0) {
				snprintf(tmp, sizeof(tmp), "LNX1/%8s:", name);
				strlcat(state->pp_buf, tmp, PAGE_SIZE);
				if (label->lnx.ldl_version == 0xf2) {
					fmt_size = label->lnx.formatted_blocks
						* (blocksize >> 9);
				} else if (!strcmp(info->type, "ECKD")) {
					/* formated w/o large volume support */
					fmt_size = geo->cylinders * geo->heads
					      * geo->sectors * (blocksize >> 9);
				} else {
					/* old label and no usable disk geometry
					 * (e.g. DIAG) */
					fmt_size = i_size >> 9;
				}
				size = i_size >> 9;
				if (fmt_size < size)
					size = fmt_size;
				offset = (info->label_block + 1);
			} else {
				/* unlabeled disk */
				strlcat(state->pp_buf, "(nonl)", PAGE_SIZE);
				size = i_size >> 9;
				offset = (info->label_block + 1);
			}
			put_partition(state, 1, offset*(blocksize >> 9),
				      size-offset*(blocksize >> 9));
		}
	} else if (info->format == DASD_FORMAT_CDL) {
		/*
		 * New style CDL formatted disk
		 */
		sector_t blk;
		int counter;

		/*
		 * check if VOL1 label is available
		 * if not, something is wrong, skipping partition detection
		 */
		if (strncmp(type, "VOL1",  4) == 0) {
			snprintf(tmp, sizeof(tmp), "VOL1/%8s:", name);
			strlcat(state->pp_buf, tmp, PAGE_SIZE);
			/*
			 * get block number and read then go through format1
			 * labels
			 */
			blk = cchhb2blk(&label->vol.vtoc, geo) + 1;
			counter = 0;
			data = read_part_sector(state, blk * (blocksize/512),
						&sect);
			while (data != NULL) {
				struct vtoc_format1_label f1;

				memcpy(&f1, data,
				       sizeof(struct vtoc_format1_label));
				put_dev_sector(sect);

				/* skip FMT4 / FMT5 / FMT7 labels */
				if (f1.DS1FMTID == _ascebc['4']
				    || f1.DS1FMTID == _ascebc['5']
				    || f1.DS1FMTID == _ascebc['7']
				    || f1.DS1FMTID == _ascebc['9']) {
					blk++;
					data = read_part_sector(state,
						blk * (blocksize/512), &sect);
					continue;
				}

				/* only FMT1 and 8 labels valid at this point */
				if (f1.DS1FMTID != _ascebc['1'] &&
				    f1.DS1FMTID != _ascebc['8'])
					break;

				/* OK, we got valid partition data */
				offset = cchh2blk(&f1.DS1EXT1.llimit, geo);
				size  = cchh2blk(&f1.DS1EXT1.ulimit, geo) -
					offset + geo->sectors;
				if (counter >= state->limit)
					break;
				put_partition(state, counter + 1,
					      offset * (blocksize >> 9),
					      size * (blocksize >> 9));
				counter++;
				blk++;
				data = read_part_sector(state,
						blk * (blocksize/512), &sect);
			}

			if (!data)
				/* Are we not supposed to report this ? */
				goto out_readerr;
		} else
			printk(KERN_WARNING "Warning, expected Label VOL1 not "
			       "found, treating as CDL formated Disk");

	}

	strlcat(state->pp_buf, "\n", PAGE_SIZE);
	goto out_freeall;


out_readerr:
	res = -1;
out_freeall:
	kfree(label);
out_nolab:
	kfree(geo);
out_nogeo:
	kfree(info);
out_exit:
	return res;
}
/*
 *  Copyright (C) 1995  Linus Torvalds
 *  Copyright (C) 2001, 2002 Andi Kleen, SuSE Labs.
 *  Copyright (C) 2008-2009, Red Hat Inc., Ingo Molnar
 */
#include <linux/magic.h>		/* STACK_END_MAGIC		*/
#include <linux/sched.h>		/* test_thread_flag(), ...	*/
#include <linux/kdebug.h>		/* oops_begin/end, ...		*/
#include <linux/module.h>		/* search_exception_table	*/
#include <linux/bootmem.h>		/* max_low_pfn			*/
#include <linux/kprobes.h>		/* __kprobes, ...		*/
#include <linux/mmiotrace.h>		/* kmmio_handler, ...		*/
#include <linux/perf_event.h>		/* perf_sw_event		*/

#include <asm/traps.h>			/* dotraplinkage, ...		*/
#include <asm/pgalloc.h>		/* pgd_*(), ...			*/
#include <asm/kmemcheck.h>		/* kmemcheck_*(), ...		*/

/*
 * Page fault error code bits:
 *
 *   bit 0 ==	 0: no page found	1: protection fault
 *   bit 1 ==	 0: read access		1: write access
 *   bit 2 ==	 0: kernel-mode access	1: user-mode access
 *   bit 3 ==				1: use of reserved bit detected
 *   bit 4 ==				1: fault was an instruction fetch
 */
enum x86_pf_error_code {

	PF_PROT		=		1 << 0,
	PF_WRITE	=		1 << 1,
	PF_USER		=		1 << 2,
	PF_RSVD		=		1 << 3,
	PF_INSTR	=		1 << 4,
};

/*
 * Returns 0 if mmiotrace is disabled, or if the fault is not
 * handled by mmiotrace:
 */
static inline int __kprobes
kmmio_fault(struct pt_regs *regs, unsigned long addr)
{
	if (unlikely(is_kmmio_active()))
		if (kmmio_handler(regs, addr) == 1)
			return -1;
	return 0;
}

static inline int __kprobes notify_page_fault(struct pt_regs *regs)
{
	int ret = 0;

	/* kprobe_running() needs smp_processor_id() */
	if (kprobes_built_in() && !user_mode_vm(regs)) {
		preempt_disable();
		if (kprobe_running() && kprobe_fault_handler(regs, 14))
			ret = 1;
		preempt_enable();
	}

	return ret;
}

/*
 * Prefetch quirks:
 *
 * 32-bit mode:
 *
 *   Sometimes AMD Athlon/Opteron CPUs report invalid exceptions on prefetch.
 *   Check that here and ignore it.
 *
 * 64-bit mode:
 *
 *   Sometimes the CPU reports invalid exceptions on prefetch.
 *   Check that here and ignore it.
 *
 * Opcode checker based on code by Richard Brunner.
 */
static inline int
check_prefetch_opcode(struct pt_regs *regs, unsigned char *instr,
		      unsigned char opcode, int *prefetch)
{
	unsigned char instr_hi = opcode & 0xf0;
	unsigned char instr_lo = opcode & 0x0f;

	switch (instr_hi) {
	case 0x20:
	case 0x30:
		/*
		 * Values 0x26,0x2E,0x36,0x3E are valid x86 prefixes.
		 * In X86_64 long mode, the CPU will signal invalid
		 * opcode if some of these prefixes are present so
		 * X86_64 will never get here anyway
		 */
		return ((instr_lo & 7) == 0x6);
#ifdef CONFIG_X86_64
	case 0x40:
		/*
		 * In AMD64 long mode 0x40..0x4F are valid REX prefixes
		 * Need to figure out under what instruction mode the
		 * instruction was issued. Could check the LDT for lm,
		 * but for now it's good enough to assume that long
		 * mode only uses well known segments or kernel.
		 */
		return (!user_mode(regs)) || (regs->cs == __USER_CS);
#endif
	case 0x60:
		/* 0x64 thru 0x67 are valid prefixes in all modes. */
		return (instr_lo & 0xC) == 0x4;
	case 0xF0:
		/* 0xF0, 0xF2, 0xF3 are valid prefixes in all modes. */
		return !instr_lo || (instr_lo>>1) == 1;
	case 0x00:
		/* Prefetch instruction is 0x0F0D or 0x0F18 */
		if (probe_kernel_address(instr, opcode))
			return 0;

		*prefetch = (instr_lo == 0xF) &&
			(opcode == 0x0D || opcode == 0x18);
		return 0;
	default:
		return 0;
	}
}

static int
is_prefetch(struct pt_regs *regs, unsigned long error_code, unsigned long addr)
{
	unsigned char *max_instr;
	unsigned char *instr;
	int prefetch = 0;

	/*
	 * If it was a exec (instruction fetch) fault on NX page, then
	 * do not ignore the fault:
	 */
	if (error_code & PF_INSTR)
		return 0;

	instr = (void *)convert_ip_to_linear(current, regs);
	max_instr = instr + 15;

	if (user_mode(regs) && instr >= (unsigned char *)TASK_SIZE)
		return 0;

	while (instr < max_instr) {
		unsigned char opcode;

		if (probe_kernel_address(instr, opcode))
			break;

		instr++;

		if (!check_prefetch_opcode(regs, instr, opcode, &prefetch))
			break;
	}
	return prefetch;
}

static void
force_sig_info_fault(int si_signo, int si_code, unsigned long address,
		     struct task_struct *tsk)
{
	siginfo_t info;

	info.si_signo	= si_signo;
	info.si_errno	= 0;
	info.si_code	= si_code;
	info.si_addr	= (void __user *)address;
	info.si_addr_lsb = si_code == BUS_MCEERR_AR ? PAGE_SHIFT : 0;

	force_sig_info(si_signo, &info, tsk);
}

DEFINE_SPINLOCK(pgd_lock);
LIST_HEAD(pgd_list);

#ifdef CONFIG_X86_32
static inline pmd_t *vmalloc_sync_one(pgd_t *pgd, unsigned long address)
{
	unsigned index = pgd_index(address);
	pgd_t *pgd_k;
	pud_t *pud, *pud_k;
	pmd_t *pmd, *pmd_k;

	pgd += index;
	pgd_k = init_mm.pgd + index;

	if (!pgd_present(*pgd_k))
		return NULL;

	/*
	 * set_pgd(pgd, *pgd_k); here would be useless on PAE
	 * and redundant with the set_pmd() on non-PAE. As would
	 * set_pud.
	 */
	pud = pud_offset(pgd, address);
	pud_k = pud_offset(pgd_k, address);
	if (!pud_present(*pud_k))
		return NULL;

	pmd = pmd_offset(pud, address);
	pmd_k = pmd_offset(pud_k, address);
	if (!pmd_present(*pmd_k))
		return NULL;

	if (!pmd_present(*pmd))
		set_pmd(pmd, *pmd_k);
	else
		BUG_ON(pmd_page(*pmd) != pmd_page(*pmd_k));

	return pmd_k;
}

void vmalloc_sync_all(void)
{
	unsigned long address;

	if (SHARED_KERNEL_PMD)
		return;

	for (address = VMALLOC_START & PMD_MASK;
	     address >= TASK_SIZE && address < FIXADDR_TOP;
	     address += PMD_SIZE) {

		unsigned long flags;
		struct page *page;

		spin_lock_irqsave(&pgd_lock, flags);
		list_for_each_entry(page, &pgd_list, lru) {
			if (!vmalloc_sync_one(page_address(page), address))
				break;
		}
		spin_unlock_irqrestore(&pgd_lock, flags);
	}
}

/*
 * 32-bit:
 *
 *   Handle a fault on the vmalloc or module mapping area
 */
static noinline __kprobes int vmalloc_fault(unsigned long address)
{
	unsigned long pgd_paddr;
	pmd_t *pmd_k;
	pte_t *pte_k;

	/* Make sure we are in vmalloc area: */
	if (!(address >= VMALLOC_START && address < VMALLOC_END))
		return -1;

	/*
	 * Synchronize this task's top level page-table
	 * with the 'reference' page table.
	 *
	 * Do _not_ use "current" here. We might be inside
	 * an interrupt in the middle of a task switch..
	 */
	pgd_paddr = read_cr3();
	pmd_k = vmalloc_sync_one(__va(pgd_paddr), address);
	if (!pmd_k)
		return -1;

	pte_k = pte_offset_kernel(pmd_k, address);
	if (!pte_present(*pte_k))
		return -1;

	return 0;
}

/*
 * Did it hit the DOS screen memory VA from vm86 mode?
 */
static inline void
check_v8086_mode(struct pt_regs *regs, unsigned long address,
		 struct task_struct *tsk)
{
	unsigned long bit;

	if (!v8086_mode(regs))
		return;

	bit = (address - 0xA0000) >> PAGE_SHIFT;
	if (bit < 32)
		tsk->thread.screen_bitmap |= 1 << bit;
}

static bool low_pfn(unsigned long pfn)
{
	return pfn < max_low_pfn;
}

static void dump_pagetable(unsigned long address)
{
	pgd_t *base = __va(read_cr3());
	pgd_t *pgd = &base[pgd_index(address)];
	pmd_t *pmd;
	pte_t *pte;

#ifdef CONFIG_X86_PAE
	printk("*pdpt = %016Lx ", pgd_val(*pgd));
	if (!low_pfn(pgd_val(*pgd) >> PAGE_SHIFT) || !pgd_present(*pgd))
		goto out;
#endif
	pmd = pmd_offset(pud_offset(pgd, address), address);
	printk(KERN_CONT "*pde = %0*Lx ", sizeof(*pmd) * 2, (u64)pmd_val(*pmd));

	/*
	 * We must not directly access the pte in the highpte
	 * case if the page table is located in highmem.
	 * And let's rather not kmap-atomic the pte, just in case
	 * it's allocated already:
	 */
	if (!low_pfn(pmd_pfn(*pmd)) || !pmd_present(*pmd) || pmd_large(*pmd))
		goto out;

	pte = pte_offset_kernel(pmd, address);
	printk("*pte = %0*Lx ", sizeof(*pte) * 2, (u64)pte_val(*pte));
out:
	printk("\n");
}

#else /* CONFIG_X86_64: */

void vmalloc_sync_all(void)
{
	unsigned long address;

	for (address = VMALLOC_START & PGDIR_MASK; address <= VMALLOC_END;
	     address += PGDIR_SIZE) {

		const pgd_t *pgd_ref = pgd_offset_k(address);
		unsigned long flags;
		struct page *page;

		if (pgd_none(*pgd_ref))
			continue;

		spin_lock_irqsave(&pgd_lock, flags);
		list_for_each_entry(page, &pgd_list, lru) {
			pgd_t *pgd;
			pgd = (pgd_t *)page_address(page) + pgd_index(address);
			if (pgd_none(*pgd))
				set_pgd(pgd, *pgd_ref);
			else
				BUG_ON(pgd_page_vaddr(*pgd) != pgd_page_vaddr(*pgd_ref));
		}
		spin_unlock_irqrestore(&pgd_lock, flags);
	}
}

/*
 * 64-bit:
 *
 *   Handle a fault on the vmalloc area
 *
 * This assumes no large pages in there.
 */
static noinline __kprobes int vmalloc_fault(unsigned long address)
{
	pgd_t *pgd, *pgd_ref;
	pud_t *pud, *pud_ref;
	pmd_t *pmd, *pmd_ref;
	pte_t *pte, *pte_ref;

	/* Make sure we are in vmalloc area: */
	if (!(address >= VMALLOC_START && address < VMALLOC_END))
		return -1;

	/*
	 * Copy kernel mappings over when needed. This can also
	 * happen within a race in page table update. In the later
	 * case just flush:
	 */
	pgd = pgd_offset(current->active_mm, address);
	pgd_ref = pgd_offset_k(address);
	if (pgd_none(*pgd_ref))
		return -1;

	if (pgd_none(*pgd))
		set_pgd(pgd, *pgd_ref);
	else
		BUG_ON(pgd_page_vaddr(*pgd) != pgd_page_vaddr(*pgd_ref));

	/*
	 * Below here mismatches are bugs because these lower tables
	 * are shared:
	 */

	pud = pud_offset(pgd, address);
	pud_ref = pud_offset(pgd_ref, address);
	if (pud_none(*pud_ref))
		return -1;

	if (pud_none(*pud) || pud_page_vaddr(*pud) != pud_page_vaddr(*pud_ref))
		BUG();

	pmd = pmd_offset(pud, address);
	pmd_ref = pmd_offset(pud_ref, address);
	if (pmd_none(*pmd_ref))
		return -1;

	if (pmd_none(*pmd) || pmd_page(*pmd) != pmd_page(*pmd_ref))
		BUG();

	pte_ref = pte_offset_kernel(pmd_ref, address);
	if (!pte_present(*pte_ref))
		return -1;

	pte = pte_offset_kernel(pmd, address);

	/*
	 * Don't use pte_page here, because the mappings can point
	 * outside mem_map, and the NUMA hash lookup cannot handle
	 * that:
	 */
	if (!pte_present(*pte) || pte_pfn(*pte) != pte_pfn(*pte_ref))
		BUG();

	return 0;
}

static const char errata93_warning[] =
KERN_ERR 
"******* Your BIOS seems to not contain a fix for K8 errata #93\n"
"******* Working around it, but it may cause SEGVs or burn power.\n"
"******* Please consider a BIOS update.\n"
"******* Disabling USB legacy in the BIOS may also help.\n";

/*
 * No vm86 mode in 64-bit mode:
 */
static inline void
check_v8086_mode(struct pt_regs *regs, unsigned long address,
		 struct task_struct *tsk)
{
}

static int bad_address(void *p)
{
	unsigned long dummy;

	return probe_kernel_address((unsigned long *)p, dummy);
}

static void dump_pagetable(unsigned long address)
{
	pgd_t *base = __va(read_cr3() & PHYSICAL_PAGE_MASK);
	pgd_t *pgd = base + pgd_index(address);
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;

	if (bad_address(pgd))
		goto bad;

	printk("PGD %lx ", pgd_val(*pgd));

	if (!pgd_present(*pgd))
		goto out;

	pud = pud_offset(pgd, address);
	if (bad_address(pud))
		goto bad;

	printk("PUD %lx ", pud_val(*pud));
	if (!pud_present(*pud) || pud_large(*pud))
		goto out;

	pmd = pmd_offset(pud, address);
	if (bad_address(pmd))
		goto bad;

	printk("PMD %lx ", pmd_val(*pmd));
	if (!pmd_present(*pmd) || pmd_large(*pmd))
		goto out;

	pte = pte_offset_kernel(pmd, address);
	if (bad_address(pte))
		goto bad;

	printk("PTE %lx", pte_val(*pte));
out:
	printk("\n");
	return;
bad:
	printk("BAD\n");
}

#endif /* CONFIG_X86_64 */

/*
 * Workaround for K8 erratum #93 & buggy BIOS.
 *
 * BIOS SMM functions are required to use a specific workaround
 * to avoid corruption of the 64bit RIP register on C stepping K8.
 *
 * A lot of BIOS that didn't get tested properly miss this.
 *
 * The OS sees this as a page fault with the upper 32bits of RIP cleared.
 * Try to work around it here.
 *
 * Note we only handle faults in kernel here.
 * Does nothing on 32-bit.
 */
static int is_errata93(struct pt_regs *regs, unsigned long address)
{
#ifdef CONFIG_X86_64
	if (address != regs->ip)
		return 0;

	if ((address >> 32) != 0)
		return 0;

	address |= 0xffffffffUL << 32;
	if ((address >= (u64)_stext && address <= (u64)_etext) ||
	    (address >= MODULES_VADDR && address <= MODULES_END)) {
		printk_once(errata93_warning);
		regs->ip = address;
		return 1;
	}
#endif
	return 0;
}

/*
 * Work around K8 erratum #100 K8 in compat mode occasionally jumps
 * to illegal addresses >4GB.
 *
 * We catch this in the page fault handler because these addresses
 * are not reachable. Just detect this case and return.  Any code
 * segment in LDT is compatibility mode.
 */
static int is_errata100(struct pt_regs *regs, unsigned long address)
{
#ifdef CONFIG_X86_64
	if ((regs->cs == __USER32_CS || (regs->cs & (1<<2))) && (address >> 32))
		return 1;
#endif
	return 0;
}

static int is_f00f_bug(struct pt_regs *regs, unsigned long address)
{
#ifdef CONFIG_X86_F00F_BUG
	unsigned long nr;

	/*
	 * Pentium F0 0F C7 C8 bug workaround:
	 */
	if (boot_cpu_data.f00f_bug) {
		nr = (address - idt_descr.address) >> 3;

		if (nr == 6) {
			do_invalid_op(regs, 0);
			return 1;
		}
	}
#endif
	return 0;
}

static const char nx_warning[] = KERN_CRIT
"kernel tried to execute NX-protected page - exploit attempt? (uid: %d)\n";

static void
show_fault_oops(struct pt_regs *regs, unsigned long error_code,
		unsigned long address)
{
	if (!oops_may_print())
		return;

	if (error_code & PF_INSTR) {
		unsigned int level;

		pte_t *pte = lookup_address(address, &level);

		if (pte && pte_present(*pte) && !pte_exec(*pte))
			printk(nx_warning, current_uid());
	}

	printk(KERN_ALERT "BUG: unable to handle kernel ");
	if (address < PAGE_SIZE)
		printk(KERN_CONT "NULL pointer dereference");
	else
		printk(KERN_CONT "paging request");

	printk(KERN_CONT " at %p\n", (void *) address);
	printk(KERN_ALERT "IP:");
	printk_address(regs->ip, 1);

	dump_pagetable(address);
}

static noinline void
pgtable_bad(struct pt_regs *regs, unsigned long error_code,
	    unsigned long address)
{
	struct task_struct *tsk;
	unsigned long flags;
	int sig;

	flags = oops_begin();
	tsk = current;
	sig = SIGKILL;

	printk(KERN_ALERT "%s: Corrupted page table at address %lx\n",
	       tsk->comm, address);
	dump_pagetable(address);

	tsk->thread.cr2		= address;
	tsk->thread.trap_no	= 14;
	tsk->thread.error_code	= error_code;

	if (__die("Bad pagetable", regs, error_code))
		sig = 0;

	oops_end(flags, regs, sig);
}

static noinline void
no_context(struct pt_regs *regs, unsigned long error_code,
	   unsigned long address)
{
	struct task_struct *tsk = current;
	unsigned long *stackend;
	unsigned long flags;
	int sig;

	/* Are we prepared to handle this kernel fault? */
	if (fixup_exception(regs))
		return;

	/*
	 * 32-bit:
	 *
	 *   Valid to do another page fault here, because if this fault
	 *   had been triggered by is_prefetch fixup_exception would have
	 *   handled it.
	 *
	 * 64-bit:
	 *
	 *   Hall of shame of CPU/BIOS bugs.
	 */
	if (is_prefetch(regs, error_code, address))
		return;

	if (is_errata93(regs, address))
		return;

	/*
	 * Oops. The kernel tried to access some bad page. We'll have to
	 * terminate things with extreme prejudice:
	 */
	flags = oops_begin();

	show_fault_oops(regs, error_code, address);

	stackend = end_of_stack(tsk);
	if (tsk != &init_task && *stackend != STACK_END_MAGIC)
		printk(KERN_ALERT "Thread overran stack, or stack corrupted\n");

	tsk->thread.cr2		= address;
	tsk->thread.trap_no	= 14;
	tsk->thread.error_code	= error_code;

	sig = SIGKILL;
	if (__die("Oops", regs, error_code))
		sig = 0;

	/* Executive summary in case the body of the oops scrolled away */
	printk(KERN_EMERG "CR2: %016lx\n", address);

	oops_end(flags, regs, sig);
}

/*
 * Print out info about fatal segfaults, if the show_unhandled_signals
 * sysctl is set:
 */
static inline void
show_signal_msg(struct pt_regs *regs, unsigned long error_code,
		unsigned long address, struct task_struct *tsk)
{
	if (!unhandled_signal(tsk, SIGSEGV))
		return;

	if (!printk_ratelimit())
		return;

	printk("%s%s[%d]: segfault at %lx ip %p sp %p error %lx",
		task_pid_nr(tsk) > 1 ? KERN_INFO : KERN_EMERG,
		tsk->comm, task_pid_nr(tsk), address,
		(void *)regs->ip, (void *)regs->sp, error_code);

	print_vma_addr(KERN_CONT " in ", regs->ip);

	printk(KERN_CONT "\n");
}

static void
__bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
		       unsigned long address, int si_code)
{
	struct task_struct *tsk = current;

	/* User mode accesses just cause a SIGSEGV */
	if (error_code & PF_USER) {
		/*
		 * It's possible to have interrupts off here:
		 */
		local_irq_enable();

		/*
		 * Valid to do another page fault here because this one came
		 * from user space:
		 */
		if (is_prefetch(regs, error_code, address))
			return;

		if (is_errata100(regs, address))
			return;

		if (unlikely(show_unhandled_signals))
			show_signal_msg(regs, error_code, address, tsk);

		/* Kernel addresses are always protection faults: */
		tsk->thread.cr2		= address;
		tsk->thread.error_code	= error_code | (address >= TASK_SIZE);
		tsk->thread.trap_no	= 14;

		force_sig_info_fault(SIGSEGV, si_code, address, tsk);

		return;
	}

	if (is_f00f_bug(regs, address))
		return;

	no_context(regs, error_code, address);
}

static noinline void
bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
		     unsigned long address)
{
	__bad_area_nosemaphore(regs, error_code, address, SEGV_MAPERR);
}

static void
__bad_area(struct pt_regs *regs, unsigned long error_code,
	   unsigned long address, int si_code)
{
	struct mm_struct *mm = current->mm;

	/*
	 * Something tried to access memory that isn't in our memory map..
	 * Fix it, but check if it's kernel or user first..
	 */
	up_read(&mm->mmap_sem);

	__bad_area_nosemaphore(regs, error_code, address, si_code);
}

static noinline void
bad_area(struct pt_regs *regs, unsigned long error_code, unsigned long address)
{
	__bad_area(regs, error_code, address, SEGV_MAPERR);
}

static noinline void
bad_area_access_error(struct pt_regs *regs, unsigned long error_code,
		      unsigned long address)
{
	__bad_area(regs, error_code, address, SEGV_ACCERR);
}

/* TODO: fixup for "mm-invoke-oom-killer-from-page-fault.patch" */
static void
out_of_memory(struct pt_regs *regs, unsigned long error_code,
	      unsigned long address)
{
	/*
	 * We ran out of memory, call the OOM killer, and return the userspace
	 * (which will retry the fault, or kill us if we got oom-killed):
	 */
	up_read(&current->mm->mmap_sem);

	pagefault_out_of_memory();
}

static void
do_sigbus(struct pt_regs *regs, unsigned long error_code, unsigned long address,
	  unsigned int fault)
{
	struct task_struct *tsk = current;
	struct mm_struct *mm = tsk->mm;
	int code = BUS_ADRERR;

	up_read(&mm->mmap_sem);

	/* Kernel mode? Handle exceptions or die: */
	if (!(error_code & PF_USER)) {
		no_context(regs, error_code, address);
		return;
	}

	/* User-space => ok to do another page fault: */
	if (is_prefetch(regs, error_code, address))
		return;

	tsk->thread.cr2		= address;
	tsk->thread.error_code	= error_code;
	tsk->thread.trap_no	= 14;

#ifdef CONFIG_MEMORY_FAILURE
	if (fault & VM_FAULT_HWPOISON) {
		printk(KERN_ERR
	"MCE: Killing %s:%d due to hardware memory corruption fault at %lx\n",
			tsk->comm, tsk->pid, address);
		code = BUS_MCEERR_AR;
	}
#endif
	force_sig_info_fault(SIGBUS, code, address, tsk);
}

static noinline void
mm_fault_error(struct pt_regs *regs, unsigned long error_code,
	       unsigned long address, unsigned int fault)
{
	if (fault & VM_FAULT_OOM) {
		out_of_memory(regs, error_code, address);
	} else {
		if (fault & (VM_FAULT_SIGBUS|VM_FAULT_HWPOISON))
			do_sigbus(regs, error_code, address, fault);
		else
			BUG();
	}
}

static int spurious_fault_check(unsigned long error_code, pte_t *pte)
{
	if ((error_code & PF_WRITE) && !pte_write(*pte))
		return 0;

	if ((error_code & PF_INSTR) && !pte_exec(*pte))
		return 0;

	return 1;
}

/*
 * Handle a spurious fault caused by a stale TLB entry.
 *
 * This allows us to lazily refresh the TLB when increasing the
 * permissions of a kernel page (RO -> RW or NX -> X).  Doing it
 * eagerly is very expensive since that implies doing a full
 * cross-processor TLB flush, even if no stale TLB entries exist
 * on other processors.
 *
 * There are no security implications to leaving a stale TLB when
 * increasing the permissions on a page.
 */
static noinline __kprobes int
spurious_fault(unsigned long error_code, unsigned long address)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
	int ret;

	/* Reserved-bit violation or user access to kernel space? */
	if (error_code & (PF_USER | PF_RSVD))
		return 0;

	pgd = init_mm.pgd + pgd_index(address);
	if (!pgd_present(*pgd))
		return 0;

	pud = pud_offset(pgd, address);
	if (!pud_present(*pud))
		return 0;

	if (pud_large(*pud))
		return spurious_fault_check(error_code, (pte_t *) pud);

	pmd = pmd_offset(pud, address);
	if (!pmd_present(*pmd))
		return 0;

	if (pmd_large(*pmd))
		return spurious_fault_check(error_code, (pte_t *) pmd);

	pte = pte_offset_kernel(pmd, address);
	if (!pte_present(*pte))
		return 0;

	ret = spurious_fault_check(error_code, pte);
	if (!ret)
		return 0;

	/*
	 * Make sure we have permissions in PMD.
	 * If not, then there's a bug in the page tables:
	 */
	ret = spurious_fault_check(error_code, (pte_t *) pmd);
	WARN_ONCE(!ret, "PMD has incorrect permission bits\n");

	return ret;
}

int show_unhandled_signals = 1;

static inline int
access_error(unsigned long error_code, int write, struct vm_area_struct *vma)
{
	if (write) {
		/* write, present and write, not present: */
		if (unlikely(!(vma->vm_flags & VM_WRITE)))
			return 1;
		return 0;
	}

	/* read, present: */
	if (unlikely(error_code & PF_PROT))
		return 1;

	/* read, not present: */
	if (unlikely(!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))))
		return 1;

	return 0;
}

static int fault_in_kernel_space(unsigned long address)
{
	return address >= TASK_SIZE_MAX;
}

/*
 * This routine handles page faults.  It determines the address,
 * and the problem, and then passes it off to one of the appropriate
 * routines.
 */
dotraplinkage void __kprobes
do_page_fault(struct pt_regs *regs, unsigned long error_code)
{
	struct vm_area_struct *vma;
	struct task_struct *tsk;
	unsigned long address;
	struct mm_struct *mm;
	int write;
	int fault;

	tsk = current;
	mm = tsk->mm;

	/* Get the faulting address: */
	address = read_cr2();

	/*
	 * Detect and handle instructions that would cause a page fault for
	 * both a tracked kernel page and a userspace page.
	 */
	if (kmemcheck_active(regs))
		kmemcheck_hide(regs);
	prefetchw(&mm->mmap_sem);

	if (unlikely(kmmio_fault(regs, address)))
		return;

	/*
	 * We fault-in kernel-space virtual memory on-demand. The
	 * 'reference' page table is init_mm.pgd.
	 *
	 * NOTE! We MUST NOT take any locks for this case. We may
	 * be in an interrupt or a critical region, and should
	 * only copy the information from the master page table,
	 * nothing more.
	 *
	 * This verifies that the fault happens in kernel space
	 * (error_code & 4) == 0, and that the fault was not a
	 * protection error (error_code & 9) == 0.
	 */
	if (unlikely(fault_in_kernel_space(address))) {
		if (!(error_code & (PF_RSVD | PF_USER | PF_PROT))) {
			if (vmalloc_fault(address) >= 0)
				return;

			if (kmemcheck_fault(regs, address, error_code))
				return;
		}

		/* Can handle a stale RO->RW TLB: */
		if (spurious_fault(error_code, address))
			return;

		/* kprobes don't want to hook the spurious faults: */
		if (notify_page_fault(regs))
			return;
		/*
		 * Don't take the mm semaphore here. If we fixup a prefetch
		 * fault we could otherwise deadlock:
		 */
		bad_area_nosemaphore(regs, error_code, address);

		return;
	}

	/* kprobes don't want to hook the spurious faults: */
	if (unlikely(notify_page_fault(regs)))
		return;
	/*
	 * It's safe to allow irq's after cr2 has been saved and the
	 * vmalloc fault has been handled.
	 *
	 * User-mode registers count as a user access even for any
	 * potential system fault or CPU buglet:
	 */
	if (user_mode_vm(regs)) {
		local_irq_enable();
		error_code |= PF_USER;
	} else {
		if (regs->flags & X86_EFLAGS_IF)
			local_irq_enable();
	}

	if (unlikely(error_code & PF_RSVD))
		pgtable_bad(regs, error_code, address);

	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);

	/*
	 * If we're in an interrupt, have no user context or are running
	 * in an atomic region then we must not take the fault:
	 */
	if (unlikely(in_atomic() || !mm)) {
		bad_area_nosemaphore(regs, error_code, address);
		return;
	}

	/*
	 * When running in the kernel we expect faults to occur only to
	 * addresses in user space.  All other faults represent errors in
	 * the kernel and should generate an OOPS.  Unfortunately, in the
	 * case of an erroneous fault occurring in a code path which already
	 * holds mmap_sem we will deadlock attempting to validate the fault
	 * against the address space.  Luckily the kernel only validly
	 * references user space from well defined areas of code, which are
	 * listed in the exceptions table.
	 *
	 * As the vast majority of faults will be valid we will only perform
	 * the source reference check when there is a possibility of a
	 * deadlock. Attempt to lock the address space, if we cannot we then
	 * validate the source. If this is invalid we can skip the address
	 * space check, thus avoiding the deadlock:
	 */
	if (unlikely(!down_read_trylock(&mm->mmap_sem))) {
		if ((error_code & PF_USER) == 0 &&
		    !search_exception_tables(regs->ip)) {
			bad_area_nosemaphore(regs, error_code, address);
			return;
		}
		down_read(&mm->mmap_sem);
	} else {
		/*
		 * The above down_read_trylock() might have succeeded in
		 * which case we'll have missed the might_sleep() from
		 * down_read():
		 */
		might_sleep();
	}

	vma = find_vma(mm, address);
	if (unlikely(!vma)) {
		bad_area(regs, error_code, address);
		return;
	}
	if (likely(vma->vm_start <= address))
		goto good_area;
	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
		bad_area(regs, error_code, address);
		return;
	}
	if (error_code & PF_USER) {
		/*
		 * Accessing the stack below %sp is always a bug.
		 * The large cushion allows instructions like enter
		 * and pusha to work. ("enter $65535, $31" pushes
		 * 32 pointers and then decrements %sp by 65535.)
		 */
		if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
			bad_area(regs, error_code, address);
			return;
		}
	}
	if (unlikely(expand_stack(vma, address))) {
		bad_area(regs, error_code, address);
		return;
	}

	/*
	 * Ok, we have a good vm_area for this memory access, so
	 * we can handle it..
	 */
good_area:
	write = error_code & PF_WRITE;

	if (unlikely(access_error(error_code, write, vma))) {
		bad_area_access_error(regs, error_code, address);
		return;
	}

	/*
	 * If for any reason at all we couldn't handle the fault,
	 * make sure we exit gracefully rather than endlessly redo
	 * the fault:
	 */
	fault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);

	if (unlikely(fault & VM_FAULT_ERROR)) {
		mm_fault_error(regs, error_code, address, fault);
		return;
	}

	if (fault & VM_FAULT_MAJOR) {
		tsk->maj_flt++;
		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,
				     regs, address);
	} else {
		tsk->min_flt++;
		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,
				     regs, address);
	}

	check_v8086_mode(regs, address, tsk);

	up_read(&mm->mmap_sem);
}
cmd_drivers/ata/sata_svw.o := gcc -Wp,-MD,drivers/ata/.sata_svw.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(sata_svw)"  -D"KBUILD_MODNAME=KBUILD_STR(sata_svw)"  -c -o drivers/ata/.tmp_sata_svw.o drivers/ata/sata_svw.c

deps_drivers/ata/sata_svw.o := \
  drivers/ata/sata_svw.c \
    $(wildcard include/config/ppc/of.h) \
  include/linux/kernel.h \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/linkage.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/32.h) \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  include/linux/stddef.h \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/paravirt.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/pci.h \
    $(wildcard include/config/pci/iov.h) \
    $(wildcard include/config/pcieaspm.h) \
    $(wildcard include/config/pci/msi.h) \
    $(wildcard include/config/pci.h) \
    $(wildcard include/config/pcie/ecrc.h) \
    $(wildcard include/config/ht/irq.h) \
    $(wildcard include/config/pci/domains.h) \
    $(wildcard include/config/pci/quirks.h) \
    $(wildcard include/config/hotplug/pci.h) \
  include/linux/pci_regs.h \
  include/linux/mod_devicetable.h \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/io.h \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/has/ioport.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  include/linux/irqreturn.h \
  include/linux/pci_ids.h \
  include/linux/pci-dma.h \
  include/linux/dmapool.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/scatterlist.h \
  include/asm-generic/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
    $(wildcard include/config/need/sg/dma/length.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci.h \
  include/linux/mm.h \
    $(wildcard include/config/sysctl.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/rbtree.h \
  include/linux/prio_tree.h \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mm/owner.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/s390.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci_64.h \
    $(wildcard include/config/calgary/iommu.h) \
  include/asm-generic/pci-dma-compat.h \
  include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  include/linux/dma-attrs.h \
  include/linux/bug.h \
  include/linux/scatterlist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/dma-mapping.h \
    $(wildcard include/config/isa.h) \
  include/linux/kmemcheck.h \
  include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swiotlb.h \
    $(wildcard include/config/swiotlb.h) \
  include/linux/swiotlb.h \
  include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  include/asm-generic/dma-mapping-common.h \
  include/asm-generic/pci.h \
  include/linux/blkdev.h \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/blk/cgroup.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/blk/dev/bsg.h) \
    $(wildcard include/config/bounce.h) \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/virt/cpu/accounting.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/cgroup/sched.h) \
  include/linux/capability.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/major.h \
  include/linux/genhd.h \
    $(wildcard include/config/fail/make/request.h) \
    $(wildcard include/config/solaris/x86/partition.h) \
    $(wildcard include/config/bsd/disklabel.h) \
    $(wildcard include/config/unixware/disklabel.h) \
    $(wildcard include/config/minix/subpartition.h) \
  include/linux/kdev_t.h \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
  include/linux/dcache.h \
  include/linux/radix-tree.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/pagemap.h \
  include/linux/highmem.h \
    $(wildcard include/config/debug/highmem.h) \
  include/linux/uaccess.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cacheflush.h \
    $(wildcard include/config/x86/pat.h) \
    $(wildcard include/config/debug/rodata.h) \
    $(wildcard include/config/debug/rodata/test.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/kmap_types.h \
  include/asm-generic/kmap_types.h \
  include/linux/hardirq.h \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  include/linux/irqnr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
  include/asm-generic/sections.h \
  include/linux/hugetlb_inline.h \
  include/linux/backing-dev.h \
    $(wildcard include/config/debug/fs.h) \
  include/linux/writeback.h \
  include/linux/mempool.h \
  include/linux/bio.h \
  include/linux/ioprio.h \
  include/linux/iocontext.h \
  include/linux/bsg.h \
  include/linux/elevator.h \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/scsi/scsi_host.h \
  include/scsi/scsi.h \
  include/scsi/scsi_cmnd.h \
  include/linux/libata.h \
    $(wildcard include/config/ata/nonstandard.h) \
    $(wildcard include/config/ata/sff.h) \
    $(wildcard include/config/ata/bmdma.h) \
    $(wildcard include/config/ata/acpi.h) \
    $(wildcard include/config/sata/pmp.h) \
  include/linux/ata.h \
    $(wildcard include/config/stream.h) \
  include/linux/acpi.h \
    $(wildcard include/config/acpi/hotplug/cpu.h) \
    $(wildcard include/config/acpi/wmi.h) \
    $(wildcard include/config/acpi/video.h) \
    $(wildcard include/config/support.h) \
  include/acpi/acpi.h \
  include/acpi/platform/acenv.h \
  include/acpi/platform/aclinux.h \
  include/linux/ctype.h \
  include/acpi/platform/acgcc.h \
  include/acpi/actypes.h \
  include/acpi/acnames.h \
  include/acpi/actypes.h \
  include/acpi/acexcep.h \
  include/acpi/actbl.h \
  include/acpi/actbl1.h \
  include/acpi/actbl2.h \
  include/acpi/acoutput.h \
  include/acpi/acrestyp.h \
  include/acpi/acpiosxf.h \
  include/acpi/acpixf.h \
  include/acpi/acpi_bus.h \
    $(wildcard include/config/acpi/proc/event.h) \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
  include/linux/magic.h \
  include/acpi/acpi_drivers.h \
    $(wildcard include/config/acpi/dock.h) \
  include/acpi/acpi_numa.h \
  include/linux/cdrom.h \
  include/asm-generic/libata-portmap.h \

drivers/ata/sata_svw.o: $(deps_drivers/ata/sata_svw.o)

$(deps_drivers/ata/sata_svw.o):
cmd_drivers/net/phy/cicada.o := gcc -Wp,-MD,drivers/net/phy/.cicada.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(cicada)"  -D"KBUILD_MODNAME=KBUILD_STR(cicada)"  -c -o drivers/net/phy/.tmp_cicada.o drivers/net/phy/cicada.c

deps_drivers/net/phy/cicada.o := \
  drivers/net/phy/cicada.c \
  include/linux/kernel.h \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/linkage.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/32.h) \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  include/linux/stddef.h \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/paravirt.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
    $(wildcard include/config/kmemcheck.h) \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/generic/irq/probe.h) \
    $(wildcard include/config/proc/fs.h) \
  include/linux/preempt.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/preempt.h) \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/compat/vdso.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  include/linux/irqreturn.h \
  include/linux/irqnr.h \
  include/linux/hardirq.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
    $(wildcard include/config/no/hz.h) \
    $(wildcard include/config/tiny/rcu.h) \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/prove/rcu.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/debug/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  include/linux/capability.h \
  include/linux/timex.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lock/stat.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/jiffies.h \
  include/linux/rbtree.h \
  include/linux/nodemask.h \
    $(wildcard include/config/highmem.h) \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  include/linux/prio_tree.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/completion.h \
  include/linux/wait.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  include/linux/mutex.h \
  include/linux/mutex-debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/kobject.h \
  include/linux/sysfs.h \
    $(wildcard include/config/sysfs.h) \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/s390.h) \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  include/linux/gfp.h \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
    $(wildcard include/config/4kstacks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/tr.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/net/dsa/tag/dsa.h) \
    $(wildcard include/config/net/dsa/tag/trailer.h) \
    $(wildcard include/config/netpoll/trap.h) \
  include/linux/if.h \
  include/linux/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/socket.h \
  include/asm-generic/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sockios.h \
  include/asm-generic/sockios.h \
  include/linux/sockios.h \
  include/linux/hdlc/ioctl.h \
  include/linux/if_ether.h \
  include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/dma.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
  include/linux/kmemcheck.h \
  include/linux/net.h \
  include/linux/random.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/ratelimit.h \
  include/linux/textsearch.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/kmod.h \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/net/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum_64.h \
  include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/disable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  include/linux/dma-attrs.h \
  include/linux/bug.h \
  include/linux/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/scatterlist.h \
  include/asm-generic/scatterlist.h \
    $(wildcard include/config/need/sg/dma/length.h) \
  include/linux/mm.h \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/dma-mapping.h \
    $(wildcard include/config/isa.h) \
  include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swiotlb.h \
    $(wildcard include/config/swiotlb.h) \
  include/linux/swiotlb.h \
  include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  include/asm-generic/dma-mapping-common.h \
  include/linux/if_packet.h \
  include/linux/if_link.h \
  include/linux/netlink.h \
  include/linux/pm_qos_params.h \
  include/linux/miscdevice.h \
  include/linux/major.h \
  include/linux/ethtool.h \
  include/net/net_namespace.h \
    $(wildcard include/config/ipv6.h) \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/wext/core.h) \
    $(wildcard include/config/net.h) \
  include/net/netns/core.h \
  include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  include/net/snmp.h \
  include/linux/snmp.h \
  include/linux/u64_stats_sync.h \
  include/net/netns/unix.h \
  include/net/netns/packet.h \
  include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  include/net/inet_frag.h \
  include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  include/net/dst_ops.h \
  include/net/netns/dccp.h \
  include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  include/linux/netfilter.h \
    $(wildcard include/config/netfilter/debug.h) \
    $(wildcard include/config/nf/nat/needed.h) \
  include/linux/in.h \
  include/linux/in6.h \
  include/net/flow.h \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/radix-tree.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/magic.h \
  include/net/netns/conntrack.h \
  include/linux/list_nulls.h \
  include/net/netns/xfrm.h \
  include/linux/xfrm.h \
  include/linux/seq_file_net.h \
  include/linux/seq_file.h \
  include/net/dsa.h \
  include/linux/etherdevice.h \
    $(wildcard include/config/have/efficient/unaligned/access.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unaligned.h \
  include/linux/unaligned/access_ok.h \
  include/linux/unaligned/generic.h \
  include/linux/mii.h \
  include/linux/phy.h \
  include/linux/mod_devicetable.h \

drivers/net/phy/cicada.o: $(deps_drivers/net/phy/cicada.o)

$(deps_drivers/net/phy/cicada.o):
/*
 * latencytop.h: Infrastructure for displaying latency
 *
 * (C) Copyright 2008 Intel Corporation
 * Author: Arjan van de Ven <arjan@linux.intel.com>
 *
 */

#ifndef _INCLUDE_GUARD_LATENCYTOP_H_
#define _INCLUDE_GUARD_LATENCYTOP_H_

#include <linux/compiler.h>
#ifdef CONFIG_LATENCYTOP

#define LT_SAVECOUNT		32
#define LT_BACKTRACEDEPTH	12

struct latency_record {
	unsigned long	backtrace[LT_BACKTRACEDEPTH];
	unsigned int	count;
	unsigned long	time;
	unsigned long	max;
};


struct task_struct;

extern int latencytop_enabled;
void __account_scheduler_latency(struct task_struct *task, int usecs, int inter);
static inline void
account_scheduler_latency(struct task_struct *task, int usecs, int inter)
{
	if (unlikely(latencytop_enabled))
		__account_scheduler_latency(task, usecs, inter);
}

void clear_all_latency_tracing(struct task_struct *p);

#else

static inline void
account_scheduler_latency(struct task_struct *task, int usecs, int inter)
{
}

static inline void clear_all_latency_tracing(struct task_struct *p)
{
}

#endif

#endif
/*
 * Compressed RAM block device
 *
 * Copyright (C) 2008, 2009, 2010  Nitin Gupta
 *
 * This code is released using a dual license strategy: BSD/GPL
 * You can choose the licence that better fits your requirements.
 *
 * Released under the terms of 3-clause BSD License
 * Released under the terms of GNU General Public License Version 2.0
 *
 * Project home: http://compcache.googlecode.com
 */

#ifndef _ZRAM_DRV_H_
#define _ZRAM_DRV_H_

#include <linux/spinlock.h>
#include <linux/mutex.h>

#include "zram_ioctl.h"
#include "xvmalloc.h"

/*
 * Some arbitrary value. This is just to catch
 * invalid value for num_devices module parameter.
 */
static const unsigned max_num_devices = 32;

/*
 * Stored at beginning of each compressed object.
 *
 * It stores back-reference to table entry which points to this
 * object. This is required to support memory defragmentation.
 */
struct zobj_header {
#if 0
	u32 table_idx;
#endif
};

/*-- Configurable parameters */

/* Default zram disk size: 25% of total RAM */
static const unsigned default_disksize_perc_ram = 25;

/*
 * Pages that compress to size greater than this are stored
 * uncompressed in memory.
 */
static const unsigned max_zpage_size = PAGE_SIZE / 4 * 3;

/*
 * NOTE: max_zpage_size must be less than or equal to:
 *   XV_MAX_ALLOC_SIZE - sizeof(struct zobj_header)
 * otherwise, xv_malloc() would always return failure.
 */

/*-- End of configurable params */

#define SECTOR_SHIFT		9
#define SECTOR_SIZE		(1 << SECTOR_SHIFT)
#define SECTORS_PER_PAGE_SHIFT	(PAGE_SHIFT - SECTOR_SHIFT)
#define SECTORS_PER_PAGE	(1 << SECTORS_PER_PAGE_SHIFT)

/* Flags for zram pages (table[page_no].flags) */
enum zram_pageflags {
	/* Page is stored uncompressed */
	ZRAM_UNCOMPRESSED,

	/* Page consists entirely of zeros */
	ZRAM_ZERO,

	__NR_ZRAM_PAGEFLAGS,
};

/*-- Data structures */

/* Allocated for each disk page */
struct table {
	struct page *page;
	u16 offset;
	u8 count;	/* object ref count (not yet used) */
	u8 flags;
} __attribute__((aligned(4)));

struct zram_stats {
	/* basic stats */
	size_t compr_size;	/* compressed size of pages stored -
				 * needed to enforce memlimit */
	/* more stats */
#if defined(CONFIG_ZRAM_STATS)
	u64 num_reads;		/* failed + successful */
	u64 num_writes;		/* --do-- */
	u64 failed_reads;	/* should NEVER! happen */
	u64 failed_writes;	/* can happen when memory is too low */
	u64 invalid_io;		/* non-page-aligned I/O requests */
	u64 notify_free;	/* no. of swap slot free notifications */
	u32 pages_zero;		/* no. of zero filled pages */
	u32 pages_stored;	/* no. of pages currently stored */
	u32 good_compress;	/* % of pages with compression ratio<=50% */
	u32 pages_expand;	/* % of incompressible pages */
#endif
};

struct zram {
	struct xv_pool *mem_pool;
	void *compress_workmem;
	void *compress_buffer;
	struct table *table;
	spinlock_t stat64_lock;	/* protect 64-bit stats */
	struct mutex lock;	/* protect compression buffers against
				 * concurrent writes */
	struct request_queue *queue;
	struct gendisk *disk;
	int init_done;
	/*
	 * This is the limit on amount of *uncompressed* worth of data
	 * we can store in a disk.
	 */
	size_t disksize;	/* bytes */

	struct zram_stats stats;
};

/*-- */

/* Debugging and Stats */
#if defined(CONFIG_ZRAM_STATS)
static void zram_stat_inc(u32 *v)
{
	*v = *v + 1;
}

static void zram_stat_dec(u32 *v)
{
	*v = *v - 1;
}

static void zram_stat64_inc(struct zram *zram, u64 *v)
{
	spin_lock(&zram->stat64_lock);
	*v = *v + 1;
	spin_unlock(&zram->stat64_lock);
}

static u64 zram_stat64_read(struct zram *zram, u64 *v)
{
	u64 val;

	spin_lock(&zram->stat64_lock);
	val = *v;
	spin_unlock(&zram->stat64_lock);

	return val;
}
#else
#define zram_stat_inc(v)
#define zram_stat_dec(v)
#define zram_stat64_inc(r, v)
#define zram_stat64_read(r, v)
#endif /* CONFIG_ZRAM_STATS */

#endif
cmd_fs/gfs2/glock.o := gcc -Wp,-MD,fs/gfs2/.glock.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -Ifs/gfs2    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(glock)"  -D"KBUILD_MODNAME=KBUILD_STR(gfs2)"  -c -o fs/gfs2/.tmp_glock.o fs/gfs2/glock.c

deps_fs/gfs2/glock.o := \
  fs/gfs2/glock.c \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/lockdep.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/prove/rcu.h) \
    $(wildcard include/config/no/hz.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/virt/cpu/accounting.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/preempt/notifiers.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/debug/mutexes.h) \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/compat.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/debug/stack/usage.h) \
    $(wildcard include/config/preempt.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  include/linux/capability.h \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
    $(wildcard include/config/paravirt.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/linux/timex.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
    $(wildcard include/config/x86/vsmp.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/debug/lock/alloc.h) \
  include/linux/preempt.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/preempt/tracer.h) \
  include/linux/thread_info.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lock/stat.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/jiffies.h \
  include/linux/rbtree.h \
  include/linux/nodemask.h \
    $(wildcard include/config/highmem.h) \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  include/linux/prio_tree.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/completion.h \
  include/linux/wait.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  include/linux/mutex.h \
  include/linux/mutex-debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/kobject.h \
  include/linux/sysfs.h \
    $(wildcard include/config/sysfs.h) \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/gfp.h \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/linux/tracepoint.h \
    $(wildcard include/config/tracepoints.h) \
  include/trace/events/gfpflags.h \
  include/trace/define_trace.h \
    $(wildcard include/config/event/tracing.h) \
  include/linux/kmalloc_sizes.h \
  include/linux/buffer_head.h \
    $(wildcard include/config/block.h) \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/radix-tree.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/pagemap.h \
  include/linux/mm.h \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/s390.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  include/linux/highmem.h \
    $(wildcard include/config/debug/highmem.h) \
  include/linux/uaccess.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cacheflush.h \
    $(wildcard include/config/x86/pat.h) \
    $(wildcard include/config/debug/rodata.h) \
    $(wildcard include/config/debug/rodata/test.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/kmap_types.h \
  include/asm-generic/kmap_types.h \
  include/linux/hardirq.h \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  include/linux/irqreturn.h \
  include/linux/irqnr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
    $(wildcard include/config/4kstacks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
  include/asm-generic/sections.h \
  include/linux/hugetlb_inline.h \
  include/linux/sort.h \
  include/linux/jhash.h \
  include/linux/kallsyms.h \
    $(wildcard include/config/kallsyms.h) \
  include/linux/gfs2_ondisk.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
  include/linux/kmod.h \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ppc64.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/linux/seq_file.h \
  include/linux/debugfs.h \
    $(wildcard include/config/debug/fs.h) \
  include/linux/kthread.h \
  include/linux/freezer.h \
    $(wildcard include/config/cgroup/freezer.h) \
  fs/gfs2/gfs2.h \
  fs/gfs2/incore.h \
  include/linux/dlm.h \
  include/linux/dlmconstants.h \
  fs/gfs2/glock.h \
  include/linux/parser.h \
  fs/gfs2/glops.h \
  fs/gfs2/inode.h \
    $(wildcard include/config/gfs2/fs/locking/dlm.h) \
  fs/gfs2/util.h \
  fs/gfs2/lops.h \
  fs/gfs2/meta_io.h \
  fs/gfs2/quota.h \
  fs/gfs2/super.h \
  fs/gfs2/bmap.h \
  fs/gfs2/trace_gfs2.h \
  fs/gfs2/./trace_gfs2.h \
  fs/gfs2/./incore.h \
  fs/gfs2/./glock.h \

fs/gfs2/glock.o: $(deps_fs/gfs2/glock.o)

$(deps_fs/gfs2/glock.o):
cmd_sound/pci/emu10k1/memory.o := gcc -Wp,-MD,sound/pci/emu10k1/.memory.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(memory)"  -D"KBUILD_MODNAME=KBUILD_STR(snd_emu10k1)"  -c -o sound/pci/emu10k1/.tmp_memory.o sound/pci/emu10k1/memory.c

deps_sound/pci/emu10k1/memory.o := \
  sound/pci/emu10k1/memory.c \
  include/linux/pci.h \
    $(wildcard include/config/pci/iov.h) \
    $(wildcard include/config/pcieaspm.h) \
    $(wildcard include/config/pci/msi.h) \
    $(wildcard include/config/pci.h) \
    $(wildcard include/config/hotplug.h) \
    $(wildcard include/config/pcie/ecrc.h) \
    $(wildcard include/config/ht/irq.h) \
    $(wildcard include/config/pci/domains.h) \
    $(wildcard include/config/pci/quirks.h) \
    $(wildcard include/config/pci/mmconfig.h) \
    $(wildcard include/config/hotplug/pci.h) \
  include/linux/pci_regs.h \
  include/linux/mod_devicetable.h \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
  include/linux/ioport.h \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
    $(wildcard include/config/sysfs.h) \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/kobject_ns.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kref.h \
  include/linux/wait.h \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/io.h \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/has/ioport.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  include/linux/irqreturn.h \
  include/linux/pci_ids.h \
  include/linux/pci-dma.h \
  include/linux/dmapool.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/scatterlist.h \
  include/asm-generic/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
    $(wildcard include/config/need/sg/dma/length.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci.h \
  include/linux/mm.h \
    $(wildcard include/config/sysctl.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/rbtree.h \
  include/linux/prio_tree.h \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mm/owner.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/s390.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci_64.h \
    $(wildcard include/config/calgary/iommu.h) \
  include/asm-generic/pci-dma-compat.h \
  include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  include/linux/dma-attrs.h \
  include/linux/bug.h \
  include/linux/scatterlist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/dma-mapping.h \
    $(wildcard include/config/isa.h) \
  include/linux/kmemcheck.h \
  include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swiotlb.h \
    $(wildcard include/config/swiotlb.h) \
  include/linux/swiotlb.h \
  include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  include/asm-generic/dma-mapping-common.h \
  include/asm-generic/pci.h \
  include/sound/core.h \
    $(wildcard include/config/snd/dynamic/minors.h) \
    $(wildcard include/config/snd/major.h) \
    $(wildcard include/config/sysfs/deprecated.h) \
    $(wildcard include/config/snd/mixer/oss.h) \
    $(wildcard include/config/snd/ossemul.h) \
    $(wildcard include/config/isa/dma/api.h) \
    $(wildcard include/config/snd/debug.h) \
    $(wildcard include/config/snd/verbose/printk.h) \
    $(wildcard include/config/snd/debug/verbose.h) \
    $(wildcard include/config/gameport.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/virt/cpu/accounting.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/cgroup/sched.h) \
  include/linux/capability.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/sound/emu10k1.h \
    $(wildcard include/config/audiodock.h) \
    $(wildcard include/config/hana.h) \
  include/sound/pcm.h \
    $(wildcard include/config/snd/pcm/oss.h) \
    $(wildcard include/config/snd/pcm/xrun/debug.h) \
    $(wildcard include/config/snd/verbose/procfs.h) \
    $(wildcard include/config/snd/dma/sgbuf.h) \
    $(wildcard include/config/ppc.h) \
  include/sound/asound.h \
  include/sound/memalloc.h \
  include/sound/minors.h \
  include/linux/poll.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/poll.h \
  include/asm-generic/poll.h \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/radix-tree.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  include/linux/pm_qos_params.h \
  include/linux/miscdevice.h \
  include/linux/major.h \
  include/sound/pcm_oss.h \
    $(wildcard include/config/snd/pcm/oss/plugins.h) \
  include/sound/rawmidi.h \
    $(wildcard include/config/snd/sequencer.h) \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/irqnr.h \
  include/linux/hardirq.h \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  include/sound/seq_device.h \
  include/sound/hwdep.h \
  include/sound/ac97_codec.h \
    $(wildcard include/config/snd/ac97/power/save.h) \
  include/sound/pcm.h \
  include/sound/control.h \
  include/sound/info.h \
  include/sound/util_mem.h \
  include/sound/pcm-indirect.h \
  include/sound/timer.h \

sound/pci/emu10k1/memory.o: $(deps_sound/pci/emu10k1/memory.o)

$(deps_sound/pci/emu10k1/memory.o):
#include <linux/module.h>
#include <asm/string.h>
#include <asm/checksum.h>

/*XXX: we need them because they would be exported by x86_64 */
#if (__GNUC__ == 4 && __GNUC_MINOR__ >= 3) || __GNUC__ > 4
EXPORT_SYMBOL(memcpy);
#else
EXPORT_SYMBOL(__memcpy);
#endif
EXPORT_SYMBOL(csum_partial);
/*
 * arch/arm/mach-orion5x/ts78xx-setup.c
 *
 * Maintainer: Alexander Clouter <alex@digriz.org.uk>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2.  This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 */

#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/sysfs.h>
#include <linux/platform_device.h>
#include <linux/mv643xx_eth.h>
#include <linux/ata_platform.h>
#include <linux/m48t86.h>
#include <linux/mtd/nand.h>
#include <linux/mtd/partitions.h>
#include <linux/timeriomem-rng.h>
#include <asm/mach-types.h>
#include <asm/mach/arch.h>
#include <asm/mach/map.h>
#include <mach/orion5x.h>
#include "common.h"
#include "mpp.h"
#include "ts78xx-fpga.h"

/*****************************************************************************
 * TS-78xx Info
 ****************************************************************************/

/*
 * FPGA - lives where the PCI bus would be at ORION5X_PCI_MEM_PHYS_BASE
 */
#define TS78XX_FPGA_REGS_PHYS_BASE	0xe8000000
#define TS78XX_FPGA_REGS_VIRT_BASE	0xff900000
#define TS78XX_FPGA_REGS_SIZE		SZ_1M

static struct ts78xx_fpga_data ts78xx_fpga = {
	.id		= 0,
	.state		= 1,
/*	.supports	= ... - populated by ts78xx_fpga_supports() */
};

/*****************************************************************************
 * I/O Address Mapping
 ****************************************************************************/
static struct map_desc ts78xx_io_desc[] __initdata = {
	{
		.virtual	= TS78XX_FPGA_REGS_VIRT_BASE,
		.pfn		= __phys_to_pfn(TS78XX_FPGA_REGS_PHYS_BASE),
		.length		= TS78XX_FPGA_REGS_SIZE,
		.type		= MT_DEVICE,
	},
};

void __init ts78xx_map_io(void)
{
	orion5x_map_io();
	iotable_init(ts78xx_io_desc, ARRAY_SIZE(ts78xx_io_desc));
}

/*****************************************************************************
 * Ethernet
 ****************************************************************************/
static struct mv643xx_eth_platform_data ts78xx_eth_data = {
	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
};

/*****************************************************************************
 * SATA
 ****************************************************************************/
static struct mv_sata_platform_data ts78xx_sata_data = {
	.n_ports	= 2,
};

/*****************************************************************************
 * RTC M48T86 - nicked^Wborrowed from arch/arm/mach-ep93xx/ts72xx.c
 ****************************************************************************/
#define TS_RTC_CTRL	(TS78XX_FPGA_REGS_VIRT_BASE | 0x808)
#define TS_RTC_DATA	(TS78XX_FPGA_REGS_VIRT_BASE | 0x80c)

static unsigned char ts78xx_ts_rtc_readbyte(unsigned long addr)
{
	writeb(addr, TS_RTC_CTRL);
	return readb(TS_RTC_DATA);
}

static void ts78xx_ts_rtc_writebyte(unsigned char value, unsigned long addr)
{
	writeb(addr, TS_RTC_CTRL);
	writeb(value, TS_RTC_DATA);
}

static struct m48t86_ops ts78xx_ts_rtc_ops = {
	.readbyte	= ts78xx_ts_rtc_readbyte,
	.writebyte	= ts78xx_ts_rtc_writebyte,
};

static struct platform_device ts78xx_ts_rtc_device = {
	.name		= "rtc-m48t86",
	.id		= -1,
	.dev		= {
		.platform_data	= &ts78xx_ts_rtc_ops,
	},
	.num_resources	= 0,
};

/*
 * TS uses some of the user storage space on the RTC chip so see if it is
 * present; as it's an optional feature at purchase time and not all boards
 * will have it present
 *
 * I've used the method TS use in their rtc7800.c example for the detection
 *
 * TODO: track down a guinea pig without an RTC to see if we can work out a
 * 		better RTC detection routine
 */
static int ts78xx_ts_rtc_load(void)
{
	int rc;
	unsigned char tmp_rtc0, tmp_rtc1;

	tmp_rtc0 = ts78xx_ts_rtc_readbyte(126);
	tmp_rtc1 = ts78xx_ts_rtc_readbyte(127);

	ts78xx_ts_rtc_writebyte(0x00, 126);
	ts78xx_ts_rtc_writebyte(0x55, 127);
	if (ts78xx_ts_rtc_readbyte(127) == 0x55) {
		ts78xx_ts_rtc_writebyte(0xaa, 127);
		if (ts78xx_ts_rtc_readbyte(127) == 0xaa
				&& ts78xx_ts_rtc_readbyte(126) == 0x00) {
			ts78xx_ts_rtc_writebyte(tmp_rtc0, 126);
			ts78xx_ts_rtc_writebyte(tmp_rtc1, 127);

			if (ts78xx_fpga.supports.ts_rtc.init == 0) {
				rc = platform_device_register(&ts78xx_ts_rtc_device);
				if (!rc)
					ts78xx_fpga.supports.ts_rtc.init = 1;
			} else
				rc = platform_device_add(&ts78xx_ts_rtc_device);

			return rc;
		}
	}

	return -ENODEV;
};

static void ts78xx_ts_rtc_unload(void)
{
	platform_device_del(&ts78xx_ts_rtc_device);
}

/*****************************************************************************
 * NAND Flash
 ****************************************************************************/
#define TS_NAND_CTRL	(TS78XX_FPGA_REGS_VIRT_BASE | 0x800)	/* VIRT */
#define TS_NAND_DATA	(TS78XX_FPGA_REGS_PHYS_BASE | 0x804)	/* PHYS */

/*
 * hardware specific access to control-lines
 *
 * ctrl:
 * NAND_NCE: bit 0 -> bit 2
 * NAND_CLE: bit 1 -> bit 1
 * NAND_ALE: bit 2 -> bit 0
 */
static void ts78xx_ts_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
			unsigned int ctrl)
{
	struct nand_chip *this = mtd->priv;

	if (ctrl & NAND_CTRL_CHANGE) {
		unsigned char bits;

		bits = (ctrl & NAND_NCE) << 2;
		bits |= ctrl & NAND_CLE;
		bits |= (ctrl & NAND_ALE) >> 2;

		writeb((readb(TS_NAND_CTRL) & ~0x7) | bits, TS_NAND_CTRL);
	}

	if (cmd != NAND_CMD_NONE)
		writeb(cmd, this->IO_ADDR_W);
}

static int ts78xx_ts_nand_dev_ready(struct mtd_info *mtd)
{
	return readb(TS_NAND_CTRL) & 0x20;
}

const char *ts_nand_part_probes[] = { "cmdlinepart", NULL };

static struct mtd_partition ts78xx_ts_nand_parts[] = {
	{
		.name		= "mbr",
		.offset		= 0,
		.size		= SZ_128K,
		.mask_flags	= MTD_WRITEABLE,
	}, {
		.name		= "kernel",
		.offset		= MTDPART_OFS_APPEND,
		.size		= SZ_4M,
	}, {
		.name		= "initrd",
		.offset		= MTDPART_OFS_APPEND,
		.size		= SZ_4M,
	}, {
		.name		= "rootfs",
		.offset		= MTDPART_OFS_APPEND,
		.size		= MTDPART_SIZ_FULL,
	}
};

static struct platform_nand_data ts78xx_ts_nand_data = {
	.chip	= {
		.nr_chips		= 1,
		.part_probe_types	= ts_nand_part_probes,
		.partitions		= ts78xx_ts_nand_parts,
		.nr_partitions		= ARRAY_SIZE(ts78xx_ts_nand_parts),
		.chip_delay		= 15,
		.options		= NAND_USE_FLASH_BBT,
	},
	.ctrl	= {
		/*
		 * The HW ECC offloading functions, used to give about a 9%
		 * performance increase for 'dd if=/dev/mtdblockX' and 5% for
		 * nanddump.  This all however was changed by git commit
		 * e6cf5df1838c28bb060ac45b5585e48e71bbc740 so now there is
		 * no performance advantage to be had so we no longer bother
		 */
		.cmd_ctrl		= ts78xx_ts_nand_cmd_ctrl,
		.dev_ready		= ts78xx_ts_nand_dev_ready,
	},
};

static struct resource ts78xx_ts_nand_resources = {
	.start		= TS_NAND_DATA,
	.end		= TS_NAND_DATA + 4,
	.flags		= IORESOURCE_IO,
};

static struct platform_device ts78xx_ts_nand_device = {
	.name		= "gen_nand",
	.id		= -1,
	.dev		= {
		.platform_data	= &ts78xx_ts_nand_data,
	},
	.resource	= &ts78xx_ts_nand_resources,
	.num_resources	= 1,
};

static int ts78xx_ts_nand_load(void)
{
	int rc;

	if (ts78xx_fpga.supports.ts_nand.init == 0) {
		rc = platform_device_register(&ts78xx_ts_nand_device);
		if (!rc)
			ts78xx_fpga.supports.ts_nand.init = 1;
	} else
		rc = platform_device_add(&ts78xx_ts_nand_device);

	return rc;
};

static void ts78xx_ts_nand_unload(void)
{
	platform_device_del(&ts78xx_ts_nand_device);
}

/*****************************************************************************
 * HW RNG
 ****************************************************************************/
#define TS_RNG_DATA	(TS78XX_FPGA_REGS_PHYS_BASE | 0x044)

static struct resource ts78xx_ts_rng_resource = {
	.flags		= IORESOURCE_MEM,
	.start		= TS_RNG_DATA,
	.end		= TS_RNG_DATA + 4 - 1,
};

static struct timeriomem_rng_data ts78xx_ts_rng_data = {
	.period		= 1000000, /* one second */
};

static struct platform_device ts78xx_ts_rng_device = {
	.name		= "timeriomem_rng",
	.id		= -1,
	.dev		= {
		.platform_data	= &ts78xx_ts_rng_data,
	},
	.resource	= &ts78xx_ts_rng_resource,
	.num_resources	= 1,
};

static int ts78xx_ts_rng_load(void)
{
	int rc;

	if (ts78xx_fpga.supports.ts_rng.init == 0) {
		rc = platform_device_register(&ts78xx_ts_rng_device);
		if (!rc)
			ts78xx_fpga.supports.ts_rng.init = 1;
	} else
		rc = platform_device_add(&ts78xx_ts_rng_device);

	return rc;
};

static void ts78xx_ts_rng_unload(void)
{
	platform_device_del(&ts78xx_ts_rng_device);
}

/*****************************************************************************
 * FPGA 'hotplug' support code
 ****************************************************************************/
static void ts78xx_fpga_devices_zero_init(void)
{
	ts78xx_fpga.supports.ts_rtc.init = 0;
	ts78xx_fpga.supports.ts_nand.init = 0;
	ts78xx_fpga.supports.ts_rng.init = 0;
}

static void ts78xx_fpga_supports(void)
{
	/* TODO: put this 'table' into ts78xx-fpga.h */
	switch (ts78xx_fpga.id) {
	case TS7800_REV_1:
	case TS7800_REV_2:
	case TS7800_REV_3:
	case TS7800_REV_4:
	case TS7800_REV_5:
		ts78xx_fpga.supports.ts_rtc.present = 1;
		ts78xx_fpga.supports.ts_nand.present = 1;
		ts78xx_fpga.supports.ts_rng.present = 1;
		break;
	default:
		ts78xx_fpga.supports.ts_rtc.present = 0;
		ts78xx_fpga.supports.ts_nand.present = 0;
		ts78xx_fpga.supports.ts_rng.present = 0;
	}
}

static int ts78xx_fpga_load_devices(void)
{
	int tmp, ret = 0;

	if (ts78xx_fpga.supports.ts_rtc.present == 1) {
		tmp = ts78xx_ts_rtc_load();
		if (tmp) {
			printk(KERN_INFO "TS-78xx: RTC not registered\n");
			ts78xx_fpga.supports.ts_rtc.present = 0;
		}
		ret |= tmp;
	}
	if (ts78xx_fpga.supports.ts_nand.present == 1) {
		tmp = ts78xx_ts_nand_load();
		if (tmp) {
			printk(KERN_INFO "TS-78xx: NAND not registered\n");
			ts78xx_fpga.supports.ts_nand.present = 0;
		}
		ret |= tmp;
	}
	if (ts78xx_fpga.supports.ts_rng.present == 1) {
		tmp = ts78xx_ts_rng_load();
		if (tmp) {
			printk(KERN_INFO "TS-78xx: RNG not registered\n");
			ts78xx_fpga.supports.ts_rng.present = 0;
		}
		ret |= tmp;
	}

	return ret;
}

static int ts78xx_fpga_unload_devices(void)
{
	int ret = 0;

	if (ts78xx_fpga.supports.ts_rtc.present == 1)
		ts78xx_ts_rtc_unload();
	if (ts78xx_fpga.supports.ts_nand.present == 1)
		ts78xx_ts_nand_unload();
	if (ts78xx_fpga.supports.ts_rng.present == 1)
		ts78xx_ts_rng_unload();

	return ret;
}

static int ts78xx_fpga_load(void)
{
	ts78xx_fpga.id = readl(TS78XX_FPGA_REGS_VIRT_BASE);

	printk(KERN_INFO "TS-78xx FPGA: magic=0x%.6x, rev=0x%.2x\n",
			(ts78xx_fpga.id >> 8) & 0xffffff,
			ts78xx_fpga.id & 0xff);

	ts78xx_fpga_supports();

	if (ts78xx_fpga_load_devices()) {
		ts78xx_fpga.state = -1;
		return -EBUSY;
	}

	return 0;
};

static int ts78xx_fpga_unload(void)
{
	unsigned int fpga_id;

	fpga_id = readl(TS78XX_FPGA_REGS_VIRT_BASE);

	/*
	 * There does not seem to be a feasible way to block access to the GPIO
	 * pins from userspace (/dev/mem).  This if clause should hopefully warn
	 * those foolish enough not to follow 'policy' :)
	 *
	 * UrJTAG SVN since r1381 can be used to reprogram the FPGA
	 */
	if (ts78xx_fpga.id != fpga_id) {
		printk(KERN_ERR	"TS-78xx FPGA: magic/rev mismatch\n"
			"TS-78xx FPGA: was 0x%.6x/%.2x but now 0x%.6x/%.2x\n",
			(ts78xx_fpga.id >> 8) & 0xffffff, ts78xx_fpga.id & 0xff,
			(fpga_id >> 8) & 0xffffff, fpga_id & 0xff);
		ts78xx_fpga.state = -1;
		return -EBUSY;
	}

	if (ts78xx_fpga_unload_devices()) {
		ts78xx_fpga.state = -1;
		return -EBUSY;
	}

	return 0;
};

static ssize_t ts78xx_fpga_show(struct kobject *kobj,
			struct kobj_attribute *attr, char *buf)
{
	if (ts78xx_fpga.state < 0)
		return sprintf(buf, "borked\n");

	return sprintf(buf, "%s\n", (ts78xx_fpga.state) ? "online" : "offline");
}

static ssize_t ts78xx_fpga_store(struct kobject *kobj,
			struct kobj_attribute *attr, const char *buf, size_t n)
{
	int value, ret;

	if (ts78xx_fpga.state < 0) {
		printk(KERN_ERR "TS-78xx FPGA: borked, you must powercycle asap\n");
		return -EBUSY;
	}

	if (strncmp(buf, "online", sizeof("online") - 1) == 0)
		value = 1;
	else if (strncmp(buf, "offline", sizeof("offline") - 1) == 0)
		value = 0;
	else {
		printk(KERN_ERR "ts78xx_fpga_store: Invalid value\n");
		return -EINVAL;
	}

	if (ts78xx_fpga.state == value)
		return n;

	ret = (ts78xx_fpga.state == 0)
		? ts78xx_fpga_load()
		: ts78xx_fpga_unload();

	if (!(ret < 0))
		ts78xx_fpga.state = value;

	return n;
}

static struct kobj_attribute ts78xx_fpga_attr =
	__ATTR(ts78xx_fpga, 0644, ts78xx_fpga_show, ts78xx_fpga_store);

/*****************************************************************************
 * General Setup
 ****************************************************************************/
static struct orion5x_mpp_mode ts78xx_mpp_modes[] __initdata = {
	{  0, MPP_UNUSED },
	{  1, MPP_GPIO },		/* JTAG Clock */
	{  2, MPP_GPIO },		/* JTAG Data In */
	{  3, MPP_GPIO },		/* Lat ECP2 256 FPGA - PB2B */
	{  4, MPP_GPIO },		/* JTAG Data Out */
	{  5, MPP_GPIO },		/* JTAG TMS */
	{  6, MPP_GPIO },		/* Lat ECP2 256 FPGA - PB31A_CLK4+ */
	{  7, MPP_GPIO },		/* Lat ECP2 256 FPGA - PB22B */
	{  8, MPP_UNUSED },
	{  9, MPP_UNUSED },
	{ 10, MPP_UNUSED },
	{ 11, MPP_UNUSED },
	{ 12, MPP_UNUSED },
	{ 13, MPP_UNUSED },
	{ 14, MPP_UNUSED },
	{ 15, MPP_UNUSED },
	{ 16, MPP_UART },
	{ 17, MPP_UART },
	{ 18, MPP_UART },
	{ 19, MPP_UART },
	/*
	 * MPP[20] PCI Clock Out 1
	 * MPP[21] PCI Clock Out 0
	 * MPP[22] Unused
	 * MPP[23] Unused
	 * MPP[24] Unused
	 * MPP[25] Unused
	 */
	{ -1 },
};

static void __init ts78xx_init(void)
{
	int ret;

	/*
	 * Setup basic Orion functions. Need to be called early.
	 */
	orion5x_init();

	orion5x_mpp_conf(ts78xx_mpp_modes);

	/*
	 * Configure peripherals.
	 */
	orion5x_ehci0_init();
	orion5x_ehci1_init();
	orion5x_eth_init(&ts78xx_eth_data);
	orion5x_sata_init(&ts78xx_sata_data);
	orion5x_uart0_init();
	orion5x_uart1_init();
	orion5x_xor_init();

	/* FPGA init */
	ts78xx_fpga_devices_zero_init();
	ret = ts78xx_fpga_load();
	ret = sysfs_create_file(power_kobj, &ts78xx_fpga_attr.attr);
	if (ret)
		printk(KERN_ERR "sysfs_create_file failed: %d\n", ret);
}

MACHINE_START(TS78XX, "Technologic Systems TS-78xx SBC")
	/* Maintainer: Alexander Clouter <alex@digriz.org.uk> */
	.phys_io	= ORION5X_REGS_PHYS_BASE,
	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
	.boot_params	= 0x00000100,
	.init_machine	= ts78xx_init,
	.map_io		= ts78xx_map_io,
	.init_irq	= orion5x_init_irq,
	.timer		= &orion5x_timer,
MACHINE_END
/*
 *   ALSA soundcard driver for Miro miroSOUND PCM1 pro
 *                                  miroSOUND PCM12
 *                                  miroSOUND PCM20 Radio
 *
 *   Copyright (C) 2004-2005 Martin Langer <martin-langer@gmx.de>
 *
 *   Based on OSS ACI and ALSA OPTi9xx drivers
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

#include <linux/init.h>
#include <linux/err.h>
#include <linux/isa.h>
#include <linux/pnp.h>
#include <linux/delay.h>
#include <linux/ioport.h>
#include <linux/moduleparam.h>
#include <asm/io.h>
#include <asm/dma.h>
#include <sound/core.h>
#include <sound/wss.h>
#include <sound/mpu401.h>
#include <sound/opl4.h>
#include <sound/control.h>
#include <sound/info.h>
#define SNDRV_LEGACY_FIND_FREE_IRQ
#define SNDRV_LEGACY_FIND_FREE_DMA
#include <sound/initval.h>
#include <sound/aci.h>

MODULE_AUTHOR("Martin Langer <martin-langer@gmx.de>");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Miro miroSOUND PCM1 pro, PCM12, PCM20 Radio");
MODULE_SUPPORTED_DEVICE("{{Miro,miroSOUND PCM1 pro}, "
			"{Miro,miroSOUND PCM12}, "
			"{Miro,miroSOUND PCM20 Radio}}");

static int index = SNDRV_DEFAULT_IDX1;		/* Index 0-MAX */
static char *id = SNDRV_DEFAULT_STR1;		/* ID for this card */
static long port = SNDRV_DEFAULT_PORT1; 	/* 0x530,0xe80,0xf40,0x604 */
static long mpu_port = SNDRV_DEFAULT_PORT1;	/* 0x300,0x310,0x320,0x330 */
static long fm_port = SNDRV_DEFAULT_PORT1;	/* 0x388 */
static int irq = SNDRV_DEFAULT_IRQ1;		/* 5,7,9,10,11 */
static int mpu_irq = SNDRV_DEFAULT_IRQ1;	/* 5,7,9,10 */
static int dma1 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
static int dma2 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
static int wss;
static int ide;
#ifdef CONFIG_PNP
static int isapnp = 1;				/* Enable ISA PnP detection */
#endif

module_param(index, int, 0444);
MODULE_PARM_DESC(index, "Index value for miro soundcard.");
module_param(id, charp, 0444);
MODULE_PARM_DESC(id, "ID string for miro soundcard.");
module_param(port, long, 0444);
MODULE_PARM_DESC(port, "WSS port # for miro driver.");
module_param(mpu_port, long, 0444);
MODULE_PARM_DESC(mpu_port, "MPU-401 port # for miro driver.");
module_param(fm_port, long, 0444);
MODULE_PARM_DESC(fm_port, "FM Port # for miro driver.");
module_param(irq, int, 0444);
MODULE_PARM_DESC(irq, "WSS irq # for miro driver.");
module_param(mpu_irq, int, 0444);
MODULE_PARM_DESC(mpu_irq, "MPU-401 irq # for miro driver.");
module_param(dma1, int, 0444);
MODULE_PARM_DESC(dma1, "1st dma # for miro driver.");
module_param(dma2, int, 0444);
MODULE_PARM_DESC(dma2, "2nd dma # for miro driver.");
module_param(wss, int, 0444);
MODULE_PARM_DESC(wss, "wss mode");
module_param(ide, int, 0444);
MODULE_PARM_DESC(ide, "enable ide port");
#ifdef CONFIG_PNP
module_param(isapnp, bool, 0444);
MODULE_PARM_DESC(isapnp, "Enable ISA PnP detection for specified soundcard.");
#endif

#define OPTi9XX_HW_DETECT	0
#define OPTi9XX_HW_82C928	1
#define OPTi9XX_HW_82C929	2
#define OPTi9XX_HW_82C924	3
#define OPTi9XX_HW_82C925	4
#define OPTi9XX_HW_82C930	5
#define OPTi9XX_HW_82C931	6
#define OPTi9XX_HW_82C933	7
#define OPTi9XX_HW_LAST		OPTi9XX_HW_82C933

#define OPTi9XX_MC_REG(n)	n

struct snd_miro {
	unsigned short hardware;
	unsigned char password;
	char name[7];

	struct resource *res_mc_base;
	struct resource *res_aci_port;

	unsigned long mc_base;
	unsigned long mc_base_size;
	unsigned long pwd_reg;

	spinlock_t lock;
	struct snd_pcm *pcm;

	long wss_base;
	int irq;
	int dma1;
	int dma2;

	long mpu_port;
	int mpu_irq;

	struct snd_miro_aci *aci;
};

static struct snd_miro_aci aci_device;

static char * snd_opti9xx_names[] = {
	"unknown",
	"82C928", "82C929",
	"82C924", "82C925",
	"82C930", "82C931", "82C933"
};

static int snd_miro_pnp_is_probed;

#ifdef CONFIG_PNP

static struct pnp_card_device_id snd_miro_pnpids[] = {
	/* PCM20 and PCM12 in PnP mode */
	{ .id = "MIR0924",
	  .devs = { { "MIR0000" }, { "MIR0002" }, { "MIR0005" } }, },
	{ .id = "" }
};

MODULE_DEVICE_TABLE(pnp_card, snd_miro_pnpids);

#endif	/* CONFIG_PNP */

/* 
 *  ACI control
 */

static int aci_busy_wait(struct snd_miro_aci *aci)
{
	long timeout;
	unsigned char byte;

	for (timeout = 1; timeout <= ACI_MINTIME + 30; timeout++) {
		byte = inb(aci->aci_port + ACI_REG_BUSY);
		if ((byte & 1) == 0) {
			if (timeout >= ACI_MINTIME)
				snd_printd("aci ready in round %ld.\n",
					   timeout-ACI_MINTIME);
			return byte;
		}
		if (timeout >= ACI_MINTIME) {
			long out=10*HZ;
			switch (timeout-ACI_MINTIME) {
			case 0 ... 9:
				out /= 10;
			case 10 ... 19:
				out /= 10;
			case 20 ... 30:
				out /= 10;
			default:
				set_current_state(TASK_UNINTERRUPTIBLE);
				schedule_timeout(out);
				break;
			}
		}
	}
	snd_printk(KERN_ERR "aci_busy_wait() time out\n");
	return -EBUSY;
}

static inline int aci_write(struct snd_miro_aci *aci, unsigned char byte)
{
	if (aci_busy_wait(aci) >= 0) {
		outb(byte, aci->aci_port + ACI_REG_COMMAND);
		return 0;
	} else {
		snd_printk(KERN_ERR "aci busy, aci_write(0x%x) stopped.\n", byte);
		return -EBUSY;
	}
}

static inline int aci_read(struct snd_miro_aci *aci)
{
	unsigned char byte;

	if (aci_busy_wait(aci) >= 0) {
		byte = inb(aci->aci_port + ACI_REG_STATUS);
		return byte;
	} else {
		snd_printk(KERN_ERR "aci busy, aci_read() stopped.\n");
		return -EBUSY;
	}
}

int snd_aci_cmd(struct snd_miro_aci *aci, int write1, int write2, int write3)
{
	int write[] = {write1, write2, write3};
	int value, i;

	if (mutex_lock_interruptible(&aci->aci_mutex))
		return -EINTR;

	for (i=0; i<3; i++) {
		if (write[i]< 0 || write[i] > 255)
			break;
		else {
			value = aci_write(aci, write[i]);
			if (value < 0)
				goto out;
		}
	}

	value = aci_read(aci);

out:	mutex_unlock(&aci->aci_mutex);
	return value;
}
EXPORT_SYMBOL(snd_aci_cmd);

static int aci_getvalue(struct snd_miro_aci *aci, unsigned char index)
{
	return snd_aci_cmd(aci, ACI_STATUS, index, -1);
}

static int aci_setvalue(struct snd_miro_aci *aci, unsigned char index,
			int value)
{
	return snd_aci_cmd(aci, index, value, -1);
}

struct snd_miro_aci *snd_aci_get_aci(void)
{
	if (aci_device.aci_port == 0)
		return NULL;
	return &aci_device;
}
EXPORT_SYMBOL(snd_aci_get_aci);

/*
 *  MIXER part
 */

#define snd_miro_info_capture	snd_ctl_boolean_mono_info

static int snd_miro_get_capture(struct snd_kcontrol *kcontrol,
				struct snd_ctl_elem_value *ucontrol)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	int value;

	value = aci_getvalue(miro->aci, ACI_S_GENERAL);
	if (value < 0) {
		snd_printk(KERN_ERR "snd_miro_get_capture() failed: %d\n",
			   value);
		return value;
	}

	ucontrol->value.integer.value[0] = value & 0x20;

	return 0;
}

static int snd_miro_put_capture(struct snd_kcontrol *kcontrol,
				struct snd_ctl_elem_value *ucontrol)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	int change, value, error;

	value = !(ucontrol->value.integer.value[0]);

	error = aci_setvalue(miro->aci, ACI_SET_SOLOMODE, value);
	if (error < 0) {
		snd_printk(KERN_ERR "snd_miro_put_capture() failed: %d\n",
			   error);
		return error;
	}

	change = (value != miro->aci->aci_solomode);
	miro->aci->aci_solomode = value;
	
	return change;
}

static int snd_miro_info_preamp(struct snd_kcontrol *kcontrol,
				struct snd_ctl_elem_info *uinfo)
{
	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
	uinfo->count = 1;
	uinfo->value.integer.min = 0;
	uinfo->value.integer.max = 3;

	return 0;
}

static int snd_miro_get_preamp(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	int value;

	if (miro->aci->aci_version <= 176) {

		/* 
		   OSS says it's not readable with versions < 176.
		   But it doesn't work on my card,
		   which is a PCM12 with aci_version = 176.
		*/

		ucontrol->value.integer.value[0] = miro->aci->aci_preamp;
		return 0;
	}

	value = aci_getvalue(miro->aci, ACI_GET_PREAMP);
	if (value < 0) {
		snd_printk(KERN_ERR "snd_miro_get_preamp() failed: %d\n",
			   value);
		return value;
	}
	
	ucontrol->value.integer.value[0] = value;

	return 0;
}

static int snd_miro_put_preamp(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	int error, value, change;

	value = ucontrol->value.integer.value[0];

	error = aci_setvalue(miro->aci, ACI_SET_PREAMP, value);
	if (error < 0) {
		snd_printk(KERN_ERR "snd_miro_put_preamp() failed: %d\n",
			   error);
		return error;
	}

	change = (value != miro->aci->aci_preamp);
	miro->aci->aci_preamp = value;

	return change;
}

#define snd_miro_info_amp	snd_ctl_boolean_mono_info

static int snd_miro_get_amp(struct snd_kcontrol *kcontrol,
			    struct snd_ctl_elem_value *ucontrol)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	ucontrol->value.integer.value[0] = miro->aci->aci_amp;

	return 0;
}

static int snd_miro_put_amp(struct snd_kcontrol *kcontrol,
			    struct snd_ctl_elem_value *ucontrol)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	int error, value, change;

	value = ucontrol->value.integer.value[0];

	error = aci_setvalue(miro->aci, ACI_SET_POWERAMP, value);
	if (error < 0) {
		snd_printk(KERN_ERR "snd_miro_put_amp() to %d failed: %d\n", value, error);
		return error;
	}

	change = (value != miro->aci->aci_amp);
	miro->aci->aci_amp = value;

	return change;
}

#define MIRO_DOUBLE(ctl_name, ctl_index, get_right_reg, set_right_reg) \
{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
  .name = ctl_name, \
  .index = ctl_index, \
  .info = snd_miro_info_double, \
  .get = snd_miro_get_double, \
  .put = snd_miro_put_double, \
  .private_value = get_right_reg | (set_right_reg << 8) \
}

static int snd_miro_info_double(struct snd_kcontrol *kcontrol, 
				struct snd_ctl_elem_info *uinfo)
{
	int reg = kcontrol->private_value & 0xff;

	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
	uinfo->count = 2;

	if ((reg >= ACI_GET_EQ1) && (reg <= ACI_GET_EQ7)) {

		/* equalizer elements */

		uinfo->value.integer.min = - 0x7f;
		uinfo->value.integer.max = 0x7f;
	} else {

		/* non-equalizer elements */

		uinfo->value.integer.min = 0;
		uinfo->value.integer.max = 0x20;
	}

	return 0;
}

static int snd_miro_get_double(struct snd_kcontrol *kcontrol, 
			       struct snd_ctl_elem_value *uinfo)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	int left_val, right_val;

	int right_reg = kcontrol->private_value & 0xff;
	int left_reg = right_reg + 1;

	right_val = aci_getvalue(miro->aci, right_reg);
	if (right_val < 0) {
		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", right_reg, right_val);
		return right_val;
	}

	left_val = aci_getvalue(miro->aci, left_reg);
	if (left_val < 0) {
		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", left_reg, left_val);
		return left_val;
	}

	if ((right_reg >= ACI_GET_EQ1) && (right_reg <= ACI_GET_EQ7)) {

		/* equalizer elements */

		if (left_val < 0x80) {
			uinfo->value.integer.value[0] = left_val;
		} else {
			uinfo->value.integer.value[0] = 0x80 - left_val;
		}

		if (right_val < 0x80) {
			uinfo->value.integer.value[1] = right_val;
		} else {
			uinfo->value.integer.value[1] = 0x80 - right_val;
		}

	} else {

		/* non-equalizer elements */

		uinfo->value.integer.value[0] = 0x20 - left_val;
		uinfo->value.integer.value[1] = 0x20 - right_val;
	}

	return 0;
}

static int snd_miro_put_double(struct snd_kcontrol *kcontrol, 
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
	struct snd_miro_aci *aci = miro->aci;
	int left, right, left_old, right_old;
	int setreg_left, setreg_right, getreg_left, getreg_right;
	int change, error;

	left = ucontrol->value.integer.value[0];
	right = ucontrol->value.integer.value[1];

	setreg_right = (kcontrol->private_value >> 8) & 0xff;
	setreg_left = setreg_right + 8;
	if (setreg_right == ACI_SET_MASTER)
		setreg_left -= 7;

	getreg_right = kcontrol->private_value & 0xff;
	getreg_left = getreg_right + 1;

	left_old = aci_getvalue(aci, getreg_left);
	if (left_old < 0) {
		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_left, left_old);
		return left_old;
	}

	right_old = aci_getvalue(aci, getreg_right);
	if (right_old < 0) {
		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_right, right_old);
		return right_old;
	}

	if ((getreg_right >= ACI_GET_EQ1) && (getreg_right <= ACI_GET_EQ7)) {

		/* equalizer elements */

		if (left < -0x7f || left > 0x7f ||
		    right < -0x7f || right > 0x7f)
			return -EINVAL;

		if (left_old > 0x80) 
			left_old = 0x80 - left_old;
		if (right_old > 0x80) 
			right_old = 0x80 - right_old;

		if (left >= 0) {
			error = aci_setvalue(aci, setreg_left, left);
			if (error < 0) {
				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
					   left, error);
				return error;
			}
		} else {
			error = aci_setvalue(aci, setreg_left, 0x80 - left);
			if (error < 0) {
				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
					   0x80 - left, error);
				return error;
			}
		}

		if (right >= 0) {
			error = aci_setvalue(aci, setreg_right, right);
			if (error < 0) {
				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
					   right, error);
				return error;
			}
		} else {
			error = aci_setvalue(aci, setreg_right, 0x80 - right);
			if (error < 0) {
				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
					   0x80 - right, error);
				return error;
			}
		}

	} else {

		/* non-equalizer elements */

		if (left < 0 || left > 0x20 ||
		    right < 0 || right > 0x20)
			return -EINVAL;

		left_old = 0x20 - left_old;
		right_old = 0x20 - right_old;

		error = aci_setvalue(aci, setreg_left, 0x20 - left);
		if (error < 0) {
			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
				   0x20 - left, error);
			return error;
		}
		error = aci_setvalue(aci, setreg_right, 0x20 - right);
		if (error < 0) {
			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
				   0x20 - right, error);
			return error;
		}
	}

	change = (left != left_old) || (right != right_old);

	return change;
}

static struct snd_kcontrol_new snd_miro_controls[] __devinitdata = {
MIRO_DOUBLE("Master Playback Volume", 0, ACI_GET_MASTER, ACI_SET_MASTER),
MIRO_DOUBLE("Mic Playback Volume", 1, ACI_GET_MIC, ACI_SET_MIC),
MIRO_DOUBLE("Line Playback Volume", 1, ACI_GET_LINE, ACI_SET_LINE),
MIRO_DOUBLE("CD Playback Volume", 0, ACI_GET_CD, ACI_SET_CD),
MIRO_DOUBLE("Synth Playback Volume", 0, ACI_GET_SYNTH, ACI_SET_SYNTH),
MIRO_DOUBLE("PCM Playback Volume", 1, ACI_GET_PCM, ACI_SET_PCM),
MIRO_DOUBLE("Aux Playback Volume", 2, ACI_GET_LINE2, ACI_SET_LINE2),
};

/* Equalizer with seven bands (only PCM20) 
   from -12dB up to +12dB on each band */
static struct snd_kcontrol_new snd_miro_eq_controls[] __devinitdata = {
MIRO_DOUBLE("Tone Control - 28 Hz", 0, ACI_GET_EQ1, ACI_SET_EQ1),
MIRO_DOUBLE("Tone Control - 160 Hz", 0, ACI_GET_EQ2, ACI_SET_EQ2),
MIRO_DOUBLE("Tone Control - 400 Hz", 0, ACI_GET_EQ3, ACI_SET_EQ3),
MIRO_DOUBLE("Tone Control - 1 kHz", 0, ACI_GET_EQ4, ACI_SET_EQ4),
MIRO_DOUBLE("Tone Control - 2.5 kHz", 0, ACI_GET_EQ5, ACI_SET_EQ5),
MIRO_DOUBLE("Tone Control - 6.3 kHz", 0, ACI_GET_EQ6, ACI_SET_EQ6),
MIRO_DOUBLE("Tone Control - 16 kHz", 0, ACI_GET_EQ7, ACI_SET_EQ7),
};

static struct snd_kcontrol_new snd_miro_radio_control[] __devinitdata = {
MIRO_DOUBLE("Radio Playback Volume", 0, ACI_GET_LINE1, ACI_SET_LINE1),
};

static struct snd_kcontrol_new snd_miro_line_control[] __devinitdata = {
MIRO_DOUBLE("Line Playback Volume", 2, ACI_GET_LINE1, ACI_SET_LINE1),
};

static struct snd_kcontrol_new snd_miro_preamp_control[] __devinitdata = {
{
	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
	.name = "Mic Boost",
	.index = 1,
	.info = snd_miro_info_preamp,
	.get = snd_miro_get_preamp,
	.put = snd_miro_put_preamp,
}};

static struct snd_kcontrol_new snd_miro_amp_control[] __devinitdata = {
{
	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
	.name = "Line Boost",
	.index = 0,
	.info = snd_miro_info_amp,
	.get = snd_miro_get_amp,
	.put = snd_miro_put_amp,
}};

static struct snd_kcontrol_new snd_miro_capture_control[] __devinitdata = {
{
	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
	.name = "PCM Capture Switch",
	.index = 0,
	.info = snd_miro_info_capture,
	.get = snd_miro_get_capture,
	.put = snd_miro_put_capture,
}};

static unsigned char aci_init_values[][2] __devinitdata = {
	{ ACI_SET_MUTE, 0x00 },
	{ ACI_SET_POWERAMP, 0x00 },
	{ ACI_SET_PREAMP, 0x00 },
	{ ACI_SET_SOLOMODE, 0x00 },
	{ ACI_SET_MIC + 0, 0x20 },
	{ ACI_SET_MIC + 8, 0x20 },
	{ ACI_SET_LINE + 0, 0x20 },
	{ ACI_SET_LINE + 8, 0x20 },
	{ ACI_SET_CD + 0, 0x20 },
	{ ACI_SET_CD + 8, 0x20 },
	{ ACI_SET_PCM + 0, 0x20 },
	{ ACI_SET_PCM + 8, 0x20 },
	{ ACI_SET_LINE1 + 0, 0x20 },
	{ ACI_SET_LINE1 + 8, 0x20 },
	{ ACI_SET_LINE2 + 0, 0x20 },
	{ ACI_SET_LINE2 + 8, 0x20 },
	{ ACI_SET_SYNTH + 0, 0x20 },
	{ ACI_SET_SYNTH + 8, 0x20 },
	{ ACI_SET_MASTER + 0, 0x20 },
	{ ACI_SET_MASTER + 1, 0x20 },
};

static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
{
	int idx, error;
	struct snd_miro_aci *aci = miro->aci;

	/* enable WSS on PCM1 */

	if ((aci->aci_product == 'A') && wss) {
		error = aci_setvalue(aci, ACI_SET_WSS, wss);
		if (error < 0) {
			snd_printk(KERN_ERR "enabling WSS mode failed\n");
			return error;
		}
	}

	/* enable IDE port */

	if (ide) {
		error = aci_setvalue(aci, ACI_SET_IDE, ide);
		if (error < 0) {
			snd_printk(KERN_ERR "enabling IDE port failed\n");
			return error;
		}
	}

	/* set common aci values */

	for (idx = 0; idx < ARRAY_SIZE(aci_init_values); idx++) {
		error = aci_setvalue(aci, aci_init_values[idx][0],
				     aci_init_values[idx][1]);
		if (error < 0) {
			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n", 
				   aci_init_values[idx][0], error);
                        return error;
                }
	}
	aci->aci_amp = 0;
	aci->aci_preamp = 0;
	aci->aci_solomode = 1;

	return 0;
}

static int __devinit snd_miro_mixer(struct snd_card *card,
				    struct snd_miro *miro)
{
	unsigned int idx;
	int err;

	if (snd_BUG_ON(!miro || !card))
		return -EINVAL;

	switch (miro->hardware) {
	case OPTi9XX_HW_82C924:
		strcpy(card->mixername, "ACI & OPTi924");
		break;
	case OPTi9XX_HW_82C929:
		strcpy(card->mixername, "ACI & OPTi929");
		break;
	default:
		snd_BUG();
		break;
	}

	for (idx = 0; idx < ARRAY_SIZE(snd_miro_controls); idx++) {
		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_controls[idx], miro))) < 0)
			return err;
	}

	if ((miro->aci->aci_product == 'A') ||
	    (miro->aci->aci_product == 'B')) {
		/* PCM1/PCM12 with power-amp and Line 2 */
		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_line_control[0], miro))) < 0)
			return err;
		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_amp_control[0], miro))) < 0)
			return err;
	}

	if ((miro->aci->aci_product == 'B') ||
	    (miro->aci->aci_product == 'C')) {
		/* PCM12/PCM20 with mic-preamp */
		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_preamp_control[0], miro))) < 0)
			return err;
		if (miro->aci->aci_version >= 176)
			if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_capture_control[0], miro))) < 0)
				return err;
	}

	if (miro->aci->aci_product == 'C') {
		/* PCM20 with radio and 7 band equalizer */
		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_radio_control[0], miro))) < 0)
			return err;
		for (idx = 0; idx < ARRAY_SIZE(snd_miro_eq_controls); idx++) {
			if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_eq_controls[idx], miro))) < 0)
				return err;
		}
	}

	return 0;
}

static long snd_legacy_find_free_ioport(long *port_table, long size)
{
	while (*port_table != -1) {
		struct resource *res;
		if ((res = request_region(*port_table, size, 
					  "ALSA test")) != NULL) {
			release_and_free_resource(res);
			return *port_table;
		}
		port_table++;
	}
	return -1;
}

static int __devinit snd_miro_init(struct snd_miro *chip,
				   unsigned short hardware)
{
	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};

	chip->hardware = hardware;
	strcpy(chip->name, snd_opti9xx_names[hardware]);

	chip->mc_base_size = opti9xx_mc_size[hardware];  

	spin_lock_init(&chip->lock);

	chip->wss_base = -1;
	chip->irq = -1;
	chip->dma1 = -1;
	chip->dma2 = -1;
	chip->mpu_port = -1;
	chip->mpu_irq = -1;

	chip->pwd_reg = 3;

#ifdef CONFIG_PNP
	if (isapnp && chip->mc_base)
		/* PnP resource gives the least 10 bits */
		chip->mc_base |= 0xc00;
	else
#endif
		chip->mc_base = 0xf8c;

	switch (hardware) {
	case OPTi9XX_HW_82C929:
		chip->password = 0xe3;
		break;

	case OPTi9XX_HW_82C924:
		chip->password = 0xe5;
		break;

	default:
		snd_printk(KERN_ERR "sorry, no support for %d\n", hardware);
		return -ENODEV;
	}

	return 0;
}

static unsigned char snd_miro_read(struct snd_miro *chip,
				   unsigned char reg)
{
	unsigned long flags;
	unsigned char retval = 0xff;

	spin_lock_irqsave(&chip->lock, flags);
	outb(chip->password, chip->mc_base + chip->pwd_reg);

	switch (chip->hardware) {
	case OPTi9XX_HW_82C924:
		if (reg > 7) {
			outb(reg, chip->mc_base + 8);
			outb(chip->password, chip->mc_base + chip->pwd_reg);
			retval = inb(chip->mc_base + 9);
			break;
		}

	case OPTi9XX_HW_82C929:
		retval = inb(chip->mc_base + reg);
		break;

	default:
		snd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);
	}

	spin_unlock_irqrestore(&chip->lock, flags);
	return retval;
}

static void snd_miro_write(struct snd_miro *chip, unsigned char reg,
			   unsigned char value)
{
	unsigned long flags;

	spin_lock_irqsave(&chip->lock, flags);
	outb(chip->password, chip->mc_base + chip->pwd_reg);

	switch (chip->hardware) {
	case OPTi9XX_HW_82C924:
		if (reg > 7) {
			outb(reg, chip->mc_base + 8);
			outb(chip->password, chip->mc_base + chip->pwd_reg);
			outb(value, chip->mc_base + 9);
			break;
		}

	case OPTi9XX_HW_82C929:
		outb(value, chip->mc_base + reg);
		break;

	default:
		snd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);
	}

	spin_unlock_irqrestore(&chip->lock, flags);
}


#define snd_miro_write_mask(chip, reg, value, mask)	\
	snd_miro_write(chip, reg,			\
		(snd_miro_read(chip, reg) & ~(mask)) | ((value) & (mask)))

/*
 *  Proc Interface
 */

static void snd_miro_proc_read(struct snd_info_entry * entry, 
			       struct snd_info_buffer *buffer)
{
	struct snd_miro *miro = (struct snd_miro *) entry->private_data;
	struct snd_miro_aci *aci = miro->aci;
	char* model = "unknown";

	/* miroSOUND PCM1 pro, early PCM12 */

	if ((miro->hardware == OPTi9XX_HW_82C929) &&
	    (aci->aci_vendor == 'm') &&
	    (aci->aci_product == 'A')) {
		switch (aci->aci_version) {
		case 3:
			model = "miroSOUND PCM1 pro";
			break;
		default:
			model = "miroSOUND PCM1 pro / (early) PCM12";
			break;
		}
	}

	/* miroSOUND PCM12, PCM12 (Rev. E), PCM12 pnp */

	if ((miro->hardware == OPTi9XX_HW_82C924) &&
	    (aci->aci_vendor == 'm') &&
	    (aci->aci_product == 'B')) {
		switch (aci->aci_version) {
		case 4:
			model = "miroSOUND PCM12";
			break;
		case 176:
			model = "miroSOUND PCM12 (Rev. E)";
			break;
		default:
			model = "miroSOUND PCM12 / PCM12 pnp";
			break;
		}
	}

	/* miroSOUND PCM20 radio */

	if ((miro->hardware == OPTi9XX_HW_82C924) &&
	    (aci->aci_vendor == 'm') &&
	    (aci->aci_product == 'C')) {
		switch (aci->aci_version) {
		case 7:
			model = "miroSOUND PCM20 radio (Rev. E)";
			break;
		default:
			model = "miroSOUND PCM20 radio";
			break;
		}
	}

	snd_iprintf(buffer, "\nGeneral information:\n");
	snd_iprintf(buffer, "  model   : %s\n", model);
	snd_iprintf(buffer, "  opti    : %s\n", miro->name);
	snd_iprintf(buffer, "  codec   : %s\n", miro->pcm->name);
	snd_iprintf(buffer, "  port    : 0x%lx\n", miro->wss_base);
	snd_iprintf(buffer, "  irq     : %d\n", miro->irq);
	snd_iprintf(buffer, "  dma     : %d,%d\n\n", miro->dma1, miro->dma2);

	snd_iprintf(buffer, "MPU-401:\n");
	snd_iprintf(buffer, "  port    : 0x%lx\n", miro->mpu_port);
	snd_iprintf(buffer, "  irq     : %d\n\n", miro->mpu_irq);

	snd_iprintf(buffer, "ACI information:\n");
	snd_iprintf(buffer, "  vendor  : ");
	switch (aci->aci_vendor) {
	case 'm':
		snd_iprintf(buffer, "Miro\n");
		break;
	default:
		snd_iprintf(buffer, "unknown (0x%x)\n", aci->aci_vendor);
		break;
	}

	snd_iprintf(buffer, "  product : ");
	switch (aci->aci_product) {
	case 'A':
		snd_iprintf(buffer, "miroSOUND PCM1 pro / (early) PCM12\n");
		break;
	case 'B':
		snd_iprintf(buffer, "miroSOUND PCM12\n");
		break;
	case 'C':
		snd_iprintf(buffer, "miroSOUND PCM20 radio\n");
		break;
	default:
		snd_iprintf(buffer, "unknown (0x%x)\n", aci->aci_product);
		break;
	}

	snd_iprintf(buffer, "  firmware: %d (0x%x)\n",
		    aci->aci_version, aci->aci_version);
	snd_iprintf(buffer, "  port    : 0x%lx-0x%lx\n", 
		    aci->aci_port, aci->aci_port+2);
	snd_iprintf(buffer, "  wss     : 0x%x\n", wss);
	snd_iprintf(buffer, "  ide     : 0x%x\n", ide);
	snd_iprintf(buffer, "  solomode: 0x%x\n", aci->aci_solomode);
	snd_iprintf(buffer, "  amp     : 0x%x\n", aci->aci_amp);
	snd_iprintf(buffer, "  preamp  : 0x%x\n", aci->aci_preamp);
}

static void __devinit snd_miro_proc_init(struct snd_card *card,
					 struct snd_miro *miro)
{
	struct snd_info_entry *entry;

	if (!snd_card_proc_new(card, "miro", &entry))
		snd_info_set_text_ops(entry, miro, snd_miro_proc_read);
}

/*
 *  Init
 */

static int __devinit snd_miro_configure(struct snd_miro *chip)
{
	unsigned char wss_base_bits;
	unsigned char irq_bits;
	unsigned char dma_bits;
	unsigned char mpu_port_bits = 0;
	unsigned char mpu_irq_bits;
	unsigned long flags;

	snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
	snd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20); /* OPL4 */
	snd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);

	switch (chip->hardware) {
	case OPTi9XX_HW_82C924:
		snd_miro_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);
		snd_miro_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
		break;
	case OPTi9XX_HW_82C929:
		/* untested init commands for OPTi929 */
		snd_miro_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);
		break;
	default:
		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
		return -EINVAL;
	}

	/* PnP resource says it decodes only 10 bits of address */
	switch (chip->wss_base & 0x3ff) {
	case 0x130:
		chip->wss_base = 0x530;
		wss_base_bits = 0x00;
		break;
	case 0x204:
		chip->wss_base = 0x604;
		wss_base_bits = 0x03;
		break;
	case 0x280:
		chip->wss_base = 0xe80;
		wss_base_bits = 0x01;
		break;
	case 0x340:
		chip->wss_base = 0xf40;
		wss_base_bits = 0x02;
		break;
	default:
		snd_printk(KERN_ERR "WSS port 0x%lx not valid\n", chip->wss_base);
		goto __skip_base;
	}
	snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);

__skip_base:
	switch (chip->irq) {
	case 5:
		irq_bits = 0x05;
		break;
	case 7:
		irq_bits = 0x01;
		break;
	case 9:
		irq_bits = 0x02;
		break;
	case 10:
		irq_bits = 0x03;
		break;
	case 11:
		irq_bits = 0x04;
		break;
	default:
		snd_printk(KERN_ERR "WSS irq # %d not valid\n", chip->irq);
		goto __skip_resources;
	}

	switch (chip->dma1) {
	case 0:
		dma_bits = 0x01;
		break;
	case 1:
		dma_bits = 0x02;
		break;
	case 3:
		dma_bits = 0x03;
		break;
	default:
		snd_printk(KERN_ERR "WSS dma1 # %d not valid\n", chip->dma1);
		goto __skip_resources;
	}

	if (chip->dma1 == chip->dma2) {
		snd_printk(KERN_ERR "don't want to share dmas\n");
		return -EBUSY;
	}

	switch (chip->dma2) {
	case 0:
	case 1:
		break;
	default:
		snd_printk(KERN_ERR "WSS dma2 # %d not valid\n", chip->dma2);
		goto __skip_resources;
	}
	dma_bits |= 0x04;

	spin_lock_irqsave(&chip->lock, flags);
	outb(irq_bits << 3 | dma_bits, chip->wss_base);
	spin_unlock_irqrestore(&chip->lock, flags);

__skip_resources:
	if (chip->hardware > OPTi9XX_HW_82C928) {
		switch (chip->mpu_port) {
		case 0:
		case -1:
			break;
		case 0x300:
			mpu_port_bits = 0x03;
			break;
		case 0x310:
			mpu_port_bits = 0x02;
			break;
		case 0x320:
			mpu_port_bits = 0x01;
			break;
		case 0x330:
			mpu_port_bits = 0x00;
			break;
		default:
			snd_printk(KERN_ERR "MPU-401 port 0x%lx not valid\n",
				   chip->mpu_port);
			goto __skip_mpu;
		}

		switch (chip->mpu_irq) {
		case 5:
			mpu_irq_bits = 0x02;
			break;
		case 7:
			mpu_irq_bits = 0x03;
			break;
		case 9:
			mpu_irq_bits = 0x00;
			break;
		case 10:
			mpu_irq_bits = 0x01;
			break;
		default:
			snd_printk(KERN_ERR "MPU-401 irq # %d not valid\n",
				   chip->mpu_irq);
			goto __skip_mpu;
		}

		snd_miro_write_mask(chip, OPTi9XX_MC_REG(6),
			(chip->mpu_port <= 0) ? 0x00 :
				0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,
			0xf8);
	}
__skip_mpu:

	return 0;
}

static int __devinit snd_miro_opti_check(struct snd_miro *chip)
{
	unsigned char value;

	chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,
					   "OPTi9xx MC");
	if (chip->res_mc_base == NULL)
		return -ENOMEM;

	value = snd_miro_read(chip, OPTi9XX_MC_REG(1));
	if (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))
		if (value == snd_miro_read(chip, OPTi9XX_MC_REG(1)))
			return 0;

	release_and_free_resource(chip->res_mc_base);
	chip->res_mc_base = NULL;

	return -ENODEV;
}

static int __devinit snd_card_miro_detect(struct snd_card *card,
					  struct snd_miro *chip)
{
	int i, err;

	for (i = OPTi9XX_HW_82C929; i <= OPTi9XX_HW_82C924; i++) {

		if ((err = snd_miro_init(chip, i)) < 0)
			return err;

		err = snd_miro_opti_check(chip);
		if (err == 0)
			return 1;
	}

	return -ENODEV;
}

static int __devinit snd_card_miro_aci_detect(struct snd_card *card,
					      struct snd_miro *miro)
{
	unsigned char regval;
	int i;
	struct snd_miro_aci *aci = &aci_device;

	miro->aci = aci;

	mutex_init(&aci->aci_mutex);

	/* get ACI port from OPTi9xx MC 4 */

	regval=inb(miro->mc_base + 4);
	aci->aci_port = (regval & 0x10) ? 0x344 : 0x354;

	miro->res_aci_port = request_region(aci->aci_port, 3, "miro aci");
	if (miro->res_aci_port == NULL) {
		snd_printk(KERN_ERR "aci i/o area 0x%lx-0x%lx already used.\n", 
			   aci->aci_port, aci->aci_port+2);
		return -ENOMEM;
	}

        /* force ACI into a known state */
	for (i = 0; i < 3; i++)
		if (snd_aci_cmd(aci, ACI_ERROR_OP, -1, -1) < 0) {
			snd_printk(KERN_ERR "can't force aci into known state.\n");
			return -ENXIO;
		}

	aci->aci_vendor = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);
	aci->aci_product = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);
	if (aci->aci_vendor < 0 || aci->aci_product < 0) {
		snd_printk(KERN_ERR "can't read aci id on 0x%lx.\n",
			   aci->aci_port);
		return -ENXIO;
	}

	aci->aci_version = snd_aci_cmd(aci, ACI_READ_VERSION, -1, -1);
	if (aci->aci_version < 0) {
		snd_printk(KERN_ERR "can't read aci version on 0x%lx.\n", 
			   aci->aci_port);
		return -ENXIO;
	}

	if (snd_aci_cmd(aci, ACI_INIT, -1, -1) < 0 ||
	    snd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0 ||
	    snd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0) {
		snd_printk(KERN_ERR "can't initialize aci.\n"); 
		return -ENXIO;
	}

	return 0;
}

static void snd_card_miro_free(struct snd_card *card)
{
	struct snd_miro *miro = card->private_data;

	release_and_free_resource(miro->res_aci_port);
	if (miro->aci)
		miro->aci->aci_port = 0;
	release_and_free_resource(miro->res_mc_base);
}

static int __devinit snd_miro_probe(struct snd_card *card)
{
	int error;
	struct snd_miro *miro = card->private_data;
	struct snd_wss *codec;
	struct snd_timer *timer;
	struct snd_pcm *pcm;
	struct snd_rawmidi *rmidi;

	if (!miro->res_mc_base) {
		miro->res_mc_base = request_region(miro->mc_base,
						miro->mc_base_size,
						"miro (OPTi9xx MC)");
		if (miro->res_mc_base == NULL) {
			snd_printk(KERN_ERR "request for OPTI9xx MC failed\n");
			return -ENOMEM;
		}
	}

	error = snd_card_miro_aci_detect(card, miro);
	if (error < 0) {
		snd_card_free(card);
		snd_printk(KERN_ERR "unable to detect aci chip\n");
		return -ENODEV;
	}

	miro->wss_base = port;
	miro->mpu_port = mpu_port;
	miro->irq = irq;
	miro->mpu_irq = mpu_irq;
	miro->dma1 = dma1;
	miro->dma2 = dma2;

	/* init proc interface */
	snd_miro_proc_init(card, miro);

	error = snd_miro_configure(miro);
	if (error)
		return error;

	error = snd_wss_create(card, miro->wss_base + 4, -1,
			       miro->irq, miro->dma1, miro->dma2,
			       WSS_HW_DETECT, 0, &codec);
	if (error < 0)
		return error;

	error = snd_wss_pcm(codec, 0, &pcm);
	if (error < 0)
		return error;

	error = snd_wss_mixer(codec);
	if (error < 0)
		return error;

	error = snd_wss_timer(codec, 0, &timer);
	if (error < 0)
		return error;

	miro->pcm = pcm;

	error = snd_miro_mixer(card, miro);
	if (error < 0)
		return error;

	if (miro->aci->aci_vendor == 'm') {
		/* It looks like a miro sound card. */
		switch (miro->aci->aci_product) {
		case 'A':
			sprintf(card->shortname, 
				"miroSOUND PCM1 pro / PCM12");
			break;
		case 'B':
			sprintf(card->shortname, 
				"miroSOUND PCM12");
			break;
		case 'C':
			sprintf(card->shortname, 
				"miroSOUND PCM20 radio");
			break;
		default:
			sprintf(card->shortname, 
				"unknown miro");
			snd_printk(KERN_INFO "unknown miro aci id\n");
			break;
		}
	} else {
		snd_printk(KERN_INFO "found unsupported aci card\n");
		sprintf(card->shortname, "unknown Cardinal Technologies");
	}

	strcpy(card->driver, "miro");
	sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
		card->shortname, miro->name, pcm->name, miro->wss_base + 4,
		miro->irq, miro->dma1, miro->dma2);

	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)
		rmidi = NULL;
	else {
		error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
				mpu_port, 0, miro->mpu_irq, IRQF_DISABLED,
				&rmidi);
		if (error < 0)
			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",
				   mpu_port);
	}

	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {
		struct snd_opl3 *opl3 = NULL;
		struct snd_opl4 *opl4;

		if (snd_opl4_create(card, fm_port, fm_port - 8,
				    2, &opl3, &opl4) < 0)
			snd_printk(KERN_WARNING "no OPL4 device at 0x%lx\n",
				   fm_port);
	}

	error = snd_set_aci_init_values(miro);
	if (error < 0)
                return error;

	return snd_card_register(card);
}

static int __devinit snd_miro_isa_match(struct device *devptr, unsigned int n)
{
#ifdef CONFIG_PNP
	if (snd_miro_pnp_is_probed)
		return 0;
	if (isapnp)
		return 0;
#endif
	return 1;
}

static int __devinit snd_miro_isa_probe(struct device *devptr, unsigned int n)
{
	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
	static long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
	static int possible_irqs[] = {11, 9, 10, 7, -1};
	static int possible_mpu_irqs[] = {10, 5, 9, 7, -1};
	static int possible_dma1s[] = {3, 1, 0, -1};
	static int possible_dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1},
					   {0, -1} };

	int error;
	struct snd_miro *miro;
	struct snd_card *card;

	error = snd_card_create(index, id, THIS_MODULE,
				sizeof(struct snd_miro), &card);
	if (error < 0)
		return error;

	card->private_free = snd_card_miro_free;
	miro = card->private_data;

	error = snd_card_miro_detect(card, miro);
	if (error < 0) {
		snd_card_free(card);
		snd_printk(KERN_ERR "unable to detect OPTi9xx chip\n");
		return -ENODEV;
	}

	if (port == SNDRV_AUTO_PORT) {
		port = snd_legacy_find_free_ioport(possible_ports, 4);
		if (port < 0) {
			snd_card_free(card);
			snd_printk(KERN_ERR "unable to find a free WSS port\n");
			return -EBUSY;
		}
	}

	if (mpu_port == SNDRV_AUTO_PORT) {
		mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2);
		if (mpu_port < 0) {
			snd_card_free(card);
			snd_printk(KERN_ERR
				   "unable to find a free MPU401 port\n");
			return -EBUSY;
		}
	}

	if (irq == SNDRV_AUTO_IRQ) {
		irq = snd_legacy_find_free_irq(possible_irqs);
		if (irq < 0) {
			snd_card_free(card);
			snd_printk(KERN_ERR "unable to find a free IRQ\n");
			return -EBUSY;
		}
	}
	if (mpu_irq == SNDRV_AUTO_IRQ) {
		mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs);
		if (mpu_irq < 0) {
			snd_card_free(card);
			snd_printk(KERN_ERR
				   "unable to find a free MPU401 IRQ\n");
			return -EBUSY;
		}
	}
	if (dma1 == SNDRV_AUTO_DMA) {
		dma1 = snd_legacy_find_free_dma(possible_dma1s);
		if (dma1 < 0) {
			snd_card_free(card);
			snd_printk(KERN_ERR "unable to find a free DMA1\n");
			return -EBUSY;
		}
	}
	if (dma2 == SNDRV_AUTO_DMA) {
		dma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4]);
		if (dma2 < 0) {
			snd_card_free(card);
			snd_printk(KERN_ERR "unable to find a free DMA2\n");
			return -EBUSY;
		}
	}

	snd_card_set_dev(card, devptr);

	error = snd_miro_probe(card);
	if (error < 0) {
		snd_card_free(card);
		return error;
	}

	dev_set_drvdata(devptr, card);
	return 0;
}

static int __devexit snd_miro_isa_remove(struct device *devptr,
					 unsigned int dev)
{
	snd_card_free(dev_get_drvdata(devptr));
	dev_set_drvdata(devptr, NULL);
	return 0;
}

#define DEV_NAME "miro"

static struct isa_driver snd_miro_driver = {
	.match		= snd_miro_isa_match,
	.probe		= snd_miro_isa_probe,
	.remove		= __devexit_p(snd_miro_isa_remove),
	/* FIXME: suspend/resume */
	.driver		= {
		.name	= DEV_NAME
	},
};

#ifdef CONFIG_PNP

static int __devinit snd_card_miro_pnp(struct snd_miro *chip,
					struct pnp_card_link *card,
					const struct pnp_card_device_id *pid)
{
	struct pnp_dev *pdev;
	int err;
	struct pnp_dev *devmpu;
	struct pnp_dev *devmc;

	pdev = pnp_request_card_device(card, pid->devs[0].id, NULL);
	if (pdev == NULL)
		return -EBUSY;

	devmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);
	if (devmpu == NULL)
		return -EBUSY;

	devmc = pnp_request_card_device(card, pid->devs[2].id, NULL);
	if (devmc == NULL)
		return -EBUSY;

	err = pnp_activate_dev(pdev);
	if (err < 0) {
		snd_printk(KERN_ERR "AUDIO pnp configure failure: %d\n", err);
		return err;
	}

	err = pnp_activate_dev(devmc);
	if (err < 0) {
		snd_printk(KERN_ERR "MC pnp configure failure: %d\n",
				    err);
		return err;
	}

	port = pnp_port_start(pdev, 1);
	fm_port = pnp_port_start(pdev, 2) + 8;

	/*
	 * The MC(0) is never accessed and the miroSOUND PCM20 card does not
	 * include it in the PnP resource range. OPTI93x include it.
	 */
	chip->mc_base = pnp_port_start(devmc, 0) - 1;
	chip->mc_base_size = pnp_port_len(devmc, 0) + 1;

	irq = pnp_irq(pdev, 0);
	dma1 = pnp_dma(pdev, 0);
	dma2 = pnp_dma(pdev, 1);

	if (mpu_port > 0) {
		err = pnp_activate_dev(devmpu);
		if (err < 0) {
			snd_printk(KERN_ERR "MPU401 pnp configure failure\n");
			mpu_port = -1;
			return err;
		}
		mpu_port = pnp_port_start(devmpu, 0);
		mpu_irq = pnp_irq(devmpu, 0);
	}
	return 0;
}

static int __devinit snd_miro_pnp_probe(struct pnp_card_link *pcard,
					const struct pnp_card_device_id *pid)
{
	struct snd_card *card;
	int err;
	struct snd_miro *miro;

	if (snd_miro_pnp_is_probed)
		return -EBUSY;
	if (!isapnp)
		return -ENODEV;
	err = snd_card_create(index, id, THIS_MODULE,
				sizeof(struct snd_miro), &card);
	if (err < 0)
		return err;

	card->private_free = snd_card_miro_free;
	miro = card->private_data;

	err = snd_card_miro_pnp(miro, pcard, pid);
	if (err) {
		snd_card_free(card);
		return err;
	}

	/* only miroSOUND PCM20 and PCM12 == OPTi924 */
	err = snd_miro_init(miro, OPTi9XX_HW_82C924);
	if (err) {
		snd_card_free(card);
		return err;
	}

	err = snd_miro_opti_check(miro);
	if (err) {
		snd_printk(KERN_ERR "OPTI chip not found\n");
		snd_card_free(card);
		return err;
	}

	snd_card_set_dev(card, &pcard->card->dev);
	err = snd_miro_probe(card);
	if (err < 0) {
		snd_card_free(card);
		return err;
	}
	pnp_set_card_drvdata(pcard, card);
	snd_miro_pnp_is_probed = 1;
	return 0;
}

static void __devexit snd_miro_pnp_remove(struct pnp_card_link * pcard)
{
	snd_card_free(pnp_get_card_drvdata(pcard));
	pnp_set_card_drvdata(pcard, NULL);
	snd_miro_pnp_is_probed = 0;
}

static struct pnp_card_driver miro_pnpc_driver = {
	.flags		= PNP_DRIVER_RES_DISABLE,
	.name		= "miro",
	.id_table	= snd_miro_pnpids,
	.probe		= snd_miro_pnp_probe,
	.remove		= __devexit_p(snd_miro_pnp_remove),
};
#endif

static int __init alsa_card_miro_init(void)
{
#ifdef CONFIG_PNP
	pnp_register_card_driver(&miro_pnpc_driver);
	if (snd_miro_pnp_is_probed)
		return 0;
	pnp_unregister_card_driver(&miro_pnpc_driver);
#endif
	return isa_register_driver(&snd_miro_driver, 1);
}

static void __exit alsa_card_miro_exit(void)
{
	if (!snd_miro_pnp_is_probed) {
		isa_unregister_driver(&snd_miro_driver);
		return;
	}
#ifdef CONFIG_PNP
	pnp_unregister_card_driver(&miro_pnpc_driver);
#endif
}

module_init(alsa_card_miro_init)
module_exit(alsa_card_miro_exit)
/******************************************************************************
 *
 *	(C)Copyright 1998,1999 SysKonnect,
 *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
 *
 *	See the file "skfddi.c" for further information.
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	The information in this file is provided "AS IS" without warranty.
 *
 ******************************************************************************/

/*
 * FBI board dependent Driver for SMT and LLC
 */

#include "h/types.h"
#include "h/fddi.h"
#include "h/smc.h"
#include "h/supern_2.h"
#include "h/skfbiinc.h"
#include <linux/bitrev.h>

#ifndef	lint
static const char ID_sccs[] = "@(#)drvfbi.c	1.63 99/02/11 (C) SK " ;
#endif

/*
 * PCM active state
 */
#define PC8_ACTIVE	8

#define	LED_Y_ON	0x11	/* Used for ring up/down indication */
#define	LED_Y_OFF	0x10


#define MS2BCLK(x)	((x)*12500L)

/*
 * valid configuration values are:
 */

/*
 *	xPOS_ID:xxxx
 *	|	\  /
 *	|	 \/
 *	|	  --------------------- the patched POS_ID of the Adapter
 *	|				xxxx = (Vendor ID low byte,
 *	|					Vendor ID high byte,
 *	|					Device ID low byte,
 *	|					Device ID high byte)
 *	+------------------------------ the patched oem_id must be
 *					'S' for SK or 'I' for IBM
 *					this is a short id for the driver.
 */
#ifndef MULT_OEM
#ifndef	OEM_CONCEPT
const u_char oem_id[] = "xPOS_ID:xxxx" ;
#else	/* OEM_CONCEPT */
const u_char oem_id[] = OEM_ID ;
#endif	/* OEM_CONCEPT */
#define	ID_BYTE0	8
#define	OEMID(smc,i)	oem_id[ID_BYTE0 + i]
#else	/* MULT_OEM */
const struct s_oem_ids oem_ids[] = {
#include "oemids.h"
{0}
};
#define	OEMID(smc,i)	smc->hw.oem_id->oi_id[i]
#endif	/* MULT_OEM */

/* Prototypes of external functions */
#ifdef AIX
extern int AIX_vpdReadByte() ;
#endif


/* Prototype of a local function. */
static void smt_stop_watchdog(struct s_smc *smc);

/*
 * FDDI card reset
 */
static void card_start(struct s_smc *smc)
{
	int i ;
#ifdef	PCI
	u_char	rev_id ;
	u_short word;
#endif

	smt_stop_watchdog(smc) ;

#ifdef	PCI
	/*
	 * make sure no transfer activity is pending
	 */
	outpw(FM_A(FM_MDREG1),FM_MINIT) ;
	outp(ADDR(B0_CTRL), CTRL_HPI_SET) ;
	hwt_wait_time(smc,hwt_quick_read(smc),MS2BCLK(10)) ;
	/*
	 * now reset everything
	 */
	outp(ADDR(B0_CTRL),CTRL_RST_SET) ;	/* reset for all chips */
	i = (int) inp(ADDR(B0_CTRL)) ;		/* do dummy read */
	SK_UNUSED(i) ;				/* Make LINT happy. */
	outp(ADDR(B0_CTRL), CTRL_RST_CLR) ;

	/*
	 * Reset all bits in the PCI STATUS register
	 */
	outp(ADDR(B0_TST_CTRL), TST_CFG_WRITE_ON) ;	/* enable for writes */
	word = inpw(PCI_C(PCI_STATUS)) ;
	outpw(PCI_C(PCI_STATUS), word | PCI_ERRBITS) ;
	outp(ADDR(B0_TST_CTRL), TST_CFG_WRITE_OFF) ;	/* disable writes */

	/*
	 * Release the reset of all the State machines
	 * Release Master_Reset
	 * Release HPI_SM_Reset
	 */
	outp(ADDR(B0_CTRL), CTRL_MRST_CLR|CTRL_HPI_CLR) ;

	/*
	 * determine the adapter type
	 * Note: Do it here, because some drivers may call card_start() once
	 *	 at very first before any other initialization functions is
	 *	 executed.
	 */
	rev_id = inp(PCI_C(PCI_REV_ID)) ;
	if ((rev_id & 0xf0) == SK_ML_ID_1 || (rev_id & 0xf0) == SK_ML_ID_2) {
		smc->hw.hw_is_64bit = TRUE ;
	} else {
		smc->hw.hw_is_64bit = FALSE ;
	}

	/*
	 * Watermark initialization
	 */
	if (!smc->hw.hw_is_64bit) {
		outpd(ADDR(B4_R1_F), RX_WATERMARK) ;
		outpd(ADDR(B5_XA_F), TX_WATERMARK) ;
		outpd(ADDR(B5_XS_F), TX_WATERMARK) ;
	}

	outp(ADDR(B0_CTRL),CTRL_RST_CLR) ;	/* clear the reset chips */
	outp(ADDR(B0_LED),LED_GA_OFF|LED_MY_ON|LED_GB_OFF) ; /* ye LED on */

	/* init the timer value for the watch dog 2,5 minutes */
	outpd(ADDR(B2_WDOG_INI),0x6FC23AC0) ;

	/* initialize the ISR mask */
	smc->hw.is_imask = ISR_MASK ;
	smc->hw.hw_state = STOPPED ;
#endif
	GET_PAGE(0) ;		/* necessary for BOOT */
}

void card_stop(struct s_smc *smc)
{
	smt_stop_watchdog(smc) ;
	smc->hw.mac_ring_is_up = 0 ;		/* ring down */

#ifdef	PCI
	/*
	 * make sure no transfer activity is pending
	 */
	outpw(FM_A(FM_MDREG1),FM_MINIT) ;
	outp(ADDR(B0_CTRL), CTRL_HPI_SET) ;
	hwt_wait_time(smc,hwt_quick_read(smc),MS2BCLK(10)) ;
	/*
	 * now reset everything
	 */
	outp(ADDR(B0_CTRL),CTRL_RST_SET) ;	/* reset for all chips */
	outp(ADDR(B0_CTRL),CTRL_RST_CLR) ;	/* reset for all chips */
	outp(ADDR(B0_LED),LED_GA_OFF|LED_MY_OFF|LED_GB_OFF) ; /* all LEDs off */
	smc->hw.hw_state = STOPPED ;
#endif
}
/*--------------------------- ISR handling ----------------------------------*/

void mac1_irq(struct s_smc *smc, u_short stu, u_short stl)
{
	int	restart_tx = 0 ;
again:

	/*
	 * parity error: note encoding error is not possible in tag mode
	 */
	if (stl & (FM_SPCEPDS  |	/* parity err. syn.q.*/
		   FM_SPCEPDA0 |	/* parity err. a.q.0 */
		   FM_SPCEPDA1)) {	/* parity err. a.q.1 */
		SMT_PANIC(smc,SMT_E0134, SMT_E0134_MSG) ;
	}
	/*
	 * buffer underrun: can only occur if a tx threshold is specified
	 */
	if (stl & (FM_STBURS  |		/* tx buffer underrun syn.q.*/
		   FM_STBURA0 |		/* tx buffer underrun a.q.0 */
		   FM_STBURA1)) {	/* tx buffer underrun a.q.2 */
		SMT_PANIC(smc,SMT_E0133, SMT_E0133_MSG) ;
	}

	if ( (stu & (FM_SXMTABT |		/* transmit abort */
		     FM_STXABRS |		/* syn. tx abort */
		     FM_STXABRA0)) ||		/* asyn. tx abort */
	     (stl & (FM_SQLCKS |		/* lock for syn. q. */
		     FM_SQLCKA0)) ) {		/* lock for asyn. q. */
		formac_tx_restart(smc) ;	/* init tx */
		restart_tx = 1 ;
		stu = inpw(FM_A(FM_ST1U)) ;
		stl = inpw(FM_A(FM_ST1L)) ;
		stu &= ~ (FM_STECFRMA0 | FM_STEFRMA0 | FM_STEFRMS) ;
		if (stu || stl)
			goto again ;
	}

	if (stu & (FM_STEFRMA0 |	/* end of asyn tx */
		    FM_STEFRMS)) {	/* end of sync tx */
		restart_tx = 1 ;
	}

	if (restart_tx)
		llc_restart_tx(smc) ;
}

/*
 * interrupt source= plc1
 * this function is called in nwfbisr.asm
 */
void plc1_irq(struct s_smc *smc)
{
	u_short	st = inpw(PLC(PB,PL_INTR_EVENT)) ;

	plc_irq(smc,PB,st) ;
}

/*
 * interrupt source= plc2
 * this function is called in nwfbisr.asm
 */
void plc2_irq(struct s_smc *smc)
{
	u_short	st = inpw(PLC(PA,PL_INTR_EVENT)) ;

	plc_irq(smc,PA,st) ;
}


/*
 * interrupt source= timer
 */
void timer_irq(struct s_smc *smc)
{
	hwt_restart(smc);
	smc->hw.t_stop = smc->hw.t_start;
	smt_timer_done(smc) ;
}

/*
 * return S-port (PA or PB)
 */
int pcm_get_s_port(struct s_smc *smc)
{
	SK_UNUSED(smc) ;
	return(PS) ;
}

/*
 * Station Label = "FDDI-XYZ" where
 *
 *	X = connector type
 *	Y = PMD type
 *	Z = port type
 */
#define STATION_LABEL_CONNECTOR_OFFSET	5
#define STATION_LABEL_PMD_OFFSET	6
#define STATION_LABEL_PORT_OFFSET	7

void read_address(struct s_smc *smc, u_char *mac_addr)
{
	char ConnectorType ;
	char PmdType ;
	int	i ;

#ifdef	PCI
	for (i = 0; i < 6; i++) {	/* read mac address from board */
		smc->hw.fddi_phys_addr.a[i] =
			bitrev8(inp(ADDR(B2_MAC_0+i)));
	}
#endif

	ConnectorType = inp(ADDR(B2_CONN_TYP)) ;
	PmdType = inp(ADDR(B2_PMD_TYP)) ;

	smc->y[PA].pmd_type[PMD_SK_CONN] =
	smc->y[PB].pmd_type[PMD_SK_CONN] = ConnectorType ;
	smc->y[PA].pmd_type[PMD_SK_PMD ] =
	smc->y[PB].pmd_type[PMD_SK_PMD ] = PmdType ;

	if (mac_addr) {
		for (i = 0; i < 6 ;i++) {
			smc->hw.fddi_canon_addr.a[i] = mac_addr[i] ;
			smc->hw.fddi_home_addr.a[i] = bitrev8(mac_addr[i]);
		}
		return ;
	}
	smc->hw.fddi_home_addr = smc->hw.fddi_phys_addr ;

	for (i = 0; i < 6 ;i++) {
		smc->hw.fddi_canon_addr.a[i] =
			bitrev8(smc->hw.fddi_phys_addr.a[i]);
	}
}

/*
 * FDDI card soft reset
 */
void init_board(struct s_smc *smc, u_char *mac_addr)
{
	card_start(smc) ;
	read_address(smc,mac_addr) ;

	if (!(inp(ADDR(B0_DAS)) & DAS_AVAIL))
		smc->s.sas = SMT_SAS ;	/* Single att. station */
	else
		smc->s.sas = SMT_DAS ;	/* Dual att. station */

	if (!(inp(ADDR(B0_DAS)) & DAS_BYP_ST))
		smc->mib.fddiSMTBypassPresent = 0 ;
		/* without opt. bypass */
	else
		smc->mib.fddiSMTBypassPresent = 1 ;
		/* with opt. bypass */
}

/*
 * insert or deinsert optical bypass (called by ECM)
 */
void sm_pm_bypass_req(struct s_smc *smc, int mode)
{
	DB_ECMN(1,"ECM : sm_pm_bypass_req(%s)\n",(mode == BP_INSERT) ?
					"BP_INSERT" : "BP_DEINSERT",0) ;

	if (smc->s.sas != SMT_DAS)
		return ;

#ifdef	PCI
	switch(mode) {
	case BP_INSERT :
		outp(ADDR(B0_DAS),DAS_BYP_INS) ;	/* insert station */
		break ;
	case BP_DEINSERT :
		outp(ADDR(B0_DAS),DAS_BYP_RMV) ;	/* bypass station */
		break ;
	}
#endif
}

/*
 * check if bypass connected
 */
int sm_pm_bypass_present(struct s_smc *smc)
{
	return(	(inp(ADDR(B0_DAS)) & DAS_BYP_ST) ? TRUE: FALSE) ;
}

void plc_clear_irq(struct s_smc *smc, int p)
{
	SK_UNUSED(p) ;

	SK_UNUSED(smc) ;
}


/*
 * led_indication called by rmt_indication() and
 * pcm_state_change()
 *
 * Input:
 *	smc:	SMT context
 *	led_event:
 *	0	Only switch green LEDs according to their respective PCM state
 *	LED_Y_OFF	just switch yellow LED off
 *	LED_Y_ON	just switch yello LED on
 */
static void led_indication(struct s_smc *smc, int led_event)
{
	/* use smc->hw.mac_ring_is_up == TRUE 
	 * as indication for Ring Operational
	 */
	u_short			led_state ;
	struct s_phy		*phy ;
	struct fddi_mib_p	*mib_a ;
	struct fddi_mib_p	*mib_b ;

	phy = &smc->y[PA] ;
	mib_a = phy->mib ;
	phy = &smc->y[PB] ;
	mib_b = phy->mib ;

#ifdef	PCI
        led_state = 0 ;
	
	/* Ring up = yellow led OFF*/
	if (led_event == LED_Y_ON) {
		led_state |= LED_MY_ON ;
	}
	else if (led_event == LED_Y_OFF) {
		led_state |= LED_MY_OFF ;
	}
	else {	/* PCM state changed */
		/* Link at Port A/S = green led A ON */
		if (mib_a->fddiPORTPCMState == PC8_ACTIVE) {	
			led_state |= LED_GA_ON ;
		}
		else {
			led_state |= LED_GA_OFF ;
		}
		
		/* Link at Port B = green led B ON */
		if (mib_b->fddiPORTPCMState == PC8_ACTIVE) {
			led_state |= LED_GB_ON ;
		}
		else {
			led_state |= LED_GB_OFF ;
		}
	}

        outp(ADDR(B0_LED), led_state) ;
#endif	/* PCI */

}


void pcm_state_change(struct s_smc *smc, int plc, int p_state)
{
	/*
	 * the current implementation of pcm_state_change() in the driver
	 * parts must be renamed to drv_pcm_state_change() which will be called
	 * now after led_indication.
	 */
	DRV_PCM_STATE_CHANGE(smc,plc,p_state) ;
	
	led_indication(smc,0) ;
}


void rmt_indication(struct s_smc *smc, int i)
{
	/* Call a driver special function if defined */
	DRV_RMT_INDICATION(smc,i) ;

        led_indication(smc, i ? LED_Y_OFF : LED_Y_ON) ;
}


/*
 * llc_recover_tx called by init_tx (fplus.c)
 */
void llc_recover_tx(struct s_smc *smc)
{
#ifdef	LOAD_GEN
	extern	int load_gen_flag ;

	load_gen_flag = 0 ;
#endif
#ifndef	SYNC
	smc->hw.n_a_send= 0 ;
#else
	SK_UNUSED(smc) ;
#endif
}

#ifdef MULT_OEM
static int is_equal_num(char comp1[], char comp2[], int num)
{
	int i ;

	for (i = 0 ; i < num ; i++) {
		if (comp1[i] != comp2[i])
			return (0) ;
	}
		return (1) ;
}	/* is_equal_num */


/*
 * set the OEM ID defaults, and test the contents of the OEM data base
 * The default OEM is the first ACTIVE entry in the OEM data base 
 *
 * returns:	0	success
 *		1	error in data base
 *		2	data base empty
 *		3	no active entry	
 */
int set_oi_id_def(struct s_smc *smc)
{
	int sel_id ;
	int i ;
	int act_entries ;

	i = 0 ;
	sel_id = -1 ;
	act_entries = FALSE ;
	smc->hw.oem_id = 0 ;
	smc->hw.oem_min_status = OI_STAT_ACTIVE ;
	
	/* check OEM data base */
	while (oem_ids[i].oi_status) {
		switch (oem_ids[i].oi_status) {
		case OI_STAT_ACTIVE:
			act_entries = TRUE ;	/* we have active IDs */
			if (sel_id == -1)
				sel_id = i ;	/* save the first active ID */
		case OI_STAT_VALID:
		case OI_STAT_PRESENT:
			i++ ;
			break ;			/* entry ok */
		default:
			return (1) ;		/* invalid oi_status */
		}
	}

	if (i == 0)
		return (2) ;
	if (!act_entries)
		return (3) ;

	/* ok, we have a valid OEM data base with an active entry */
	smc->hw.oem_id = (struct s_oem_ids *)  &oem_ids[sel_id] ;
	return (0) ;
}
#endif	/* MULT_OEM */

void driver_get_bia(struct s_smc *smc, struct fddi_addr *bia_addr)
{
	int i ;

	for (i = 0 ; i < 6 ; i++)
		bia_addr->a[i] = bitrev8(smc->hw.fddi_phys_addr.a[i]);
}

void smt_start_watchdog(struct s_smc *smc)
{
	SK_UNUSED(smc) ;	/* Make LINT happy. */

#ifndef	DEBUG

#ifdef	PCI
	if (smc->hw.wdog_used) {
		outpw(ADDR(B2_WDOG_CRTL),TIM_START) ;	/* Start timer. */
	}
#endif

#endif	/* DEBUG */
}

static void smt_stop_watchdog(struct s_smc *smc)
{
	SK_UNUSED(smc) ;	/* Make LINT happy. */
#ifndef	DEBUG

#ifdef	PCI
	if (smc->hw.wdog_used) {
		outpw(ADDR(B2_WDOG_CRTL),TIM_STOP) ;	/* Stop timer. */
	}
#endif

#endif	/* DEBUG */
}

#ifdef	PCI

void mac_do_pci_fix(struct s_smc *smc)
{
	SK_UNUSED(smc) ;
}
#endif	/* PCI */

/*
 * Compaq Hot Plug Controller Driver
 *
 * Copyright (C) 1995,2001 Compaq Computer Corporation
 * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
 * Copyright (C) 2001 IBM Corp.
 *
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
 * NON INFRINGEMENT.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Send feedback to <greg@kroah.com>
 *
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/proc_fs.h>
#include <linux/slab.h>
#include <linux/workqueue.h>
#include <linux/pci.h>
#include <linux/pci_hotplug.h>
#include <linux/init.h>
#include <asm/uaccess.h>
#include "cpqphp.h"
#include "cpqphp_nvram.h"


#define ROM_INT15_PHY_ADDR		0x0FF859
#define READ_EV				0xD8A4
#define WRITE_EV			0xD8A5

struct register_foo {
	union {
		unsigned long lword;		/* eax */
		unsigned short word;		/* ax */

		struct {
			unsigned char low;	/* al */
			unsigned char high;	/* ah */
		} byte;
	} data;

	unsigned char opcode;	/* see below */
	unsigned long length;	/* if the reg. is a pointer, how much data */
} __attribute__ ((packed));

struct all_reg {
	struct register_foo eax_reg;
	struct register_foo ebx_reg;
	struct register_foo ecx_reg;
	struct register_foo edx_reg;
	struct register_foo edi_reg;
	struct register_foo esi_reg;
	struct register_foo eflags_reg;
} __attribute__ ((packed));


struct ev_hrt_header {
	u8 Version;
	u8 num_of_ctrl;
	u8 next;
};

struct ev_hrt_ctrl {
	u8 bus;
	u8 device;
	u8 function;
	u8 mem_avail;
	u8 p_mem_avail;
	u8 io_avail;
	u8 bus_avail;
	u8 next;
};


static u8 evbuffer_init;
static u8 evbuffer_length;
static u8 evbuffer[1024];

static void __iomem *compaq_int15_entry_point;

/* lock for ordering int15_bios_call() */
static spinlock_t int15_lock;


/* This is a series of function that deals with
 * setting & getting the hotplug resource table in some environment variable.
 */

/*
 * We really shouldn't be doing this unless there is a _very_ good reason to!!!
 * greg k-h
 */


static u32 add_byte( u32 **p_buffer, u8 value, u32 *used, u32 *avail)
{
	u8 **tByte;

	if ((*used + 1) > *avail)
		return(1);

	*((u8*)*p_buffer) = value;
	tByte = (u8**)p_buffer;
	(*tByte)++;
	*used+=1;
	return(0);
}


static u32 add_dword( u32 **p_buffer, u32 value, u32 *used, u32 *avail)
{
	if ((*used + 4) > *avail)
		return(1);

	**p_buffer = value;
	(*p_buffer)++;
	*used+=4;
	return(0);
}


/*
 * check_for_compaq_ROM
 *
 * this routine verifies that the ROM OEM string is 'COMPAQ'
 *
 * returns 0 for non-Compaq ROM, 1 for Compaq ROM
 */
static int check_for_compaq_ROM (void __iomem *rom_start)
{
	u8 temp1, temp2, temp3, temp4, temp5, temp6;
	int result = 0;

	temp1 = readb(rom_start + 0xffea + 0);
	temp2 = readb(rom_start + 0xffea + 1);
	temp3 = readb(rom_start + 0xffea + 2);
	temp4 = readb(rom_start + 0xffea + 3);
	temp5 = readb(rom_start + 0xffea + 4);
	temp6 = readb(rom_start + 0xffea + 5);
	if ((temp1 == 'C') &&
	    (temp2 == 'O') &&
	    (temp3 == 'M') &&
	    (temp4 == 'P') &&
	    (temp5 == 'A') &&
	    (temp6 == 'Q')) {
		result = 1;
	}
	dbg ("%s - returned %d\n", __func__, result);
	return result;
}


static u32 access_EV (u16 operation, u8 *ev_name, u8 *buffer, u32 *buf_size)
{
	unsigned long flags;
	int op = operation;
	int ret_val;

	if (!compaq_int15_entry_point)
		return -ENODEV;

	spin_lock_irqsave(&int15_lock, flags);
	__asm__ (
		"xorl   %%ebx,%%ebx\n" \
		"xorl    %%edx,%%edx\n" \
		"pushf\n" \
		"push %%cs\n" \
		"cli\n" \
		"call *%6\n"
		: "=c" (*buf_size), "=a" (ret_val)
		: "a" (op), "c" (*buf_size), "S" (ev_name),
		"D" (buffer), "m" (compaq_int15_entry_point)
		: "%ebx", "%edx");
	spin_unlock_irqrestore(&int15_lock, flags);

	return((ret_val & 0xFF00) >> 8);
}


/*
 * load_HRT
 *
 * Read the hot plug Resource Table from NVRAM
 */
static int load_HRT (void __iomem *rom_start)
{
	u32 available;
	u32 temp_dword;
	u8 temp_byte = 0xFF;
	u32 rc;

	if (!check_for_compaq_ROM(rom_start)) {
		return -ENODEV;
	}

	available = 1024;

	/* Now load the EV */
	temp_dword = available;

	rc = access_EV(READ_EV, "CQTHPS", evbuffer, &temp_dword);

	evbuffer_length = temp_dword;

	/* We're maintaining the resource lists so write FF to invalidate old
	 * info
	 */
	temp_dword = 1;

	rc = access_EV(WRITE_EV, "CQTHPS", &temp_byte, &temp_dword);

	return rc;
}


/*
 * store_HRT
 *
 * Save the hot plug Resource Table in NVRAM
 */
static u32 store_HRT (void __iomem *rom_start)
{
	u32 *buffer;
	u32 *pFill;
	u32 usedbytes;
	u32 available;
	u32 temp_dword;
	u32 rc;
	u8 loop;
	u8 numCtrl = 0;
	struct controller *ctrl;
	struct pci_resource *resNode;
	struct ev_hrt_header *p_EV_header;
	struct ev_hrt_ctrl *p_ev_ctrl;

	available = 1024;

	if (!check_for_compaq_ROM(rom_start)) {
		return(1);
	}

	buffer = (u32*) evbuffer;

	if (!buffer)
		return(1);

	pFill = buffer;
	usedbytes = 0;

	p_EV_header = (struct ev_hrt_header *) pFill;

	ctrl = cpqhp_ctrl_list;

	/* The revision of this structure */
	rc = add_byte( &pFill, 1 + ctrl->push_flag, &usedbytes, &available);
	if (rc)
		return(rc);

	/* The number of controllers */
	rc = add_byte( &pFill, 1, &usedbytes, &available);
	if (rc)
		return(rc);

	while (ctrl) {
		p_ev_ctrl = (struct ev_hrt_ctrl *) pFill;

		numCtrl++;

		/* The bus number */
		rc = add_byte( &pFill, ctrl->bus, &usedbytes, &available);
		if (rc)
			return(rc);

		/* The device Number */
		rc = add_byte( &pFill, PCI_SLOT(ctrl->pci_dev->devfn), &usedbytes, &available);
		if (rc)
			return(rc);

		/* The function Number */
		rc = add_byte( &pFill, PCI_FUNC(ctrl->pci_dev->devfn), &usedbytes, &available);
		if (rc)
			return(rc);

		/* Skip the number of available entries */
		rc = add_dword( &pFill, 0, &usedbytes, &available);
		if (rc)
			return(rc);

		/* Figure out memory Available */

		resNode = ctrl->mem_head;

		loop = 0;

		while (resNode) {
			loop ++;

			/* base */
			rc = add_dword( &pFill, resNode->base, &usedbytes, &available);
			if (rc)
				return(rc);

			/* length */
			rc = add_dword( &pFill, resNode->length, &usedbytes, &available);
			if (rc)
				return(rc);

			resNode = resNode->next;
		}

		/* Fill in the number of entries */
		p_ev_ctrl->mem_avail = loop;

		/* Figure out prefetchable memory Available */

		resNode = ctrl->p_mem_head;

		loop = 0;

		while (resNode) {
			loop ++;

			/* base */
			rc = add_dword( &pFill, resNode->base, &usedbytes, &available);
			if (rc)
				return(rc);

			/* length */
			rc = add_dword( &pFill, resNode->length, &usedbytes, &available);
			if (rc)
				return(rc);

			resNode = resNode->next;
		}

		/* Fill in the number of entries */
		p_ev_ctrl->p_mem_avail = loop;

		/* Figure out IO Available */

		resNode = ctrl->io_head;

		loop = 0;

		while (resNode) {
			loop ++;

			/* base */
			rc = add_dword( &pFill, resNode->base, &usedbytes, &available);
			if (rc)
				return(rc);

			/* length */
			rc = add_dword( &pFill, resNode->length, &usedbytes, &available);
			if (rc)
				return(rc);

			resNode = resNode->next;
		}

		/* Fill in the number of entries */
		p_ev_ctrl->io_avail = loop;

		/* Figure out bus Available */

		resNode = ctrl->bus_head;

		loop = 0;

		while (resNode) {
			loop ++;

			/* base */
			rc = add_dword( &pFill, resNode->base, &usedbytes, &available);
			if (rc)
				return(rc);

			/* length */
			rc = add_dword( &pFill, resNode->length, &usedbytes, &available);
			if (rc)
				return(rc);

			resNode = resNode->next;
		}

		/* Fill in the number of entries */
		p_ev_ctrl->bus_avail = loop;

		ctrl = ctrl->next;
	}

	p_EV_header->num_of_ctrl = numCtrl;

	/* Now store the EV */

	temp_dword = usedbytes;

	rc = access_EV(WRITE_EV, "CQTHPS", (u8*) buffer, &temp_dword);

	dbg("usedbytes = 0x%x, length = 0x%x\n", usedbytes, temp_dword);

	evbuffer_length = temp_dword;

	if (rc) {
		err(msg_unable_to_save);
		return(1);
	}

	return(0);
}


void compaq_nvram_init (void __iomem *rom_start)
{
	if (rom_start) {
		compaq_int15_entry_point = (rom_start + ROM_INT15_PHY_ADDR - ROM_PHY_ADDR);
	}
	dbg("int15 entry  = %p\n", compaq_int15_entry_point);

	/* initialize our int15 lock */
	spin_lock_init(&int15_lock);
}


int compaq_nvram_load (void __iomem *rom_start, struct controller *ctrl)
{
	u8 bus, device, function;
	u8 nummem, numpmem, numio, numbus;
	u32 rc;
	u8 *p_byte;
	struct pci_resource *mem_node;
	struct pci_resource *p_mem_node;
	struct pci_resource *io_node;
	struct pci_resource *bus_node;
	struct ev_hrt_ctrl *p_ev_ctrl;
	struct ev_hrt_header *p_EV_header;

	if (!evbuffer_init) {
		/* Read the resource list information in from NVRAM */
		if (load_HRT(rom_start))
			memset (evbuffer, 0, 1024);

		evbuffer_init = 1;
	}

	/* If we saved information in NVRAM, use it now */
	p_EV_header = (struct ev_hrt_header *) evbuffer;

	/* The following code is for systems where version 1.0 of this
	 * driver has been loaded, but doesn't support the hardware.
	 * In that case, the driver would incorrectly store something
	 * in NVRAM.
	 */
	if ((p_EV_header->Version == 2) ||
	    ((p_EV_header->Version == 1) && !ctrl->push_flag)) {
		p_byte = &(p_EV_header->next);

		p_ev_ctrl = (struct ev_hrt_ctrl *) &(p_EV_header->next);

		p_byte += 3;

		if (p_byte > ((u8*)p_EV_header + evbuffer_length))
			return 2;

		bus = p_ev_ctrl->bus;
		device = p_ev_ctrl->device;
		function = p_ev_ctrl->function;

		while ((bus != ctrl->bus) ||
		       (device != PCI_SLOT(ctrl->pci_dev->devfn)) ||
		       (function != PCI_FUNC(ctrl->pci_dev->devfn))) {
			nummem = p_ev_ctrl->mem_avail;
			numpmem = p_ev_ctrl->p_mem_avail;
			numio = p_ev_ctrl->io_avail;
			numbus = p_ev_ctrl->bus_avail;

			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length))
				return 2;

			/* Skip forward to the next entry */
			p_byte += (nummem + numpmem + numio + numbus) * 8;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length))
				return 2;

			p_ev_ctrl = (struct ev_hrt_ctrl *) p_byte;

			p_byte += 3;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length))
				return 2;

			bus = p_ev_ctrl->bus;
			device = p_ev_ctrl->device;
			function = p_ev_ctrl->function;
		}

		nummem = p_ev_ctrl->mem_avail;
		numpmem = p_ev_ctrl->p_mem_avail;
		numio = p_ev_ctrl->io_avail;
		numbus = p_ev_ctrl->bus_avail;

		p_byte += 4;

		if (p_byte > ((u8*)p_EV_header + evbuffer_length))
			return 2;

		while (nummem--) {
			mem_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);

			if (!mem_node)
				break;

			mem_node->base = *(u32*)p_byte;
			dbg("mem base = %8.8x\n",mem_node->base);
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(mem_node);
				return 2;
			}

			mem_node->length = *(u32*)p_byte;
			dbg("mem length = %8.8x\n",mem_node->length);
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(mem_node);
				return 2;
			}

			mem_node->next = ctrl->mem_head;
			ctrl->mem_head = mem_node;
		}

		while (numpmem--) {
			p_mem_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);

			if (!p_mem_node)
				break;

			p_mem_node->base = *(u32*)p_byte;
			dbg("pre-mem base = %8.8x\n",p_mem_node->base);
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(p_mem_node);
				return 2;
			}

			p_mem_node->length = *(u32*)p_byte;
			dbg("pre-mem length = %8.8x\n",p_mem_node->length);
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(p_mem_node);
				return 2;
			}

			p_mem_node->next = ctrl->p_mem_head;
			ctrl->p_mem_head = p_mem_node;
		}

		while (numio--) {
			io_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);

			if (!io_node)
				break;

			io_node->base = *(u32*)p_byte;
			dbg("io base = %8.8x\n",io_node->base);
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(io_node);
				return 2;
			}

			io_node->length = *(u32*)p_byte;
			dbg("io length = %8.8x\n",io_node->length);
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(io_node);
				return 2;
			}

			io_node->next = ctrl->io_head;
			ctrl->io_head = io_node;
		}

		while (numbus--) {
			bus_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);

			if (!bus_node)
				break;

			bus_node->base = *(u32*)p_byte;
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(bus_node);
				return 2;
			}

			bus_node->length = *(u32*)p_byte;
			p_byte += 4;

			if (p_byte > ((u8*)p_EV_header + evbuffer_length)) {
				kfree(bus_node);
				return 2;
			}

			bus_node->next = ctrl->bus_head;
			ctrl->bus_head = bus_node;
		}

		/* If all of the following fail, we don't have any resources for
		 * hot plug add
		 */
		rc = 1;
		rc &= cpqhp_resource_sort_and_combine(&(ctrl->mem_head));
		rc &= cpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));
		rc &= cpqhp_resource_sort_and_combine(&(ctrl->io_head));
		rc &= cpqhp_resource_sort_and_combine(&(ctrl->bus_head));

		if (rc)
			return(rc);
	} else {
		if ((evbuffer[0] != 0) && (!ctrl->push_flag))
			return 1;
	}

	return 0;
}


int compaq_nvram_store (void __iomem *rom_start)
{
	int rc = 1;

	if (rom_start == NULL)
		return -ENODEV;

	if (evbuffer_init) {
		rc = store_HRT(rom_start);
		if (rc) {
			err(msg_unable_to_save);
		}
	}
	return rc;
}

/*
 *  ncpsign_kernel.c
 *
 *  Arne de Bruijn (arne@knoware.nl), 1997
 *
 */


#ifdef CONFIG_NCPFS_PACKET_SIGNING

#include <linux/string.h>
#include <linux/ncp.h>
#include <linux/bitops.h>
#include "ncpsign_kernel.h"

/* i386: 32-bit, little endian, handles mis-alignment */
#ifdef __i386__
#define GET_LE32(p) (*(int *)(p))
#define PUT_LE32(p,v) { *(int *)(p)=v; }
#else
/* from include/ncplib.h */
#define BVAL(buf,pos) (((__u8 *)(buf))[pos])
#define PVAL(buf,pos) ((unsigned)BVAL(buf,pos))
#define BSET(buf,pos,val) (BVAL(buf,pos) = (val))

static inline __u16
WVAL_LH(__u8 * buf, int pos)
{
	return PVAL(buf, pos) | PVAL(buf, pos + 1) << 8;
}
static inline __u32
DVAL_LH(__u8 * buf, int pos)
{
	return WVAL_LH(buf, pos) | WVAL_LH(buf, pos + 2) << 16;
}
static inline void
WSET_LH(__u8 * buf, int pos, __u16 val)
{
	BSET(buf, pos, val & 0xff);
	BSET(buf, pos + 1, val >> 8);
}
static inline void
DSET_LH(__u8 * buf, int pos, __u32 val)
{
	WSET_LH(buf, pos, val & 0xffff);
	WSET_LH(buf, pos + 2, val >> 16);
}

#define GET_LE32(p) DVAL_LH(p,0)
#define PUT_LE32(p,v) DSET_LH(p,0,v)
#endif

static void nwsign(char *r_data1, char *r_data2, char *outdata) {
 int i;
 unsigned int w0,w1,w2,w3;
 static int rbit[4]={0, 2, 1, 3};
#ifdef __i386__
 unsigned int *data2=(unsigned int *)r_data2;
#else
 unsigned int data2[16];
 for (i=0;i<16;i++)
  data2[i]=GET_LE32(r_data2+(i<<2));
#endif 
 w0=GET_LE32(r_data1);
 w1=GET_LE32(r_data1+4);
 w2=GET_LE32(r_data1+8);
 w3=GET_LE32(r_data1+12);
 for (i=0;i<16;i+=4) {
  w0=rol32(w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0],3);
  w3=rol32(w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1],7);
  w2=rol32(w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2],11);
  w1=rol32(w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3],19);
 }
 for (i=0;i<4;i++) {
  w0=rol32(w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0],3);
  w3=rol32(w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4],5);
  w2=rol32(w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8],9);
  w1=rol32(w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12],13);
 }
 for (i=0;i<4;i++) {
  w0=rol32(w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0],3);
  w3=rol32(w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8],9);
  w2=rol32(w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4],11);
  w1=rol32(w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12],15);
 }
 PUT_LE32(outdata,(w0+GET_LE32(r_data1)) & 0xffffffff);
 PUT_LE32(outdata+4,(w1+GET_LE32(r_data1+4)) & 0xffffffff);
 PUT_LE32(outdata+8,(w2+GET_LE32(r_data1+8)) & 0xffffffff);
 PUT_LE32(outdata+12,(w3+GET_LE32(r_data1+12)) & 0xffffffff);
}

/* Make a signature for the current packet and add it at the end of the */
/* packet. */
void __sign_packet(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, void *sign_buff) {
	unsigned char data[64];

	memcpy(data, server->sign_root, 8);
	*(__u32*)(data + 8) = totalsize;
	if (size < 52) {
		memcpy(data + 12, packet, size);
		memset(data + 12 + size, 0, 52 - size);
	} else {
		memcpy(data + 12, packet, 52);
	}
	nwsign(server->sign_last, data, server->sign_last);
	memcpy(sign_buff, server->sign_last, 8);
}

int sign_verify_reply(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, const void *sign_buff) {
	unsigned char data[64];
	unsigned char hash[16];

	memcpy(data, server->sign_root, 8);
	*(__u32*)(data + 8) = totalsize;
	if (size < 52) {
		memcpy(data + 12, packet, size);
		memset(data + 12 + size, 0, 52 - size);
	} else {
		memcpy(data + 12, packet, 52);
	}
	nwsign(server->sign_last, data, hash);
	return memcmp(sign_buff, hash, 8);
}

#endif	/* CONFIG_NCPFS_PACKET_SIGNING */

/* drivers/rtc/rtc-s3c.c
 *
 * Copyright (c) 2010 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com/
 *
 * Copyright (c) 2004,2006 Simtec Electronics
 *	Ben Dooks, <ben@simtec.co.uk>
 *	http://armlinux.simtec.co.uk/
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * S3C2410/S3C2440/S3C24XX Internal RTC Driver
*/

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/string.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/interrupt.h>
#include <linux/rtc.h>
#include <linux/bcd.h>
#include <linux/clk.h>
#include <linux/log2.h>
#include <linux/slab.h>

#include <mach/hardware.h>
#include <asm/uaccess.h>
#include <asm/io.h>
#include <asm/irq.h>
#include <plat/regs-rtc.h>

enum s3c_cpu_type {
	TYPE_S3C2410,
	TYPE_S3C64XX,
};

/* I have yet to find an S3C implementation with more than one
 * of these rtc blocks in */

static struct resource *s3c_rtc_mem;

static struct clk *rtc_clk;
static void __iomem *s3c_rtc_base;
static int s3c_rtc_alarmno = NO_IRQ;
static int s3c_rtc_tickno  = NO_IRQ;
static enum s3c_cpu_type s3c_rtc_cpu_type;

static DEFINE_SPINLOCK(s3c_rtc_pie_lock);

/* IRQ Handlers */

static irqreturn_t s3c_rtc_alarmirq(int irq, void *id)
{
	struct rtc_device *rdev = id;

	rtc_update_irq(rdev, 1, RTC_AF | RTC_IRQF);

	if (s3c_rtc_cpu_type == TYPE_S3C64XX)
		writeb(S3C2410_INTP_ALM, s3c_rtc_base + S3C2410_INTP);

	return IRQ_HANDLED;
}

static irqreturn_t s3c_rtc_tickirq(int irq, void *id)
{
	struct rtc_device *rdev = id;

	rtc_update_irq(rdev, 1, RTC_PF | RTC_IRQF);

	if (s3c_rtc_cpu_type == TYPE_S3C64XX)
		writeb(S3C2410_INTP_TIC, s3c_rtc_base + S3C2410_INTP);

	return IRQ_HANDLED;
}

/* Update control registers */
static void s3c_rtc_setaie(int to)
{
	unsigned int tmp;

	pr_debug("%s: aie=%d\n", __func__, to);

	tmp = readb(s3c_rtc_base + S3C2410_RTCALM) & ~S3C2410_RTCALM_ALMEN;

	if (to)
		tmp |= S3C2410_RTCALM_ALMEN;

	writeb(tmp, s3c_rtc_base + S3C2410_RTCALM);
}

static int s3c_rtc_setpie(struct device *dev, int enabled)
{
	unsigned int tmp;

	pr_debug("%s: pie=%d\n", __func__, enabled);

	spin_lock_irq(&s3c_rtc_pie_lock);

	if (s3c_rtc_cpu_type == TYPE_S3C64XX) {
		tmp = readb(s3c_rtc_base + S3C2410_RTCCON);
		tmp &= ~S3C64XX_RTCCON_TICEN;

		if (enabled)
			tmp |= S3C64XX_RTCCON_TICEN;

		writew(tmp, s3c_rtc_base + S3C2410_RTCCON);
	} else {
		tmp = readb(s3c_rtc_base + S3C2410_TICNT);
		tmp &= ~S3C2410_TICNT_ENABLE;

		if (enabled)
			tmp |= S3C2410_TICNT_ENABLE;

		writeb(tmp, s3c_rtc_base + S3C2410_TICNT);
	}

	spin_unlock_irq(&s3c_rtc_pie_lock);

	return 0;
}

static int s3c_rtc_setfreq(struct device *dev, int freq)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct rtc_device *rtc_dev = platform_get_drvdata(pdev);
	unsigned int tmp = 0;

	if (!is_power_of_2(freq))
		return -EINVAL;

	spin_lock_irq(&s3c_rtc_pie_lock);

	if (s3c_rtc_cpu_type == TYPE_S3C2410) {
		tmp = readb(s3c_rtc_base + S3C2410_TICNT);
		tmp &= S3C2410_TICNT_ENABLE;
	}

	tmp |= (rtc_dev->max_user_freq / freq)-1;

	writel(tmp, s3c_rtc_base + S3C2410_TICNT);
	spin_unlock_irq(&s3c_rtc_pie_lock);

	return 0;
}

/* Time read/write */

static int s3c_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)
{
	unsigned int have_retried = 0;
	void __iomem *base = s3c_rtc_base;

 retry_get_time:
	rtc_tm->tm_min  = readb(base + S3C2410_RTCMIN);
	rtc_tm->tm_hour = readb(base + S3C2410_RTCHOUR);
	rtc_tm->tm_mday = readb(base + S3C2410_RTCDATE);
	rtc_tm->tm_mon  = readb(base + S3C2410_RTCMON);
	rtc_tm->tm_year = readb(base + S3C2410_RTCYEAR);
	rtc_tm->tm_sec  = readb(base + S3C2410_RTCSEC);

	/* the only way to work out wether the system was mid-update
	 * when we read it is to check the second counter, and if it
	 * is zero, then we re-try the entire read
	 */

	if (rtc_tm->tm_sec == 0 && !have_retried) {
		have_retried = 1;
		goto retry_get_time;
	}

	pr_debug("read time %02x.%02x.%02x %02x/%02x/%02x\n",
		 rtc_tm->tm_year, rtc_tm->tm_mon, rtc_tm->tm_mday,
		 rtc_tm->tm_hour, rtc_tm->tm_min, rtc_tm->tm_sec);

	rtc_tm->tm_sec = bcd2bin(rtc_tm->tm_sec);
	rtc_tm->tm_min = bcd2bin(rtc_tm->tm_min);
	rtc_tm->tm_hour = bcd2bin(rtc_tm->tm_hour);
	rtc_tm->tm_mday = bcd2bin(rtc_tm->tm_mday);
	rtc_tm->tm_mon = bcd2bin(rtc_tm->tm_mon);
	rtc_tm->tm_year = bcd2bin(rtc_tm->tm_year);

	rtc_tm->tm_year += 100;
	rtc_tm->tm_mon -= 1;

	return 0;
}

static int s3c_rtc_settime(struct device *dev, struct rtc_time *tm)
{
	void __iomem *base = s3c_rtc_base;
	int year = tm->tm_year - 100;

	pr_debug("set time %02d.%02d.%02d %02d/%02d/%02d\n",
		 tm->tm_year, tm->tm_mon, tm->tm_mday,
		 tm->tm_hour, tm->tm_min, tm->tm_sec);

	/* we get around y2k by simply not supporting it */

	if (year < 0 || year >= 100) {
		dev_err(dev, "rtc only supports 100 years\n");
		return -EINVAL;
	}

	writeb(bin2bcd(tm->tm_sec),  base + S3C2410_RTCSEC);
	writeb(bin2bcd(tm->tm_min),  base + S3C2410_RTCMIN);
	writeb(bin2bcd(tm->tm_hour), base + S3C2410_RTCHOUR);
	writeb(bin2bcd(tm->tm_mday), base + S3C2410_RTCDATE);
	writeb(bin2bcd(tm->tm_mon + 1), base + S3C2410_RTCMON);
	writeb(bin2bcd(year), base + S3C2410_RTCYEAR);

	return 0;
}

static int s3c_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)
{
	struct rtc_time *alm_tm = &alrm->time;
	void __iomem *base = s3c_rtc_base;
	unsigned int alm_en;

	alm_tm->tm_sec  = readb(base + S3C2410_ALMSEC);
	alm_tm->tm_min  = readb(base + S3C2410_ALMMIN);
	alm_tm->tm_hour = readb(base + S3C2410_ALMHOUR);
	alm_tm->tm_mon  = readb(base + S3C2410_ALMMON);
	alm_tm->tm_mday = readb(base + S3C2410_ALMDATE);
	alm_tm->tm_year = readb(base + S3C2410_ALMYEAR);

	alm_en = readb(base + S3C2410_RTCALM);

	alrm->enabled = (alm_en & S3C2410_RTCALM_ALMEN) ? 1 : 0;

	pr_debug("read alarm %02x %02x.%02x.%02x %02x/%02x/%02x\n",
		 alm_en,
		 alm_tm->tm_year, alm_tm->tm_mon, alm_tm->tm_mday,
		 alm_tm->tm_hour, alm_tm->tm_min, alm_tm->tm_sec);


	/* decode the alarm enable field */

	if (alm_en & S3C2410_RTCALM_SECEN)
		alm_tm->tm_sec = bcd2bin(alm_tm->tm_sec);
	else
		alm_tm->tm_sec = 0xff;

	if (alm_en & S3C2410_RTCALM_MINEN)
		alm_tm->tm_min = bcd2bin(alm_tm->tm_min);
	else
		alm_tm->tm_min = 0xff;

	if (alm_en & S3C2410_RTCALM_HOUREN)
		alm_tm->tm_hour = bcd2bin(alm_tm->tm_hour);
	else
		alm_tm->tm_hour = 0xff;

	if (alm_en & S3C2410_RTCALM_DAYEN)
		alm_tm->tm_mday = bcd2bin(alm_tm->tm_mday);
	else
		alm_tm->tm_mday = 0xff;

	if (alm_en & S3C2410_RTCALM_MONEN) {
		alm_tm->tm_mon = bcd2bin(alm_tm->tm_mon);
		alm_tm->tm_mon -= 1;
	} else {
		alm_tm->tm_mon = 0xff;
	}

	if (alm_en & S3C2410_RTCALM_YEAREN)
		alm_tm->tm_year = bcd2bin(alm_tm->tm_year);
	else
		alm_tm->tm_year = 0xffff;

	return 0;
}

static int s3c_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
{
	struct rtc_time *tm = &alrm->time;
	void __iomem *base = s3c_rtc_base;
	unsigned int alrm_en;

	pr_debug("s3c_rtc_setalarm: %d, %02x/%02x/%02x %02x.%02x.%02x\n",
		 alrm->enabled,
		 tm->tm_mday & 0xff, tm->tm_mon & 0xff, tm->tm_year & 0xff,
		 tm->tm_hour & 0xff, tm->tm_min & 0xff, tm->tm_sec);


	alrm_en = readb(base + S3C2410_RTCALM) & S3C2410_RTCALM_ALMEN;
	writeb(0x00, base + S3C2410_RTCALM);

	if (tm->tm_sec < 60 && tm->tm_sec >= 0) {
		alrm_en |= S3C2410_RTCALM_SECEN;
		writeb(bin2bcd(tm->tm_sec), base + S3C2410_ALMSEC);
	}

	if (tm->tm_min < 60 && tm->tm_min >= 0) {
		alrm_en |= S3C2410_RTCALM_MINEN;
		writeb(bin2bcd(tm->tm_min), base + S3C2410_ALMMIN);
	}

	if (tm->tm_hour < 24 && tm->tm_hour >= 0) {
		alrm_en |= S3C2410_RTCALM_HOUREN;
		writeb(bin2bcd(tm->tm_hour), base + S3C2410_ALMHOUR);
	}

	pr_debug("setting S3C2410_RTCALM to %08x\n", alrm_en);

	writeb(alrm_en, base + S3C2410_RTCALM);

	s3c_rtc_setaie(alrm->enabled);

	return 0;
}

static int s3c_rtc_proc(struct device *dev, struct seq_file *seq)
{
	unsigned int ticnt;

	if (s3c_rtc_cpu_type == TYPE_S3C64XX) {
		ticnt = readb(s3c_rtc_base + S3C2410_RTCCON);
		ticnt &= S3C64XX_RTCCON_TICEN;
	} else {
		ticnt = readb(s3c_rtc_base + S3C2410_TICNT);
		ticnt &= S3C2410_TICNT_ENABLE;
	}

	seq_printf(seq, "periodic_IRQ\t: %s\n", ticnt  ? "yes" : "no");
	return 0;
}

static int s3c_rtc_open(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct rtc_device *rtc_dev = platform_get_drvdata(pdev);
	int ret;

	ret = request_irq(s3c_rtc_alarmno, s3c_rtc_alarmirq,
			  IRQF_DISABLED,  "s3c2410-rtc alarm", rtc_dev);

	if (ret) {
		dev_err(dev, "IRQ%d error %d\n", s3c_rtc_alarmno, ret);
		return ret;
	}

	ret = request_irq(s3c_rtc_tickno, s3c_rtc_tickirq,
			  IRQF_DISABLED,  "s3c2410-rtc tick", rtc_dev);

	if (ret) {
		dev_err(dev, "IRQ%d error %d\n", s3c_rtc_tickno, ret);
		goto tick_err;
	}

	return ret;

 tick_err:
	free_irq(s3c_rtc_alarmno, rtc_dev);
	return ret;
}

static void s3c_rtc_release(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct rtc_device *rtc_dev = platform_get_drvdata(pdev);

	/* do not clear AIE here, it may be needed for wake */

	s3c_rtc_setpie(dev, 0);
	free_irq(s3c_rtc_alarmno, rtc_dev);
	free_irq(s3c_rtc_tickno, rtc_dev);
}

static const struct rtc_class_ops s3c_rtcops = {
	.open		= s3c_rtc_open,
	.release	= s3c_rtc_release,
	.read_time	= s3c_rtc_gettime,
	.set_time	= s3c_rtc_settime,
	.read_alarm	= s3c_rtc_getalarm,
	.set_alarm	= s3c_rtc_setalarm,
	.irq_set_freq	= s3c_rtc_setfreq,
	.irq_set_state	= s3c_rtc_setpie,
	.proc	        = s3c_rtc_proc,
};

static void s3c_rtc_enable(struct platform_device *pdev, int en)
{
	void __iomem *base = s3c_rtc_base;
	unsigned int tmp;

	if (s3c_rtc_base == NULL)
		return;

	if (!en) {
		tmp = readb(base + S3C2410_RTCCON);
		if (s3c_rtc_cpu_type == TYPE_S3C64XX)
			tmp &= ~S3C64XX_RTCCON_TICEN;
		tmp &= ~S3C2410_RTCCON_RTCEN;
		writeb(tmp, base + S3C2410_RTCCON);

		if (s3c_rtc_cpu_type == TYPE_S3C2410) {
			tmp = readb(base + S3C2410_TICNT);
			tmp &= ~S3C2410_TICNT_ENABLE;
			writeb(tmp, base + S3C2410_TICNT);
		}
	} else {
		/* re-enable the device, and check it is ok */

		if ((readb(base+S3C2410_RTCCON) & S3C2410_RTCCON_RTCEN) == 0){
			dev_info(&pdev->dev, "rtc disabled, re-enabling\n");

			tmp = readb(base + S3C2410_RTCCON);
			writeb(tmp|S3C2410_RTCCON_RTCEN, base+S3C2410_RTCCON);
		}

		if ((readb(base + S3C2410_RTCCON) & S3C2410_RTCCON_CNTSEL)){
			dev_info(&pdev->dev, "removing RTCCON_CNTSEL\n");

			tmp = readb(base + S3C2410_RTCCON);
			writeb(tmp& ~S3C2410_RTCCON_CNTSEL, base+S3C2410_RTCCON);
		}

		if ((readb(base + S3C2410_RTCCON) & S3C2410_RTCCON_CLKRST)){
			dev_info(&pdev->dev, "removing RTCCON_CLKRST\n");

			tmp = readb(base + S3C2410_RTCCON);
			writeb(tmp & ~S3C2410_RTCCON_CLKRST, base+S3C2410_RTCCON);
		}
	}
}

static int __devexit s3c_rtc_remove(struct platform_device *dev)
{
	struct rtc_device *rtc = platform_get_drvdata(dev);

	platform_set_drvdata(dev, NULL);
	rtc_device_unregister(rtc);

	s3c_rtc_setpie(&dev->dev, 0);
	s3c_rtc_setaie(0);

	clk_disable(rtc_clk);
	clk_put(rtc_clk);
	rtc_clk = NULL;

	iounmap(s3c_rtc_base);
	release_resource(s3c_rtc_mem);
	kfree(s3c_rtc_mem);

	return 0;
}

static int __devinit s3c_rtc_probe(struct platform_device *pdev)
{
	struct rtc_device *rtc;
	struct resource *res;
	unsigned int tmp, i;
	int ret;

	pr_debug("%s: probe=%p\n", __func__, pdev);

	/* find the IRQs */

	s3c_rtc_tickno = platform_get_irq(pdev, 1);
	if (s3c_rtc_tickno < 0) {
		dev_err(&pdev->dev, "no irq for rtc tick\n");
		return -ENOENT;
	}

	s3c_rtc_alarmno = platform_get_irq(pdev, 0);
	if (s3c_rtc_alarmno < 0) {
		dev_err(&pdev->dev, "no irq for alarm\n");
		return -ENOENT;
	}

	pr_debug("s3c2410_rtc: tick irq %d, alarm irq %d\n",
		 s3c_rtc_tickno, s3c_rtc_alarmno);

	/* get the memory region */

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (res == NULL) {
		dev_err(&pdev->dev, "failed to get memory region resource\n");
		return -ENOENT;
	}

	s3c_rtc_mem = request_mem_region(res->start,
					 res->end-res->start+1,
					 pdev->name);

	if (s3c_rtc_mem == NULL) {
		dev_err(&pdev->dev, "failed to reserve memory region\n");
		ret = -ENOENT;
		goto err_nores;
	}

	s3c_rtc_base = ioremap(res->start, res->end - res->start + 1);
	if (s3c_rtc_base == NULL) {
		dev_err(&pdev->dev, "failed ioremap()\n");
		ret = -EINVAL;
		goto err_nomap;
	}

	rtc_clk = clk_get(&pdev->dev, "rtc");
	if (IS_ERR(rtc_clk)) {
		dev_err(&pdev->dev, "failed to find rtc clock source\n");
		ret = PTR_ERR(rtc_clk);
		rtc_clk = NULL;
		goto err_clk;
	}

	clk_enable(rtc_clk);

	/* check to see if everything is setup correctly */

	s3c_rtc_enable(pdev, 1);

 	pr_debug("s3c2410_rtc: RTCCON=%02x\n",
		 readb(s3c_rtc_base + S3C2410_RTCCON));

	device_init_wakeup(&pdev->dev, 1);

	/* register RTC and exit */

	rtc = rtc_device_register("s3c", &pdev->dev, &s3c_rtcops,
				  THIS_MODULE);

	if (IS_ERR(rtc)) {
		dev_err(&pdev->dev, "cannot attach rtc\n");
		ret = PTR_ERR(rtc);
		goto err_nortc;
	}

	s3c_rtc_cpu_type = platform_get_device_id(pdev)->driver_data;

	/* Check RTC Time */

	for (i = S3C2410_RTCSEC; i <= S3C2410_RTCYEAR; i += 0x4) {
		tmp = readb(s3c_rtc_base + i);

		if ((tmp & 0xf) > 0x9 || ((tmp >> 4) & 0xf) > 0x9)
			writeb(0, s3c_rtc_base + i);
	}

	if (s3c_rtc_cpu_type == TYPE_S3C64XX)
		rtc->max_user_freq = 32768;
	else
		rtc->max_user_freq = 128;

	platform_set_drvdata(pdev, rtc);

	s3c_rtc_setfreq(&pdev->dev, 1);

	return 0;

 err_nortc:
	s3c_rtc_enable(pdev, 0);
	clk_disable(rtc_clk);
	clk_put(rtc_clk);

 err_clk:
	iounmap(s3c_rtc_base);

 err_nomap:
	release_resource(s3c_rtc_mem);

 err_nores:
	return ret;
}

#ifdef CONFIG_PM

/* RTC Power management control */

static int ticnt_save, ticnt_en_save;

static int s3c_rtc_suspend(struct platform_device *pdev, pm_message_t state)
{
	/* save TICNT for anyone using periodic interrupts */
	ticnt_save = readb(s3c_rtc_base + S3C2410_TICNT);
	if (s3c_rtc_cpu_type == TYPE_S3C64XX) {
		ticnt_en_save = readb(s3c_rtc_base + S3C2410_RTCCON);
		ticnt_en_save &= S3C64XX_RTCCON_TICEN;
	}
	s3c_rtc_enable(pdev, 0);

	if (device_may_wakeup(&pdev->dev))
		enable_irq_wake(s3c_rtc_alarmno);

	return 0;
}

static int s3c_rtc_resume(struct platform_device *pdev)
{
	unsigned int tmp;

	s3c_rtc_enable(pdev, 1);
	writeb(ticnt_save, s3c_rtc_base + S3C2410_TICNT);
	if (s3c_rtc_cpu_type == TYPE_S3C64XX && ticnt_en_save) {
		tmp = readb(s3c_rtc_base + S3C2410_RTCCON);
		writeb(tmp | ticnt_en_save, s3c_rtc_base + S3C2410_RTCCON);
	}

	if (device_may_wakeup(&pdev->dev))
		disable_irq_wake(s3c_rtc_alarmno);

	return 0;
}
#else
#define s3c_rtc_suspend NULL
#define s3c_rtc_resume  NULL
#endif

static struct platform_device_id s3c_rtc_driver_ids[] = {
	{
		.name		= "s3c2410-rtc",
		.driver_data	= TYPE_S3C2410,
	}, {
		.name		= "s3c64xx-rtc",
		.driver_data	= TYPE_S3C64XX,
	},
	{ }
};

MODULE_DEVICE_TABLE(platform, s3c_rtc_driver_ids);

static struct platform_driver s3c_rtc_driver = {
	.probe		= s3c_rtc_probe,
	.remove		= __devexit_p(s3c_rtc_remove),
	.suspend	= s3c_rtc_suspend,
	.resume		= s3c_rtc_resume,
	.id_table	= s3c_rtc_driver_ids,
	.driver		= {
		.name	= "s3c-rtc",
		.owner	= THIS_MODULE,
	},
};

static char __initdata banner[] = "S3C24XX RTC, (c) 2004,2006 Simtec Electronics\n";

static int __init s3c_rtc_init(void)
{
	printk(banner);
	return platform_driver_register(&s3c_rtc_driver);
}

static void __exit s3c_rtc_exit(void)
{
	platform_driver_unregister(&s3c_rtc_driver);
}

module_init(s3c_rtc_init);
module_exit(s3c_rtc_exit);

MODULE_DESCRIPTION("Samsung S3C RTC Driver");
MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:s3c2410-rtc");
cmd_arch/x86/kernel/irqinit.o := gcc -Wp,-MD,arch/x86/kernel/.irqinit.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(irqinit)"  -D"KBUILD_MODNAME=KBUILD_STR(irqinit)"  -c -o arch/x86/kernel/.tmp_irqinit.o arch/x86/kernel/irqinit.c

deps_arch/x86/kernel/irqinit.o := \
  arch/x86/kernel/irqinit.c \
    $(wildcard include/config/x86/32.h) \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
    $(wildcard include/config/x86/mce.h) \
    $(wildcard include/config/perf/events.h) \
  include/linux/linkage.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
    $(wildcard include/config/paravirt.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
    $(wildcard include/config/x86/vsmp.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
    $(wildcard include/config/debug/lock/alloc.h) \
  include/linux/preempt.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/no/hz.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/virt/cpu/accounting.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/debug/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  include/linux/capability.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/jiffies.h \
  include/linux/rbtree.h \
  include/linux/nodemask.h \
    $(wildcard include/config/highmem.h) \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  include/linux/prio_tree.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/completion.h \
  include/linux/wait.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  include/linux/mutex.h \
  include/linux/mutex-debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/kobject.h \
  include/linux/sysfs.h \
    $(wildcard include/config/sysfs.h) \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/irqreturn.h \
  include/linux/irqnr.h \
  include/linux/hardirq.h \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
  include/linux/irq.h \
    $(wildcard include/config/s390.h) \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  include/linux/gfp.h \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
    $(wildcard include/config/4kstacks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  include/linux/random.h \
  include/linux/kprobes.h \
    $(wildcard include/config/kprobes.h) \
    $(wildcard include/config/kretprobes.h) \
    $(wildcard include/config/kprobes/sanity/test.h) \
    $(wildcard include/config/optprobes.h) \
  include/linux/kernel_stat.h \
  include/linux/sysdev.h \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/kmod.h \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/acpi.h \
    $(wildcard include/config/acpi/hotplug/cpu.h) \
    $(wildcard include/config/acpi/wmi.h) \
    $(wildcard include/config/acpi/video.h) \
    $(wildcard include/config/support.h) \
  include/linux/mod_devicetable.h \
  include/acpi/acpi.h \
  include/acpi/platform/acenv.h \
  include/acpi/platform/aclinux.h \
  include/linux/ctype.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/acpi/platform/acgcc.h \
  include/acpi/actypes.h \
  include/acpi/acnames.h \
  include/acpi/actypes.h \
  include/acpi/acexcep.h \
  include/acpi/actbl.h \
  include/acpi/actbl1.h \
  include/acpi/actbl2.h \
  include/acpi/acoutput.h \
  include/acpi/acrestyp.h \
  include/acpi/acpiosxf.h \
  include/acpi/acpixf.h \
  include/acpi/acpi_bus.h \
    $(wildcard include/config/acpi/proc/event.h) \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/radix-tree.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/magic.h \
  include/acpi/acpi_drivers.h \
    $(wildcard include/config/acpi/dock.h) \
  include/acpi/acpi_numa.h \
  include/linux/io.h \
    $(wildcard include/config/has/ioport.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timer.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ldt.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/setup.h \
    $(wildcard include/config/x86/visws.h) \
    $(wildcard include/config/x86/mrst.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/i8259.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/traps.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/debugreg.h \

arch/x86/kernel/irqinit.o: $(deps_arch/x86/kernel/irqinit.o)

$(deps_arch/x86/kernel/irqinit.o):
/*
 * $Id: synclinkmp.c,v 4.38 2005/07/15 13:29:44 paulkf Exp $
 *
 * Device driver for Microgate SyncLink Multiport
 * high speed multiprotocol serial adapter.
 *
 * written by Paul Fulghum for Microgate Corporation
 * paulkf@microgate.com
 *
 * Microgate and SyncLink are trademarks of Microgate Corporation
 *
 * Derived from serial.c written by Theodore Ts'o and Linus Torvalds
 * This code is released under the GNU General Public License (GPL)
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define VERSION(ver,rel,seq) (((ver)<<16) | ((rel)<<8) | (seq))
#if defined(__i386__)
#  define BREAKPOINT() asm("   int $3");
#else
#  define BREAKPOINT() { }
#endif

#define MAX_DEVICES 12

#include <linux/module.h>
#include <linux/errno.h>
#include <linux/signal.h>
#include <linux/sched.h>
#include <linux/timer.h>
#include <linux/interrupt.h>
#include <linux/pci.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/serial.h>
#include <linux/major.h>
#include <linux/string.h>
#include <linux/fcntl.h>
#include <linux/ptrace.h>
#include <linux/ioport.h>
#include <linux/mm.h>
#include <linux/seq_file.h>
#include <linux/slab.h>
#include <linux/netdevice.h>
#include <linux/vmalloc.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/ioctl.h>

#include <asm/system.h>
#include <asm/io.h>
#include <asm/irq.h>
#include <asm/dma.h>
#include <linux/bitops.h>
#include <asm/types.h>
#include <linux/termios.h>
#include <linux/workqueue.h>
#include <linux/hdlc.h>
#include <linux/synclink.h>

#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) && defined(CONFIG_SYNCLINKMP_MODULE))
#define SYNCLINK_GENERIC_HDLC 1
#else
#define SYNCLINK_GENERIC_HDLC 0
#endif

#define GET_USER(error,value,addr) error = get_user(value,addr)
#define COPY_FROM_USER(error,dest,src,size) error = copy_from_user(dest,src,size) ? -EFAULT : 0
#define PUT_USER(error,value,addr) error = put_user(value,addr)
#define COPY_TO_USER(error,dest,src,size) error = copy_to_user(dest,src,size) ? -EFAULT : 0

#include <asm/uaccess.h>

static MGSL_PARAMS default_params = {
	MGSL_MODE_HDLC,			/* unsigned long mode */
	0,				/* unsigned char loopback; */
	HDLC_FLAG_UNDERRUN_ABORT15,	/* unsigned short flags; */
	HDLC_ENCODING_NRZI_SPACE,	/* unsigned char encoding; */
	0,				/* unsigned long clock_speed; */
	0xff,				/* unsigned char addr_filter; */
	HDLC_CRC_16_CCITT,		/* unsigned short crc_type; */
	HDLC_PREAMBLE_LENGTH_8BITS,	/* unsigned char preamble_length; */
	HDLC_PREAMBLE_PATTERN_NONE,	/* unsigned char preamble; */
	9600,				/* unsigned long data_rate; */
	8,				/* unsigned char data_bits; */
	1,				/* unsigned char stop_bits; */
	ASYNC_PARITY_NONE		/* unsigned char parity; */
};

/* size in bytes of DMA data buffers */
#define SCABUFSIZE 	1024
#define SCA_MEM_SIZE	0x40000
#define SCA_BASE_SIZE   512
#define SCA_REG_SIZE    16
#define SCA_MAX_PORTS   4
#define SCAMAXDESC 	128

#define	BUFFERLISTSIZE	4096

/* SCA-I style DMA buffer descriptor */
typedef struct _SCADESC
{
	u16	next;		/* lower l6 bits of next descriptor addr */
	u16	buf_ptr;	/* lower 16 bits of buffer addr */
	u8	buf_base;	/* upper 8 bits of buffer addr */
	u8	pad1;
	u16	length;		/* length of buffer */
	u8	status;		/* status of buffer */
	u8	pad2;
} SCADESC, *PSCADESC;

typedef struct _SCADESC_EX
{
	/* device driver bookkeeping section */
	char 	*virt_addr;    	/* virtual address of data buffer */
	u16	phys_entry;	/* lower 16-bits of physical address of this descriptor */
} SCADESC_EX, *PSCADESC_EX;

/* The queue of BH actions to be performed */

#define BH_RECEIVE  1
#define BH_TRANSMIT 2
#define BH_STATUS   4

#define IO_PIN_SHUTDOWN_LIMIT 100

struct	_input_signal_events {
	int	ri_up;
	int	ri_down;
	int	dsr_up;
	int	dsr_down;
	int	dcd_up;
	int	dcd_down;
	int	cts_up;
	int	cts_down;
};

/*
 * Device instance data structure
 */
typedef struct _synclinkmp_info {
	void *if_ptr;				/* General purpose pointer (used by SPPP) */
	int			magic;
	struct tty_port		port;
	int			line;
	unsigned short		close_delay;
	unsigned short		closing_wait;	/* time to wait before closing */

	struct mgsl_icount	icount;

	int			timeout;
	int			x_char;		/* xon/xoff character */
	u16			read_status_mask1;  /* break detection (SR1 indications) */
	u16			read_status_mask2;  /* parity/framing/overun (SR2 indications) */
	unsigned char 		ignore_status_mask1;  /* break detection (SR1 indications) */
	unsigned char		ignore_status_mask2;  /* parity/framing/overun (SR2 indications) */
	unsigned char 		*tx_buf;
	int			tx_put;
	int			tx_get;
	int			tx_count;

	wait_queue_head_t	status_event_wait_q;
	wait_queue_head_t	event_wait_q;
	struct timer_list	tx_timer;	/* HDLC transmit timeout timer */
	struct _synclinkmp_info	*next_device;	/* device list link */
	struct timer_list	status_timer;	/* input signal status check timer */

	spinlock_t lock;		/* spinlock for synchronizing with ISR */
	struct work_struct task;	 		/* task structure for scheduling bh */

	u32 max_frame_size;			/* as set by device config */

	u32 pending_bh;

	bool bh_running;				/* Protection from multiple */
	int isr_overflow;
	bool bh_requested;

	int dcd_chkcount;			/* check counts to prevent */
	int cts_chkcount;			/* too many IRQs if a signal */
	int dsr_chkcount;			/* is floating */
	int ri_chkcount;

	char *buffer_list;			/* virtual address of Rx & Tx buffer lists */
	unsigned long buffer_list_phys;

	unsigned int rx_buf_count;		/* count of total allocated Rx buffers */
	SCADESC *rx_buf_list;   		/* list of receive buffer entries */
	SCADESC_EX rx_buf_list_ex[SCAMAXDESC]; /* list of receive buffer entries */
	unsigned int current_rx_buf;

	unsigned int tx_buf_count;		/* count of total allocated Tx buffers */
	SCADESC *tx_buf_list;		/* list of transmit buffer entries */
	SCADESC_EX tx_buf_list_ex[SCAMAXDESC]; /* list of transmit buffer entries */
	unsigned int last_tx_buf;

	unsigned char *tmp_rx_buf;
	unsigned int tmp_rx_buf_count;

	bool rx_enabled;
	bool rx_overflow;

	bool tx_enabled;
	bool tx_active;
	u32 idle_mode;

	unsigned char ie0_value;
	unsigned char ie1_value;
	unsigned char ie2_value;
	unsigned char ctrlreg_value;
	unsigned char old_signals;

	char device_name[25];			/* device instance name */

	int port_count;
	int adapter_num;
	int port_num;

	struct _synclinkmp_info *port_array[SCA_MAX_PORTS];

	unsigned int bus_type;			/* expansion bus type (ISA,EISA,PCI) */

	unsigned int irq_level;			/* interrupt level */
	unsigned long irq_flags;
	bool irq_requested;			/* true if IRQ requested */

	MGSL_PARAMS params;			/* communications parameters */

	unsigned char serial_signals;		/* current serial signal states */

	bool irq_occurred;			/* for diagnostics use */
	unsigned int init_error;		/* Initialization startup error */

	u32 last_mem_alloc;
	unsigned char* memory_base;		/* shared memory address (PCI only) */
	u32 phys_memory_base;
    	int shared_mem_requested;

	unsigned char* sca_base;		/* HD64570 SCA Memory address */
	u32 phys_sca_base;
	u32 sca_offset;
	bool sca_base_requested;

	unsigned char* lcr_base;		/* local config registers (PCI only) */
	u32 phys_lcr_base;
	u32 lcr_offset;
	int lcr_mem_requested;

	unsigned char* statctrl_base;		/* status/control register memory */
	u32 phys_statctrl_base;
	u32 statctrl_offset;
	bool sca_statctrl_requested;

	u32 misc_ctrl_value;
	char flag_buf[MAX_ASYNC_BUFFER_SIZE];
	char char_buf[MAX_ASYNC_BUFFER_SIZE];
	bool drop_rts_on_tx_done;

	struct	_input_signal_events	input_signal_events;

	/* SPPP/Cisco HDLC device parts */
	int netcount;
	spinlock_t netlock;

#if SYNCLINK_GENERIC_HDLC
	struct net_device *netdev;
#endif

} SLMP_INFO;

#define MGSL_MAGIC 0x5401

/*
 * define serial signal status change macros
 */
#define	MISCSTATUS_DCD_LATCHED	(SerialSignal_DCD<<8)	/* indicates change in DCD */
#define MISCSTATUS_RI_LATCHED	(SerialSignal_RI<<8)	/* indicates change in RI */
#define MISCSTATUS_CTS_LATCHED	(SerialSignal_CTS<<8)	/* indicates change in CTS */
#define MISCSTATUS_DSR_LATCHED	(SerialSignal_DSR<<8)	/* change in DSR */

/* Common Register macros */
#define LPR	0x00
#define PABR0	0x02
#define PABR1	0x03
#define WCRL	0x04
#define WCRM	0x05
#define WCRH	0x06
#define DPCR	0x08
#define DMER	0x09
#define ISR0	0x10
#define ISR1	0x11
#define ISR2	0x12
#define IER0	0x14
#define IER1	0x15
#define IER2	0x16
#define ITCR	0x18
#define INTVR 	0x1a
#define IMVR	0x1c

/* MSCI Register macros */
#define TRB	0x20
#define TRBL	0x20
#define TRBH	0x21
#define SR0	0x22
#define SR1	0x23
#define SR2	0x24
#define SR3	0x25
#define FST	0x26
#define IE0	0x28
#define IE1	0x29
#define IE2	0x2a
#define FIE	0x2b
#define CMD	0x2c
#define MD0	0x2e
#define MD1	0x2f
#define MD2	0x30
#define CTL	0x31
#define SA0	0x32
#define SA1	0x33
#define IDL	0x34
#define TMC	0x35
#define RXS	0x36
#define TXS	0x37
#define TRC0	0x38
#define TRC1	0x39
#define RRC	0x3a
#define CST0	0x3c
#define CST1	0x3d

/* Timer Register Macros */
#define TCNT	0x60
#define TCNTL	0x60
#define TCNTH	0x61
#define TCONR	0x62
#define TCONRL	0x62
#define TCONRH	0x63
#define TMCS	0x64
#define TEPR	0x65

/* DMA Controller Register macros */
#define DARL	0x80
#define DARH	0x81
#define DARB	0x82
#define BAR	0x80
#define BARL	0x80
#define BARH	0x81
#define BARB	0x82
#define SAR	0x84
#define SARL	0x84
#define SARH	0x85
#define SARB	0x86
#define CPB	0x86
#define CDA	0x88
#define CDAL	0x88
#define CDAH	0x89
#define EDA	0x8a
#define EDAL	0x8a
#define EDAH	0x8b
#define BFL	0x8c
#define BFLL	0x8c
#define BFLH	0x8d
#define BCR	0x8e
#define BCRL	0x8e
#define BCRH	0x8f
#define DSR	0x90
#define DMR	0x91
#define FCT	0x93
#define DIR	0x94
#define DCMD	0x95

/* combine with timer or DMA register address */
#define TIMER0	0x00
#define TIMER1	0x08
#define TIMER2	0x10
#define TIMER3	0x18
#define RXDMA 	0x00
#define TXDMA 	0x20

/* SCA Command Codes */
#define NOOP		0x00
#define TXRESET		0x01
#define TXENABLE	0x02
#define TXDISABLE	0x03
#define TXCRCINIT	0x04
#define TXCRCEXCL	0x05
#define TXEOM		0x06
#define TXABORT		0x07
#define MPON		0x08
#define TXBUFCLR	0x09
#define RXRESET		0x11
#define RXENABLE	0x12
#define RXDISABLE	0x13
#define RXCRCINIT	0x14
#define RXREJECT	0x15
#define SEARCHMP	0x16
#define RXCRCEXCL	0x17
#define RXCRCCALC	0x18
#define CHRESET		0x21
#define HUNT		0x31

/* DMA command codes */
#define SWABORT		0x01
#define FEICLEAR	0x02

/* IE0 */
#define TXINTE 		BIT7
#define RXINTE 		BIT6
#define TXRDYE 		BIT1
#define RXRDYE 		BIT0

/* IE1 & SR1 */
#define UDRN   	BIT7
#define IDLE   	BIT6
#define SYNCD  	BIT4
#define FLGD   	BIT4
#define CCTS   	BIT3
#define CDCD   	BIT2
#define BRKD   	BIT1
#define ABTD   	BIT1
#define GAPD   	BIT1
#define BRKE   	BIT0
#define IDLD	BIT0

/* IE2 & SR2 */
#define EOM	BIT7
#define PMP	BIT6
#define SHRT	BIT6
#define PE	BIT5
#define ABT	BIT5
#define FRME	BIT4
#define RBIT	BIT4
#define OVRN	BIT3
#define CRCE	BIT2


/*
 * Global linked list of SyncLink devices
 */
static SLMP_INFO *synclinkmp_device_list = NULL;
static int synclinkmp_adapter_count = -1;
static int synclinkmp_device_count = 0;

/*
 * Set this param to non-zero to load eax with the
 * .text section address and breakpoint on module load.
 * This is useful for use with gdb and add-symbol-file command.
 */
static int break_on_load = 0;

/*
 * Driver major number, defaults to zero to get auto
 * assigned major number. May be forced as module parameter.
 */
static int ttymajor = 0;

/*
 * Array of user specified options for ISA adapters.
 */
static int debug_level = 0;
static int maxframe[MAX_DEVICES] = {0,};

module_param(break_on_load, bool, 0);
module_param(ttymajor, int, 0);
module_param(debug_level, int, 0);
module_param_array(maxframe, int, NULL, 0);

static char *driver_name = "SyncLink MultiPort driver";
static char *driver_version = "$Revision: 4.38 $";

static int synclinkmp_init_one(struct pci_dev *dev,const struct pci_device_id *ent);
static void synclinkmp_remove_one(struct pci_dev *dev);

static struct pci_device_id synclinkmp_pci_tbl[] = {
	{ PCI_VENDOR_ID_MICROGATE, PCI_DEVICE_ID_MICROGATE_SCA, PCI_ANY_ID, PCI_ANY_ID, },
	{ 0, }, /* terminate list */
};
MODULE_DEVICE_TABLE(pci, synclinkmp_pci_tbl);

MODULE_LICENSE("GPL");

static struct pci_driver synclinkmp_pci_driver = {
	.name		= "synclinkmp",
	.id_table	= synclinkmp_pci_tbl,
	.probe		= synclinkmp_init_one,
	.remove		= __devexit_p(synclinkmp_remove_one),
};


static struct tty_driver *serial_driver;

/* number of characters left in xmit buffer before we ask for more */
#define WAKEUP_CHARS 256


/* tty callbacks */

static int  open(struct tty_struct *tty, struct file * filp);
static void close(struct tty_struct *tty, struct file * filp);
static void hangup(struct tty_struct *tty);
static void set_termios(struct tty_struct *tty, struct ktermios *old_termios);

static int  write(struct tty_struct *tty, const unsigned char *buf, int count);
static int put_char(struct tty_struct *tty, unsigned char ch);
static void send_xchar(struct tty_struct *tty, char ch);
static void wait_until_sent(struct tty_struct *tty, int timeout);
static int  write_room(struct tty_struct *tty);
static void flush_chars(struct tty_struct *tty);
static void flush_buffer(struct tty_struct *tty);
static void tx_hold(struct tty_struct *tty);
static void tx_release(struct tty_struct *tty);

static int  ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg);
static int  chars_in_buffer(struct tty_struct *tty);
static void throttle(struct tty_struct * tty);
static void unthrottle(struct tty_struct * tty);
static int set_break(struct tty_struct *tty, int break_state);

#if SYNCLINK_GENERIC_HDLC
#define dev_to_port(D) (dev_to_hdlc(D)->priv)
static void hdlcdev_tx_done(SLMP_INFO *info);
static void hdlcdev_rx(SLMP_INFO *info, char *buf, int size);
static int  hdlcdev_init(SLMP_INFO *info);
static void hdlcdev_exit(SLMP_INFO *info);
#endif

/* ioctl handlers */

static int  get_stats(SLMP_INFO *info, struct mgsl_icount __user *user_icount);
static int  get_params(SLMP_INFO *info, MGSL_PARAMS __user *params);
static int  set_params(SLMP_INFO *info, MGSL_PARAMS __user *params);
static int  get_txidle(SLMP_INFO *info, int __user *idle_mode);
static int  set_txidle(SLMP_INFO *info, int idle_mode);
static int  tx_enable(SLMP_INFO *info, int enable);
static int  tx_abort(SLMP_INFO *info);
static int  rx_enable(SLMP_INFO *info, int enable);
static int  modem_input_wait(SLMP_INFO *info,int arg);
static int  wait_mgsl_event(SLMP_INFO *info, int __user *mask_ptr);
static int  tiocmget(struct tty_struct *tty, struct file *file);
static int  tiocmset(struct tty_struct *tty, struct file *file,
		     unsigned int set, unsigned int clear);
static int  set_break(struct tty_struct *tty, int break_state);

static void add_device(SLMP_INFO *info);
static void device_init(int adapter_num, struct pci_dev *pdev);
static int  claim_resources(SLMP_INFO *info);
static void release_resources(SLMP_INFO *info);

static int  startup(SLMP_INFO *info);
static int  block_til_ready(struct tty_struct *tty, struct file * filp,SLMP_INFO *info);
static int carrier_raised(struct tty_port *port);
static void shutdown(SLMP_INFO *info);
static void program_hw(SLMP_INFO *info);
static void change_params(SLMP_INFO *info);

static bool init_adapter(SLMP_INFO *info);
static bool register_test(SLMP_INFO *info);
static bool irq_test(SLMP_INFO *info);
static bool loopback_test(SLMP_INFO *info);
static int  adapter_test(SLMP_INFO *info);
static bool memory_test(SLMP_INFO *info);

static void reset_adapter(SLMP_INFO *info);
static void reset_port(SLMP_INFO *info);
static void async_mode(SLMP_INFO *info);
static void hdlc_mode(SLMP_INFO *info);

static void rx_stop(SLMP_INFO *info);
static void rx_start(SLMP_INFO *info);
static void rx_reset_buffers(SLMP_INFO *info);
static void rx_free_frame_buffers(SLMP_INFO *info, unsigned int first, unsigned int last);
static bool rx_get_frame(SLMP_INFO *info);

static void tx_start(SLMP_INFO *info);
static void tx_stop(SLMP_INFO *info);
static void tx_load_fifo(SLMP_INFO *info);
static void tx_set_idle(SLMP_INFO *info);
static void tx_load_dma_buffer(SLMP_INFO *info, const char *buf, unsigned int count);

static void get_signals(SLMP_INFO *info);
static void set_signals(SLMP_INFO *info);
static void enable_loopback(SLMP_INFO *info, int enable);
static void set_rate(SLMP_INFO *info, u32 data_rate);

static int  bh_action(SLMP_INFO *info);
static void bh_handler(struct work_struct *work);
static void bh_receive(SLMP_INFO *info);
static void bh_transmit(SLMP_INFO *info);
static void bh_status(SLMP_INFO *info);
static void isr_timer(SLMP_INFO *info);
static void isr_rxint(SLMP_INFO *info);
static void isr_rxrdy(SLMP_INFO *info);
static void isr_txint(SLMP_INFO *info);
static void isr_txrdy(SLMP_INFO *info);
static void isr_rxdmaok(SLMP_INFO *info);
static void isr_rxdmaerror(SLMP_INFO *info);
static void isr_txdmaok(SLMP_INFO *info);
static void isr_txdmaerror(SLMP_INFO *info);
static void isr_io_pin(SLMP_INFO *info, u16 status);

static int  alloc_dma_bufs(SLMP_INFO *info);
static void free_dma_bufs(SLMP_INFO *info);
static int  alloc_buf_list(SLMP_INFO *info);
static int  alloc_frame_bufs(SLMP_INFO *info, SCADESC *list, SCADESC_EX *list_ex,int count);
static int  alloc_tmp_rx_buf(SLMP_INFO *info);
static void free_tmp_rx_buf(SLMP_INFO *info);

static void load_pci_memory(SLMP_INFO *info, char* dest, const char* src, unsigned short count);
static void trace_block(SLMP_INFO *info, const char* data, int count, int xmit);
static void tx_timeout(unsigned long context);
static void status_timeout(unsigned long context);

static unsigned char read_reg(SLMP_INFO *info, unsigned char addr);
static void write_reg(SLMP_INFO *info, unsigned char addr, unsigned char val);
static u16 read_reg16(SLMP_INFO *info, unsigned char addr);
static void write_reg16(SLMP_INFO *info, unsigned char addr, u16 val);
static unsigned char read_status_reg(SLMP_INFO * info);
static void write_control_reg(SLMP_INFO * info);


static unsigned char rx_active_fifo_level = 16;	// rx request FIFO activation level in bytes
static unsigned char tx_active_fifo_level = 16;	// tx request FIFO activation level in bytes
static unsigned char tx_negate_fifo_level = 32;	// tx request FIFO negation level in bytes

static u32 misc_ctrl_value = 0x007e4040;
static u32 lcr1_brdr_value = 0x00800028;

static u32 read_ahead_count = 8;

/* DPCR, DMA Priority Control
 *
 * 07..05  Not used, must be 0
 * 04      BRC, bus release condition: 0=all transfers complete
 *              1=release after 1 xfer on all channels
 * 03      CCC, channel change condition: 0=every cycle
 *              1=after each channel completes all xfers
 * 02..00  PR<2..0>, priority 100=round robin
 *
 * 00000100 = 0x00
 */
static unsigned char dma_priority = 0x04;

// Number of bytes that can be written to shared RAM
// in a single write operation
static u32 sca_pci_load_interval = 64;

/*
 * 1st function defined in .text section. Calling this function in
 * init_module() followed by a breakpoint allows a remote debugger
 * (gdb) to get the .text address for the add-symbol-file command.
 * This allows remote debugging of dynamically loadable modules.
 */
static void* synclinkmp_get_text_ptr(void);
static void* synclinkmp_get_text_ptr(void) {return synclinkmp_get_text_ptr;}

static inline int sanity_check(SLMP_INFO *info,
			       char *name, const char *routine)
{
#ifdef SANITY_CHECK
	static const char *badmagic =
		"Warning: bad magic number for synclinkmp_struct (%s) in %s\n";
	static const char *badinfo =
		"Warning: null synclinkmp_struct for (%s) in %s\n";

	if (!info) {
		printk(badinfo, name, routine);
		return 1;
	}
	if (info->magic != MGSL_MAGIC) {
		printk(badmagic, name, routine);
		return 1;
	}
#else
	if (!info)
		return 1;
#endif
	return 0;
}

/**
 * line discipline callback wrappers
 *
 * The wrappers maintain line discipline references
 * while calling into the line discipline.
 *
 * ldisc_receive_buf  - pass receive data to line discipline
 */

static void ldisc_receive_buf(struct tty_struct *tty,
			      const __u8 *data, char *flags, int count)
{
	struct tty_ldisc *ld;
	if (!tty)
		return;
	ld = tty_ldisc_ref(tty);
	if (ld) {
		if (ld->ops->receive_buf)
			ld->ops->receive_buf(tty, data, flags, count);
		tty_ldisc_deref(ld);
	}
}

/* tty callbacks */

/* Called when a port is opened.  Init and enable port.
 */
static int open(struct tty_struct *tty, struct file *filp)
{
	SLMP_INFO *info;
	int retval, line;
	unsigned long flags;

	line = tty->index;
	if ((line < 0) || (line >= synclinkmp_device_count)) {
		printk("%s(%d): open with invalid line #%d.\n",
			__FILE__,__LINE__,line);
		return -ENODEV;
	}

	info = synclinkmp_device_list;
	while(info && info->line != line)
		info = info->next_device;
	if (sanity_check(info, tty->name, "open"))
		return -ENODEV;
	if ( info->init_error ) {
		printk("%s(%d):%s device is not allocated, init error=%d\n",
			__FILE__,__LINE__,info->device_name,info->init_error);
		return -ENODEV;
	}

	tty->driver_data = info;
	info->port.tty = tty;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s open(), old ref count = %d\n",
			 __FILE__,__LINE__,tty->driver->name, info->port.count);

	/* If port is closing, signal caller to try again */
	if (tty_hung_up_p(filp) || info->port.flags & ASYNC_CLOSING){
		if (info->port.flags & ASYNC_CLOSING)
			interruptible_sleep_on(&info->port.close_wait);
		retval = ((info->port.flags & ASYNC_HUP_NOTIFY) ?
			-EAGAIN : -ERESTARTSYS);
		goto cleanup;
	}

	info->port.tty->low_latency = (info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;

	spin_lock_irqsave(&info->netlock, flags);
	if (info->netcount) {
		retval = -EBUSY;
		spin_unlock_irqrestore(&info->netlock, flags);
		goto cleanup;
	}
	info->port.count++;
	spin_unlock_irqrestore(&info->netlock, flags);

	if (info->port.count == 1) {
		/* 1st open on this device, init hardware */
		retval = startup(info);
		if (retval < 0)
			goto cleanup;
	}

	retval = block_til_ready(tty, filp, info);
	if (retval) {
		if (debug_level >= DEBUG_LEVEL_INFO)
			printk("%s(%d):%s block_til_ready() returned %d\n",
				 __FILE__,__LINE__, info->device_name, retval);
		goto cleanup;
	}

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s open() success\n",
			 __FILE__,__LINE__, info->device_name);
	retval = 0;

cleanup:
	if (retval) {
		if (tty->count == 1)
			info->port.tty = NULL; /* tty layer will release tty struct */
		if(info->port.count)
			info->port.count--;
	}

	return retval;
}

/* Called when port is closed. Wait for remaining data to be
 * sent. Disable port and free resources.
 */
static void close(struct tty_struct *tty, struct file *filp)
{
	SLMP_INFO * info = tty->driver_data;

	if (sanity_check(info, tty->name, "close"))
		return;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s close() entry, count=%d\n",
			 __FILE__,__LINE__, info->device_name, info->port.count);

	if (tty_port_close_start(&info->port, tty, filp) == 0)
		goto cleanup;

	mutex_lock(&info->port.mutex);
 	if (info->port.flags & ASYNC_INITIALIZED)
 		wait_until_sent(tty, info->timeout);

	flush_buffer(tty);
	tty_ldisc_flush(tty);
	shutdown(info);
	mutex_unlock(&info->port.mutex);

	tty_port_close_end(&info->port, tty);
	info->port.tty = NULL;
cleanup:
	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s close() exit, count=%d\n", __FILE__,__LINE__,
			tty->driver->name, info->port.count);
}

/* Called by tty_hangup() when a hangup is signaled.
 * This is the same as closing all open descriptors for the port.
 */
static void hangup(struct tty_struct *tty)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s hangup()\n",
			 __FILE__,__LINE__, info->device_name );

	if (sanity_check(info, tty->name, "hangup"))
		return;

	mutex_lock(&info->port.mutex);
	flush_buffer(tty);
	shutdown(info);

	spin_lock_irqsave(&info->port.lock, flags);
	info->port.count = 0;
	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
	info->port.tty = NULL;
	spin_unlock_irqrestore(&info->port.lock, flags);
	mutex_unlock(&info->port.mutex);

	wake_up_interruptible(&info->port.open_wait);
}

/* Set new termios settings
 */
static void set_termios(struct tty_struct *tty, struct ktermios *old_termios)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s set_termios()\n", __FILE__,__LINE__,
			tty->driver->name );

	change_params(info);

	/* Handle transition to B0 status */
	if (old_termios->c_cflag & CBAUD &&
	    !(tty->termios->c_cflag & CBAUD)) {
		info->serial_signals &= ~(SerialSignal_RTS + SerialSignal_DTR);
		spin_lock_irqsave(&info->lock,flags);
	 	set_signals(info);
		spin_unlock_irqrestore(&info->lock,flags);
	}

	/* Handle transition away from B0 status */
	if (!(old_termios->c_cflag & CBAUD) &&
	    tty->termios->c_cflag & CBAUD) {
		info->serial_signals |= SerialSignal_DTR;
 		if (!(tty->termios->c_cflag & CRTSCTS) ||
 		    !test_bit(TTY_THROTTLED, &tty->flags)) {
			info->serial_signals |= SerialSignal_RTS;
 		}
		spin_lock_irqsave(&info->lock,flags);
	 	set_signals(info);
		spin_unlock_irqrestore(&info->lock,flags);
	}

	/* Handle turning off CRTSCTS */
	if (old_termios->c_cflag & CRTSCTS &&
	    !(tty->termios->c_cflag & CRTSCTS)) {
		tty->hw_stopped = 0;
		tx_release(tty);
	}
}

/* Send a block of data
 *
 * Arguments:
 *
 * 	tty		pointer to tty information structure
 * 	buf		pointer to buffer containing send data
 * 	count		size of send data in bytes
 *
 * Return Value:	number of characters written
 */
static int write(struct tty_struct *tty,
		 const unsigned char *buf, int count)
{
	int	c, ret = 0;
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s write() count=%d\n",
		       __FILE__,__LINE__,info->device_name,count);

	if (sanity_check(info, tty->name, "write"))
		goto cleanup;

	if (!info->tx_buf)
		goto cleanup;

	if (info->params.mode == MGSL_MODE_HDLC) {
		if (count > info->max_frame_size) {
			ret = -EIO;
			goto cleanup;
		}
		if (info->tx_active)
			goto cleanup;
		if (info->tx_count) {
			/* send accumulated data from send_char() calls */
			/* as frame and wait before accepting more data. */
			tx_load_dma_buffer(info, info->tx_buf, info->tx_count);
			goto start;
		}
		ret = info->tx_count = count;
		tx_load_dma_buffer(info, buf, count);
		goto start;
	}

	for (;;) {
		c = min_t(int, count,
			min(info->max_frame_size - info->tx_count - 1,
			    info->max_frame_size - info->tx_put));
		if (c <= 0)
			break;
			
		memcpy(info->tx_buf + info->tx_put, buf, c);

		spin_lock_irqsave(&info->lock,flags);
		info->tx_put += c;
		if (info->tx_put >= info->max_frame_size)
			info->tx_put -= info->max_frame_size;
		info->tx_count += c;
		spin_unlock_irqrestore(&info->lock,flags);

		buf += c;
		count -= c;
		ret += c;
	}

	if (info->params.mode == MGSL_MODE_HDLC) {
		if (count) {
			ret = info->tx_count = 0;
			goto cleanup;
		}
		tx_load_dma_buffer(info, info->tx_buf, info->tx_count);
	}
start:
 	if (info->tx_count && !tty->stopped && !tty->hw_stopped) {
		spin_lock_irqsave(&info->lock,flags);
		if (!info->tx_active)
		 	tx_start(info);
		spin_unlock_irqrestore(&info->lock,flags);
 	}

cleanup:
	if (debug_level >= DEBUG_LEVEL_INFO)
		printk( "%s(%d):%s write() returning=%d\n",
			__FILE__,__LINE__,info->device_name,ret);
	return ret;
}

/* Add a character to the transmit buffer.
 */
static int put_char(struct tty_struct *tty, unsigned char ch)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;
	int ret = 0;

	if ( debug_level >= DEBUG_LEVEL_INFO ) {
		printk( "%s(%d):%s put_char(%d)\n",
			__FILE__,__LINE__,info->device_name,ch);
	}

	if (sanity_check(info, tty->name, "put_char"))
		return 0;

	if (!info->tx_buf)
		return 0;

	spin_lock_irqsave(&info->lock,flags);

	if ( (info->params.mode != MGSL_MODE_HDLC) ||
	     !info->tx_active ) {

		if (info->tx_count < info->max_frame_size - 1) {
			info->tx_buf[info->tx_put++] = ch;
			if (info->tx_put >= info->max_frame_size)
				info->tx_put -= info->max_frame_size;
			info->tx_count++;
			ret = 1;
		}
	}

	spin_unlock_irqrestore(&info->lock,flags);
	return ret;
}

/* Send a high-priority XON/XOFF character
 */
static void send_xchar(struct tty_struct *tty, char ch)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s send_xchar(%d)\n",
			 __FILE__,__LINE__, info->device_name, ch );

	if (sanity_check(info, tty->name, "send_xchar"))
		return;

	info->x_char = ch;
	if (ch) {
		/* Make sure transmit interrupts are on */
		spin_lock_irqsave(&info->lock,flags);
		if (!info->tx_enabled)
		 	tx_start(info);
		spin_unlock_irqrestore(&info->lock,flags);
	}
}

/* Wait until the transmitter is empty.
 */
static void wait_until_sent(struct tty_struct *tty, int timeout)
{
	SLMP_INFO * info = tty->driver_data;
	unsigned long orig_jiffies, char_time;

	if (!info )
		return;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s wait_until_sent() entry\n",
			 __FILE__,__LINE__, info->device_name );

	if (sanity_check(info, tty->name, "wait_until_sent"))
		return;

	if (!test_bit(ASYNCB_INITIALIZED, &info->port.flags))
		goto exit;

	orig_jiffies = jiffies;

	/* Set check interval to 1/5 of estimated time to
	 * send a character, and make it at least 1. The check
	 * interval should also be less than the timeout.
	 * Note: use tight timings here to satisfy the NIST-PCTS.
	 */

	if ( info->params.data_rate ) {
	       	char_time = info->timeout/(32 * 5);
		if (!char_time)
			char_time++;
	} else
		char_time = 1;

	if (timeout)
		char_time = min_t(unsigned long, char_time, timeout);

	if ( info->params.mode == MGSL_MODE_HDLC ) {
		while (info->tx_active) {
			msleep_interruptible(jiffies_to_msecs(char_time));
			if (signal_pending(current))
				break;
			if (timeout && time_after(jiffies, orig_jiffies + timeout))
				break;
		}
	} else {
		/*
		 * TODO: determine if there is something similar to USC16C32
		 * 	 TXSTATUS_ALL_SENT status
		 */
		while ( info->tx_active && info->tx_enabled) {
			msleep_interruptible(jiffies_to_msecs(char_time));
			if (signal_pending(current))
				break;
			if (timeout && time_after(jiffies, orig_jiffies + timeout))
				break;
		}
	}

exit:
	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s wait_until_sent() exit\n",
			 __FILE__,__LINE__, info->device_name );
}

/* Return the count of free bytes in transmit buffer
 */
static int write_room(struct tty_struct *tty)
{
	SLMP_INFO *info = tty->driver_data;
	int ret;

	if (sanity_check(info, tty->name, "write_room"))
		return 0;

	if (info->params.mode == MGSL_MODE_HDLC) {
		ret = (info->tx_active) ? 0 : HDLC_MAX_FRAME_SIZE;
	} else {
		ret = info->max_frame_size - info->tx_count - 1;
		if (ret < 0)
			ret = 0;
	}

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s write_room()=%d\n",
		       __FILE__, __LINE__, info->device_name, ret);

	return ret;
}

/* enable transmitter and send remaining buffered characters
 */
static void flush_chars(struct tty_struct *tty)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk( "%s(%d):%s flush_chars() entry tx_count=%d\n",
			__FILE__,__LINE__,info->device_name,info->tx_count);

	if (sanity_check(info, tty->name, "flush_chars"))
		return;

	if (info->tx_count <= 0 || tty->stopped || tty->hw_stopped ||
	    !info->tx_buf)
		return;

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk( "%s(%d):%s flush_chars() entry, starting transmitter\n",
			__FILE__,__LINE__,info->device_name );

	spin_lock_irqsave(&info->lock,flags);

	if (!info->tx_active) {
		if ( (info->params.mode == MGSL_MODE_HDLC) &&
			info->tx_count ) {
			/* operating in synchronous (frame oriented) mode */
			/* copy data from circular tx_buf to */
			/* transmit DMA buffer. */
			tx_load_dma_buffer(info,
				 info->tx_buf,info->tx_count);
		}
	 	tx_start(info);
	}

	spin_unlock_irqrestore(&info->lock,flags);
}

/* Discard all data in the send buffer
 */
static void flush_buffer(struct tty_struct *tty)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s flush_buffer() entry\n",
			 __FILE__,__LINE__, info->device_name );

	if (sanity_check(info, tty->name, "flush_buffer"))
		return;

	spin_lock_irqsave(&info->lock,flags);
	info->tx_count = info->tx_put = info->tx_get = 0;
	del_timer(&info->tx_timer);
	spin_unlock_irqrestore(&info->lock,flags);

	tty_wakeup(tty);
}

/* throttle (stop) transmitter
 */
static void tx_hold(struct tty_struct *tty)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (sanity_check(info, tty->name, "tx_hold"))
		return;

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk("%s(%d):%s tx_hold()\n",
			__FILE__,__LINE__,info->device_name);

	spin_lock_irqsave(&info->lock,flags);
	if (info->tx_enabled)
	 	tx_stop(info);
	spin_unlock_irqrestore(&info->lock,flags);
}

/* release (start) transmitter
 */
static void tx_release(struct tty_struct *tty)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (sanity_check(info, tty->name, "tx_release"))
		return;

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk("%s(%d):%s tx_release()\n",
			__FILE__,__LINE__,info->device_name);

	spin_lock_irqsave(&info->lock,flags);
	if (!info->tx_enabled)
	 	tx_start(info);
	spin_unlock_irqrestore(&info->lock,flags);
}

/* Service an IOCTL request
 *
 * Arguments:
 *
 * 	tty	pointer to tty instance data
 * 	file	pointer to associated file object for device
 * 	cmd	IOCTL command code
 * 	arg	command argument/context
 *
 * Return Value:	0 if success, otherwise error code
 */
static int ioctl(struct tty_struct *tty, struct file *file,
		 unsigned int cmd, unsigned long arg)
{
	SLMP_INFO *info = tty->driver_data;
	int error;
	struct mgsl_icount cnow;	/* kernel counter temps */
	struct serial_icounter_struct __user *p_cuser;	/* user space */
	unsigned long flags;
	void __user *argp = (void __user *)arg;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s ioctl() cmd=%08X\n", __FILE__,__LINE__,
			info->device_name, cmd );

	if (sanity_check(info, tty->name, "ioctl"))
		return -ENODEV;

	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
		if (tty->flags & (1 << TTY_IO_ERROR))
		    return -EIO;
	}

	switch (cmd) {
	case MGSL_IOCGPARAMS:
		return get_params(info, argp);
	case MGSL_IOCSPARAMS:
		return set_params(info, argp);
	case MGSL_IOCGTXIDLE:
		return get_txidle(info, argp);
	case MGSL_IOCSTXIDLE:
		return set_txidle(info, (int)arg);
	case MGSL_IOCTXENABLE:
		return tx_enable(info, (int)arg);
	case MGSL_IOCRXENABLE:
		return rx_enable(info, (int)arg);
	case MGSL_IOCTXABORT:
		return tx_abort(info);
	case MGSL_IOCGSTATS:
		return get_stats(info, argp);
	case MGSL_IOCWAITEVENT:
		return wait_mgsl_event(info, argp);
	case MGSL_IOCLOOPTXDONE:
		return 0; // TODO: Not supported, need to document
		/* Wait for modem input (DCD,RI,DSR,CTS) change
		 * as specified by mask in arg (TIOCM_RNG/DSR/CD/CTS)
		 */
	case TIOCMIWAIT:
		return modem_input_wait(info,(int)arg);
		
		/*
		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
		 * Return: write counters to the user passed counter struct
		 * NB: both 1->0 and 0->1 transitions are counted except for
		 *     RI where only 0->1 is counted.
		 */
	case TIOCGICOUNT:
		spin_lock_irqsave(&info->lock,flags);
		cnow = info->icount;
		spin_unlock_irqrestore(&info->lock,flags);
		p_cuser = argp;
		PUT_USER(error,cnow.cts, &p_cuser->cts);
		if (error) return error;
		PUT_USER(error,cnow.dsr, &p_cuser->dsr);
		if (error) return error;
		PUT_USER(error,cnow.rng, &p_cuser->rng);
		if (error) return error;
		PUT_USER(error,cnow.dcd, &p_cuser->dcd);
		if (error) return error;
		PUT_USER(error,cnow.rx, &p_cuser->rx);
		if (error) return error;
		PUT_USER(error,cnow.tx, &p_cuser->tx);
		if (error) return error;
		PUT_USER(error,cnow.frame, &p_cuser->frame);
		if (error) return error;
		PUT_USER(error,cnow.overrun, &p_cuser->overrun);
		if (error) return error;
		PUT_USER(error,cnow.parity, &p_cuser->parity);
		if (error) return error;
		PUT_USER(error,cnow.brk, &p_cuser->brk);
		if (error) return error;
		PUT_USER(error,cnow.buf_overrun, &p_cuser->buf_overrun);
		if (error) return error;
		return 0;
	default:
		return -ENOIOCTLCMD;
	}
	return 0;
}

/*
 * /proc fs routines....
 */

static inline void line_info(struct seq_file *m, SLMP_INFO *info)
{
	char	stat_buf[30];
	unsigned long flags;

	seq_printf(m, "%s: SCABase=%08x Mem=%08X StatusControl=%08x LCR=%08X\n"
		       "\tIRQ=%d MaxFrameSize=%u\n",
		info->device_name,
		info->phys_sca_base,
		info->phys_memory_base,
		info->phys_statctrl_base,
		info->phys_lcr_base,
		info->irq_level,
		info->max_frame_size );

	/* output current serial signal states */
	spin_lock_irqsave(&info->lock,flags);
 	get_signals(info);
	spin_unlock_irqrestore(&info->lock,flags);

	stat_buf[0] = 0;
	stat_buf[1] = 0;
	if (info->serial_signals & SerialSignal_RTS)
		strcat(stat_buf, "|RTS");
	if (info->serial_signals & SerialSignal_CTS)
		strcat(stat_buf, "|CTS");
	if (info->serial_signals & SerialSignal_DTR)
		strcat(stat_buf, "|DTR");
	if (info->serial_signals & SerialSignal_DSR)
		strcat(stat_buf, "|DSR");
	if (info->serial_signals & SerialSignal_DCD)
		strcat(stat_buf, "|CD");
	if (info->serial_signals & SerialSignal_RI)
		strcat(stat_buf, "|RI");

	if (info->params.mode == MGSL_MODE_HDLC) {
		seq_printf(m, "\tHDLC txok:%d rxok:%d",
			      info->icount.txok, info->icount.rxok);
		if (info->icount.txunder)
			seq_printf(m, " txunder:%d", info->icount.txunder);
		if (info->icount.txabort)
			seq_printf(m, " txabort:%d", info->icount.txabort);
		if (info->icount.rxshort)
			seq_printf(m, " rxshort:%d", info->icount.rxshort);
		if (info->icount.rxlong)
			seq_printf(m, " rxlong:%d", info->icount.rxlong);
		if (info->icount.rxover)
			seq_printf(m, " rxover:%d", info->icount.rxover);
		if (info->icount.rxcrc)
			seq_printf(m, " rxlong:%d", info->icount.rxcrc);
	} else {
		seq_printf(m, "\tASYNC tx:%d rx:%d",
			      info->icount.tx, info->icount.rx);
		if (info->icount.frame)
			seq_printf(m, " fe:%d", info->icount.frame);
		if (info->icount.parity)
			seq_printf(m, " pe:%d", info->icount.parity);
		if (info->icount.brk)
			seq_printf(m, " brk:%d", info->icount.brk);
		if (info->icount.overrun)
			seq_printf(m, " oe:%d", info->icount.overrun);
	}

	/* Append serial signal status to end */
	seq_printf(m, " %s\n", stat_buf+1);

	seq_printf(m, "\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
	 info->tx_active,info->bh_requested,info->bh_running,
	 info->pending_bh);
}

/* Called to print information about devices
 */
static int synclinkmp_proc_show(struct seq_file *m, void *v)
{
	SLMP_INFO *info;

	seq_printf(m, "synclinkmp driver:%s\n", driver_version);

	info = synclinkmp_device_list;
	while( info ) {
		line_info(m, info);
		info = info->next_device;
	}
	return 0;
}

static int synclinkmp_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, synclinkmp_proc_show, NULL);
}

static const struct file_operations synclinkmp_proc_fops = {
	.owner		= THIS_MODULE,
	.open		= synclinkmp_proc_open,
	.read		= seq_read,
	.llseek		= seq_lseek,
	.release	= single_release,
};

/* Return the count of bytes in transmit buffer
 */
static int chars_in_buffer(struct tty_struct *tty)
{
	SLMP_INFO *info = tty->driver_data;

	if (sanity_check(info, tty->name, "chars_in_buffer"))
		return 0;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s chars_in_buffer()=%d\n",
		       __FILE__, __LINE__, info->device_name, info->tx_count);

	return info->tx_count;
}

/* Signal remote device to throttle send data (our receive data)
 */
static void throttle(struct tty_struct * tty)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s throttle() entry\n",
			 __FILE__,__LINE__, info->device_name );

	if (sanity_check(info, tty->name, "throttle"))
		return;

	if (I_IXOFF(tty))
		send_xchar(tty, STOP_CHAR(tty));

 	if (tty->termios->c_cflag & CRTSCTS) {
		spin_lock_irqsave(&info->lock,flags);
		info->serial_signals &= ~SerialSignal_RTS;
	 	set_signals(info);
		spin_unlock_irqrestore(&info->lock,flags);
	}
}

/* Signal remote device to stop throttling send data (our receive data)
 */
static void unthrottle(struct tty_struct * tty)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s unthrottle() entry\n",
			 __FILE__,__LINE__, info->device_name );

	if (sanity_check(info, tty->name, "unthrottle"))
		return;

	if (I_IXOFF(tty)) {
		if (info->x_char)
			info->x_char = 0;
		else
			send_xchar(tty, START_CHAR(tty));
	}

 	if (tty->termios->c_cflag & CRTSCTS) {
		spin_lock_irqsave(&info->lock,flags);
		info->serial_signals |= SerialSignal_RTS;
	 	set_signals(info);
		spin_unlock_irqrestore(&info->lock,flags);
	}
}

/* set or clear transmit break condition
 * break_state	-1=set break condition, 0=clear
 */
static int set_break(struct tty_struct *tty, int break_state)
{
	unsigned char RegValue;
	SLMP_INFO * info = tty->driver_data;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s set_break(%d)\n",
			 __FILE__,__LINE__, info->device_name, break_state);

	if (sanity_check(info, tty->name, "set_break"))
		return -EINVAL;

	spin_lock_irqsave(&info->lock,flags);
	RegValue = read_reg(info, CTL);
 	if (break_state == -1)
		RegValue |= BIT3;
	else
		RegValue &= ~BIT3;
	write_reg(info, CTL, RegValue);
	spin_unlock_irqrestore(&info->lock,flags);
	return 0;
}

#if SYNCLINK_GENERIC_HDLC

/**
 * called by generic HDLC layer when protocol selected (PPP, frame relay, etc.)
 * set encoding and frame check sequence (FCS) options
 *
 * dev       pointer to network device structure
 * encoding  serial encoding setting
 * parity    FCS setting
 *
 * returns 0 if success, otherwise error code
 */
static int hdlcdev_attach(struct net_device *dev, unsigned short encoding,
			  unsigned short parity)
{
	SLMP_INFO *info = dev_to_port(dev);
	unsigned char  new_encoding;
	unsigned short new_crctype;

	/* return error if TTY interface open */
	if (info->port.count)
		return -EBUSY;

	switch (encoding)
	{
	case ENCODING_NRZ:        new_encoding = HDLC_ENCODING_NRZ; break;
	case ENCODING_NRZI:       new_encoding = HDLC_ENCODING_NRZI_SPACE; break;
	case ENCODING_FM_MARK:    new_encoding = HDLC_ENCODING_BIPHASE_MARK; break;
	case ENCODING_FM_SPACE:   new_encoding = HDLC_ENCODING_BIPHASE_SPACE; break;
	case ENCODING_MANCHESTER: new_encoding = HDLC_ENCODING_BIPHASE_LEVEL; break;
	default: return -EINVAL;
	}

	switch (parity)
	{
	case PARITY_NONE:            new_crctype = HDLC_CRC_NONE; break;
	case PARITY_CRC16_PR1_CCITT: new_crctype = HDLC_CRC_16_CCITT; break;
	case PARITY_CRC32_PR1_CCITT: new_crctype = HDLC_CRC_32_CCITT; break;
	default: return -EINVAL;
	}

	info->params.encoding = new_encoding;
	info->params.crc_type = new_crctype;

	/* if network interface up, reprogram hardware */
	if (info->netcount)
		program_hw(info);

	return 0;
}

/**
 * called by generic HDLC layer to send frame
 *
 * skb  socket buffer containing HDLC frame
 * dev  pointer to network device structure
 */
static netdev_tx_t hdlcdev_xmit(struct sk_buff *skb,
				      struct net_device *dev)
{
	SLMP_INFO *info = dev_to_port(dev);
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk(KERN_INFO "%s:hdlc_xmit(%s)\n",__FILE__,dev->name);

	/* stop sending until this frame completes */
	netif_stop_queue(dev);

	/* copy data to device buffers */
	info->tx_count = skb->len;
	tx_load_dma_buffer(info, skb->data, skb->len);

	/* update network statistics */
	dev->stats.tx_packets++;
	dev->stats.tx_bytes += skb->len;

	/* done with socket buffer, so free it */
	dev_kfree_skb(skb);

	/* save start time for transmit timeout detection */
	dev->trans_start = jiffies;

	/* start hardware transmitter if necessary */
	spin_lock_irqsave(&info->lock,flags);
	if (!info->tx_active)
	 	tx_start(info);
	spin_unlock_irqrestore(&info->lock,flags);

	return NETDEV_TX_OK;
}

/**
 * called by network layer when interface enabled
 * claim resources and initialize hardware
 *
 * dev  pointer to network device structure
 *
 * returns 0 if success, otherwise error code
 */
static int hdlcdev_open(struct net_device *dev)
{
	SLMP_INFO *info = dev_to_port(dev);
	int rc;
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s:hdlcdev_open(%s)\n",__FILE__,dev->name);

	/* generic HDLC layer open processing */
	if ((rc = hdlc_open(dev)))
		return rc;

	/* arbitrate between network and tty opens */
	spin_lock_irqsave(&info->netlock, flags);
	if (info->port.count != 0 || info->netcount != 0) {
		printk(KERN_WARNING "%s: hdlc_open returning busy\n", dev->name);
		spin_unlock_irqrestore(&info->netlock, flags);
		return -EBUSY;
	}
	info->netcount=1;
	spin_unlock_irqrestore(&info->netlock, flags);

	/* claim resources and init adapter */
	if ((rc = startup(info)) != 0) {
		spin_lock_irqsave(&info->netlock, flags);
		info->netcount=0;
		spin_unlock_irqrestore(&info->netlock, flags);
		return rc;
	}

	/* assert DTR and RTS, apply hardware settings */
	info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
	program_hw(info);

	/* enable network layer transmit */
	dev->trans_start = jiffies;
	netif_start_queue(dev);

	/* inform generic HDLC layer of current DCD status */
	spin_lock_irqsave(&info->lock, flags);
	get_signals(info);
	spin_unlock_irqrestore(&info->lock, flags);
	if (info->serial_signals & SerialSignal_DCD)
		netif_carrier_on(dev);
	else
		netif_carrier_off(dev);
	return 0;
}

/**
 * called by network layer when interface is disabled
 * shutdown hardware and release resources
 *
 * dev  pointer to network device structure
 *
 * returns 0 if success, otherwise error code
 */
static int hdlcdev_close(struct net_device *dev)
{
	SLMP_INFO *info = dev_to_port(dev);
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s:hdlcdev_close(%s)\n",__FILE__,dev->name);

	netif_stop_queue(dev);

	/* shutdown adapter and release resources */
	shutdown(info);

	hdlc_close(dev);

	spin_lock_irqsave(&info->netlock, flags);
	info->netcount=0;
	spin_unlock_irqrestore(&info->netlock, flags);

	return 0;
}

/**
 * called by network layer to process IOCTL call to network device
 *
 * dev  pointer to network device structure
 * ifr  pointer to network interface request structure
 * cmd  IOCTL command code
 *
 * returns 0 if success, otherwise error code
 */
static int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
	const size_t size = sizeof(sync_serial_settings);
	sync_serial_settings new_line;
	sync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;
	SLMP_INFO *info = dev_to_port(dev);
	unsigned int flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s:hdlcdev_ioctl(%s)\n",__FILE__,dev->name);

	/* return error if TTY interface open */
	if (info->port.count)
		return -EBUSY;

	if (cmd != SIOCWANDEV)
		return hdlc_ioctl(dev, ifr, cmd);

	switch(ifr->ifr_settings.type) {
	case IF_GET_IFACE: /* return current sync_serial_settings */

		ifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;
		if (ifr->ifr_settings.size < size) {
			ifr->ifr_settings.size = size; /* data size wanted */
			return -ENOBUFS;
		}

		flags = info->params.flags & (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |
					      HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |
					      HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |
					      HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN);

		switch (flags){
		case (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN): new_line.clock_type = CLOCK_EXT; break;
		case (HDLC_FLAG_RXC_BRG    | HDLC_FLAG_TXC_BRG):    new_line.clock_type = CLOCK_INT; break;
		case (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG):    new_line.clock_type = CLOCK_TXINT; break;
		case (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN): new_line.clock_type = CLOCK_TXFROMRX; break;
		default: new_line.clock_type = CLOCK_DEFAULT;
		}

		new_line.clock_rate = info->params.clock_speed;
		new_line.loopback   = info->params.loopback ? 1:0;

		if (copy_to_user(line, &new_line, size))
			return -EFAULT;
		return 0;

	case IF_IFACE_SYNC_SERIAL: /* set sync_serial_settings */

		if(!capable(CAP_NET_ADMIN))
			return -EPERM;
		if (copy_from_user(&new_line, line, size))
			return -EFAULT;

		switch (new_line.clock_type)
		{
		case CLOCK_EXT:      flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN; break;
		case CLOCK_TXFROMRX: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN; break;
		case CLOCK_INT:      flags = HDLC_FLAG_RXC_BRG    | HDLC_FLAG_TXC_BRG;    break;
		case CLOCK_TXINT:    flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG;    break;
		case CLOCK_DEFAULT:  flags = info->params.flags &
					     (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |
					      HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |
					      HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |
					      HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN); break;
		default: return -EINVAL;
		}

		if (new_line.loopback != 0 && new_line.loopback != 1)
			return -EINVAL;

		info->params.flags &= ~(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |
					HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |
					HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |
					HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN);
		info->params.flags |= flags;

		info->params.loopback = new_line.loopback;

		if (flags & (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG))
			info->params.clock_speed = new_line.clock_rate;
		else
			info->params.clock_speed = 0;

		/* if network interface up, reprogram hardware */
		if (info->netcount)
			program_hw(info);
		return 0;

	default:
		return hdlc_ioctl(dev, ifr, cmd);
	}
}

/**
 * called by network layer when transmit timeout is detected
 *
 * dev  pointer to network device structure
 */
static void hdlcdev_tx_timeout(struct net_device *dev)
{
	SLMP_INFO *info = dev_to_port(dev);
	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("hdlcdev_tx_timeout(%s)\n",dev->name);

	dev->stats.tx_errors++;
	dev->stats.tx_aborted_errors++;

	spin_lock_irqsave(&info->lock,flags);
	tx_stop(info);
	spin_unlock_irqrestore(&info->lock,flags);

	netif_wake_queue(dev);
}

/**
 * called by device driver when transmit completes
 * reenable network layer transmit if stopped
 *
 * info  pointer to device instance information
 */
static void hdlcdev_tx_done(SLMP_INFO *info)
{
	if (netif_queue_stopped(info->netdev))
		netif_wake_queue(info->netdev);
}

/**
 * called by device driver when frame received
 * pass frame to network layer
 *
 * info  pointer to device instance information
 * buf   pointer to buffer contianing frame data
 * size  count of data bytes in buf
 */
static void hdlcdev_rx(SLMP_INFO *info, char *buf, int size)
{
	struct sk_buff *skb = dev_alloc_skb(size);
	struct net_device *dev = info->netdev;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("hdlcdev_rx(%s)\n",dev->name);

	if (skb == NULL) {
		printk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n",
		       dev->name);
		dev->stats.rx_dropped++;
		return;
	}

	memcpy(skb_put(skb, size), buf, size);

	skb->protocol = hdlc_type_trans(skb, dev);

	dev->stats.rx_packets++;
	dev->stats.rx_bytes += size;

	netif_rx(skb);
}

static const struct net_device_ops hdlcdev_ops = {
	.ndo_open       = hdlcdev_open,
	.ndo_stop       = hdlcdev_close,
	.ndo_change_mtu = hdlc_change_mtu,
	.ndo_start_xmit = hdlc_start_xmit,
	.ndo_do_ioctl   = hdlcdev_ioctl,
	.ndo_tx_timeout = hdlcdev_tx_timeout,
};

/**
 * called by device driver when adding device instance
 * do generic HDLC initialization
 *
 * info  pointer to device instance information
 *
 * returns 0 if success, otherwise error code
 */
static int hdlcdev_init(SLMP_INFO *info)
{
	int rc;
	struct net_device *dev;
	hdlc_device *hdlc;

	/* allocate and initialize network and HDLC layer objects */

	if (!(dev = alloc_hdlcdev(info))) {
		printk(KERN_ERR "%s:hdlc device allocation failure\n",__FILE__);
		return -ENOMEM;
	}

	/* for network layer reporting purposes only */
	dev->mem_start = info->phys_sca_base;
	dev->mem_end   = info->phys_sca_base + SCA_BASE_SIZE - 1;
	dev->irq       = info->irq_level;

	/* network layer callbacks and settings */
	dev->netdev_ops	    = &hdlcdev_ops;
	dev->watchdog_timeo = 10 * HZ;
	dev->tx_queue_len   = 50;

	/* generic HDLC layer callbacks and settings */
	hdlc         = dev_to_hdlc(dev);
	hdlc->attach = hdlcdev_attach;
	hdlc->xmit   = hdlcdev_xmit;

	/* register objects with HDLC layer */
	if ((rc = register_hdlc_device(dev))) {
		printk(KERN_WARNING "%s:unable to register hdlc device\n",__FILE__);
		free_netdev(dev);
		return rc;
	}

	info->netdev = dev;
	return 0;
}

/**
 * called by device driver when removing device instance
 * do generic HDLC cleanup
 *
 * info  pointer to device instance information
 */
static void hdlcdev_exit(SLMP_INFO *info)
{
	unregister_hdlc_device(info->netdev);
	free_netdev(info->netdev);
	info->netdev = NULL;
}

#endif /* CONFIG_HDLC */


/* Return next bottom half action to perform.
 * Return Value:	BH action code or 0 if nothing to do.
 */
static int bh_action(SLMP_INFO *info)
{
	unsigned long flags;
	int rc = 0;

	spin_lock_irqsave(&info->lock,flags);

	if (info->pending_bh & BH_RECEIVE) {
		info->pending_bh &= ~BH_RECEIVE;
		rc = BH_RECEIVE;
	} else if (info->pending_bh & BH_TRANSMIT) {
		info->pending_bh &= ~BH_TRANSMIT;
		rc = BH_TRANSMIT;
	} else if (info->pending_bh & BH_STATUS) {
		info->pending_bh &= ~BH_STATUS;
		rc = BH_STATUS;
	}

	if (!rc) {
		/* Mark BH routine as complete */
		info->bh_running = false;
		info->bh_requested = false;
	}

	spin_unlock_irqrestore(&info->lock,flags);

	return rc;
}

/* Perform bottom half processing of work items queued by ISR.
 */
static void bh_handler(struct work_struct *work)
{
	SLMP_INFO *info = container_of(work, SLMP_INFO, task);
	int action;

	if (!info)
		return;

	if ( debug_level >= DEBUG_LEVEL_BH )
		printk( "%s(%d):%s bh_handler() entry\n",
			__FILE__,__LINE__,info->device_name);

	info->bh_running = true;

	while((action = bh_action(info)) != 0) {

		/* Process work item */
		if ( debug_level >= DEBUG_LEVEL_BH )
			printk( "%s(%d):%s bh_handler() work item action=%d\n",
				__FILE__,__LINE__,info->device_name, action);

		switch (action) {

		case BH_RECEIVE:
			bh_receive(info);
			break;
		case BH_TRANSMIT:
			bh_transmit(info);
			break;
		case BH_STATUS:
			bh_status(info);
			break;
		default:
			/* unknown work item ID */
			printk("%s(%d):%s Unknown work item ID=%08X!\n",
				__FILE__,__LINE__,info->device_name,action);
			break;
		}
	}

	if ( debug_level >= DEBUG_LEVEL_BH )
		printk( "%s(%d):%s bh_handler() exit\n",
			__FILE__,__LINE__,info->device_name);
}

static void bh_receive(SLMP_INFO *info)
{
	if ( debug_level >= DEBUG_LEVEL_BH )
		printk( "%s(%d):%s bh_receive()\n",
			__FILE__,__LINE__,info->device_name);

	while( rx_get_frame(info) );
}

static void bh_transmit(SLMP_INFO *info)
{
	struct tty_struct *tty = info->port.tty;

	if ( debug_level >= DEBUG_LEVEL_BH )
		printk( "%s(%d):%s bh_transmit() entry\n",
			__FILE__,__LINE__,info->device_name);

	if (tty)
		tty_wakeup(tty);
}

static void bh_status(SLMP_INFO *info)
{
	if ( debug_level >= DEBUG_LEVEL_BH )
		printk( "%s(%d):%s bh_status() entry\n",
			__FILE__,__LINE__,info->device_name);

	info->ri_chkcount = 0;
	info->dsr_chkcount = 0;
	info->dcd_chkcount = 0;
	info->cts_chkcount = 0;
}

static void isr_timer(SLMP_INFO * info)
{
	unsigned char timer = (info->port_num & 1) ? TIMER2 : TIMER0;

	/* IER2<7..4> = timer<3..0> interrupt enables (0=disabled) */
	write_reg(info, IER2, 0);

	/* TMCS, Timer Control/Status Register
	 *
	 * 07      CMF, Compare match flag (read only) 1=match
	 * 06      ECMI, CMF Interrupt Enable: 0=disabled
	 * 05      Reserved, must be 0
	 * 04      TME, Timer Enable
	 * 03..00  Reserved, must be 0
	 *
	 * 0000 0000
	 */
	write_reg(info, (unsigned char)(timer + TMCS), 0);

	info->irq_occurred = true;

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_timer()\n",
			__FILE__,__LINE__,info->device_name);
}

static void isr_rxint(SLMP_INFO * info)
{
 	struct tty_struct *tty = info->port.tty;
 	struct	mgsl_icount *icount = &info->icount;
	unsigned char status = read_reg(info, SR1) & info->ie1_value & (FLGD + IDLD + CDCD + BRKD);
	unsigned char status2 = read_reg(info, SR2) & info->ie2_value & OVRN;

	/* clear status bits */
	if (status)
		write_reg(info, SR1, status);

	if (status2)
		write_reg(info, SR2, status2);
	
	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_rxint status=%02X %02x\n",
			__FILE__,__LINE__,info->device_name,status,status2);

	if (info->params.mode == MGSL_MODE_ASYNC) {
		if (status & BRKD) {
			icount->brk++;

			/* process break detection if tty control
			 * is not set to ignore it
			 */
			if ( tty ) {
				if (!(status & info->ignore_status_mask1)) {
					if (info->read_status_mask1 & BRKD) {
						tty_insert_flip_char(tty, 0, TTY_BREAK);
						if (info->port.flags & ASYNC_SAK)
							do_SAK(tty);
					}
				}
			}
		}
	}
	else {
		if (status & (FLGD|IDLD)) {
			if (status & FLGD)
				info->icount.exithunt++;
			else if (status & IDLD)
				info->icount.rxidle++;
			wake_up_interruptible(&info->event_wait_q);
		}
	}

	if (status & CDCD) {
		/* simulate a common modem status change interrupt
		 * for our handler
		 */
		get_signals( info );
		isr_io_pin(info,
			MISCSTATUS_DCD_LATCHED|(info->serial_signals&SerialSignal_DCD));
	}
}

/*
 * handle async rx data interrupts
 */
static void isr_rxrdy(SLMP_INFO * info)
{
	u16 status;
	unsigned char DataByte;
 	struct tty_struct *tty = info->port.tty;
 	struct	mgsl_icount *icount = &info->icount;

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_rxrdy\n",
			__FILE__,__LINE__,info->device_name);

	while((status = read_reg(info,CST0)) & BIT0)
	{
		int flag = 0;
		bool over = false;
		DataByte = read_reg(info,TRB);

		icount->rx++;

		if ( status & (PE + FRME + OVRN) ) {
			printk("%s(%d):%s rxerr=%04X\n",
				__FILE__,__LINE__,info->device_name,status);

			/* update error statistics */
			if (status & PE)
				icount->parity++;
			else if (status & FRME)
				icount->frame++;
			else if (status & OVRN)
				icount->overrun++;

			/* discard char if tty control flags say so */
			if (status & info->ignore_status_mask2)
				continue;

			status &= info->read_status_mask2;

			if ( tty ) {
				if (status & PE)
					flag = TTY_PARITY;
				else if (status & FRME)
					flag = TTY_FRAME;
				if (status & OVRN) {
					/* Overrun is special, since it's
					 * reported immediately, and doesn't
					 * affect the current character
					 */
					over = true;
				}
			}
		}	/* end of if (error) */

		if ( tty ) {
			tty_insert_flip_char(tty, DataByte, flag);
			if (over)
				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
		}
	}

	if ( debug_level >= DEBUG_LEVEL_ISR ) {
		printk("%s(%d):%s rx=%d brk=%d parity=%d frame=%d overrun=%d\n",
			__FILE__,__LINE__,info->device_name,
			icount->rx,icount->brk,icount->parity,
			icount->frame,icount->overrun);
	}

	if ( tty )
		tty_flip_buffer_push(tty);
}

static void isr_txeom(SLMP_INFO * info, unsigned char status)
{
	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_txeom status=%02x\n",
			__FILE__,__LINE__,info->device_name,status);

	write_reg(info, TXDMA + DIR, 0x00); /* disable Tx DMA IRQs */
	write_reg(info, TXDMA + DSR, 0xc0); /* clear IRQs and disable DMA */
	write_reg(info, TXDMA + DCMD, SWABORT);	/* reset/init DMA channel */

	if (status & UDRN) {
		write_reg(info, CMD, TXRESET);
		write_reg(info, CMD, TXENABLE);
	} else
		write_reg(info, CMD, TXBUFCLR);

	/* disable and clear tx interrupts */
	info->ie0_value &= ~TXRDYE;
	info->ie1_value &= ~(IDLE + UDRN);
	write_reg16(info, IE0, (unsigned short)((info->ie1_value << 8) + info->ie0_value));
	write_reg(info, SR1, (unsigned char)(UDRN + IDLE));

	if ( info->tx_active ) {
		if (info->params.mode != MGSL_MODE_ASYNC) {
			if (status & UDRN)
				info->icount.txunder++;
			else if (status & IDLE)
				info->icount.txok++;
		}

		info->tx_active = false;
		info->tx_count = info->tx_put = info->tx_get = 0;

		del_timer(&info->tx_timer);

		if (info->params.mode != MGSL_MODE_ASYNC && info->drop_rts_on_tx_done ) {
			info->serial_signals &= ~SerialSignal_RTS;
			info->drop_rts_on_tx_done = false;
			set_signals(info);
		}

#if SYNCLINK_GENERIC_HDLC
		if (info->netcount)
			hdlcdev_tx_done(info);
		else
#endif
		{
			if (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {
				tx_stop(info);
				return;
			}
			info->pending_bh |= BH_TRANSMIT;
		}
	}
}


/*
 * handle tx status interrupts
 */
static void isr_txint(SLMP_INFO * info)
{
	unsigned char status = read_reg(info, SR1) & info->ie1_value & (UDRN + IDLE + CCTS);

	/* clear status bits */
	write_reg(info, SR1, status);

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_txint status=%02x\n",
			__FILE__,__LINE__,info->device_name,status);

	if (status & (UDRN + IDLE))
		isr_txeom(info, status);

	if (status & CCTS) {
		/* simulate a common modem status change interrupt
		 * for our handler
		 */
		get_signals( info );
		isr_io_pin(info,
			MISCSTATUS_CTS_LATCHED|(info->serial_signals&SerialSignal_CTS));

	}
}

/*
 * handle async tx data interrupts
 */
static void isr_txrdy(SLMP_INFO * info)
{
	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_txrdy() tx_count=%d\n",
			__FILE__,__LINE__,info->device_name,info->tx_count);

	if (info->params.mode != MGSL_MODE_ASYNC) {
		/* disable TXRDY IRQ, enable IDLE IRQ */
		info->ie0_value &= ~TXRDYE;
		info->ie1_value |= IDLE;
		write_reg16(info, IE0, (unsigned short)((info->ie1_value << 8) + info->ie0_value));
		return;
	}

	if (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {
		tx_stop(info);
		return;
	}

	if ( info->tx_count )
		tx_load_fifo( info );
	else {
		info->tx_active = false;
		info->ie0_value &= ~TXRDYE;
		write_reg(info, IE0, info->ie0_value);
	}

	if (info->tx_count < WAKEUP_CHARS)
		info->pending_bh |= BH_TRANSMIT;
}

static void isr_rxdmaok(SLMP_INFO * info)
{
	/* BIT7 = EOT (end of transfer)
	 * BIT6 = EOM (end of message/frame)
	 */
	unsigned char status = read_reg(info,RXDMA + DSR) & 0xc0;

	/* clear IRQ (BIT0 must be 1 to prevent clearing DE bit) */
	write_reg(info, RXDMA + DSR, (unsigned char)(status | 1));

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_rxdmaok(), status=%02x\n",
			__FILE__,__LINE__,info->device_name,status);

	info->pending_bh |= BH_RECEIVE;
}

static void isr_rxdmaerror(SLMP_INFO * info)
{
	/* BIT5 = BOF (buffer overflow)
	 * BIT4 = COF (counter overflow)
	 */
	unsigned char status = read_reg(info,RXDMA + DSR) & 0x30;

	/* clear IRQ (BIT0 must be 1 to prevent clearing DE bit) */
	write_reg(info, RXDMA + DSR, (unsigned char)(status | 1));

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_rxdmaerror(), status=%02x\n",
			__FILE__,__LINE__,info->device_name,status);

	info->rx_overflow = true;
	info->pending_bh |= BH_RECEIVE;
}

static void isr_txdmaok(SLMP_INFO * info)
{
	unsigned char status_reg1 = read_reg(info, SR1);

	write_reg(info, TXDMA + DIR, 0x00);	/* disable Tx DMA IRQs */
	write_reg(info, TXDMA + DSR, 0xc0); /* clear IRQs and disable DMA */
	write_reg(info, TXDMA + DCMD, SWABORT);	/* reset/init DMA channel */

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_txdmaok(), status=%02x\n",
			__FILE__,__LINE__,info->device_name,status_reg1);

	/* program TXRDY as FIFO empty flag, enable TXRDY IRQ */
	write_reg16(info, TRC0, 0);
	info->ie0_value |= TXRDYE;
	write_reg(info, IE0, info->ie0_value);
}

static void isr_txdmaerror(SLMP_INFO * info)
{
	/* BIT5 = BOF (buffer overflow)
	 * BIT4 = COF (counter overflow)
	 */
	unsigned char status = read_reg(info,TXDMA + DSR) & 0x30;

	/* clear IRQ (BIT0 must be 1 to prevent clearing DE bit) */
	write_reg(info, TXDMA + DSR, (unsigned char)(status | 1));

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):%s isr_txdmaerror(), status=%02x\n",
			__FILE__,__LINE__,info->device_name,status);
}

/* handle input serial signal changes
 */
static void isr_io_pin( SLMP_INFO *info, u16 status )
{
 	struct	mgsl_icount *icount;

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk("%s(%d):isr_io_pin status=%04X\n",
			__FILE__,__LINE__,status);

	if (status & (MISCSTATUS_CTS_LATCHED | MISCSTATUS_DCD_LATCHED |
	              MISCSTATUS_DSR_LATCHED | MISCSTATUS_RI_LATCHED) ) {
		icount = &info->icount;
		/* update input line counters */
		if (status & MISCSTATUS_RI_LATCHED) {
			icount->rng++;
			if ( status & SerialSignal_RI )
				info->input_signal_events.ri_up++;
			else
				info->input_signal_events.ri_down++;
		}
		if (status & MISCSTATUS_DSR_LATCHED) {
			icount->dsr++;
			if ( status & SerialSignal_DSR )
				info->input_signal_events.dsr_up++;
			else
				info->input_signal_events.dsr_down++;
		}
		if (status & MISCSTATUS_DCD_LATCHED) {
			if ((info->dcd_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT) {
				info->ie1_value &= ~CDCD;
				write_reg(info, IE1, info->ie1_value);
			}
			icount->dcd++;
			if (status & SerialSignal_DCD) {
				info->input_signal_events.dcd_up++;
			} else
				info->input_signal_events.dcd_down++;
#if SYNCLINK_GENERIC_HDLC
			if (info->netcount) {
				if (status & SerialSignal_DCD)
					netif_carrier_on(info->netdev);
				else
					netif_carrier_off(info->netdev);
			}
#endif
		}
		if (status & MISCSTATUS_CTS_LATCHED)
		{
			if ((info->cts_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT) {
				info->ie1_value &= ~CCTS;
				write_reg(info, IE1, info->ie1_value);
			}
			icount->cts++;
			if ( status & SerialSignal_CTS )
				info->input_signal_events.cts_up++;
			else
				info->input_signal_events.cts_down++;
		}
		wake_up_interruptible(&info->status_event_wait_q);
		wake_up_interruptible(&info->event_wait_q);

		if ( (info->port.flags & ASYNC_CHECK_CD) &&
		     (status & MISCSTATUS_DCD_LATCHED) ) {
			if ( debug_level >= DEBUG_LEVEL_ISR )
				printk("%s CD now %s...", info->device_name,
				       (status & SerialSignal_DCD) ? "on" : "off");
			if (status & SerialSignal_DCD)
				wake_up_interruptible(&info->port.open_wait);
			else {
				if ( debug_level >= DEBUG_LEVEL_ISR )
					printk("doing serial hangup...");
				if (info->port.tty)
					tty_hangup(info->port.tty);
			}
		}

		if ( (info->port.flags & ASYNC_CTS_FLOW) &&
		     (status & MISCSTATUS_CTS_LATCHED) ) {
			if ( info->port.tty ) {
				if (info->port.tty->hw_stopped) {
					if (status & SerialSignal_CTS) {
						if ( debug_level >= DEBUG_LEVEL_ISR )
							printk("CTS tx start...");
			 			info->port.tty->hw_stopped = 0;
						tx_start(info);
						info->pending_bh |= BH_TRANSMIT;
						return;
					}
				} else {
					if (!(status & SerialSignal_CTS)) {
						if ( debug_level >= DEBUG_LEVEL_ISR )
							printk("CTS tx stop...");
			 			info->port.tty->hw_stopped = 1;
						tx_stop(info);
					}
				}
			}
		}
	}

	info->pending_bh |= BH_STATUS;
}

/* Interrupt service routine entry point.
 *
 * Arguments:
 * 	irq		interrupt number that caused interrupt
 * 	dev_id		device ID supplied during interrupt registration
 * 	regs		interrupted processor context
 */
static irqreturn_t synclinkmp_interrupt(int dummy, void *dev_id)
{
	SLMP_INFO *info = dev_id;
	unsigned char status, status0, status1=0;
	unsigned char dmastatus, dmastatus0, dmastatus1=0;
	unsigned char timerstatus0, timerstatus1=0;
	unsigned char shift;
	unsigned int i;
	unsigned short tmp;

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk(KERN_DEBUG "%s(%d): synclinkmp_interrupt(%d)entry.\n",
			__FILE__, __LINE__, info->irq_level);

	spin_lock(&info->lock);

	for(;;) {

		/* get status for SCA0 (ports 0-1) */
		tmp = read_reg16(info, ISR0);	/* get ISR0 and ISR1 in one read */
		status0 = (unsigned char)tmp;
		dmastatus0 = (unsigned char)(tmp>>8);
		timerstatus0 = read_reg(info, ISR2);

		if ( debug_level >= DEBUG_LEVEL_ISR )
			printk(KERN_DEBUG "%s(%d):%s status0=%02x, dmastatus0=%02x, timerstatus0=%02x\n",
				__FILE__, __LINE__, info->device_name,
				status0, dmastatus0, timerstatus0);

		if (info->port_count == 4) {
			/* get status for SCA1 (ports 2-3) */
			tmp = read_reg16(info->port_array[2], ISR0);
			status1 = (unsigned char)tmp;
			dmastatus1 = (unsigned char)(tmp>>8);
			timerstatus1 = read_reg(info->port_array[2], ISR2);

			if ( debug_level >= DEBUG_LEVEL_ISR )
				printk("%s(%d):%s status1=%02x, dmastatus1=%02x, timerstatus1=%02x\n",
					__FILE__,__LINE__,info->device_name,
					status1,dmastatus1,timerstatus1);
		}

		if (!status0 && !dmastatus0 && !timerstatus0 &&
			 !status1 && !dmastatus1 && !timerstatus1)
			break;

		for(i=0; i < info->port_count ; i++) {
			if (info->port_array[i] == NULL)
				continue;
			if (i < 2) {
				status = status0;
				dmastatus = dmastatus0;
			} else {
				status = status1;
				dmastatus = dmastatus1;
			}

			shift = i & 1 ? 4 :0;

			if (status & BIT0 << shift)
				isr_rxrdy(info->port_array[i]);
			if (status & BIT1 << shift)
				isr_txrdy(info->port_array[i]);
			if (status & BIT2 << shift)
				isr_rxint(info->port_array[i]);
			if (status & BIT3 << shift)
				isr_txint(info->port_array[i]);

			if (dmastatus & BIT0 << shift)
				isr_rxdmaerror(info->port_array[i]);
			if (dmastatus & BIT1 << shift)
				isr_rxdmaok(info->port_array[i]);
			if (dmastatus & BIT2 << shift)
				isr_txdmaerror(info->port_array[i]);
			if (dmastatus & BIT3 << shift)
				isr_txdmaok(info->port_array[i]);
		}

		if (timerstatus0 & (BIT5 | BIT4))
			isr_timer(info->port_array[0]);
		if (timerstatus0 & (BIT7 | BIT6))
			isr_timer(info->port_array[1]);
		if (timerstatus1 & (BIT5 | BIT4))
			isr_timer(info->port_array[2]);
		if (timerstatus1 & (BIT7 | BIT6))
			isr_timer(info->port_array[3]);
	}

	for(i=0; i < info->port_count ; i++) {
		SLMP_INFO * port = info->port_array[i];

		/* Request bottom half processing if there's something
		 * for it to do and the bh is not already running.
		 *
		 * Note: startup adapter diags require interrupts.
		 * do not request bottom half processing if the
		 * device is not open in a normal mode.
		 */
		if ( port && (port->port.count || port->netcount) &&
		     port->pending_bh && !port->bh_running &&
		     !port->bh_requested ) {
			if ( debug_level >= DEBUG_LEVEL_ISR )
				printk("%s(%d):%s queueing bh task.\n",
					__FILE__,__LINE__,port->device_name);
			schedule_work(&port->task);
			port->bh_requested = true;
		}
	}

	spin_unlock(&info->lock);

	if ( debug_level >= DEBUG_LEVEL_ISR )
		printk(KERN_DEBUG "%s(%d):synclinkmp_interrupt(%d)exit.\n",
			__FILE__, __LINE__, info->irq_level);
	return IRQ_HANDLED;
}

/* Initialize and start device.
 */
static int startup(SLMP_INFO * info)
{
	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk("%s(%d):%s tx_releaseup()\n",__FILE__,__LINE__,info->device_name);

	if (info->port.flags & ASYNC_INITIALIZED)
		return 0;

	if (!info->tx_buf) {
		info->tx_buf = kmalloc(info->max_frame_size, GFP_KERNEL);
		if (!info->tx_buf) {
			printk(KERN_ERR"%s(%d):%s can't allocate transmit buffer\n",
				__FILE__,__LINE__,info->device_name);
			return -ENOMEM;
		}
	}

	info->pending_bh = 0;

	memset(&info->icount, 0, sizeof(info->icount));

	/* program hardware for current parameters */
	reset_port(info);

	change_params(info);

	mod_timer(&info->status_timer, jiffies + msecs_to_jiffies(10));

	if (info->port.tty)
		clear_bit(TTY_IO_ERROR, &info->port.tty->flags);

	info->port.flags |= ASYNC_INITIALIZED;

	return 0;
}

/* Called by close() and hangup() to shutdown hardware
 */
static void shutdown(SLMP_INFO * info)
{
	unsigned long flags;

	if (!(info->port.flags & ASYNC_INITIALIZED))
		return;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s synclinkmp_shutdown()\n",
			 __FILE__,__LINE__, info->device_name );

	/* clear status wait queue because status changes */
	/* can't happen after shutting down the hardware */
	wake_up_interruptible(&info->status_event_wait_q);
	wake_up_interruptible(&info->event_wait_q);

	del_timer(&info->tx_timer);
	del_timer(&info->status_timer);

	kfree(info->tx_buf);
	info->tx_buf = NULL;

	spin_lock_irqsave(&info->lock,flags);

	reset_port(info);

 	if (!info->port.tty || info->port.tty->termios->c_cflag & HUPCL) {
 		info->serial_signals &= ~(SerialSignal_DTR + SerialSignal_RTS);
		set_signals(info);
	}

	spin_unlock_irqrestore(&info->lock,flags);

	if (info->port.tty)
		set_bit(TTY_IO_ERROR, &info->port.tty->flags);

	info->port.flags &= ~ASYNC_INITIALIZED;
}

static void program_hw(SLMP_INFO *info)
{
	unsigned long flags;

	spin_lock_irqsave(&info->lock,flags);

	rx_stop(info);
	tx_stop(info);

	info->tx_count = info->tx_put = info->tx_get = 0;

	if (info->params.mode == MGSL_MODE_HDLC || info->netcount)
		hdlc_mode(info);
	else
		async_mode(info);

	set_signals(info);

	info->dcd_chkcount = 0;
	info->cts_chkcount = 0;
	info->ri_chkcount = 0;
	info->dsr_chkcount = 0;

	info->ie1_value |= (CDCD|CCTS);
	write_reg(info, IE1, info->ie1_value);

	get_signals(info);

	if (info->netcount || (info->port.tty && info->port.tty->termios->c_cflag & CREAD) )
		rx_start(info);

	spin_unlock_irqrestore(&info->lock,flags);
}

/* Reconfigure adapter based on new parameters
 */
static void change_params(SLMP_INFO *info)
{
	unsigned cflag;
	int bits_per_char;

	if (!info->port.tty || !info->port.tty->termios)
		return;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s change_params()\n",
			 __FILE__,__LINE__, info->device_name );

	cflag = info->port.tty->termios->c_cflag;

	/* if B0 rate (hangup) specified then negate DTR and RTS */
	/* otherwise assert DTR and RTS */
 	if (cflag & CBAUD)
		info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
	else
		info->serial_signals &= ~(SerialSignal_RTS + SerialSignal_DTR);

	/* byte size and parity */

	switch (cflag & CSIZE) {
	      case CS5: info->params.data_bits = 5; break;
	      case CS6: info->params.data_bits = 6; break;
	      case CS7: info->params.data_bits = 7; break;
	      case CS8: info->params.data_bits = 8; break;
	      /* Never happens, but GCC is too dumb to figure it out */
	      default:  info->params.data_bits = 7; break;
	      }

	if (cflag & CSTOPB)
		info->params.stop_bits = 2;
	else
		info->params.stop_bits = 1;

	info->params.parity = ASYNC_PARITY_NONE;
	if (cflag & PARENB) {
		if (cflag & PARODD)
			info->params.parity = ASYNC_PARITY_ODD;
		else
			info->params.parity = ASYNC_PARITY_EVEN;
#ifdef CMSPAR
		if (cflag & CMSPAR)
			info->params.parity = ASYNC_PARITY_SPACE;
#endif
	}

	/* calculate number of jiffies to transmit a full
	 * FIFO (32 bytes) at specified data rate
	 */
	bits_per_char = info->params.data_bits +
			info->params.stop_bits + 1;

	/* if port data rate is set to 460800 or less then
	 * allow tty settings to override, otherwise keep the
	 * current data rate.
	 */
	if (info->params.data_rate <= 460800) {
		info->params.data_rate = tty_get_baud_rate(info->port.tty);
	}

	if ( info->params.data_rate ) {
		info->timeout = (32*HZ*bits_per_char) /
				info->params.data_rate;
	}
	info->timeout += HZ/50;		/* Add .02 seconds of slop */

	if (cflag & CRTSCTS)
		info->port.flags |= ASYNC_CTS_FLOW;
	else
		info->port.flags &= ~ASYNC_CTS_FLOW;

	if (cflag & CLOCAL)
		info->port.flags &= ~ASYNC_CHECK_CD;
	else
		info->port.flags |= ASYNC_CHECK_CD;

	/* process tty input control flags */

	info->read_status_mask2 = OVRN;
	if (I_INPCK(info->port.tty))
		info->read_status_mask2 |= PE | FRME;
 	if (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))
 		info->read_status_mask1 |= BRKD;
	if (I_IGNPAR(info->port.tty))
		info->ignore_status_mask2 |= PE | FRME;
	if (I_IGNBRK(info->port.tty)) {
		info->ignore_status_mask1 |= BRKD;
		/* If ignoring parity and break indicators, ignore
		 * overruns too.  (For real raw support).
		 */
		if (I_IGNPAR(info->port.tty))
			info->ignore_status_mask2 |= OVRN;
	}

	program_hw(info);
}

static int get_stats(SLMP_INFO * info, struct mgsl_icount __user *user_icount)
{
	int err;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s get_params()\n",
			 __FILE__,__LINE__, info->device_name);

	if (!user_icount) {
		memset(&info->icount, 0, sizeof(info->icount));
	} else {
		mutex_lock(&info->port.mutex);
		COPY_TO_USER(err, user_icount, &info->icount, sizeof(struct mgsl_icount));
		mutex_unlock(&info->port.mutex);
		if (err)
			return -EFAULT;
	}

	return 0;
}

static int get_params(SLMP_INFO * info, MGSL_PARAMS __user *user_params)
{
	int err;
	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s get_params()\n",
			 __FILE__,__LINE__, info->device_name);

	mutex_lock(&info->port.mutex);
	COPY_TO_USER(err,user_params, &info->params, sizeof(MGSL_PARAMS));
	mutex_unlock(&info->port.mutex);
	if (err) {
		if ( debug_level >= DEBUG_LEVEL_INFO )
			printk( "%s(%d):%s get_params() user buffer copy failed\n",
				__FILE__,__LINE__,info->device_name);
		return -EFAULT;
	}

	return 0;
}

static int set_params(SLMP_INFO * info, MGSL_PARAMS __user *new_params)
{
 	unsigned long flags;
	MGSL_PARAMS tmp_params;
	int err;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s set_params\n",
			__FILE__,__LINE__,info->device_name );
	COPY_FROM_USER(err,&tmp_params, new_params, sizeof(MGSL_PARAMS));
	if (err) {
		if ( debug_level >= DEBUG_LEVEL_INFO )
			printk( "%s(%d):%s set_params() user buffer copy failed\n",
				__FILE__,__LINE__,info->device_name);
		return -EFAULT;
	}

	mutex_lock(&info->port.mutex);
	spin_lock_irqsave(&info->lock,flags);
	memcpy(&info->params,&tmp_params,sizeof(MGSL_PARAMS));
	spin_unlock_irqrestore(&info->lock,flags);

 	change_params(info);
	mutex_unlock(&info->port.mutex);

	return 0;
}

static int get_txidle(SLMP_INFO * info, int __user *idle_mode)
{
	int err;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s get_txidle()=%d\n",
			 __FILE__,__LINE__, info->device_name, info->idle_mode);

	COPY_TO_USER(err,idle_mode, &info->idle_mode, sizeof(int));
	if (err) {
		if ( debug_level >= DEBUG_LEVEL_INFO )
			printk( "%s(%d):%s get_txidle() user buffer copy failed\n",
				__FILE__,__LINE__,info->device_name);
		return -EFAULT;
	}

	return 0;
}

static int set_txidle(SLMP_INFO * info, int idle_mode)
{
 	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s set_txidle(%d)\n",
			__FILE__,__LINE__,info->device_name, idle_mode );

	spin_lock_irqsave(&info->lock,flags);
	info->idle_mode = idle_mode;
	tx_set_idle( info );
	spin_unlock_irqrestore(&info->lock,flags);
	return 0;
}

static int tx_enable(SLMP_INFO * info, int enable)
{
 	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s tx_enable(%d)\n",
			__FILE__,__LINE__,info->device_name, enable);

	spin_lock_irqsave(&info->lock,flags);
	if ( enable ) {
		if ( !info->tx_enabled ) {
			tx_start(info);
		}
	} else {
		if ( info->tx_enabled )
			tx_stop(info);
	}
	spin_unlock_irqrestore(&info->lock,flags);
	return 0;
}

/* abort send HDLC frame
 */
static int tx_abort(SLMP_INFO * info)
{
 	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s tx_abort()\n",
			__FILE__,__LINE__,info->device_name);

	spin_lock_irqsave(&info->lock,flags);
	if ( info->tx_active && info->params.mode == MGSL_MODE_HDLC ) {
		info->ie1_value &= ~UDRN;
		info->ie1_value |= IDLE;
		write_reg(info, IE1, info->ie1_value);	/* disable tx status interrupts */
		write_reg(info, SR1, (unsigned char)(IDLE + UDRN));	/* clear pending */

		write_reg(info, TXDMA + DSR, 0);		/* disable DMA channel */
		write_reg(info, TXDMA + DCMD, SWABORT);	/* reset/init DMA channel */

   		write_reg(info, CMD, TXABORT);
	}
	spin_unlock_irqrestore(&info->lock,flags);
	return 0;
}

static int rx_enable(SLMP_INFO * info, int enable)
{
 	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s rx_enable(%d)\n",
			__FILE__,__LINE__,info->device_name,enable);

	spin_lock_irqsave(&info->lock,flags);
	if ( enable ) {
		if ( !info->rx_enabled )
			rx_start(info);
	} else {
		if ( info->rx_enabled )
			rx_stop(info);
	}
	spin_unlock_irqrestore(&info->lock,flags);
	return 0;
}

/* wait for specified event to occur
 */
static int wait_mgsl_event(SLMP_INFO * info, int __user *mask_ptr)
{
 	unsigned long flags;
	int s;
	int rc=0;
	struct mgsl_icount cprev, cnow;
	int events;
	int mask;
	struct	_input_signal_events oldsigs, newsigs;
	DECLARE_WAITQUEUE(wait, current);

	COPY_FROM_USER(rc,&mask, mask_ptr, sizeof(int));
	if (rc) {
		return  -EFAULT;
	}

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s wait_mgsl_event(%d)\n",
			__FILE__,__LINE__,info->device_name,mask);

	spin_lock_irqsave(&info->lock,flags);

	/* return immediately if state matches requested events */
	get_signals(info);
	s = info->serial_signals;

	events = mask &
		( ((s & SerialSignal_DSR) ? MgslEvent_DsrActive:MgslEvent_DsrInactive) +
 		  ((s & SerialSignal_DCD) ? MgslEvent_DcdActive:MgslEvent_DcdInactive) +
		  ((s & SerialSignal_CTS) ? MgslEvent_CtsActive:MgslEvent_CtsInactive) +
		  ((s & SerialSignal_RI)  ? MgslEvent_RiActive :MgslEvent_RiInactive) );
	if (events) {
		spin_unlock_irqrestore(&info->lock,flags);
		goto exit;
	}

	/* save current irq counts */
	cprev = info->icount;
	oldsigs = info->input_signal_events;

	/* enable hunt and idle irqs if needed */
	if (mask & (MgslEvent_ExitHuntMode+MgslEvent_IdleReceived)) {
		unsigned char oldval = info->ie1_value;
		unsigned char newval = oldval +
			 (mask & MgslEvent_ExitHuntMode ? FLGD:0) +
			 (mask & MgslEvent_IdleReceived ? IDLD:0);
		if ( oldval != newval ) {
			info->ie1_value = newval;
			write_reg(info, IE1, info->ie1_value);
		}
	}

	set_current_state(TASK_INTERRUPTIBLE);
	add_wait_queue(&info->event_wait_q, &wait);

	spin_unlock_irqrestore(&info->lock,flags);

	for(;;) {
		schedule();
		if (signal_pending(current)) {
			rc = -ERESTARTSYS;
			break;
		}

		/* get current irq counts */
		spin_lock_irqsave(&info->lock,flags);
		cnow = info->icount;
		newsigs = info->input_signal_events;
		set_current_state(TASK_INTERRUPTIBLE);
		spin_unlock_irqrestore(&info->lock,flags);

		/* if no change, wait aborted for some reason */
		if (newsigs.dsr_up   == oldsigs.dsr_up   &&
		    newsigs.dsr_down == oldsigs.dsr_down &&
		    newsigs.dcd_up   == oldsigs.dcd_up   &&
		    newsigs.dcd_down == oldsigs.dcd_down &&
		    newsigs.cts_up   == oldsigs.cts_up   &&
		    newsigs.cts_down == oldsigs.cts_down &&
		    newsigs.ri_up    == oldsigs.ri_up    &&
		    newsigs.ri_down  == oldsigs.ri_down  &&
		    cnow.exithunt    == cprev.exithunt   &&
		    cnow.rxidle      == cprev.rxidle) {
			rc = -EIO;
			break;
		}

		events = mask &
			( (newsigs.dsr_up   != oldsigs.dsr_up   ? MgslEvent_DsrActive:0)   +
			  (newsigs.dsr_down != oldsigs.dsr_down ? MgslEvent_DsrInactive:0) +
			  (newsigs.dcd_up   != oldsigs.dcd_up   ? MgslEvent_DcdActive:0)   +
			  (newsigs.dcd_down != oldsigs.dcd_down ? MgslEvent_DcdInactive:0) +
			  (newsigs.cts_up   != oldsigs.cts_up   ? MgslEvent_CtsActive:0)   +
			  (newsigs.cts_down != oldsigs.cts_down ? MgslEvent_CtsInactive:0) +
			  (newsigs.ri_up    != oldsigs.ri_up    ? MgslEvent_RiActive:0)    +
			  (newsigs.ri_down  != oldsigs.ri_down  ? MgslEvent_RiInactive:0)  +
			  (cnow.exithunt    != cprev.exithunt   ? MgslEvent_ExitHuntMode:0) +
			  (cnow.rxidle      != cprev.rxidle     ? MgslEvent_IdleReceived:0) );
		if (events)
			break;

		cprev = cnow;
		oldsigs = newsigs;
	}

	remove_wait_queue(&info->event_wait_q, &wait);
	set_current_state(TASK_RUNNING);


	if (mask & (MgslEvent_ExitHuntMode + MgslEvent_IdleReceived)) {
		spin_lock_irqsave(&info->lock,flags);
		if (!waitqueue_active(&info->event_wait_q)) {
			/* disable enable exit hunt mode/idle rcvd IRQs */
			info->ie1_value &= ~(FLGD|IDLD);
			write_reg(info, IE1, info->ie1_value);
		}
		spin_unlock_irqrestore(&info->lock,flags);
	}
exit:
	if ( rc == 0 )
		PUT_USER(rc, events, mask_ptr);

	return rc;
}

static int modem_input_wait(SLMP_INFO *info,int arg)
{
 	unsigned long flags;
	int rc;
	struct mgsl_icount cprev, cnow;
	DECLARE_WAITQUEUE(wait, current);

	/* save current irq counts */
	spin_lock_irqsave(&info->lock,flags);
	cprev = info->icount;
	add_wait_queue(&info->status_event_wait_q, &wait);
	set_current_state(TASK_INTERRUPTIBLE);
	spin_unlock_irqrestore(&info->lock,flags);

	for(;;) {
		schedule();
		if (signal_pending(current)) {
			rc = -ERESTARTSYS;
			break;
		}

		/* get new irq counts */
		spin_lock_irqsave(&info->lock,flags);
		cnow = info->icount;
		set_current_state(TASK_INTERRUPTIBLE);
		spin_unlock_irqrestore(&info->lock,flags);

		/* if no change, wait aborted for some reason */
		if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
		    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {
			rc = -EIO;
			break;
		}

		/* check for change in caller specified modem input */
		if ((arg & TIOCM_RNG && cnow.rng != cprev.rng) ||
		    (arg & TIOCM_DSR && cnow.dsr != cprev.dsr) ||
		    (arg & TIOCM_CD  && cnow.dcd != cprev.dcd) ||
		    (arg & TIOCM_CTS && cnow.cts != cprev.cts)) {
			rc = 0;
			break;
		}

		cprev = cnow;
	}
	remove_wait_queue(&info->status_event_wait_q, &wait);
	set_current_state(TASK_RUNNING);
	return rc;
}

/* return the state of the serial control and status signals
 */
static int tiocmget(struct tty_struct *tty, struct file *file)
{
	SLMP_INFO *info = tty->driver_data;
	unsigned int result;
 	unsigned long flags;

	spin_lock_irqsave(&info->lock,flags);
 	get_signals(info);
	spin_unlock_irqrestore(&info->lock,flags);

	result = ((info->serial_signals & SerialSignal_RTS) ? TIOCM_RTS:0) +
		((info->serial_signals & SerialSignal_DTR) ? TIOCM_DTR:0) +
		((info->serial_signals & SerialSignal_DCD) ? TIOCM_CAR:0) +
		((info->serial_signals & SerialSignal_RI)  ? TIOCM_RNG:0) +
		((info->serial_signals & SerialSignal_DSR) ? TIOCM_DSR:0) +
		((info->serial_signals & SerialSignal_CTS) ? TIOCM_CTS:0);

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s tiocmget() value=%08X\n",
			 __FILE__,__LINE__, info->device_name, result );
	return result;
}

/* set modem control signals (DTR/RTS)
 */
static int tiocmset(struct tty_struct *tty, struct file *file,
		    unsigned int set, unsigned int clear)
{
	SLMP_INFO *info = tty->driver_data;
 	unsigned long flags;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s tiocmset(%x,%x)\n",
			__FILE__,__LINE__,info->device_name, set, clear);

	if (set & TIOCM_RTS)
		info->serial_signals |= SerialSignal_RTS;
	if (set & TIOCM_DTR)
		info->serial_signals |= SerialSignal_DTR;
	if (clear & TIOCM_RTS)
		info->serial_signals &= ~SerialSignal_RTS;
	if (clear & TIOCM_DTR)
		info->serial_signals &= ~SerialSignal_DTR;

	spin_lock_irqsave(&info->lock,flags);
 	set_signals(info);
	spin_unlock_irqrestore(&info->lock,flags);

	return 0;
}

static int carrier_raised(struct tty_port *port)
{
	SLMP_INFO *info = container_of(port, SLMP_INFO, port);
	unsigned long flags;

	spin_lock_irqsave(&info->lock,flags);
 	get_signals(info);
	spin_unlock_irqrestore(&info->lock,flags);

	return (info->serial_signals & SerialSignal_DCD) ? 1 : 0;
}

static void dtr_rts(struct tty_port *port, int on)
{
	SLMP_INFO *info = container_of(port, SLMP_INFO, port);
	unsigned long flags;

	spin_lock_irqsave(&info->lock,flags);
	if (on)
		info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
	else
		info->serial_signals &= ~(SerialSignal_RTS + SerialSignal_DTR);
 	set_signals(info);
	spin_unlock_irqrestore(&info->lock,flags);
}

/* Block the current process until the specified port is ready to open.
 */
static int block_til_ready(struct tty_struct *tty, struct file *filp,
			   SLMP_INFO *info)
{
	DECLARE_WAITQUEUE(wait, current);
	int		retval;
	bool		do_clocal = false;
	bool		extra_count = false;
	unsigned long	flags;
	int		cd;
	struct tty_port *port = &info->port;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s block_til_ready()\n",
			 __FILE__,__LINE__, tty->driver->name );

	if (filp->f_flags & O_NONBLOCK || tty->flags & (1 << TTY_IO_ERROR)){
		/* nonblock mode is set or port is not enabled */
		/* just verify that callout device is not active */
		port->flags |= ASYNC_NORMAL_ACTIVE;
		return 0;
	}

	if (tty->termios->c_cflag & CLOCAL)
		do_clocal = true;

	/* Wait for carrier detect and the line to become
	 * free (i.e., not in use by the callout).  While we are in
	 * this loop, port->count is dropped by one, so that
	 * close() knows when to free things.  We restore it upon
	 * exit, either normal or abnormal.
	 */

	retval = 0;
	add_wait_queue(&port->open_wait, &wait);

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s block_til_ready() before block, count=%d\n",
			 __FILE__,__LINE__, tty->driver->name, port->count );

	spin_lock_irqsave(&info->lock, flags);
	if (!tty_hung_up_p(filp)) {
		extra_count = true;
		port->count--;
	}
	spin_unlock_irqrestore(&info->lock, flags);
	port->blocked_open++;

	while (1) {
		if (tty->termios->c_cflag & CBAUD)
			tty_port_raise_dtr_rts(port);

		set_current_state(TASK_INTERRUPTIBLE);

		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)){
			retval = (port->flags & ASYNC_HUP_NOTIFY) ?
					-EAGAIN : -ERESTARTSYS;
			break;
		}

		cd = tty_port_carrier_raised(port);

 		if (!(port->flags & ASYNC_CLOSING) && (do_clocal || cd))
 			break;

		if (signal_pending(current)) {
			retval = -ERESTARTSYS;
			break;
		}

		if (debug_level >= DEBUG_LEVEL_INFO)
			printk("%s(%d):%s block_til_ready() count=%d\n",
				 __FILE__,__LINE__, tty->driver->name, port->count );

		tty_unlock();
		schedule();
		tty_lock();
	}

	set_current_state(TASK_RUNNING);
	remove_wait_queue(&port->open_wait, &wait);

	if (extra_count)
		port->count++;
	port->blocked_open--;

	if (debug_level >= DEBUG_LEVEL_INFO)
		printk("%s(%d):%s block_til_ready() after, count=%d\n",
			 __FILE__,__LINE__, tty->driver->name, port->count );

	if (!retval)
		port->flags |= ASYNC_NORMAL_ACTIVE;

	return retval;
}

static int alloc_dma_bufs(SLMP_INFO *info)
{
	unsigned short BuffersPerFrame;
	unsigned short BufferCount;

	// Force allocation to start at 64K boundary for each port.
	// This is necessary because *all* buffer descriptors for a port
	// *must* be in the same 64K block. All descriptors on a port
	// share a common 'base' address (upper 8 bits of 24 bits) programmed
	// into the CBP register.
	info->port_array[0]->last_mem_alloc = (SCA_MEM_SIZE/4) * info->port_num;

	/* Calculate the number of DMA buffers necessary to hold the */
	/* largest allowable frame size. Note: If the max frame size is */
	/* not an even multiple of the DMA buffer size then we need to */
	/* round the buffer count per frame up one. */

	BuffersPerFrame = (unsigned short)(info->max_frame_size/SCABUFSIZE);
	if ( info->max_frame_size % SCABUFSIZE )
		BuffersPerFrame++;

	/* calculate total number of data buffers (SCABUFSIZE) possible
	 * in one ports memory (SCA_MEM_SIZE/4) after allocating memory
	 * for the descriptor list (BUFFERLISTSIZE).
	 */
	BufferCount = (SCA_MEM_SIZE/4 - BUFFERLISTSIZE)/SCABUFSIZE;

	/* limit number of buffers to maximum amount of descriptors */
	if (BufferCount > BUFFERLISTSIZE/sizeof(SCADESC))
		BufferCount = BUFFERLISTSIZE/sizeof(SCADESC);

	/* use enough buffers to transmit one max size frame */
	info->tx_buf_count = BuffersPerFrame + 1;

	/* never use more than half the available buffers for transmit */
	if (info->tx_buf_count > (BufferCount/2))
		info->tx_buf_count = BufferCount/2;

	if (info->tx_buf_count > SCAMAXDESC)
		info->tx_buf_count = SCAMAXDESC;

	/* use remaining buffers for receive */
	info->rx_buf_count = BufferCount - info->tx_buf_count;

	if (info->rx_buf_count > SCAMAXDESC)
		info->rx_buf_count = SCAMAXDESC;

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk("%s(%d):%s Allocating %d TX and %d RX DMA buffers.\n",
			__FILE__,__LINE__, info->device_name,
			info->tx_buf_count,info->rx_buf_count);

	if ( alloc_buf_list( info ) < 0 ||
		alloc_frame_bufs(info,
		  			info->rx_buf_list,
		  			info->rx_buf_list_ex,
					info->rx_buf_count) < 0 ||
		alloc_frame_bufs(info,
					info->tx_buf_list,
					info->tx_buf_list_ex,
					info->tx_buf_count) < 0 ||
		alloc_tmp_rx_buf(info) < 0 ) {
		printk("%s(%d):%s Can't allocate DMA buffer memory\n",
			__FILE__,__LINE__, info->device_name);
		return -ENOMEM;
	}

	rx_reset_buffers( info );

	return 0;
}

/* Allocate DMA buffers for the transmit and receive descriptor lists.
 */
static int alloc_buf_list(SLMP_INFO *info)
{
	unsigned int i;

	/* build list in adapter shared memory */
	info->buffer_list = info->memory_base + info->port_array[0]->last_mem_alloc;
	info->buffer_list_phys = info->port_array[0]->last_mem_alloc;
	info->port_array[0]->last_mem_alloc += BUFFERLISTSIZE;

	memset(info->buffer_list, 0, BUFFERLISTSIZE);

	/* Save virtual address pointers to the receive and */
	/* transmit buffer lists. (Receive 1st). These pointers will */
	/* be used by the processor to access the lists. */
	info->rx_buf_list = (SCADESC *)info->buffer_list;

	info->tx_buf_list = (SCADESC *)info->buffer_list;
	info->tx_buf_list += info->rx_buf_count;

	/* Build links for circular buffer entry lists (tx and rx)
	 *
	 * Note: links are physical addresses read by the SCA device
	 * to determine the next buffer entry to use.
	 */

	for ( i = 0; i < info->rx_buf_count; i++ ) {
		/* calculate and store physical address of this buffer entry */
		info->rx_buf_list_ex[i].phys_entry =
			info->buffer_list_phys + (i * sizeof(SCABUFSIZE));

		/* calculate and store physical address of */
		/* next entry in cirular list of entries */
		info->rx_buf_list[i].next = info->buffer_list_phys;
		if ( i < info->rx_buf_count - 1 )
			info->rx_buf_list[i].next += (i + 1) * sizeof(SCADESC);

		info->rx_buf_list[i].length = SCABUFSIZE;
	}

	for ( i = 0; i < info->tx_buf_count; i++ ) {
		/* calculate and store physical address of this buffer entry */
		info->tx_buf_list_ex[i].phys_entry = info->buffer_list_phys +
			((info->rx_buf_count + i) * sizeof(SCADESC));

		/* calculate and store physical address of */
		/* next entry in cirular list of entries */

		info->tx_buf_list[i].next = info->buffer_list_phys +
			info->rx_buf_count * sizeof(SCADESC);

		if ( i < info->tx_buf_count - 1 )
			info->tx_buf_list[i].next += (i + 1) * sizeof(SCADESC);
	}

	return 0;
}

/* Allocate the frame DMA buffers used by the specified buffer list.
 */
static int alloc_frame_bufs(SLMP_INFO *info, SCADESC *buf_list,SCADESC_EX *buf_list_ex,int count)
{
	int i;
	unsigned long phys_addr;

	for ( i = 0; i < count; i++ ) {
		buf_list_ex[i].virt_addr = info->memory_base + info->port_array[0]->last_mem_alloc;
		phys_addr = info->port_array[0]->last_mem_alloc;
		info->port_array[0]->last_mem_alloc += SCABUFSIZE;

		buf_list[i].buf_ptr  = (unsigned short)phys_addr;
		buf_list[i].buf_base = (unsigned char)(phys_addr >> 16);
	}

	return 0;
}

static void free_dma_bufs(SLMP_INFO *info)
{
	info->buffer_list = NULL;
	info->rx_buf_list = NULL;
	info->tx_buf_list = NULL;
}

/* allocate buffer large enough to hold max_frame_size.
 * This buffer is used to pass an assembled frame to the line discipline.
 */
static int alloc_tmp_rx_buf(SLMP_INFO *info)
{
	info->tmp_rx_buf = kmalloc(info->max_frame_size, GFP_KERNEL);
	if (info->tmp_rx_buf == NULL)
		return -ENOMEM;
	return 0;
}

static void free_tmp_rx_buf(SLMP_INFO *info)
{
	kfree(info->tmp_rx_buf);
	info->tmp_rx_buf = NULL;
}

static int claim_resources(SLMP_INFO *info)
{
	if (request_mem_region(info->phys_memory_base,SCA_MEM_SIZE,"synclinkmp") == NULL) {
		printk( "%s(%d):%s mem addr conflict, Addr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_memory_base);
		info->init_error = DiagStatus_AddressConflict;
		goto errout;
	}
	else
		info->shared_mem_requested = true;

	if (request_mem_region(info->phys_lcr_base + info->lcr_offset,128,"synclinkmp") == NULL) {
		printk( "%s(%d):%s lcr mem addr conflict, Addr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_lcr_base);
		info->init_error = DiagStatus_AddressConflict;
		goto errout;
	}
	else
		info->lcr_mem_requested = true;

	if (request_mem_region(info->phys_sca_base + info->sca_offset,SCA_BASE_SIZE,"synclinkmp") == NULL) {
		printk( "%s(%d):%s sca mem addr conflict, Addr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_sca_base);
		info->init_error = DiagStatus_AddressConflict;
		goto errout;
	}
	else
		info->sca_base_requested = true;

	if (request_mem_region(info->phys_statctrl_base + info->statctrl_offset,SCA_REG_SIZE,"synclinkmp") == NULL) {
		printk( "%s(%d):%s stat/ctrl mem addr conflict, Addr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_statctrl_base);
		info->init_error = DiagStatus_AddressConflict;
		goto errout;
	}
	else
		info->sca_statctrl_requested = true;

	info->memory_base = ioremap_nocache(info->phys_memory_base,
								SCA_MEM_SIZE);
	if (!info->memory_base) {
		printk( "%s(%d):%s Cant map shared memory, MemAddr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_memory_base );
		info->init_error = DiagStatus_CantAssignPciResources;
		goto errout;
	}

	info->lcr_base = ioremap_nocache(info->phys_lcr_base, PAGE_SIZE);
	if (!info->lcr_base) {
		printk( "%s(%d):%s Cant map LCR memory, MemAddr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_lcr_base );
		info->init_error = DiagStatus_CantAssignPciResources;
		goto errout;
	}
	info->lcr_base += info->lcr_offset;

	info->sca_base = ioremap_nocache(info->phys_sca_base, PAGE_SIZE);
	if (!info->sca_base) {
		printk( "%s(%d):%s Cant map SCA memory, MemAddr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_sca_base );
		info->init_error = DiagStatus_CantAssignPciResources;
		goto errout;
	}
	info->sca_base += info->sca_offset;

	info->statctrl_base = ioremap_nocache(info->phys_statctrl_base,
								PAGE_SIZE);
	if (!info->statctrl_base) {
		printk( "%s(%d):%s Cant map SCA Status/Control memory, MemAddr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_statctrl_base );
		info->init_error = DiagStatus_CantAssignPciResources;
		goto errout;
	}
	info->statctrl_base += info->statctrl_offset;

	if ( !memory_test(info) ) {
		printk( "%s(%d):Shared Memory Test failed for device %s MemAddr=%08X\n",
			__FILE__,__LINE__,info->device_name, info->phys_memory_base );
		info->init_error = DiagStatus_MemoryError;
		goto errout;
	}

	return 0;

errout:
	release_resources( info );
	return -ENODEV;
}

static void release_resources(SLMP_INFO *info)
{
	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk( "%s(%d):%s release_resources() entry\n",
			__FILE__,__LINE__,info->device_name );

	if ( info->irq_requested ) {
		free_irq(info->irq_level, info);
		info->irq_requested = false;
	}

	if ( info->shared_mem_requested ) {
		release_mem_region(info->phys_memory_base,SCA_MEM_SIZE);
		info->shared_mem_requested = false;
	}
	if ( info->lcr_mem_requested ) {
		release_mem_region(info->phys_lcr_base + info->lcr_offset,128);
		info->lcr_mem_requested = false;
	}
	if ( info->sca_base_requested ) {
		release_mem_region(info->phys_sca_base + info->sca_offset,SCA_BASE_SIZE);
		info->sca_base_requested = false;
	}
	if ( info->sca_statctrl_requested ) {
		release_mem_region(info->phys_statctrl_base + info->statctrl_offset,SCA_REG_SIZE);
		info->sca_statctrl_requested = false;
	}

	if (info->memory_base){
		iounmap(info->memory_base);
		info->memory_base = NULL;
	}

	if (info->sca_base) {
		iounmap(info->sca_base - info->sca_offset);
		info->sca_base=NULL;
	}

	if (info->statctrl_base) {
		iounmap(info->statctrl_base - info->statctrl_offset);
		info->statctrl_base=NULL;
	}

	if (info->lcr_base){
		iounmap(info->lcr_base - info->lcr_offset);
		info->lcr_base = NULL;
	}

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk( "%s(%d):%s release_resources() exit\n",
			__FILE__,__LINE__,info->device_name );
}

/* Add the specified device instance data structure to the
 * global linked list of devices and increment the device count.
 */
static void add_device(SLMP_INFO *info)
{
	info->next_device = NULL;
	info->line = synclinkmp_device_count;
	sprintf(info->device_name,"ttySLM%dp%d",info->adapter_num,info->port_num);

	if (info->line < MAX_DEVICES) {
		if (maxframe[info->line])
			info->max_frame_size = maxframe[info->line];
	}

	synclinkmp_device_count++;

	if ( !synclinkmp_device_list )
		synclinkmp_device_list = info;
	else {
		SLMP_INFO *current_dev = synclinkmp_device_list;
		while( current_dev->next_device )
			current_dev = current_dev->next_device;
		current_dev->next_device = info;
	}

	if ( info->max_frame_size < 4096 )
		info->max_frame_size = 4096;
	else if ( info->max_frame_size > 65535 )
		info->max_frame_size = 65535;

	printk( "SyncLink MultiPort %s: "
		"Mem=(%08x %08X %08x %08X) IRQ=%d MaxFrameSize=%u\n",
		info->device_name,
		info->phys_sca_base,
		info->phys_memory_base,
		info->phys_statctrl_base,
		info->phys_lcr_base,
		info->irq_level,
		info->max_frame_size );

#if SYNCLINK_GENERIC_HDLC
	hdlcdev_init(info);
#endif
}

static const struct tty_port_operations port_ops = {
	.carrier_raised = carrier_raised,
	.dtr_rts = dtr_rts,
};

/* Allocate and initialize a device instance structure
 *
 * Return Value:	pointer to SLMP_INFO if success, otherwise NULL
 */
static SLMP_INFO *alloc_dev(int adapter_num, int port_num, struct pci_dev *pdev)
{
	SLMP_INFO *info;

	info = kzalloc(sizeof(SLMP_INFO),
		 GFP_KERNEL);

	if (!info) {
		printk("%s(%d) Error can't allocate device instance data for adapter %d, port %d\n",
			__FILE__,__LINE__, adapter_num, port_num);
	} else {
		tty_port_init(&info->port);
		info->port.ops = &port_ops;
		info->magic = MGSL_MAGIC;
		INIT_WORK(&info->task, bh_handler);
		info->max_frame_size = 4096;
		info->port.close_delay = 5*HZ/10;
		info->port.closing_wait = 30*HZ;
		init_waitqueue_head(&info->status_event_wait_q);
		init_waitqueue_head(&info->event_wait_q);
		spin_lock_init(&info->netlock);
		memcpy(&info->params,&default_params,sizeof(MGSL_PARAMS));
		info->idle_mode = HDLC_TXIDLE_FLAGS;
		info->adapter_num = adapter_num;
		info->port_num = port_num;

		/* Copy configuration info to device instance data */
		info->irq_level = pdev->irq;
		info->phys_lcr_base = pci_resource_start(pdev,0);
		info->phys_sca_base = pci_resource_start(pdev,2);
		info->phys_memory_base = pci_resource_start(pdev,3);
		info->phys_statctrl_base = pci_resource_start(pdev,4);

		/* Because veremap only works on page boundaries we must map
		 * a larger area than is actually implemented for the LCR
		 * memory range. We map a full page starting at the page boundary.
		 */
		info->lcr_offset    = info->phys_lcr_base & (PAGE_SIZE-1);
		info->phys_lcr_base &= ~(PAGE_SIZE-1);

		info->sca_offset    = info->phys_sca_base & (PAGE_SIZE-1);
		info->phys_sca_base &= ~(PAGE_SIZE-1);

		info->statctrl_offset    = info->phys_statctrl_base & (PAGE_SIZE-1);
		info->phys_statctrl_base &= ~(PAGE_SIZE-1);

		info->bus_type = MGSL_BUS_TYPE_PCI;
		info->irq_flags = IRQF_SHARED;

		setup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);
		setup_timer(&info->status_timer, status_timeout,
				(unsigned long)info);

		/* Store the PCI9050 misc control register value because a flaw
		 * in the PCI9050 prevents LCR registers from being read if
		 * BIOS assigns an LCR base address with bit 7 set.
		 *
		 * Only the misc control register is accessed for which only
		 * write access is needed, so set an initial value and change
		 * bits to the device instance data as we write the value
		 * to the actual misc control register.
		 */
		info->misc_ctrl_value = 0x087e4546;

		/* initial port state is unknown - if startup errors
		 * occur, init_error will be set to indicate the
		 * problem. Once the port is fully initialized,
		 * this value will be set to 0 to indicate the
		 * port is available.
		 */
		info->init_error = -1;
	}

	return info;
}

static void device_init(int adapter_num, struct pci_dev *pdev)
{
	SLMP_INFO *port_array[SCA_MAX_PORTS];
	int port;

	/* allocate device instances for up to SCA_MAX_PORTS devices */
	for ( port = 0; port < SCA_MAX_PORTS; ++port ) {
		port_array[port] = alloc_dev(adapter_num,port,pdev);
		if( port_array[port] == NULL ) {
			for ( --port; port >= 0; --port )
				kfree(port_array[port]);
			return;
		}
	}

	/* give copy of port_array to all ports and add to device list  */
	for ( port = 0; port < SCA_MAX_PORTS; ++port ) {
		memcpy(port_array[port]->port_array,port_array,sizeof(port_array));
		add_device( port_array[port] );
		spin_lock_init(&port_array[port]->lock);
	}

	/* Allocate and claim adapter resources */
	if ( !claim_resources(port_array[0]) ) {

		alloc_dma_bufs(port_array[0]);

		/* copy resource information from first port to others */
		for ( port = 1; port < SCA_MAX_PORTS; ++port ) {
			port_array[port]->lock  = port_array[0]->lock;
			port_array[port]->irq_level     = port_array[0]->irq_level;
			port_array[port]->memory_base   = port_array[0]->memory_base;
			port_array[port]->sca_base      = port_array[0]->sca_base;
			port_array[port]->statctrl_base = port_array[0]->statctrl_base;
			port_array[port]->lcr_base      = port_array[0]->lcr_base;
			alloc_dma_bufs(port_array[port]);
		}

		if ( request_irq(port_array[0]->irq_level,
					synclinkmp_interrupt,
					port_array[0]->irq_flags,
					port_array[0]->device_name,
					port_array[0]) < 0 ) {
			printk( "%s(%d):%s Cant request interrupt, IRQ=%d\n",
				__FILE__,__LINE__,
				port_array[0]->device_name,
				port_array[0]->irq_level );
		}
		else {
			port_array[0]->irq_requested = true;
			adapter_test(port_array[0]);
		}
	}
}

static const struct tty_operations ops = {
	.open = open,
	.close = close,
	.write = write,
	.put_char = put_char,
	.flush_chars = flush_chars,
	.write_room = write_room,
	.chars_in_buffer = chars_in_buffer,
	.flush_buffer = flush_buffer,
	.ioctl = ioctl,
	.throttle = throttle,
	.unthrottle = unthrottle,
	.send_xchar = send_xchar,
	.break_ctl = set_break,
	.wait_until_sent = wait_until_sent,
	.set_termios = set_termios,
	.stop = tx_hold,
	.start = tx_release,
	.hangup = hangup,
	.tiocmget = tiocmget,
	.tiocmset = tiocmset,
	.proc_fops = &synclinkmp_proc_fops,
};


static void synclinkmp_cleanup(void)
{
	int rc;
	SLMP_INFO *info;
	SLMP_INFO *tmp;

	printk("Unloading %s %s\n", driver_name, driver_version);

	if (serial_driver) {
		if ((rc = tty_unregister_driver(serial_driver)))
			printk("%s(%d) failed to unregister tty driver err=%d\n",
			       __FILE__,__LINE__,rc);
		put_tty_driver(serial_driver);
	}

	/* reset devices */
	info = synclinkmp_device_list;
	while(info) {
		reset_port(info);
		info = info->next_device;
	}

	/* release devices */
	info = synclinkmp_device_list;
	while(info) {
#if SYNCLINK_GENERIC_HDLC
		hdlcdev_exit(info);
#endif
		free_dma_bufs(info);
		free_tmp_rx_buf(info);
		if ( info->port_num == 0 ) {
			if (info->sca_base)
				write_reg(info, LPR, 1); /* set low power mode */
			release_resources(info);
		}
		tmp = info;
		info = info->next_device;
		kfree(tmp);
	}

	pci_unregister_driver(&synclinkmp_pci_driver);
}

/* Driver initialization entry point.
 */

static int __init synclinkmp_init(void)
{
	int rc;

	if (break_on_load) {
	 	synclinkmp_get_text_ptr();
  		BREAKPOINT();
	}

 	printk("%s %s\n", driver_name, driver_version);

	if ((rc = pci_register_driver(&synclinkmp_pci_driver)) < 0) {
		printk("%s:failed to register PCI driver, error=%d\n",__FILE__,rc);
		return rc;
	}

	serial_driver = alloc_tty_driver(128);
	if (!serial_driver) {
		rc = -ENOMEM;
		goto error;
	}

	/* Initialize the tty_driver structure */

	serial_driver->owner = THIS_MODULE;
	serial_driver->driver_name = "synclinkmp";
	serial_driver->name = "ttySLM";
	serial_driver->major = ttymajor;
	serial_driver->minor_start = 64;
	serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
	serial_driver->subtype = SERIAL_TYPE_NORMAL;
	serial_driver->init_termios = tty_std_termios;
	serial_driver->init_termios.c_cflag =
		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
	serial_driver->init_termios.c_ispeed = 9600;
	serial_driver->init_termios.c_ospeed = 9600;
	serial_driver->flags = TTY_DRIVER_REAL_RAW;
	tty_set_operations(serial_driver, &ops);
	if ((rc = tty_register_driver(serial_driver)) < 0) {
		printk("%s(%d):Couldn't register serial driver\n",
			__FILE__,__LINE__);
		put_tty_driver(serial_driver);
		serial_driver = NULL;
		goto error;
	}

 	printk("%s %s, tty major#%d\n",
		driver_name, driver_version,
		serial_driver->major);

	return 0;

error:
	synclinkmp_cleanup();
	return rc;
}

static void __exit synclinkmp_exit(void)
{
	synclinkmp_cleanup();
}

module_init(synclinkmp_init);
module_exit(synclinkmp_exit);

/* Set the port for internal loopback mode.
 * The TxCLK and RxCLK signals are generated from the BRG and
 * the TxD is looped back to the RxD internally.
 */
static void enable_loopback(SLMP_INFO *info, int enable)
{
	if (enable) {
		/* MD2 (Mode Register 2)
		 * 01..00  CNCT<1..0> Channel Connection 11=Local Loopback
		 */
		write_reg(info, MD2, (unsigned char)(read_reg(info, MD2) | (BIT1 + BIT0)));

		/* degate external TxC clock source */
		info->port_array[0]->ctrlreg_value |= (BIT0 << (info->port_num * 2));
		write_control_reg(info);

		/* RXS/TXS (Rx/Tx clock source)
		 * 07      Reserved, must be 0
		 * 06..04  Clock Source, 100=BRG
		 * 03..00  Clock Divisor, 0000=1
		 */
		write_reg(info, RXS, 0x40);
		write_reg(info, TXS, 0x40);

	} else {
		/* MD2 (Mode Register 2)
	 	 * 01..00  CNCT<1..0> Channel connection, 0=normal
		 */
		write_reg(info, MD2, (unsigned char)(read_reg(info, MD2) & ~(BIT1 + BIT0)));

		/* RXS/TXS (Rx/Tx clock source)
		 * 07      Reserved, must be 0
		 * 06..04  Clock Source, 000=RxC/TxC Pin
		 * 03..00  Clock Divisor, 0000=1
		 */
		write_reg(info, RXS, 0x00);
		write_reg(info, TXS, 0x00);
	}

	/* set LinkSpeed if available, otherwise default to 2Mbps */
	if (info->params.clock_speed)
		set_rate(info, info->params.clock_speed);
	else
		set_rate(info, 3686400);
}

/* Set the baud rate register to the desired speed
 *
 *	data_rate	data rate of clock in bits per second
 *			A data rate of 0 disables the AUX clock.
 */
static void set_rate( SLMP_INFO *info, u32 data_rate )
{
       	u32 TMCValue;
       	unsigned char BRValue;
	u32 Divisor=0;

	/* fBRG = fCLK/(TMC * 2^BR)
	 */
	if (data_rate != 0) {
		Divisor = 14745600/data_rate;
		if (!Divisor)
			Divisor = 1;

		TMCValue = Divisor;

		BRValue = 0;
		if (TMCValue != 1 && TMCValue != 2) {
			/* BRValue of 0 provides 50/50 duty cycle *only* when
			 * TMCValue is 1 or 2. BRValue of 1 to 9 always provides
			 * 50/50 duty cycle.
			 */
			BRValue = 1;
			TMCValue >>= 1;
		}

		/* while TMCValue is too big for TMC register, divide
		 * by 2 and increment BR exponent.
		 */
		for(; TMCValue > 256 && BRValue < 10; BRValue++)
			TMCValue >>= 1;

		write_reg(info, TXS,
			(unsigned char)((read_reg(info, TXS) & 0xf0) | BRValue));
		write_reg(info, RXS,
			(unsigned char)((read_reg(info, RXS) & 0xf0) | BRValue));
		write_reg(info, TMC, (unsigned char)TMCValue);
	}
	else {
		write_reg(info, TXS,0);
		write_reg(info, RXS,0);
		write_reg(info, TMC, 0);
	}
}

/* Disable receiver
 */
static void rx_stop(SLMP_INFO *info)
{
	if (debug_level >= DEBUG_LEVEL_ISR)
		printk("%s(%d):%s rx_stop()\n",
			 __FILE__,__LINE__, info->device_name );

	write_reg(info, CMD, RXRESET);

	info->ie0_value &= ~RXRDYE;
	write_reg(info, IE0, info->ie0_value);	/* disable Rx data interrupts */

	write_reg(info, RXDMA + DSR, 0);	/* disable Rx DMA */
	write_reg(info, RXDMA + DCMD, SWABORT);	/* reset/init Rx DMA */
	write_reg(info, RXDMA + DIR, 0);	/* disable Rx DMA interrupts */

	info->rx_enabled = false;
	info->rx_overflow = false;
}

/* enable the receiver
 */
static void rx_start(SLMP_INFO *info)
{
	int i;

	if (debug_level >= DEBUG_LEVEL_ISR)
		printk("%s(%d):%s rx_start()\n",
			 __FILE__,__LINE__, info->device_name );

	write_reg(info, CMD, RXRESET);

	if ( info->params.mode == MGSL_MODE_HDLC ) {
		/* HDLC, disabe IRQ on rxdata */
		info->ie0_value &= ~RXRDYE;
		write_reg(info, IE0, info->ie0_value);

		/* Reset all Rx DMA buffers and program rx dma */
		write_reg(info, RXDMA + DSR, 0);		/* disable Rx DMA */
		write_reg(info, RXDMA + DCMD, SWABORT);	/* reset/init Rx DMA */

		for (i = 0; i < info->rx_buf_count; i++) {
			info->rx_buf_list[i].status = 0xff;

			// throttle to 4 shared memory writes at a time to prevent
			// hogging local bus (keep latency time for DMA requests low).
			if (!(i % 4))
				read_status_reg(info);
		}
		info->current_rx_buf = 0;

		/* set current/1st descriptor address */
		write_reg16(info, RXDMA + CDA,
			info->rx_buf_list_ex[0].phys_entry);

		/* set new last rx descriptor address */
		write_reg16(info, RXDMA + EDA,
			info->rx_buf_list_ex[info->rx_buf_count - 1].phys_entry);

		/* set buffer length (shared by all rx dma data buffers) */
		write_reg16(info, RXDMA + BFL, SCABUFSIZE);

		write_reg(info, RXDMA + DIR, 0x60);	/* enable Rx DMA interrupts (EOM/BOF) */
		write_reg(info, RXDMA + DSR, 0xf2);	/* clear Rx DMA IRQs, enable Rx DMA */
	} else {
		/* async, enable IRQ on rxdata */
		info->ie0_value |= RXRDYE;
		write_reg(info, IE0, info->ie0_value);
	}

	write_reg(info, CMD, RXENABLE);

	info->rx_overflow = false;
	info->rx_enabled = true;
}

/* Enable the transmitter and send a transmit frame if
 * one is loaded in the DMA buffers.
 */
static void tx_start(SLMP_INFO *info)
{
	if (debug_level >= DEBUG_LEVEL_ISR)
		printk("%s(%d):%s tx_start() tx_count=%d\n",
			 __FILE__,__LINE__, info->device_name,info->tx_count );

	if (!info->tx_enabled ) {
		write_reg(info, CMD, TXRESET);
		write_reg(info, CMD, TXENABLE);
		info->tx_enabled = true;
	}

	if ( info->tx_count ) {

		/* If auto RTS enabled and RTS is inactive, then assert */
		/* RTS and set a flag indicating that the driver should */
		/* negate RTS when the transmission completes. */

		info->drop_rts_on_tx_done = false;

		if (info->params.mode != MGSL_MODE_ASYNC) {

			if ( info->params.flags & HDLC_FLAG_AUTO_RTS ) {
				get_signals( info );
				if ( !(info->serial_signals & SerialSignal_RTS) ) {
					info->serial_signals |= SerialSignal_RTS;
					set_signals( info );
					info->drop_rts_on_tx_done = true;
				}
			}

			write_reg16(info, TRC0,
				(unsigned short)(((tx_negate_fifo_level-1)<<8) + tx_active_fifo_level));

			write_reg(info, TXDMA + DSR, 0); 		/* disable DMA channel */
			write_reg(info, TXDMA + DCMD, SWABORT);	/* reset/init DMA channel */
	
			/* set TX CDA (current descriptor address) */
			write_reg16(info, TXDMA + CDA,
				info->tx_buf_list_ex[0].phys_entry);
	
			/* set TX EDA (last descriptor address) */
			write_reg16(info, TXDMA + EDA,
				info->tx_buf_list_ex[info->last_tx_buf].phys_entry);
	
			/* enable underrun IRQ */
			info->ie1_value &= ~IDLE;
			info->ie1_value |= UDRN;
			write_reg(info, IE1, info->ie1_value);
			write_reg(info, SR1, (unsigned char)(IDLE + UDRN));
	
			write_reg(info, TXDMA + DIR, 0x40);		/* enable Tx DMA interrupts (EOM) */
			write_reg(info, TXDMA + DSR, 0xf2);		/* clear Tx DMA IRQs, enable Tx DMA */
	
			mod_timer(&info->tx_timer, jiffies +
					msecs_to_jiffies(5000));
		}
		else {
			tx_load_fifo(info);
			/* async, enable IRQ on txdata */
			info->ie0_value |= TXRDYE;
			write_reg(info, IE0, info->ie0_value);
		}

		info->tx_active = true;
	}
}

/* stop the transmitter and DMA
 */
static void tx_stop( SLMP_INFO *info )
{
	if (debug_level >= DEBUG_LEVEL_ISR)
		printk("%s(%d):%s tx_stop()\n",
			 __FILE__,__LINE__, info->device_name );

	del_timer(&info->tx_timer);

	write_reg(info, TXDMA + DSR, 0);		/* disable DMA channel */
	write_reg(info, TXDMA + DCMD, SWABORT);	/* reset/init DMA channel */

	write_reg(info, CMD, TXRESET);

	info->ie1_value &= ~(UDRN + IDLE);
	write_reg(info, IE1, info->ie1_value);	/* disable tx status interrupts */
	write_reg(info, SR1, (unsigned char)(IDLE + UDRN));	/* clear pending */

	info->ie0_value &= ~TXRDYE;
	write_reg(info, IE0, info->ie0_value);	/* disable tx data interrupts */

	info->tx_enabled = false;
	info->tx_active = false;
}

/* Fill the transmit FIFO until the FIFO is full or
 * there is no more data to load.
 */
static void tx_load_fifo(SLMP_INFO *info)
{
	u8 TwoBytes[2];

	/* do nothing is now tx data available and no XON/XOFF pending */

	if ( !info->tx_count && !info->x_char )
		return;

	/* load the Transmit FIFO until FIFOs full or all data sent */

	while( info->tx_count && (read_reg(info,SR0) & BIT1) ) {

		/* there is more space in the transmit FIFO and */
		/* there is more data in transmit buffer */

		if ( (info->tx_count > 1) && !info->x_char ) {
 			/* write 16-bits */
			TwoBytes[0] = info->tx_buf[info->tx_get++];
			if (info->tx_get >= info->max_frame_size)
				info->tx_get -= info->max_frame_size;
			TwoBytes[1] = info->tx_buf[info->tx_get++];
			if (info->tx_get >= info->max_frame_size)
				info->tx_get -= info->max_frame_size;

			write_reg16(info, TRB, *((u16 *)TwoBytes));

			info->tx_count -= 2;
			info->icount.tx += 2;
		} else {
			/* only 1 byte left to transmit or 1 FIFO slot left */

			if (info->x_char) {
				/* transmit pending high priority char */
				write_reg(info, TRB, info->x_char);
				info->x_char = 0;
			} else {
				write_reg(info, TRB, info->tx_buf[info->tx_get++]);
				if (info->tx_get >= info->max_frame_size)
					info->tx_get -= info->max_frame_size;
				info->tx_count--;
			}
			info->icount.tx++;
		}
	}
}

/* Reset a port to a known state
 */
static void reset_port(SLMP_INFO *info)
{
	if (info->sca_base) {

		tx_stop(info);
		rx_stop(info);

		info->serial_signals &= ~(SerialSignal_DTR + SerialSignal_RTS);
		set_signals(info);

		/* disable all port interrupts */
		info->ie0_value = 0;
		info->ie1_value = 0;
		info->ie2_value = 0;
		write_reg(info, IE0, info->ie0_value);
		write_reg(info, IE1, info->ie1_value);
		write_reg(info, IE2, info->ie2_value);

		write_reg(info, CMD, CHRESET);
	}
}

/* Reset all the ports to a known state.
 */
static void reset_adapter(SLMP_INFO *info)
{
	int i;

	for ( i=0; i < SCA_MAX_PORTS; ++i) {
		if (info->port_array[i])
			reset_port(info->port_array[i]);
	}
}

/* Program port for asynchronous communications.
 */
static void async_mode(SLMP_INFO *info)
{

  	unsigned char RegValue;

	tx_stop(info);
	rx_stop(info);

	/* MD0, Mode Register 0
	 *
	 * 07..05  PRCTL<2..0>, Protocol Mode, 000=async
	 * 04      AUTO, Auto-enable (RTS/CTS/DCD)
	 * 03      Reserved, must be 0
	 * 02      CRCCC, CRC Calculation, 0=disabled
	 * 01..00  STOP<1..0> Stop bits (00=1,10=2)
	 *
	 * 0000 0000
	 */
	RegValue = 0x00;
	if (info->params.stop_bits != 1)
		RegValue |= BIT1;
	write_reg(info, MD0, RegValue);

	/* MD1, Mode Register 1
	 *
	 * 07..06  BRATE<1..0>, bit rate, 00=1/1 01=1/16 10=1/32 11=1/64
	 * 05..04  TXCHR<1..0>, tx char size, 00=8 bits,01=7,10=6,11=5
	 * 03..02  RXCHR<1..0>, rx char size
	 * 01..00  PMPM<1..0>, Parity mode, 00=none 10=even 11=odd
	 *
	 * 0100 0000
	 */
	RegValue = 0x40;
	switch (info->params.data_bits) {
	case 7: RegValue |= BIT4 + BIT2; break;
	case 6: RegValue |= BIT5 + BIT3; break;
	case 5: RegValue |= BIT5 + BIT4 + BIT3 + BIT2; break;
	}
	if (info->params.parity != ASYNC_PARITY_NONE) {
		RegValue |= BIT1;
		if (info->params.parity == ASYNC_PARITY_ODD)
			RegValue |= BIT0;
	}
	write_reg(info, MD1, RegValue);

	/* MD2, Mode Register 2
	 *
	 * 07..02  Reserved, must be 0
	 * 01..00  CNCT<1..0> Channel connection, 00=normal 11=local loopback
	 *
	 * 0000 0000
	 */
	RegValue = 0x00;
	if (info->params.loopback)
		RegValue |= (BIT1 + BIT0);
	write_reg(info, MD2, RegValue);

	/* RXS, Receive clock source
	 *
	 * 07      Reserved, must be 0
	 * 06..04  RXCS<2..0>, clock source, 000=RxC Pin, 100=BRG, 110=DPLL
	 * 03..00  RXBR<3..0>, rate divisor, 0000=1
	 */
	RegValue=BIT6;
	write_reg(info, RXS, RegValue);

	/* TXS, Transmit clock source
	 *
	 * 07      Reserved, must be 0
	 * 06..04  RXCS<2..0>, clock source, 000=TxC Pin, 100=BRG, 110=Receive Clock
	 * 03..00  RXBR<3..0>, rate divisor, 0000=1
	 */
	RegValue=BIT6;
	write_reg(info, TXS, RegValue);

	/* Control Register
	 *
	 * 6,4,2,0  CLKSEL<3..0>, 0 = TcCLK in, 1 = Auxclk out
	 */
	info->port_array[0]->ctrlreg_value |= (BIT0 << (info->port_num * 2));
	write_control_reg(info);

	tx_set_idle(info);

	/* RRC Receive Ready Control 0
	 *
	 * 07..05  Reserved, must be 0
	 * 04..00  RRC<4..0> Rx FIFO trigger active 0x00 = 1 byte
	 */
	write_reg(info, RRC, 0x00);

	/* TRC0 Transmit Ready Control 0
	 *
	 * 07..05  Reserved, must be 0
	 * 04..00  TRC<4..0> Tx FIFO trigger active 0x10 = 16 bytes
	 */
	write_reg(info, TRC0, 0x10);

	/* TRC1 Transmit Ready Control 1
	 *
	 * 07..05  Reserved, must be 0
	 * 04..00  TRC<4..0> Tx FIFO trigger inactive 0x1e = 31 bytes (full-1)
	 */
	write_reg(info, TRC1, 0x1e);

	/* CTL, MSCI control register
	 *
	 * 07..06  Reserved, set to 0
	 * 05      UDRNC, underrun control, 0=abort 1=CRC+flag (HDLC/BSC)
	 * 04      IDLC, idle control, 0=mark 1=idle register
	 * 03      BRK, break, 0=off 1 =on (async)
	 * 02      SYNCLD, sync char load enable (BSC) 1=enabled
	 * 01      GOP, go active on poll (LOOP mode) 1=enabled
	 * 00      RTS, RTS output control, 0=active 1=inactive
	 *
	 * 0001 0001
	 */
	RegValue = 0x10;
	if (!(info->serial_signals & SerialSignal_RTS))
		RegValue |= 0x01;
	write_reg(info, CTL, RegValue);

	/* enable status interrupts */
	info->ie0_value |= TXINTE + RXINTE;
	write_reg(info, IE0, info->ie0_value);

	/* enable break detect interrupt */
	info->ie1_value = BRKD;
	write_reg(info, IE1, info->ie1_value);

	/* enable rx overrun interrupt */
	info->ie2_value = OVRN;
	write_reg(info, IE2, info->ie2_value);

	set_rate( info, info->params.data_rate * 16 );
}

/* Program the SCA for HDLC communications.
 */
static void hdlc_mode(SLMP_INFO *info)
{
	unsigned char RegValue;
	u32 DpllDivisor;

	// Can't use DPLL because SCA outputs recovered clock on RxC when
	// DPLL mode selected. This causes output contention with RxC receiver.
	// Use of DPLL would require external hardware to disable RxC receiver
	// when DPLL mode selected.
	info->params.flags &= ~(HDLC_FLAG_TXC_DPLL + HDLC_FLAG_RXC_DPLL);

	/* disable DMA interrupts */
	write_reg(info, TXDMA + DIR, 0);
	write_reg(info, RXDMA + DIR, 0);

	/* MD0, Mode Register 0
	 *
	 * 07..05  PRCTL<2..0>, Protocol Mode, 100=HDLC
	 * 04      AUTO, Auto-enable (RTS/CTS/DCD)
	 * 03      Reserved, must be 0
	 * 02      CRCCC, CRC Calculation, 1=enabled
	 * 01      CRC1, CRC selection, 0=CRC-16,1=CRC-CCITT-16
	 * 00      CRC0, CRC initial value, 1 = all 1s
	 *
	 * 1000 0001
	 */
	RegValue = 0x81;
	if (info->params.flags & HDLC_FLAG_AUTO_CTS)
		RegValue |= BIT4;
	if (info->params.flags & HDLC_FLAG_AUTO_DCD)
		RegValue |= BIT4;
	if (info->params.crc_type == HDLC_CRC_16_CCITT)
		RegValue |= BIT2 + BIT1;
	write_reg(info, MD0, RegValue);

	/* MD1, Mode Register 1
	 *
	 * 07..06  ADDRS<1..0>, Address detect, 00=no addr check
	 * 05..04  TXCHR<1..0>, tx char size, 00=8 bits
	 * 03..02  RXCHR<1..0>, rx char size, 00=8 bits
	 * 01..00  PMPM<1..0>, Parity mode, 00=no parity
	 *
	 * 0000 0000
	 */
	RegValue = 0x00;
	write_reg(info, MD1, RegValue);

	/* MD2, Mode Register 2
	 *
	 * 07      NRZFM, 0=NRZ, 1=FM
	 * 06..05  CODE<1..0> Encoding, 00=NRZ
	 * 04..03  DRATE<1..0> DPLL Divisor, 00=8
	 * 02      Reserved, must be 0
	 * 01..00  CNCT<1..0> Channel connection, 0=normal
	 *
	 * 0000 0000
	 */
	RegValue = 0x00;
	switch(info->params.encoding) {
	case HDLC_ENCODING_NRZI:	  RegValue |= BIT5; break;
	case HDLC_ENCODING_BIPHASE_MARK:  RegValue |= BIT7 + BIT5; break; /* aka FM1 */
	case HDLC_ENCODING_BIPHASE_SPACE: RegValue |= BIT7 + BIT6; break; /* aka FM0 */
	case HDLC_ENCODING_BIPHASE_LEVEL: RegValue |= BIT7; break; 	/* aka Manchester */
#if 0
	case HDLC_ENCODING_NRZB:	       				/* not supported */
	case HDLC_ENCODING_NRZI_MARK:          				/* not supported */
	case HDLC_ENCODING_DIFF_BIPHASE_LEVEL: 				/* not supported */
#endif
	}
	if ( info->params.flags & HDLC_FLAG_DPLL_DIV16 ) {
		DpllDivisor = 16;
		RegValue |= BIT3;
	} else if ( info->params.flags & HDLC_FLAG_DPLL_DIV8 ) {
		DpllDivisor = 8;
	} else {
		DpllDivisor = 32;
		RegValue |= BIT4;
	}
	write_reg(info, MD2, RegValue);


	/* RXS, Receive clock source
	 *
	 * 07      Reserved, must be 0
	 * 06..04  RXCS<2..0>, clock source, 000=RxC Pin, 100=BRG, 110=DPLL
	 * 03..00  RXBR<3..0>, rate divisor, 0000=1
	 */
	RegValue=0;
	if (info->params.flags & HDLC_FLAG_RXC_BRG)
		RegValue |= BIT6;
	if (info->params.flags & HDLC_FLAG_RXC_DPLL)
		RegValue |= BIT6 + BIT5;
	write_reg(info, RXS, RegValue);

	/* TXS, Transmit clock source
	 *
	 * 07      Reserved, must be 0
	 * 06..04  RXCS<2..0>, clock source, 000=TxC Pin, 100=BRG, 110=Receive Clock
	 * 03..00  RXBR<3..0>, rate divisor, 0000=1
	 */
	RegValue=0;
	if (info->params.flags & HDLC_FLAG_TXC_BRG)
		RegValue |= BIT6;
	if (info->params.flags & HDLC_FLAG_TXC_DPLL)
		RegValue |= BIT6 + BIT5;
	write_reg(info, TXS, RegValue);

	if (info->params.flags & HDLC_FLAG_RXC_DPLL)
		set_rate(info, info->params.clock_speed * DpllDivisor);
	else
		set_rate(info, info->params.clock_speed);

	/* GPDATA (General Purpose I/O Data Register)
	 *
	 * 6,4,2,0  CLKSEL<3..0>, 0 = TcCLK in, 1 = Auxclk out
	 */
	if (info->params.flags & HDLC_FLAG_TXC_BRG)
		info->port_array[0]->ctrlreg_value |= (BIT0 << (info->port_num * 2));
	else
		info->port_array[0]->ctrlreg_value &= ~(BIT0 << (info->port_num * 2));
	write_control_reg(info);

	/* RRC Receive Ready Control 0
	 *
	 * 07..05  Reserved, must be 0
	 * 04..00  RRC<4..0> Rx FIFO trigger active
	 */
	write_reg(info, RRC, rx_active_fifo_level);

	/* TRC0 Transmit Ready Control 0
	 *
	 * 07..05  Reserved, must be 0
	 * 04..00  TRC<4..0> Tx FIFO trigger active
	 */
	write_reg(info, TRC0, tx_active_fifo_level);

	/* TRC1 Transmit Ready Control 1
	 *
	 * 07..05  Reserved, must be 0
	 * 04..00  TRC<4..0> Tx FIFO trigger inactive 0x1f = 32 bytes (full)
	 */
	write_reg(info, TRC1, (unsigned char)(tx_negate_fifo_level - 1));

	/* DMR, DMA Mode Register
	 *
	 * 07..05  Reserved, must be 0
	 * 04      TMOD, Transfer Mode: 1=chained-block
	 * 03      Reserved, must be 0
	 * 02      NF, Number of Frames: 1=multi-frame
	 * 01      CNTE, Frame End IRQ Counter enable: 0=disabled
	 * 00      Reserved, must be 0
	 *
	 * 0001 0100
	 */
	write_reg(info, TXDMA + DMR, 0x14);
	write_reg(info, RXDMA + DMR, 0x14);

	/* Set chain pointer base (upper 8 bits of 24 bit addr) */
	write_reg(info, RXDMA + CPB,
		(unsigned char)(info->buffer_list_phys >> 16));

	/* Set chain pointer base (upper 8 bits of 24 bit addr) */
	write_reg(info, TXDMA + CPB,
		(unsigned char)(info->buffer_list_phys >> 16));

	/* enable status interrupts. other code enables/disables
	 * the individual sources for these two interrupt classes.
	 */
	info->ie0_value |= TXINTE + RXINTE;
	write_reg(info, IE0, info->ie0_value);

	/* CTL, MSCI control register
	 *
	 * 07..06  Reserved, set to 0
	 * 05      UDRNC, underrun control, 0=abort 1=CRC+flag (HDLC/BSC)
	 * 04      IDLC, idle control, 0=mark 1=idle register
	 * 03      BRK, break, 0=off 1 =on (async)
	 * 02      SYNCLD, sync char load enable (BSC) 1=enabled
	 * 01      GOP, go active on poll (LOOP mode) 1=enabled
	 * 00      RTS, RTS output control, 0=active 1=inactive
	 *
	 * 0001 0001
	 */
	RegValue = 0x10;
	if (!(info->serial_signals & SerialSignal_RTS))
		RegValue |= 0x01;
	write_reg(info, CTL, RegValue);

	/* preamble not supported ! */

	tx_set_idle(info);
	tx_stop(info);
	rx_stop(info);

	set_rate(info, info->params.clock_speed);

	if (info->params.loopback)
		enable_loopback(info,1);
}

/* Set the transmit HDLC idle mode
 */
static void tx_set_idle(SLMP_INFO *info)
{
	unsigned char RegValue = 0xff;

	/* Map API idle mode to SCA register bits */
	switch(info->idle_mode) {
	case HDLC_TXIDLE_FLAGS:			RegValue = 0x7e; break;
	case HDLC_TXIDLE_ALT_ZEROS_ONES:	RegValue = 0xaa; break;
	case HDLC_TXIDLE_ZEROS:			RegValue = 0x00; break;
	case HDLC_TXIDLE_ONES:			RegValue = 0xff; break;
	case HDLC_TXIDLE_ALT_MARK_SPACE:	RegValue = 0xaa; break;
	case HDLC_TXIDLE_SPACE:			RegValue = 0x00; break;
	case HDLC_TXIDLE_MARK:			RegValue = 0xff; break;
	}

	write_reg(info, IDL, RegValue);
}

/* Query the adapter for the state of the V24 status (input) signals.
 */
static void get_signals(SLMP_INFO *info)
{
	u16 status = read_reg(info, SR3);
	u16 gpstatus = read_status_reg(info);
	u16 testbit;

	/* clear all serial signals except DTR and RTS */
	info->serial_signals &= SerialSignal_DTR + SerialSignal_RTS;

	/* set serial signal bits to reflect MISR */

	if (!(status & BIT3))
		info->serial_signals |= SerialSignal_CTS;

	if ( !(status & BIT2))
		info->serial_signals |= SerialSignal_DCD;

	testbit = BIT1 << (info->port_num * 2); // Port 0..3 RI is GPDATA<1,3,5,7>
	if (!(gpstatus & testbit))
		info->serial_signals |= SerialSignal_RI;

	testbit = BIT0 << (info->port_num * 2); // Port 0..3 DSR is GPDATA<0,2,4,6>
	if (!(gpstatus & testbit))
		info->serial_signals |= SerialSignal_DSR;
}

/* Set the state of DTR and RTS based on contents of
 * serial_signals member of device context.
 */
static void set_signals(SLMP_INFO *info)
{
	unsigned char RegValue;
	u16 EnableBit;

	RegValue = read_reg(info, CTL);
	if (info->serial_signals & SerialSignal_RTS)
		RegValue &= ~BIT0;
	else
		RegValue |= BIT0;
	write_reg(info, CTL, RegValue);

	// Port 0..3 DTR is ctrl reg <1,3,5,7>
	EnableBit = BIT1 << (info->port_num*2);
	if (info->serial_signals & SerialSignal_DTR)
		info->port_array[0]->ctrlreg_value &= ~EnableBit;
	else
		info->port_array[0]->ctrlreg_value |= EnableBit;
	write_control_reg(info);
}

/*******************/
/* DMA Buffer Code */
/*******************/

/* Set the count for all receive buffers to SCABUFSIZE
 * and set the current buffer to the first buffer. This effectively
 * makes all buffers free and discards any data in buffers.
 */
static void rx_reset_buffers(SLMP_INFO *info)
{
	rx_free_frame_buffers(info, 0, info->rx_buf_count - 1);
}

/* Free the buffers used by a received frame
 *
 * info   pointer to device instance data
 * first  index of 1st receive buffer of frame
 * last   index of last receive buffer of frame
 */
static void rx_free_frame_buffers(SLMP_INFO *info, unsigned int first, unsigned int last)
{
	bool done = false;

	while(!done) {
	        /* reset current buffer for reuse */
		info->rx_buf_list[first].status = 0xff;

	        if (first == last) {
	                done = true;
	                /* set new last rx descriptor address */
			write_reg16(info, RXDMA + EDA, info->rx_buf_list_ex[first].phys_entry);
	        }

	        first++;
		if (first == info->rx_buf_count)
			first = 0;
	}

	/* set current buffer to next buffer after last buffer of frame */
	info->current_rx_buf = first;
}

/* Return a received frame from the receive DMA buffers.
 * Only frames received without errors are returned.
 *
 * Return Value:	true if frame returned, otherwise false
 */
static bool rx_get_frame(SLMP_INFO *info)
{
	unsigned int StartIndex, EndIndex;	/* index of 1st and last buffers of Rx frame */
	unsigned short status;
	unsigned int framesize = 0;
	bool ReturnCode = false;
	unsigned long flags;
	struct tty_struct *tty = info->port.tty;
	unsigned char addr_field = 0xff;
   	SCADESC *desc;
	SCADESC_EX *desc_ex;

CheckAgain:
	/* assume no frame returned, set zero length */
	framesize = 0;
	addr_field = 0xff;

	/*
	 * current_rx_buf points to the 1st buffer of the next available
	 * receive frame. To find the last buffer of the frame look for
	 * a non-zero status field in the buffer entries. (The status
	 * field is set by the 16C32 after completing a receive frame.
	 */
	StartIndex = EndIndex = info->current_rx_buf;

	for ( ;; ) {
		desc = &info->rx_buf_list[EndIndex];
		desc_ex = &info->rx_buf_list_ex[EndIndex];

		if (desc->status == 0xff)
			goto Cleanup;	/* current desc still in use, no frames available */

		if (framesize == 0 && info->params.addr_filter != 0xff)
			addr_field = desc_ex->virt_addr[0];

		framesize += desc->length;

		/* Status != 0 means last buffer of frame */
		if (desc->status)
			break;

		EndIndex++;
		if (EndIndex == info->rx_buf_count)
			EndIndex = 0;

		if (EndIndex == info->current_rx_buf) {
			/* all buffers have been 'used' but none mark	   */
			/* the end of a frame. Reset buffers and receiver. */
			if ( info->rx_enabled ){
				spin_lock_irqsave(&info->lock,flags);
				rx_start(info);
				spin_unlock_irqrestore(&info->lock,flags);
			}
			goto Cleanup;
		}

	}

	/* check status of receive frame */

	/* frame status is byte stored after frame data
	 *
	 * 7 EOM (end of msg), 1 = last buffer of frame
	 * 6 Short Frame, 1 = short frame
	 * 5 Abort, 1 = frame aborted
	 * 4 Residue, 1 = last byte is partial
	 * 3 Overrun, 1 = overrun occurred during frame reception
	 * 2 CRC,     1 = CRC error detected
	 *
	 */
	status = desc->status;

	/* ignore CRC bit if not using CRC (bit is undefined) */
	/* Note:CRC is not save to data buffer */
	if (info->params.crc_type == HDLC_CRC_NONE)
		status &= ~BIT2;

	if (framesize == 0 ||
		 (addr_field != 0xff && addr_field != info->params.addr_filter)) {
		/* discard 0 byte frames, this seems to occur sometime
		 * when remote is idling flags.
		 */
		rx_free_frame_buffers(info, StartIndex, EndIndex);
		goto CheckAgain;
	}

	if (framesize < 2)
		status |= BIT6;

	if (status & (BIT6+BIT5+BIT3+BIT2)) {
		/* received frame has errors,
		 * update counts and mark frame size as 0
		 */
		if (status & BIT6)
			info->icount.rxshort++;
		else if (status & BIT5)
			info->icount.rxabort++;
		else if (status & BIT3)
			info->icount.rxover++;
		else
			info->icount.rxcrc++;

		framesize = 0;
#if SYNCLINK_GENERIC_HDLC
		{
			info->netdev->stats.rx_errors++;
			info->netdev->stats.rx_frame_errors++;
		}
#endif
	}

	if ( debug_level >= DEBUG_LEVEL_BH )
		printk("%s(%d):%s rx_get_frame() status=%04X size=%d\n",
			__FILE__,__LINE__,info->device_name,status,framesize);

	if ( debug_level >= DEBUG_LEVEL_DATA )
		trace_block(info,info->rx_buf_list_ex[StartIndex].virt_addr,
			min_t(int, framesize,SCABUFSIZE),0);

	if (framesize) {
		if (framesize > info->max_frame_size)
			info->icount.rxlong++;
		else {
			/* copy dma buffer(s) to contiguous intermediate buffer */
			int copy_count = framesize;
			int index = StartIndex;
			unsigned char *ptmp = info->tmp_rx_buf;
			info->tmp_rx_buf_count = framesize;

			info->icount.rxok++;

			while(copy_count) {
				int partial_count = min(copy_count,SCABUFSIZE);
				memcpy( ptmp,
					info->rx_buf_list_ex[index].virt_addr,
					partial_count );
				ptmp += partial_count;
				copy_count -= partial_count;

				if ( ++index == info->rx_buf_count )
					index = 0;
			}

#if SYNCLINK_GENERIC_HDLC
			if (info->netcount)
				hdlcdev_rx(info,info->tmp_rx_buf,framesize);
			else
#endif
				ldisc_receive_buf(tty,info->tmp_rx_buf,
						  info->flag_buf, framesize);
		}
	}
	/* Free the buffers used by this frame. */
	rx_free_frame_buffers( info, StartIndex, EndIndex );

	ReturnCode = true;

Cleanup:
	if ( info->rx_enabled && info->rx_overflow ) {
		/* Receiver is enabled, but needs to restarted due to
		 * rx buffer overflow. If buffers are empty, restart receiver.
		 */
		if (info->rx_buf_list[EndIndex].status == 0xff) {
			spin_lock_irqsave(&info->lock,flags);
			rx_start(info);
			spin_unlock_irqrestore(&info->lock,flags);
		}
	}

	return ReturnCode;
}

/* load the transmit DMA buffer with data
 */
static void tx_load_dma_buffer(SLMP_INFO *info, const char *buf, unsigned int count)
{
	unsigned short copy_count;
	unsigned int i = 0;
	SCADESC *desc;
	SCADESC_EX *desc_ex;

	if ( debug_level >= DEBUG_LEVEL_DATA )
		trace_block(info,buf, min_t(int, count,SCABUFSIZE), 1);

	/* Copy source buffer to one or more DMA buffers, starting with
	 * the first transmit dma buffer.
	 */
	for(i=0;;)
	{
		copy_count = min_t(unsigned short,count,SCABUFSIZE);

		desc = &info->tx_buf_list[i];
		desc_ex = &info->tx_buf_list_ex[i];

		load_pci_memory(info, desc_ex->virt_addr,buf,copy_count);

		desc->length = copy_count;
		desc->status = 0;

		buf += copy_count;
		count -= copy_count;

		if (!count)
			break;

		i++;
		if (i >= info->tx_buf_count)
			i = 0;
	}

	info->tx_buf_list[i].status = 0x81;	/* set EOM and EOT status */
	info->last_tx_buf = ++i;
}

static bool register_test(SLMP_INFO *info)
{
	static unsigned char testval[] = {0x00, 0xff, 0xaa, 0x55, 0x69, 0x96};
	static unsigned int count = ARRAY_SIZE(testval);
	unsigned int i;
	bool rc = true;
	unsigned long flags;

	spin_lock_irqsave(&info->lock,flags);
	reset_port(info);

	/* assume failure */
	info->init_error = DiagStatus_AddressFailure;

	/* Write bit patterns to various registers but do it out of */
	/* sync, then read back and verify values. */

	for (i = 0 ; i < count ; i++) {
		write_reg(info, TMC, testval[i]);
		write_reg(info, IDL, testval[(i+1)%count]);
		write_reg(info, SA0, testval[(i+2)%count]);
		write_reg(info, SA1, testval[(i+3)%count]);

		if ( (read_reg(info, TMC) != testval[i]) ||
			  (read_reg(info, IDL) != testval[(i+1)%count]) ||
			  (read_reg(info, SA0) != testval[(i+2)%count]) ||
			  (read_reg(info, SA1) != testval[(i+3)%count]) )
		{
			rc = false;
			break;
		}
	}

	reset_port(info);
	spin_unlock_irqrestore(&info->lock,flags);

	return rc;
}

static bool irq_test(SLMP_INFO *info)
{
	unsigned long timeout;
	unsigned long flags;

	unsigned char timer = (info->port_num & 1) ? TIMER2 : TIMER0;

	spin_lock_irqsave(&info->lock,flags);
	reset_port(info);

	/* assume failure */
	info->init_error = DiagStatus_IrqFailure;
	info->irq_occurred = false;

	/* setup timer0 on SCA0 to interrupt */

	/* IER2<7..4> = timer<3..0> interrupt enables (1=enabled) */
	write_reg(info, IER2, (unsigned char)((info->port_num & 1) ? BIT6 : BIT4));

	write_reg(info, (unsigned char)(timer + TEPR), 0);	/* timer expand prescale */
	write_reg16(info, (unsigned char)(timer + TCONR), 1);	/* timer constant */


	/* TMCS, Timer Control/Status Register
	 *
	 * 07      CMF, Compare match flag (read only) 1=match
	 * 06      ECMI, CMF Interrupt Enable: 1=enabled
	 * 05      Reserved, must be 0
	 * 04      TME, Timer Enable
	 * 03..00  Reserved, must be 0
	 *
	 * 0101 0000
	 */
	write_reg(info, (unsigned char)(timer + TMCS), 0x50);

	spin_unlock_irqrestore(&info->lock,flags);

	timeout=100;
	while( timeout-- && !info->irq_occurred ) {
		msleep_interruptible(10);
	}

	spin_lock_irqsave(&info->lock,flags);
	reset_port(info);
	spin_unlock_irqrestore(&info->lock,flags);

	return info->irq_occurred;
}

/* initialize individual SCA device (2 ports)
 */
static bool sca_init(SLMP_INFO *info)
{
	/* set wait controller to single mem partition (low), no wait states */
	write_reg(info, PABR0, 0);	/* wait controller addr boundary 0 */
	write_reg(info, PABR1, 0);	/* wait controller addr boundary 1 */
	write_reg(info, WCRL, 0);	/* wait controller low range */
	write_reg(info, WCRM, 0);	/* wait controller mid range */
	write_reg(info, WCRH, 0);	/* wait controller high range */

	/* DPCR, DMA Priority Control
	 *
	 * 07..05  Not used, must be 0
	 * 04      BRC, bus release condition: 0=all transfers complete
	 * 03      CCC, channel change condition: 0=every cycle
	 * 02..00  PR<2..0>, priority 100=round robin
	 *
	 * 00000100 = 0x04
	 */
	write_reg(info, DPCR, dma_priority);

	/* DMA Master Enable, BIT7: 1=enable all channels */
	write_reg(info, DMER, 0x80);

	/* enable all interrupt classes */
	write_reg(info, IER0, 0xff);	/* TxRDY,RxRDY,TxINT,RxINT (ports 0-1) */
	write_reg(info, IER1, 0xff);	/* DMIB,DMIA (channels 0-3) */
	write_reg(info, IER2, 0xf0);	/* TIRQ (timers 0-3) */

	/* ITCR, interrupt control register
	 * 07      IPC, interrupt priority, 0=MSCI->DMA
	 * 06..05  IAK<1..0>, Acknowledge cycle, 00=non-ack cycle
	 * 04      VOS, Vector Output, 0=unmodified vector
	 * 03..00  Reserved, must be 0
	 */
	write_reg(info, ITCR, 0);

	return true;
}

/* initialize adapter hardware
 */
static bool init_adapter(SLMP_INFO *info)
{
	int i;

	/* Set BIT30 of Local Control Reg 0x50 to reset SCA */
	volatile u32 *MiscCtrl = (u32 *)(info->lcr_base + 0x50);
	u32 readval;

	info->misc_ctrl_value |= BIT30;
	*MiscCtrl = info->misc_ctrl_value;

	/*
	 * Force at least 170ns delay before clearing
	 * reset bit. Each read from LCR takes at least
	 * 30ns so 10 times for 300ns to be safe.
	 */
	for(i=0;i<10;i++)
		readval = *MiscCtrl;

	info->misc_ctrl_value &= ~BIT30;
	*MiscCtrl = info->misc_ctrl_value;

	/* init control reg (all DTRs off, all clksel=input) */
	info->ctrlreg_value = 0xaa;
	write_control_reg(info);

	{
		volatile u32 *LCR1BRDR = (u32 *)(info->lcr_base + 0x2c);
		lcr1_brdr_value &= ~(BIT5 + BIT4 + BIT3);

		switch(read_ahead_count)
		{
		case 16:
			lcr1_brdr_value |= BIT5 + BIT4 + BIT3;
			break;
		case 8:
			lcr1_brdr_value |= BIT5 + BIT4;
			break;
		case 4:
			lcr1_brdr_value |= BIT5 + BIT3;
			break;
		case 0:
			lcr1_brdr_value |= BIT5;
			break;
		}

		*LCR1BRDR = lcr1_brdr_value;
		*MiscCtrl = misc_ctrl_value;
	}

	sca_init(info->port_array[0]);
	sca_init(info->port_array[2]);

	return true;
}

/* Loopback an HDLC frame to test the hardware
 * interrupt and DMA functions.
 */
static bool loopback_test(SLMP_INFO *info)
{
#define TESTFRAMESIZE 20

	unsigned long timeout;
	u16 count = TESTFRAMESIZE;
	unsigned char buf[TESTFRAMESIZE];
	bool rc = false;
	unsigned long flags;

	struct tty_struct *oldtty = info->port.tty;
	u32 speed = info->params.clock_speed;

	info->params.clock_speed = 3686400;
	info->port.tty = NULL;

	/* assume failure */
	info->init_error = DiagStatus_DmaFailure;

	/* build and send transmit frame */
	for (count = 0; count < TESTFRAMESIZE;++count)
		buf[count] = (unsigned char)count;

	memset(info->tmp_rx_buf,0,TESTFRAMESIZE);

	/* program hardware for HDLC and enabled receiver */
	spin_lock_irqsave(&info->lock,flags);
	hdlc_mode(info);
	enable_loopback(info,1);
       	rx_start(info);
	info->tx_count = count;
	tx_load_dma_buffer(info,buf,count);
	tx_start(info);
	spin_unlock_irqrestore(&info->lock,flags);

	/* wait for receive complete */
	/* Set a timeout for waiting for interrupt. */
	for ( timeout = 100; timeout; --timeout ) {
		msleep_interruptible(10);

		if (rx_get_frame(info)) {
			rc = true;
			break;
		}
	}

	/* verify received frame length and contents */
	if (rc &&
	    ( info->tmp_rx_buf_count != count ||
	      memcmp(buf, info->tmp_rx_buf,count))) {
		rc = false;
	}

	spin_lock_irqsave(&info->lock,flags);
	reset_adapter(info);
	spin_unlock_irqrestore(&info->lock,flags);

	info->params.clock_speed = speed;
	info->port.tty = oldtty;

	return rc;
}

/* Perform diagnostics on hardware
 */
static int adapter_test( SLMP_INFO *info )
{
	unsigned long flags;
	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk( "%s(%d):Testing device %s\n",
			__FILE__,__LINE__,info->device_name );

	spin_lock_irqsave(&info->lock,flags);
	init_adapter(info);
	spin_unlock_irqrestore(&info->lock,flags);

	info->port_array[0]->port_count = 0;

	if ( register_test(info->port_array[0]) &&
		register_test(info->port_array[1])) {

		info->port_array[0]->port_count = 2;

		if ( register_test(info->port_array[2]) &&
			register_test(info->port_array[3]) )
			info->port_array[0]->port_count += 2;
	}
	else {
		printk( "%s(%d):Register test failure for device %s Addr=%08lX\n",
			__FILE__,__LINE__,info->device_name, (unsigned long)(info->phys_sca_base));
		return -ENODEV;
	}

	if ( !irq_test(info->port_array[0]) ||
		!irq_test(info->port_array[1]) ||
		 (info->port_count == 4 && !irq_test(info->port_array[2])) ||
		 (info->port_count == 4 && !irq_test(info->port_array[3]))) {
		printk( "%s(%d):Interrupt test failure for device %s IRQ=%d\n",
			__FILE__,__LINE__,info->device_name, (unsigned short)(info->irq_level) );
		return -ENODEV;
	}

	if (!loopback_test(info->port_array[0]) ||
		!loopback_test(info->port_array[1]) ||
		 (info->port_count == 4 && !loopback_test(info->port_array[2])) ||
		 (info->port_count == 4 && !loopback_test(info->port_array[3]))) {
		printk( "%s(%d):DMA test failure for device %s\n",
			__FILE__,__LINE__,info->device_name);
		return -ENODEV;
	}

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk( "%s(%d):device %s passed diagnostics\n",
			__FILE__,__LINE__,info->device_name );

	info->port_array[0]->init_error = 0;
	info->port_array[1]->init_error = 0;
	if ( info->port_count > 2 ) {
		info->port_array[2]->init_error = 0;
		info->port_array[3]->init_error = 0;
	}

	return 0;
}

/* Test the shared memory on a PCI adapter.
 */
static bool memory_test(SLMP_INFO *info)
{
	static unsigned long testval[] = { 0x0, 0x55555555, 0xaaaaaaaa,
		0x66666666, 0x99999999, 0xffffffff, 0x12345678 };
	unsigned long count = ARRAY_SIZE(testval);
	unsigned long i;
	unsigned long limit = SCA_MEM_SIZE/sizeof(unsigned long);
	unsigned long * addr = (unsigned long *)info->memory_base;

	/* Test data lines with test pattern at one location. */

	for ( i = 0 ; i < count ; i++ ) {
		*addr = testval[i];
		if ( *addr != testval[i] )
			return false;
	}

	/* Test address lines with incrementing pattern over */
	/* entire address range. */

	for ( i = 0 ; i < limit ; i++ ) {
		*addr = i * 4;
		addr++;
	}

	addr = (unsigned long *)info->memory_base;

	for ( i = 0 ; i < limit ; i++ ) {
		if ( *addr != i * 4 )
			return false;
		addr++;
	}

	memset( info->memory_base, 0, SCA_MEM_SIZE );
	return true;
}

/* Load data into PCI adapter shared memory.
 *
 * The PCI9050 releases control of the local bus
 * after completing the current read or write operation.
 *
 * While the PCI9050 write FIFO not empty, the
 * PCI9050 treats all of the writes as a single transaction
 * and does not release the bus. This causes DMA latency problems
 * at high speeds when copying large data blocks to the shared memory.
 *
 * This function breaks a write into multiple transations by
 * interleaving a read which flushes the write FIFO and 'completes'
 * the write transation. This allows any pending DMA request to gain control
 * of the local bus in a timely fasion.
 */
static void load_pci_memory(SLMP_INFO *info, char* dest, const char* src, unsigned short count)
{
	/* A load interval of 16 allows for 4 32-bit writes at */
	/* 136ns each for a maximum latency of 542ns on the local bus.*/

	unsigned short interval = count / sca_pci_load_interval;
	unsigned short i;

	for ( i = 0 ; i < interval ; i++ )
	{
		memcpy(dest, src, sca_pci_load_interval);
		read_status_reg(info);
		dest += sca_pci_load_interval;
		src += sca_pci_load_interval;
	}

	memcpy(dest, src, count % sca_pci_load_interval);
}

static void trace_block(SLMP_INFO *info,const char* data, int count, int xmit)
{
	int i;
	int linecount;
	if (xmit)
		printk("%s tx data:\n",info->device_name);
	else
		printk("%s rx data:\n",info->device_name);

	while(count) {
		if (count > 16)
			linecount = 16;
		else
			linecount = count;

		for(i=0;i<linecount;i++)
			printk("%02X ",(unsigned char)data[i]);
		for(;i<17;i++)
			printk("   ");
		for(i=0;i<linecount;i++) {
			if (data[i]>=040 && data[i]<=0176)
				printk("%c",data[i]);
			else
				printk(".");
		}
		printk("\n");

		data  += linecount;
		count -= linecount;
	}
}	/* end of trace_block() */

/* called when HDLC frame times out
 * update stats and do tx completion processing
 */
static void tx_timeout(unsigned long context)
{
	SLMP_INFO *info = (SLMP_INFO*)context;
	unsigned long flags;

	if ( debug_level >= DEBUG_LEVEL_INFO )
		printk( "%s(%d):%s tx_timeout()\n",
			__FILE__,__LINE__,info->device_name);
	if(info->tx_active && info->params.mode == MGSL_MODE_HDLC) {
		info->icount.txtimeout++;
	}
	spin_lock_irqsave(&info->lock,flags);
	info->tx_active = false;
	info->tx_count = info->tx_put = info->tx_get = 0;

	spin_unlock_irqrestore(&info->lock,flags);

#if SYNCLINK_GENERIC_HDLC
	if (info->netcount)
		hdlcdev_tx_done(info);
	else
#endif
		bh_transmit(info);
}

/* called to periodically check the DSR/RI modem signal input status
 */
static void status_timeout(unsigned long context)
{
	u16 status = 0;
	SLMP_INFO *info = (SLMP_INFO*)context;
	unsigned long flags;
	unsigned char delta;


	spin_lock_irqsave(&info->lock,flags);
	get_signals(info);
	spin_unlock_irqrestore(&info->lock,flags);

	/* check for DSR/RI state change */

	delta = info->old_signals ^ info->serial_signals;
	info->old_signals = info->serial_signals;

	if (delta & SerialSignal_DSR)
		status |= MISCSTATUS_DSR_LATCHED|(info->serial_signals&SerialSignal_DSR);

	if (delta & SerialSignal_RI)
		status |= MISCSTATUS_RI_LATCHED|(info->serial_signals&SerialSignal_RI);

	if (delta & SerialSignal_DCD)
		status |= MISCSTATUS_DCD_LATCHED|(info->serial_signals&SerialSignal_DCD);

	if (delta & SerialSignal_CTS)
		status |= MISCSTATUS_CTS_LATCHED|(info->serial_signals&SerialSignal_CTS);

	if (status)
		isr_io_pin(info,status);

	mod_timer(&info->status_timer, jiffies + msecs_to_jiffies(10));
}


/* Register Access Routines -
 * All registers are memory mapped
 */
#define CALC_REGADDR() \
	unsigned char * RegAddr = (unsigned char*)(info->sca_base + Addr); \
	if (info->port_num > 1) \
		RegAddr += 256;	    		/* port 0-1 SCA0, 2-3 SCA1 */ \
	if ( info->port_num & 1) { \
		if (Addr > 0x7f) \
			RegAddr += 0x40;	/* DMA access */ \
		else if (Addr > 0x1f && Addr < 0x60) \
			RegAddr += 0x20;	/* MSCI access */ \
	}


static unsigned char read_reg(SLMP_INFO * info, unsigned char Addr)
{
	CALC_REGADDR();
	return *RegAddr;
}
static void write_reg(SLMP_INFO * info, unsigned char Addr, unsigned char Value)
{
	CALC_REGADDR();
	*RegAddr = Value;
}

static u16 read_reg16(SLMP_INFO * info, unsigned char Addr)
{
	CALC_REGADDR();
	return *((u16 *)RegAddr);
}

static void write_reg16(SLMP_INFO * info, unsigned char Addr, u16 Value)
{
	CALC_REGADDR();
	*((u16 *)RegAddr) = Value;
}

static unsigned char read_status_reg(SLMP_INFO * info)
{
	unsigned char *RegAddr = (unsigned char *)info->statctrl_base;
	return *RegAddr;
}

static void write_control_reg(SLMP_INFO * info)
{
	unsigned char *RegAddr = (unsigned char *)info->statctrl_base;
	*RegAddr = info->port_array[0]->ctrlreg_value;
}


static int __devinit synclinkmp_init_one (struct pci_dev *dev,
					  const struct pci_device_id *ent)
{
	if (pci_enable_device(dev)) {
		printk("error enabling pci device %p\n", dev);
		return -EIO;
	}
	device_init( ++synclinkmp_adapter_count, dev );
	return 0;
}

static void __devexit synclinkmp_remove_one (struct pci_dev *dev)
{
}
/*
 * arch/arm/mach-ixp4xx/include/mach/vmalloc.h
 */
#define VMALLOC_END       (0xff000000UL)

cmd_drivers/net/epic100.mod.o := gcc -Wp,-MD,drivers/net/.epic100.mod.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(epic100.mod)"  -D"KBUILD_MODNAME=KBUILD_STR(epic100)"  -DMODULE  -c -o drivers/net/epic100.mod.o drivers/net/epic100.mod.c

deps_drivers/net/epic100.mod.o := \
  drivers/net/epic100.mod.c \
    $(wildcard include/config/module/unload.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/vermagic.h \
  include/generated/utsrelease.h \

drivers/net/epic100.mod.o: $(deps_drivers/net/epic100.mod.o)

$(deps_drivers/net/epic100.mod.o):
/*
 * arch/powerpc/platforms/83xx/mpc834x_itx.c
 *
 * MPC834x ITX board specific routines
 *
 * Maintainer: Kumar Gala <galak@kernel.crashing.org>
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 */

#include <linux/stddef.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/errno.h>
#include <linux/reboot.h>
#include <linux/pci.h>
#include <linux/kdev_t.h>
#include <linux/major.h>
#include <linux/console.h>
#include <linux/delay.h>
#include <linux/seq_file.h>
#include <linux/root_dev.h>
#include <linux/of_platform.h>

#include <asm/system.h>
#include <asm/atomic.h>
#include <asm/time.h>
#include <asm/io.h>
#include <asm/machdep.h>
#include <asm/ipic.h>
#include <asm/irq.h>
#include <asm/prom.h>
#include <asm/udbg.h>
#include <sysdev/fsl_soc.h>
#include <sysdev/fsl_pci.h>

#include "mpc83xx.h"

static struct of_device_id __initdata mpc834x_itx_ids[] = {
	{ .compatible = "fsl,pq2pro-localbus", },
	{ .compatible = "simple-bus", },
	{ .compatible = "gianfar", },
	{},
};

static int __init mpc834x_itx_declare_of_platform_devices(void)
{
	return of_platform_bus_probe(NULL, mpc834x_itx_ids, NULL);
}
machine_device_initcall(mpc834x_itx, mpc834x_itx_declare_of_platform_devices);

/* ************************************************************************
 *
 * Setup the architecture
 *
 */
static void __init mpc834x_itx_setup_arch(void)
{
#ifdef CONFIG_PCI
	struct device_node *np;
#endif

	if (ppc_md.progress)
		ppc_md.progress("mpc834x_itx_setup_arch()", 0);

#ifdef CONFIG_PCI
	for_each_compatible_node(np, "pci", "fsl,mpc8349-pci")
		mpc83xx_add_bridge(np);
#endif

	mpc834x_usb_cfg();
}

static void __init mpc834x_itx_init_IRQ(void)
{
	struct device_node *np;

	np = of_find_node_by_type(NULL, "ipic");
	if (!np)
		return;

	ipic_init(np, 0);

	/* Initialize the default interrupt mapping priorities,
	 * in case the boot rom changed something on us.
	 */
	ipic_set_default_priority();
}

/*
 * Called very early, MMU is off, device-tree isn't unflattened
 */
static int __init mpc834x_itx_probe(void)
{
        unsigned long root = of_get_flat_dt_root();

        return of_flat_dt_is_compatible(root, "MPC834xMITX");
}

define_machine(mpc834x_itx) {
	.name			= "MPC834x ITX",
	.probe			= mpc834x_itx_probe,
	.setup_arch		= mpc834x_itx_setup_arch,
	.init_IRQ		= mpc834x_itx_init_IRQ,
	.get_irq		= ipic_get_irq,
	.restart		= mpc83xx_restart,
	.time_init		= mpc83xx_time_init,
	.calibrate_decr		= generic_calibrate_decr,
	.progress		= udbg_progress,
};
/*
 * lib/plist.c
 *
 * Descending-priority-sorted double-linked list
 *
 * (C) 2002-2003 Intel Corp
 * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>.
 *
 * 2001-2005 (c) MontaVista Software, Inc.
 * Daniel Walker <dwalker@mvista.com>
 *
 * (C) 2005 Thomas Gleixner <tglx@linutronix.de>
 *
 * Simplifications of the original code by
 * Oleg Nesterov <oleg@tv-sign.ru>
 *
 * Licensed under the FSF's GNU Public License v2 or later.
 *
 * Based on simple lists (include/linux/list.h).
 *
 * This file contains the add / del functions which are considered to
 * be too large to inline. See include/linux/plist.h for further
 * information.
 */

#include <linux/plist.h>
#include <linux/spinlock.h>

#ifdef CONFIG_DEBUG_PI_LIST

static void plist_check_prev_next(struct list_head *t, struct list_head *p,
				  struct list_head *n)
{
	WARN(n->prev != p || p->next != n,
			"top: %p, n: %p, p: %p\n"
			"prev: %p, n: %p, p: %p\n"
			"next: %p, n: %p, p: %p\n",
			 t, t->next, t->prev,
			p, p->next, p->prev,
			n, n->next, n->prev);
}

static void plist_check_list(struct list_head *top)
{
	struct list_head *prev = top, *next = top->next;

	plist_check_prev_next(top, prev, next);
	while (next != top) {
		prev = next;
		next = prev->next;
		plist_check_prev_next(top, prev, next);
	}
}

static void plist_check_head(struct plist_head *head)
{
	WARN_ON(!head->rawlock && !head->spinlock);
	if (head->rawlock)
		WARN_ON_SMP(!raw_spin_is_locked(head->rawlock));
	if (head->spinlock)
		WARN_ON_SMP(!spin_is_locked(head->spinlock));
	plist_check_list(&head->prio_list);
	plist_check_list(&head->node_list);
}

#else
# define plist_check_head(h)	do { } while (0)
#endif

/**
 * plist_add - add @node to @head
 *
 * @node:	&struct plist_node pointer
 * @head:	&struct plist_head pointer
 */
void plist_add(struct plist_node *node, struct plist_head *head)
{
	struct plist_node *iter;

	plist_check_head(head);
	WARN_ON(!plist_node_empty(node));

	list_for_each_entry(iter, &head->prio_list, plist.prio_list) {
		if (node->prio < iter->prio)
			goto lt_prio;
		else if (node->prio == iter->prio) {
			iter = list_entry(iter->plist.prio_list.next,
					struct plist_node, plist.prio_list);
			goto eq_prio;
		}
	}

lt_prio:
	list_add_tail(&node->plist.prio_list, &iter->plist.prio_list);
eq_prio:
	list_add_tail(&node->plist.node_list, &iter->plist.node_list);

	plist_check_head(head);
}

/**
 * plist_del - Remove a @node from plist.
 *
 * @node:	&struct plist_node pointer - entry to be removed
 * @head:	&struct plist_head pointer - list head
 */
void plist_del(struct plist_node *node, struct plist_head *head)
{
	plist_check_head(head);

	if (!list_empty(&node->plist.prio_list)) {
		struct plist_node *next = plist_first(&node->plist);

		list_move_tail(&next->plist.prio_list, &node->plist.prio_list);
		list_del_init(&node->plist.prio_list);
	}

	list_del_init(&node->plist.node_list);

	plist_check_head(head);
}
cmd_drivers/net/starfire.ko := ld -r -m elf_x86_64 -T /usr/src/linux-2.6.36-gentoo-r5/scripts/module-common.lds --build-id  -o drivers/net/starfire.ko drivers/net/starfire.o drivers/net/starfire.mod.o
#ifndef __clkgen_defs_asm_h
#define __clkgen_defs_asm_h

/*
 * This file is autogenerated from
 *   file:           clkgen.r
 *
 *   by ../../../tools/rdesc/bin/rdes2c -asm -outfile clkgen_defs_asm.h clkgen.r
 * Any changes here will be lost.
 *
 * -*- buffer-read-only: t -*-
 */

#ifndef REG_FIELD
#define REG_FIELD( scope, reg, field, value ) \
	REG_FIELD_X_( value, reg_##scope##_##reg##___##field##___lsb )
#define REG_FIELD_X_( value, shift ) ((value) << shift)
#endif

#ifndef REG_STATE
#define REG_STATE( scope, reg, field, symbolic_value ) \
	REG_STATE_X_( regk_##scope##_##symbolic_value, reg_##scope##_##reg##___##field##___lsb )
#define REG_STATE_X_( k, shift ) (k << shift)
#endif

#ifndef REG_MASK
#define REG_MASK( scope, reg, field ) \
	REG_MASK_X_( reg_##scope##_##reg##___##field##___width, reg_##scope##_##reg##___##field##___lsb )
#define REG_MASK_X_( width, lsb ) (((1 << width)-1) << lsb)
#endif

#ifndef REG_LSB
#define REG_LSB( scope, reg, field ) reg_##scope##_##reg##___##field##___lsb
#endif

#ifndef REG_BIT
#define REG_BIT( scope, reg, field ) reg_##scope##_##reg##___##field##___bit
#endif

#ifndef REG_ADDR
#define REG_ADDR( scope, inst, reg ) REG_ADDR_X_(inst, reg_##scope##_##reg##_offset)
#define REG_ADDR_X_( inst, offs ) ((inst) + offs)
#endif

#ifndef REG_ADDR_VECT
#define REG_ADDR_VECT( scope, inst, reg, index ) \
	REG_ADDR_VECT_X_(inst, reg_##scope##_##reg##_offset, index, \
			 STRIDE_##scope##_##reg )
#define REG_ADDR_VECT_X_( inst, offs, index, stride ) \
	((inst) + offs + (index) * stride)
#endif

/* Register r_bootsel, scope clkgen, type r */
#define reg_clkgen_r_bootsel___boot_mode___lsb 0
#define reg_clkgen_r_bootsel___boot_mode___width 5
#define reg_clkgen_r_bootsel___intern_main_clk___lsb 5
#define reg_clkgen_r_bootsel___intern_main_clk___width 1
#define reg_clkgen_r_bootsel___intern_main_clk___bit 5
#define reg_clkgen_r_bootsel___extern_usb2_clk___lsb 6
#define reg_clkgen_r_bootsel___extern_usb2_clk___width 1
#define reg_clkgen_r_bootsel___extern_usb2_clk___bit 6
#define reg_clkgen_r_bootsel_offset 0

/* Register rw_clk_ctrl, scope clkgen, type rw */
#define reg_clkgen_rw_clk_ctrl___pll___lsb 0
#define reg_clkgen_rw_clk_ctrl___pll___width 1
#define reg_clkgen_rw_clk_ctrl___pll___bit 0
#define reg_clkgen_rw_clk_ctrl___cpu___lsb 1
#define reg_clkgen_rw_clk_ctrl___cpu___width 1
#define reg_clkgen_rw_clk_ctrl___cpu___bit 1
#define reg_clkgen_rw_clk_ctrl___iop_usb___lsb 2
#define reg_clkgen_rw_clk_ctrl___iop_usb___width 1
#define reg_clkgen_rw_clk_ctrl___iop_usb___bit 2
#define reg_clkgen_rw_clk_ctrl___vin___lsb 3
#define reg_clkgen_rw_clk_ctrl___vin___width 1
#define reg_clkgen_rw_clk_ctrl___vin___bit 3
#define reg_clkgen_rw_clk_ctrl___sclr___lsb 4
#define reg_clkgen_rw_clk_ctrl___sclr___width 1
#define reg_clkgen_rw_clk_ctrl___sclr___bit 4
#define reg_clkgen_rw_clk_ctrl___h264___lsb 5
#define reg_clkgen_rw_clk_ctrl___h264___width 1
#define reg_clkgen_rw_clk_ctrl___h264___bit 5
#define reg_clkgen_rw_clk_ctrl___ddr2___lsb 6
#define reg_clkgen_rw_clk_ctrl___ddr2___width 1
#define reg_clkgen_rw_clk_ctrl___ddr2___bit 6
#define reg_clkgen_rw_clk_ctrl___vout_hist___lsb 7
#define reg_clkgen_rw_clk_ctrl___vout_hist___width 1
#define reg_clkgen_rw_clk_ctrl___vout_hist___bit 7
#define reg_clkgen_rw_clk_ctrl___eth___lsb 8
#define reg_clkgen_rw_clk_ctrl___eth___width 1
#define reg_clkgen_rw_clk_ctrl___eth___bit 8
#define reg_clkgen_rw_clk_ctrl___ccd_tg_200___lsb 9
#define reg_clkgen_rw_clk_ctrl___ccd_tg_200___width 1
#define reg_clkgen_rw_clk_ctrl___ccd_tg_200___bit 9
#define reg_clkgen_rw_clk_ctrl___dma0_1_eth___lsb 10
#define reg_clkgen_rw_clk_ctrl___dma0_1_eth___width 1
#define reg_clkgen_rw_clk_ctrl___dma0_1_eth___bit 10
#define reg_clkgen_rw_clk_ctrl___ccd_tg_100___lsb 11
#define reg_clkgen_rw_clk_ctrl___ccd_tg_100___width 1
#define reg_clkgen_rw_clk_ctrl___ccd_tg_100___bit 11
#define reg_clkgen_rw_clk_ctrl___jpeg___lsb 12
#define reg_clkgen_rw_clk_ctrl___jpeg___width 1
#define reg_clkgen_rw_clk_ctrl___jpeg___bit 12
#define reg_clkgen_rw_clk_ctrl___sser_ser_dma6_7___lsb 13
#define reg_clkgen_rw_clk_ctrl___sser_ser_dma6_7___width 1
#define reg_clkgen_rw_clk_ctrl___sser_ser_dma6_7___bit 13
#define reg_clkgen_rw_clk_ctrl___strdma0_2_video___lsb 14
#define reg_clkgen_rw_clk_ctrl___strdma0_2_video___width 1
#define reg_clkgen_rw_clk_ctrl___strdma0_2_video___bit 14
#define reg_clkgen_rw_clk_ctrl___dma2_3_strcop___lsb 15
#define reg_clkgen_rw_clk_ctrl___dma2_3_strcop___width 1
#define reg_clkgen_rw_clk_ctrl___dma2_3_strcop___bit 15
#define reg_clkgen_rw_clk_ctrl___dma4_5_iop___lsb 16
#define reg_clkgen_rw_clk_ctrl___dma4_5_iop___width 1
#define reg_clkgen_rw_clk_ctrl___dma4_5_iop___bit 16
#define reg_clkgen_rw_clk_ctrl___dma9_11___lsb 17
#define reg_clkgen_rw_clk_ctrl___dma9_11___width 1
#define reg_clkgen_rw_clk_ctrl___dma9_11___bit 17
#define reg_clkgen_rw_clk_ctrl___memarb_bar_ddr___lsb 18
#define reg_clkgen_rw_clk_ctrl___memarb_bar_ddr___width 1
#define reg_clkgen_rw_clk_ctrl___memarb_bar_ddr___bit 18
#define reg_clkgen_rw_clk_ctrl___sclr_h264___lsb 19
#define reg_clkgen_rw_clk_ctrl___sclr_h264___width 1
#define reg_clkgen_rw_clk_ctrl___sclr_h264___bit 19
#define reg_clkgen_rw_clk_ctrl_offset 4


/* Constants */
#define regk_clkgen_eth1000_rx                    0x0000000c
#define regk_clkgen_eth1000_tx                    0x0000000e
#define regk_clkgen_eth100_rx                     0x0000001d
#define regk_clkgen_eth100_rx_half                0x0000001c
#define regk_clkgen_eth100_tx                     0x0000001f
#define regk_clkgen_eth100_tx_half                0x0000001e
#define regk_clkgen_nand_3_2                      0x00000000
#define regk_clkgen_nand_3_2_0x30                 0x00000002
#define regk_clkgen_nand_3_2_0x30_pll             0x00000012
#define regk_clkgen_nand_3_2_pll                  0x00000010
#define regk_clkgen_nand_3_3                      0x00000001
#define regk_clkgen_nand_3_3_0x30                 0x00000003
#define regk_clkgen_nand_3_3_0x30_pll             0x00000013
#define regk_clkgen_nand_3_3_pll                  0x00000011
#define regk_clkgen_nand_4_2                      0x00000004
#define regk_clkgen_nand_4_2_0x30                 0x00000006
#define regk_clkgen_nand_4_2_0x30_pll             0x00000016
#define regk_clkgen_nand_4_2_pll                  0x00000014
#define regk_clkgen_nand_4_3                      0x00000005
#define regk_clkgen_nand_4_3_0x30                 0x00000007
#define regk_clkgen_nand_4_3_0x30_pll             0x00000017
#define regk_clkgen_nand_4_3_pll                  0x00000015
#define regk_clkgen_nand_5_2                      0x00000008
#define regk_clkgen_nand_5_2_0x30                 0x0000000a
#define regk_clkgen_nand_5_2_0x30_pll             0x0000001a
#define regk_clkgen_nand_5_2_pll                  0x00000018
#define regk_clkgen_nand_5_3                      0x00000009
#define regk_clkgen_nand_5_3_0x30                 0x0000000b
#define regk_clkgen_nand_5_3_0x30_pll             0x0000001b
#define regk_clkgen_nand_5_3_pll                  0x00000019
#define regk_clkgen_no                            0x00000000
#define regk_clkgen_rw_clk_ctrl_default           0x00000002
#define regk_clkgen_ser                           0x0000000d
#define regk_clkgen_ser_pll                       0x0000000f
#define regk_clkgen_yes                           0x00000001
#endif /* __clkgen_defs_asm_h */
/*
 * This file contains all the stubs needed when communicating with lockd.
 * This level of indirection is necessary so we can run nfsd+lockd without
 * requiring the nfs client to be compiled in/loaded, and vice versa.
 *
 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>
 */

#include <linux/file.h>
#include <linux/lockd/bind.h>
#include "nfsd.h"
#include "vfs.h"

#define NFSDDBG_FACILITY		NFSDDBG_LOCKD

#ifdef CONFIG_LOCKD_V4
#define nlm_stale_fh	nlm4_stale_fh
#define nlm_failed	nlm4_failed
#else
#define nlm_stale_fh	nlm_lck_denied_nolocks
#define nlm_failed	nlm_lck_denied_nolocks
#endif
/*
 * Note: we hold the dentry use count while the file is open.
 */
static __be32
nlm_fopen(struct svc_rqst *rqstp, struct nfs_fh *f, struct file **filp)
{
	__be32		nfserr;
	struct svc_fh	fh;

	/* must initialize before using! but maxsize doesn't matter */
	fh_init(&fh,0);
	fh.fh_handle.fh_size = f->size;
	memcpy((char*)&fh.fh_handle.fh_base, f->data, f->size);
	fh.fh_export = NULL;

	exp_readlock();
	nfserr = nfsd_open(rqstp, &fh, S_IFREG, NFSD_MAY_LOCK, filp);
	fh_put(&fh);
	rqstp->rq_client = NULL;
	exp_readunlock();
 	/* We return nlm error codes as nlm doesn't know
	 * about nfsd, but nfsd does know about nlm..
	 */
	switch (nfserr) {
	case nfs_ok:
		return 0;
	case nfserr_dropit:
		return nlm_drop_reply;
	case nfserr_stale:
		return nlm_stale_fh;
	default:
		return nlm_failed;
	}
}

static void
nlm_fclose(struct file *filp)
{
	fput(filp);
}

static struct nlmsvc_binding	nfsd_nlm_ops = {
	.fopen		= nlm_fopen,		/* open file for locking */
	.fclose		= nlm_fclose,		/* close file */
};

void
nfsd_lockd_init(void)
{
	dprintk("nfsd: initializing lockd\n");
	nlmsvc_ops = &nfsd_nlm_ops;
}

void
nfsd_lockd_shutdown(void)
{
	nlmsvc_ops = NULL;
}
#include <linux/module.h>
#include <linux/vermagic.h>
#include <linux/compiler.h>

MODULE_INFO(vermagic, VERMAGIC_STRING);

struct module __this_module
__attribute__((section(".gnu.linkonce.this_module"))) = {
 .name = KBUILD_MODNAME,
 .init = init_module,
#ifdef CONFIG_MODULE_UNLOAD
 .exit = cleanup_module,
#endif
 .arch = MODULE_ARCH_INIT,
};

static const struct modversion_info ____versions[]
__used
__attribute__((section("__versions"))) = {
	{ 0x81b768be, "module_layout" },
	{ 0xdc8873d8, "register_qdisc" },
	{ 0x914a0eed, "kfree_skb" },
	{ 0x7ed46958, "tc_classify_compat" },
	{ 0xc0cee297, "qdisc_watchdog_schedule" },
	{ 0x54832eb7, "__netif_schedule" },
	{ 0x67c70f56, "hrtimer_init" },
	{ 0x3907b386, "qdisc_watchdog_init" },
	{ 0x117093be, "qdisc_class_hash_init" },
	{ 0x9c281c9, "hrtimer_cancel" },
	{ 0x57240f80, "qdisc_watchdog_cancel" },
	{ 0xf53d4c26, "qdisc_class_hash_destroy" },
	{ 0xac6855b0, "gen_kill_estimator" },
	{ 0xd69d958d, "qdisc_destroy" },
	{ 0x557db393, "tcf_destroy_chain" },
	{ 0x64808178, "qdisc_calculate_pkt_len" },
	{ 0xc87c1f84, "ktime_get" },
	{ 0x4041c1a1, "hrtimer_start_range_ns" },
	{ 0x22ac00b9, "hrtimer_try_to_cancel" },
	{ 0x68b15562, "qdisc_class_hash_grow" },
	{ 0xa04a01bd, "qdisc_class_hash_insert" },
	{ 0x79b366b8, "noop_qdisc" },
	{ 0x37a0cba, "kfree" },
	{ 0x1c16e9fe, "gen_new_estimator" },
	{ 0x31b3ce25, "kmem_cache_alloc" },
	{ 0x3fba39a3, "malloc_sizes" },
	{ 0x9cb96e92, "qdisc_put_rtab" },
	{ 0x6c3d8021, "gen_replace_estimator" },
	{ 0xb6a61a86, "qdisc_get_rtab" },
	{ 0xa58b6804, "nla_parse" },
	{ 0x4ae77a67, "qdisc_create_dflt" },
	{ 0xce64dce2, "pfifo_qdisc_ops" },
	{ 0x6223cafb, "_raw_spin_unlock_bh" },
	{ 0x16305289, "warn_slowpath_null" },
	{ 0x6bdcfd99, "qdisc_class_hash_remove" },
	{ 0x2576dde1, "qdisc_tree_decrease_qlen" },
	{ 0xeaa43f3a, "qdisc_reset" },
	{ 0x87a45ee9, "_raw_spin_lock_bh" },
	{ 0x6b2dc060, "dump_stack" },
	{ 0x85670f1d, "rtnl_is_locked" },
	{ 0xea147363, "printk" },
	{ 0x523b728c, "skb_trim" },
	{ 0xd357c894, "nla_put" },
	{ 0xb854e584, "gnet_stats_copy_app" },
	{ 0x7da0a1d3, "gnet_stats_copy_queue" },
	{ 0x1f2d63c5, "gnet_stats_copy_rate_est" },
	{ 0x542ce6b7, "gnet_stats_copy_basic" },
	{ 0xbae65bf4, "unregister_qdisc" },
};

static const char __module_depends[]
__used
__attribute__((section(".modinfo"))) =
"depends=";

/* (C) 1999-2001 Paul `Rusty' Russell
 * (C) 2002-2006 Netfilter Core Team <coreteam@netfilter.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/types.h>
#include <linux/init.h>
#include <linux/ip.h>
#include <linux/tcp.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink_conntrack.h>
#include <net/netfilter/nf_nat.h>
#include <net/netfilter/nf_nat_rule.h>
#include <net/netfilter/nf_nat_protocol.h>
#include <net/netfilter/nf_nat_core.h>

static u_int16_t tcp_port_rover;

static void
tcp_unique_tuple(struct nf_conntrack_tuple *tuple,
		 const struct nf_nat_range *range,
		 enum nf_nat_manip_type maniptype,
		 const struct nf_conn *ct)
{
	nf_nat_proto_unique_tuple(tuple, range, maniptype, ct, &tcp_port_rover);
}

static bool
tcp_manip_pkt(struct sk_buff *skb,
	      unsigned int iphdroff,
	      const struct nf_conntrack_tuple *tuple,
	      enum nf_nat_manip_type maniptype)
{
	const struct iphdr *iph = (struct iphdr *)(skb->data + iphdroff);
	struct tcphdr *hdr;
	unsigned int hdroff = iphdroff + iph->ihl*4;
	__be32 oldip, newip;
	__be16 *portptr, newport, oldport;
	int hdrsize = 8; /* TCP connection tracking guarantees this much */

	/* this could be a inner header returned in icmp packet; in such
	   cases we cannot update the checksum field since it is outside of
	   the 8 bytes of transport layer headers we are guaranteed */
	if (skb->len >= hdroff + sizeof(struct tcphdr))
		hdrsize = sizeof(struct tcphdr);

	if (!skb_make_writable(skb, hdroff + hdrsize))
		return false;

	iph = (struct iphdr *)(skb->data + iphdroff);
	hdr = (struct tcphdr *)(skb->data + hdroff);

	if (maniptype == IP_NAT_MANIP_SRC) {
		/* Get rid of src ip and src pt */
		oldip = iph->saddr;
		newip = tuple->src.u3.ip;
		newport = tuple->src.u.tcp.port;
		portptr = &hdr->source;
	} else {
		/* Get rid of dst ip and dst pt */
		oldip = iph->daddr;
		newip = tuple->dst.u3.ip;
		newport = tuple->dst.u.tcp.port;
		portptr = &hdr->dest;
	}

	oldport = *portptr;
	*portptr = newport;

	if (hdrsize < sizeof(*hdr))
		return true;

	inet_proto_csum_replace4(&hdr->check, skb, oldip, newip, 1);
	inet_proto_csum_replace2(&hdr->check, skb, oldport, newport, 0);
	return true;
}

const struct nf_nat_protocol nf_nat_protocol_tcp = {
	.protonum		= IPPROTO_TCP,
	.me			= THIS_MODULE,
	.manip_pkt		= tcp_manip_pkt,
	.in_range		= nf_nat_proto_in_range,
	.unique_tuple		= tcp_unique_tuple,
#if defined(CONFIG_NF_CT_NETLINK) || defined(CONFIG_NF_CT_NETLINK_MODULE)
	.range_to_nlattr	= nf_nat_proto_range_to_nlattr,
	.nlattr_to_range	= nf_nat_proto_nlattr_to_range,
#endif
};
/* Unusual Devices File for SanDisk SDDR-55 SmartMedia reader
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#if defined(CONFIG_USB_STORAGE_SDDR55) || \
		defined(CONFIG_USB_STORAGE_SDDR55_MODULE)

/* Contributed by Peter Waechtler */
UNUSUAL_DEV( 0x07c4, 0xa103, 0x0000, 0x9999,
		"Datafab",
		"MDSM-B reader",
		US_SC_SCSI, US_PR_SDDR55, NULL,
		US_FL_FIX_INQUIRY),

/* SM part - aeb <Andries.Brouwer@cwi.nl> */
UNUSUAL_DEV(  0x07c4, 0xa109, 0x0000, 0xffff,
		"Datafab Systems, Inc.",
		"USB to CF + SM Combo (LC1)",
		US_SC_SCSI, US_PR_SDDR55, NULL, 0),

UNUSUAL_DEV( 0x0c0b, 0xa109, 0x0000, 0xffff,
		"Acomdata",
		"SM",
		US_SC_SCSI, US_PR_SDDR55, NULL, 0),

UNUSUAL_DEV(  0x55aa, 0xa103, 0x0000, 0x9999,
		"Sandisk",
		"ImageMate SDDR55",
		US_SC_SCSI, US_PR_SDDR55, NULL, 0),

#endif /* defined(CONFIG_USB_STORAGE_SDDR55) || ... */
/***************************************************************************/

/*
 *	linux/arch/m68knommu/platform/527x/config.c
 *
 *	Sub-architcture dependant initialization code for the Freescale
 *	5270/5271 CPUs.
 *
 *	Copyright (C) 1999-2004, Greg Ungerer (gerg@snapgear.com)
 *	Copyright (C) 2001-2004, SnapGear Inc. (www.snapgear.com)
 */

/***************************************************************************/

#include <linux/kernel.h>
#include <linux/param.h>
#include <linux/init.h>
#include <linux/io.h>
#include <linux/spi/spi.h>
#include <linux/gpio.h>
#include <asm/machdep.h>
#include <asm/coldfire.h>
#include <asm/mcfsim.h>
#include <asm/mcfuart.h>
#include <asm/mcfqspi.h>

/***************************************************************************/

static struct mcf_platform_uart m527x_uart_platform[] = {
	{
		.mapbase	= MCF_MBAR + MCFUART_BASE1,
		.irq		= MCFINT_VECBASE + MCFINT_UART0,
	},
	{
		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
		.irq		= MCFINT_VECBASE + MCFINT_UART1,
	},
	{
		.mapbase 	= MCF_MBAR + MCFUART_BASE3,
		.irq		= MCFINT_VECBASE + MCFINT_UART2,
	},
	{ },
};

static struct platform_device m527x_uart = {
	.name			= "mcfuart",
	.id			= 0,
	.dev.platform_data	= m527x_uart_platform,
};

static struct resource m527x_fec0_resources[] = {
	{
		.start		= MCF_MBAR + 0x1000,
		.end		= MCF_MBAR + 0x1000 + 0x7ff,
		.flags		= IORESOURCE_MEM,
	},
	{
		.start		= 64 + 23,
		.end		= 64 + 23,
		.flags		= IORESOURCE_IRQ,
	},
	{
		.start		= 64 + 27,
		.end		= 64 + 27,
		.flags		= IORESOURCE_IRQ,
	},
	{
		.start		= 64 + 29,
		.end		= 64 + 29,
		.flags		= IORESOURCE_IRQ,
	},
};

static struct resource m527x_fec1_resources[] = {
	{
		.start		= MCF_MBAR + 0x1800,
		.end		= MCF_MBAR + 0x1800 + 0x7ff,
		.flags		= IORESOURCE_MEM,
	},
	{
		.start		= 128 + 23,
		.end		= 128 + 23,
		.flags		= IORESOURCE_IRQ,
	},
	{
		.start		= 128 + 27,
		.end		= 128 + 27,
		.flags		= IORESOURCE_IRQ,
	},
	{
		.start		= 128 + 29,
		.end		= 128 + 29,
		.flags		= IORESOURCE_IRQ,
	},
};

static struct platform_device m527x_fec[] = {
	{
		.name		= "fec",
		.id		= 0,
		.num_resources	= ARRAY_SIZE(m527x_fec0_resources),
		.resource	= m527x_fec0_resources,
	},
	{
		.name		= "fec",
		.id		= 1,
		.num_resources	= ARRAY_SIZE(m527x_fec1_resources),
		.resource	= m527x_fec1_resources,
	},
};

#if defined(CONFIG_SPI_COLDFIRE_QSPI) || defined(CONFIG_SPI_COLDFIRE_QSPI_MODULE)
static struct resource m527x_qspi_resources[] = {
	{
		.start		= MCFQSPI_IOBASE,
		.end		= MCFQSPI_IOBASE + MCFQSPI_IOSIZE - 1,
		.flags		= IORESOURCE_MEM,
	},
	{
		.start		= MCFINT_VECBASE + MCFINT_QSPI,
		.end		= MCFINT_VECBASE + MCFINT_QSPI,
		.flags		= IORESOURCE_IRQ,
	},
};

#if defined(CONFIG_M5271)
#define MCFQSPI_CS0    91
#define MCFQSPI_CS1    92
#define MCFQSPI_CS2    99
#define MCFQSPI_CS3    103
#elif defined(CONFIG_M5275)
#define MCFQSPI_CS0    59
#define MCFQSPI_CS1    60
#define MCFQSPI_CS2    61
#define MCFQSPI_CS3    62
#endif

static int m527x_cs_setup(struct mcfqspi_cs_control *cs_control)
{
	int status;

	status = gpio_request(MCFQSPI_CS0, "MCFQSPI_CS0");
	if (status) {
		pr_debug("gpio_request for MCFQSPI_CS0 failed\n");
		goto fail0;
	}
	status = gpio_direction_output(MCFQSPI_CS0, 1);
	if (status) {
		pr_debug("gpio_direction_output for MCFQSPI_CS0 failed\n");
		goto fail1;
	}

	status = gpio_request(MCFQSPI_CS1, "MCFQSPI_CS1");
	if (status) {
		pr_debug("gpio_request for MCFQSPI_CS1 failed\n");
		goto fail1;
	}
	status = gpio_direction_output(MCFQSPI_CS1, 1);
	if (status) {
		pr_debug("gpio_direction_output for MCFQSPI_CS1 failed\n");
		goto fail2;
	}

	status = gpio_request(MCFQSPI_CS2, "MCFQSPI_CS2");
	if (status) {
		pr_debug("gpio_request for MCFQSPI_CS2 failed\n");
		goto fail2;
	}
	status = gpio_direction_output(MCFQSPI_CS2, 1);
	if (status) {
		pr_debug("gpio_direction_output for MCFQSPI_CS2 failed\n");
		goto fail3;
	}

	status = gpio_request(MCFQSPI_CS3, "MCFQSPI_CS3");
	if (status) {
		pr_debug("gpio_request for MCFQSPI_CS3 failed\n");
		goto fail3;
	}
	status = gpio_direction_output(MCFQSPI_CS3, 1);
	if (status) {
		pr_debug("gpio_direction_output for MCFQSPI_CS3 failed\n");
		goto fail4;
	}

	return 0;

fail4:
	gpio_free(MCFQSPI_CS3);
fail3:
	gpio_free(MCFQSPI_CS2);
fail2:
	gpio_free(MCFQSPI_CS1);
fail1:
	gpio_free(MCFQSPI_CS0);
fail0:
	return status;
}

static void m527x_cs_teardown(struct mcfqspi_cs_control *cs_control)
{
	gpio_free(MCFQSPI_CS3);
	gpio_free(MCFQSPI_CS2);
	gpio_free(MCFQSPI_CS1);
	gpio_free(MCFQSPI_CS0);
}

static void m527x_cs_select(struct mcfqspi_cs_control *cs_control,
			    u8 chip_select, bool cs_high)
{
	switch (chip_select) {
	case 0:
		gpio_set_value(MCFQSPI_CS0, cs_high);
		break;
	case 1:
		gpio_set_value(MCFQSPI_CS1, cs_high);
		break;
	case 2:
		gpio_set_value(MCFQSPI_CS2, cs_high);
		break;
	case 3:
		gpio_set_value(MCFQSPI_CS3, cs_high);
		break;
	}
}

static void m527x_cs_deselect(struct mcfqspi_cs_control *cs_control,
			      u8 chip_select, bool cs_high)
{
	switch (chip_select) {
	case 0:
		gpio_set_value(MCFQSPI_CS0, !cs_high);
		break;
	case 1:
		gpio_set_value(MCFQSPI_CS1, !cs_high);
		break;
	case 2:
		gpio_set_value(MCFQSPI_CS2, !cs_high);
		break;
	case 3:
		gpio_set_value(MCFQSPI_CS3, !cs_high);
		break;
	}
}

static struct mcfqspi_cs_control m527x_cs_control = {
	.setup                  = m527x_cs_setup,
	.teardown               = m527x_cs_teardown,
	.select                 = m527x_cs_select,
	.deselect               = m527x_cs_deselect,
};

static struct mcfqspi_platform_data m527x_qspi_data = {
	.bus_num		= 0,
	.num_chipselect		= 4,
	.cs_control		= &m527x_cs_control,
};

static struct platform_device m527x_qspi = {
	.name			= "mcfqspi",
	.id			= 0,
	.num_resources		= ARRAY_SIZE(m527x_qspi_resources),
	.resource		= m527x_qspi_resources,
	.dev.platform_data	= &m527x_qspi_data,
};

static void __init m527x_qspi_init(void)
{
#if defined(CONFIG_M5271)
	u16 par;

	/* setup QSPS pins for QSPI with gpio CS control */
	writeb(0x1f, MCFGPIO_PAR_QSPI);
	/* and CS2 & CS3 as gpio */
	par = readw(MCFGPIO_PAR_TIMER);
	par &= 0x3f3f;
	writew(par, MCFGPIO_PAR_TIMER);
#elif defined(CONFIG_M5275)
	/* setup QSPS pins for QSPI with gpio CS control */
	writew(0x003e, MCFGPIO_PAR_QSPI);
#endif
}
#endif /* defined(CONFIG_SPI_COLDFIRE_QSPI) || defined(CONFIG_SPI_COLDFIRE_QSPI_MODULE) */

static struct platform_device *m527x_devices[] __initdata = {
	&m527x_uart,
	&m527x_fec[0],
#ifdef CONFIG_FEC2
	&m527x_fec[1],
#endif
#if defined(CONFIG_SPI_COLDFIRE_QSPI) || defined(CONFIG_SPI_COLDFIRE_QSPI_MODULE)
	&m527x_qspi,
#endif
};

/***************************************************************************/

static void __init m527x_uart_init_line(int line, int irq)
{
	u16 sepmask;

	if ((line < 0) || (line > 2))
		return;

	/*
	 * External Pin Mask Setting & Enable External Pin for Interface
	 */
	sepmask = readw(MCF_IPSBAR + MCF_GPIO_PAR_UART);
	if (line == 0)
		sepmask |= UART0_ENABLE_MASK;
	else if (line == 1)
		sepmask |= UART1_ENABLE_MASK;
	else if (line == 2)
		sepmask |= UART2_ENABLE_MASK;
	writew(sepmask, MCF_IPSBAR + MCF_GPIO_PAR_UART);
}

static void __init m527x_uarts_init(void)
{
	const int nrlines = ARRAY_SIZE(m527x_uart_platform);
	int line;

	for (line = 0; (line < nrlines); line++)
		m527x_uart_init_line(line, m527x_uart_platform[line].irq);
}

/***************************************************************************/

static void __init m527x_fec_init(void)
{
	u16 par;
	u8 v;

	/* Set multi-function pins to ethernet mode for fec0 */
#if defined(CONFIG_M5271)
	v = readb(MCF_IPSBAR + 0x100047);
	writeb(v | 0xf0, MCF_IPSBAR + 0x100047);
#else
	par = readw(MCF_IPSBAR + 0x100082);
	writew(par | 0xf00, MCF_IPSBAR + 0x100082);
	v = readb(MCF_IPSBAR + 0x100078);
	writeb(v | 0xc0, MCF_IPSBAR + 0x100078);
#endif

#ifdef CONFIG_FEC2
	/* Set multi-function pins to ethernet mode for fec1 */
	par = readw(MCF_IPSBAR + 0x100082);
	writew(par | 0xa0, MCF_IPSBAR + 0x100082);
	v = readb(MCF_IPSBAR + 0x100079);
	writeb(v | 0xc0, MCF_IPSBAR + 0x100079);
#endif
}

/***************************************************************************/

static void m527x_cpu_reset(void)
{
	local_irq_disable();
	__raw_writeb(MCF_RCR_SWRESET, MCF_IPSBAR + MCF_RCR);
}

/***************************************************************************/

void __init config_BSP(char *commandp, int size)
{
	mach_reset = m527x_cpu_reset;
	m527x_uarts_init();
	m527x_fec_init();
#if defined(CONFIG_SPI_COLDFIRE_QSPI) || defined(CONFIG_SPI_COLDFIRE_QSPI_MODULE)
	m527x_qspi_init();
#endif
}

/***************************************************************************/

static int __init init_BSP(void)
{
	platform_add_devices(m527x_devices, ARRAY_SIZE(m527x_devices));
	return 0;
}

arch_initcall(init_BSP);

/***************************************************************************/
#ifndef __iop_sw_mpu_defs_h
#define __iop_sw_mpu_defs_h

/*
 * This file is autogenerated from
 *   file:           ../../inst/io_proc/rtl/guinness/iop_sw_mpu.r
 *     id:           <not found>
 *     last modfied: Mon Apr 11 16:10:19 2005
 *
 *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_sw_mpu_defs.h ../../inst/io_proc/rtl/guinness/iop_sw_mpu.r
 *      id: $Id: iop_sw_mpu_defs.h,v 1.4 2005/04/24 18:31:05 starvik Exp $
 * Any changes here will be lost.
 *
 * -*- buffer-read-only: t -*-
 */
/* Main access macros */
#ifndef REG_RD
#define REG_RD( scope, inst, reg ) \
  REG_READ( reg_##scope##_##reg, \
            (inst) + REG_RD_ADDR_##scope##_##reg )
#endif

#ifndef REG_WR
#define REG_WR( scope, inst, reg, val ) \
  REG_WRITE( reg_##scope##_##reg, \
             (inst) + REG_WR_ADDR_##scope##_##reg, (val) )
#endif

#ifndef REG_RD_VECT
#define REG_RD_VECT( scope, inst, reg, index ) \
  REG_READ( reg_##scope##_##reg, \
            (inst) + REG_RD_ADDR_##scope##_##reg + \
	    (index) * STRIDE_##scope##_##reg )
#endif

#ifndef REG_WR_VECT
#define REG_WR_VECT( scope, inst, reg, index, val ) \
  REG_WRITE( reg_##scope##_##reg, \
             (inst) + REG_WR_ADDR_##scope##_##reg + \
	     (index) * STRIDE_##scope##_##reg, (val) )
#endif

#ifndef REG_RD_INT
#define REG_RD_INT( scope, inst, reg ) \
  REG_READ( int, (inst) + REG_RD_ADDR_##scope##_##reg )
#endif

#ifndef REG_WR_INT
#define REG_WR_INT( scope, inst, reg, val ) \
  REG_WRITE( int, (inst) + REG_WR_ADDR_##scope##_##reg, (val) )
#endif

#ifndef REG_RD_INT_VECT
#define REG_RD_INT_VECT( scope, inst, reg, index ) \
  REG_READ( int, (inst) + REG_RD_ADDR_##scope##_##reg + \
	    (index) * STRIDE_##scope##_##reg )
#endif

#ifndef REG_WR_INT_VECT
#define REG_WR_INT_VECT( scope, inst, reg, index, val ) \
  REG_WRITE( int, (inst) + REG_WR_ADDR_##scope##_##reg + \
	     (index) * STRIDE_##scope##_##reg, (val) )
#endif

#ifndef REG_TYPE_CONV
#define REG_TYPE_CONV( type, orgtype, val ) \
  ( { union { orgtype o; type n; } r; r.o = val; r.n; } )
#endif

#ifndef reg_page_size
#define reg_page_size 8192
#endif

#ifndef REG_ADDR
#define REG_ADDR( scope, inst, reg ) \
  ( (inst) + REG_RD_ADDR_##scope##_##reg )
#endif

#ifndef REG_ADDR_VECT
#define REG_ADDR_VECT( scope, inst, reg, index ) \
  ( (inst) + REG_RD_ADDR_##scope##_##reg + \
    (index) * STRIDE_##scope##_##reg )
#endif

/* C-code for register scope iop_sw_mpu */

/* Register rw_sw_cfg_owner, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int cfg : 2;
  unsigned int dummy1 : 30;
} reg_iop_sw_mpu_rw_sw_cfg_owner;
#define REG_RD_ADDR_iop_sw_mpu_rw_sw_cfg_owner 0
#define REG_WR_ADDR_iop_sw_mpu_rw_sw_cfg_owner 0

/* Register rw_mc_ctrl, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int keep_owner  : 1;
  unsigned int cmd         : 2;
  unsigned int size        : 3;
  unsigned int wr_spu0_mem : 1;
  unsigned int wr_spu1_mem : 1;
  unsigned int dummy1      : 24;
} reg_iop_sw_mpu_rw_mc_ctrl;
#define REG_RD_ADDR_iop_sw_mpu_rw_mc_ctrl 4
#define REG_WR_ADDR_iop_sw_mpu_rw_mc_ctrl 4

/* Register rw_mc_data, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int val : 32;
} reg_iop_sw_mpu_rw_mc_data;
#define REG_RD_ADDR_iop_sw_mpu_rw_mc_data 8
#define REG_WR_ADDR_iop_sw_mpu_rw_mc_data 8

/* Register rw_mc_addr, scope iop_sw_mpu, type rw */
typedef unsigned int reg_iop_sw_mpu_rw_mc_addr;
#define REG_RD_ADDR_iop_sw_mpu_rw_mc_addr 12
#define REG_WR_ADDR_iop_sw_mpu_rw_mc_addr 12

/* Register rs_mc_data, scope iop_sw_mpu, type rs */
typedef unsigned int reg_iop_sw_mpu_rs_mc_data;
#define REG_RD_ADDR_iop_sw_mpu_rs_mc_data 16

/* Register r_mc_data, scope iop_sw_mpu, type r */
typedef unsigned int reg_iop_sw_mpu_r_mc_data;
#define REG_RD_ADDR_iop_sw_mpu_r_mc_data 20

/* Register r_mc_stat, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int busy_cpu      : 1;
  unsigned int busy_mpu      : 1;
  unsigned int busy_spu0     : 1;
  unsigned int busy_spu1     : 1;
  unsigned int owned_by_cpu  : 1;
  unsigned int owned_by_mpu  : 1;
  unsigned int owned_by_spu0 : 1;
  unsigned int owned_by_spu1 : 1;
  unsigned int dummy1        : 24;
} reg_iop_sw_mpu_r_mc_stat;
#define REG_RD_ADDR_iop_sw_mpu_r_mc_stat 24

/* Register rw_bus0_clr_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 8;
  unsigned int byte1 : 8;
  unsigned int byte2 : 8;
  unsigned int byte3 : 8;
} reg_iop_sw_mpu_rw_bus0_clr_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus0_clr_mask 28
#define REG_WR_ADDR_iop_sw_mpu_rw_bus0_clr_mask 28

/* Register rw_bus0_set_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 8;
  unsigned int byte1 : 8;
  unsigned int byte2 : 8;
  unsigned int byte3 : 8;
} reg_iop_sw_mpu_rw_bus0_set_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus0_set_mask 32
#define REG_WR_ADDR_iop_sw_mpu_rw_bus0_set_mask 32

/* Register rw_bus0_oe_clr_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 1;
  unsigned int byte1 : 1;
  unsigned int byte2 : 1;
  unsigned int byte3 : 1;
  unsigned int dummy1 : 28;
} reg_iop_sw_mpu_rw_bus0_oe_clr_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus0_oe_clr_mask 36
#define REG_WR_ADDR_iop_sw_mpu_rw_bus0_oe_clr_mask 36

/* Register rw_bus0_oe_set_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 1;
  unsigned int byte1 : 1;
  unsigned int byte2 : 1;
  unsigned int byte3 : 1;
  unsigned int dummy1 : 28;
} reg_iop_sw_mpu_rw_bus0_oe_set_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus0_oe_set_mask 40
#define REG_WR_ADDR_iop_sw_mpu_rw_bus0_oe_set_mask 40

/* Register r_bus0_in, scope iop_sw_mpu, type r */
typedef unsigned int reg_iop_sw_mpu_r_bus0_in;
#define REG_RD_ADDR_iop_sw_mpu_r_bus0_in 44

/* Register rw_bus1_clr_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 8;
  unsigned int byte1 : 8;
  unsigned int byte2 : 8;
  unsigned int byte3 : 8;
} reg_iop_sw_mpu_rw_bus1_clr_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus1_clr_mask 48
#define REG_WR_ADDR_iop_sw_mpu_rw_bus1_clr_mask 48

/* Register rw_bus1_set_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 8;
  unsigned int byte1 : 8;
  unsigned int byte2 : 8;
  unsigned int byte3 : 8;
} reg_iop_sw_mpu_rw_bus1_set_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus1_set_mask 52
#define REG_WR_ADDR_iop_sw_mpu_rw_bus1_set_mask 52

/* Register rw_bus1_oe_clr_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 1;
  unsigned int byte1 : 1;
  unsigned int byte2 : 1;
  unsigned int byte3 : 1;
  unsigned int dummy1 : 28;
} reg_iop_sw_mpu_rw_bus1_oe_clr_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus1_oe_clr_mask 56
#define REG_WR_ADDR_iop_sw_mpu_rw_bus1_oe_clr_mask 56

/* Register rw_bus1_oe_set_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int byte0 : 1;
  unsigned int byte1 : 1;
  unsigned int byte2 : 1;
  unsigned int byte3 : 1;
  unsigned int dummy1 : 28;
} reg_iop_sw_mpu_rw_bus1_oe_set_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_bus1_oe_set_mask 60
#define REG_WR_ADDR_iop_sw_mpu_rw_bus1_oe_set_mask 60

/* Register r_bus1_in, scope iop_sw_mpu, type r */
typedef unsigned int reg_iop_sw_mpu_r_bus1_in;
#define REG_RD_ADDR_iop_sw_mpu_r_bus1_in 64

/* Register rw_gio_clr_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int val : 32;
} reg_iop_sw_mpu_rw_gio_clr_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_gio_clr_mask 68
#define REG_WR_ADDR_iop_sw_mpu_rw_gio_clr_mask 68

/* Register rw_gio_set_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int val : 32;
} reg_iop_sw_mpu_rw_gio_set_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_gio_set_mask 72
#define REG_WR_ADDR_iop_sw_mpu_rw_gio_set_mask 72

/* Register rw_gio_oe_clr_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int val : 32;
} reg_iop_sw_mpu_rw_gio_oe_clr_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_gio_oe_clr_mask 76
#define REG_WR_ADDR_iop_sw_mpu_rw_gio_oe_clr_mask 76

/* Register rw_gio_oe_set_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int val : 32;
} reg_iop_sw_mpu_rw_gio_oe_set_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_gio_oe_set_mask 80
#define REG_WR_ADDR_iop_sw_mpu_rw_gio_oe_set_mask 80

/* Register r_gio_in, scope iop_sw_mpu, type r */
typedef unsigned int reg_iop_sw_mpu_r_gio_in;
#define REG_RD_ADDR_iop_sw_mpu_r_gio_in 84

/* Register rw_cpu_intr, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int intr0  : 1;
  unsigned int intr1  : 1;
  unsigned int intr2  : 1;
  unsigned int intr3  : 1;
  unsigned int intr4  : 1;
  unsigned int intr5  : 1;
  unsigned int intr6  : 1;
  unsigned int intr7  : 1;
  unsigned int intr8  : 1;
  unsigned int intr9  : 1;
  unsigned int intr10 : 1;
  unsigned int intr11 : 1;
  unsigned int intr12 : 1;
  unsigned int intr13 : 1;
  unsigned int intr14 : 1;
  unsigned int intr15 : 1;
  unsigned int intr16 : 1;
  unsigned int intr17 : 1;
  unsigned int intr18 : 1;
  unsigned int intr19 : 1;
  unsigned int intr20 : 1;
  unsigned int intr21 : 1;
  unsigned int intr22 : 1;
  unsigned int intr23 : 1;
  unsigned int intr24 : 1;
  unsigned int intr25 : 1;
  unsigned int intr26 : 1;
  unsigned int intr27 : 1;
  unsigned int intr28 : 1;
  unsigned int intr29 : 1;
  unsigned int intr30 : 1;
  unsigned int intr31 : 1;
} reg_iop_sw_mpu_rw_cpu_intr;
#define REG_RD_ADDR_iop_sw_mpu_rw_cpu_intr 88
#define REG_WR_ADDR_iop_sw_mpu_rw_cpu_intr 88

/* Register r_cpu_intr, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int intr0  : 1;
  unsigned int intr1  : 1;
  unsigned int intr2  : 1;
  unsigned int intr3  : 1;
  unsigned int intr4  : 1;
  unsigned int intr5  : 1;
  unsigned int intr6  : 1;
  unsigned int intr7  : 1;
  unsigned int intr8  : 1;
  unsigned int intr9  : 1;
  unsigned int intr10 : 1;
  unsigned int intr11 : 1;
  unsigned int intr12 : 1;
  unsigned int intr13 : 1;
  unsigned int intr14 : 1;
  unsigned int intr15 : 1;
  unsigned int intr16 : 1;
  unsigned int intr17 : 1;
  unsigned int intr18 : 1;
  unsigned int intr19 : 1;
  unsigned int intr20 : 1;
  unsigned int intr21 : 1;
  unsigned int intr22 : 1;
  unsigned int intr23 : 1;
  unsigned int intr24 : 1;
  unsigned int intr25 : 1;
  unsigned int intr26 : 1;
  unsigned int intr27 : 1;
  unsigned int intr28 : 1;
  unsigned int intr29 : 1;
  unsigned int intr30 : 1;
  unsigned int intr31 : 1;
} reg_iop_sw_mpu_r_cpu_intr;
#define REG_RD_ADDR_iop_sw_mpu_r_cpu_intr 92

/* Register rw_intr_grp0_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr0      : 1;
  unsigned int spu1_intr0      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr1      : 1;
  unsigned int spu1_intr1      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr2      : 1;
  unsigned int spu1_intr2      : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr3      : 1;
  unsigned int spu1_intr3      : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_rw_intr_grp0_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_intr_grp0_mask 96
#define REG_WR_ADDR_iop_sw_mpu_rw_intr_grp0_mask 96

/* Register rw_ack_intr_grp0, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr0 : 1;
  unsigned int spu1_intr0 : 1;
  unsigned int dummy1     : 6;
  unsigned int spu0_intr1 : 1;
  unsigned int spu1_intr1 : 1;
  unsigned int dummy2     : 6;
  unsigned int spu0_intr2 : 1;
  unsigned int spu1_intr2 : 1;
  unsigned int dummy3     : 6;
  unsigned int spu0_intr3 : 1;
  unsigned int spu1_intr3 : 1;
  unsigned int dummy4     : 6;
} reg_iop_sw_mpu_rw_ack_intr_grp0;
#define REG_RD_ADDR_iop_sw_mpu_rw_ack_intr_grp0 100
#define REG_WR_ADDR_iop_sw_mpu_rw_ack_intr_grp0 100

/* Register r_intr_grp0, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr0      : 1;
  unsigned int spu1_intr0      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr1      : 1;
  unsigned int spu1_intr1      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr2      : 1;
  unsigned int spu1_intr2      : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr3      : 1;
  unsigned int spu1_intr3      : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_intr_grp0;
#define REG_RD_ADDR_iop_sw_mpu_r_intr_grp0 104

/* Register r_masked_intr_grp0, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr0      : 1;
  unsigned int spu1_intr0      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr1      : 1;
  unsigned int spu1_intr1      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr2      : 1;
  unsigned int spu1_intr2      : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr3      : 1;
  unsigned int spu1_intr3      : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_masked_intr_grp0;
#define REG_RD_ADDR_iop_sw_mpu_r_masked_intr_grp0 108

/* Register rw_intr_grp1_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr4      : 1;
  unsigned int spu1_intr4      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr5      : 1;
  unsigned int spu1_intr5      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr6      : 1;
  unsigned int spu1_intr6      : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr7      : 1;
  unsigned int spu1_intr7      : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_rw_intr_grp1_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_intr_grp1_mask 112
#define REG_WR_ADDR_iop_sw_mpu_rw_intr_grp1_mask 112

/* Register rw_ack_intr_grp1, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr4 : 1;
  unsigned int spu1_intr4 : 1;
  unsigned int dummy1     : 6;
  unsigned int spu0_intr5 : 1;
  unsigned int spu1_intr5 : 1;
  unsigned int dummy2     : 6;
  unsigned int spu0_intr6 : 1;
  unsigned int spu1_intr6 : 1;
  unsigned int dummy3     : 6;
  unsigned int spu0_intr7 : 1;
  unsigned int spu1_intr7 : 1;
  unsigned int dummy4     : 6;
} reg_iop_sw_mpu_rw_ack_intr_grp1;
#define REG_RD_ADDR_iop_sw_mpu_rw_ack_intr_grp1 116
#define REG_WR_ADDR_iop_sw_mpu_rw_ack_intr_grp1 116

/* Register r_intr_grp1, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr4      : 1;
  unsigned int spu1_intr4      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr5      : 1;
  unsigned int spu1_intr5      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr6      : 1;
  unsigned int spu1_intr6      : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr7      : 1;
  unsigned int spu1_intr7      : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_intr_grp1;
#define REG_RD_ADDR_iop_sw_mpu_r_intr_grp1 120

/* Register r_masked_intr_grp1, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr4      : 1;
  unsigned int spu1_intr4      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr5      : 1;
  unsigned int spu1_intr5      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr6      : 1;
  unsigned int spu1_intr6      : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr7      : 1;
  unsigned int spu1_intr7      : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_masked_intr_grp1;
#define REG_RD_ADDR_iop_sw_mpu_r_masked_intr_grp1 124

/* Register rw_intr_grp2_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr8      : 1;
  unsigned int spu1_intr8      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr9      : 1;
  unsigned int spu1_intr9      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr10     : 1;
  unsigned int spu1_intr10     : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr11     : 1;
  unsigned int spu1_intr11     : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_rw_intr_grp2_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_intr_grp2_mask 128
#define REG_WR_ADDR_iop_sw_mpu_rw_intr_grp2_mask 128

/* Register rw_ack_intr_grp2, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr8  : 1;
  unsigned int spu1_intr8  : 1;
  unsigned int dummy1      : 6;
  unsigned int spu0_intr9  : 1;
  unsigned int spu1_intr9  : 1;
  unsigned int dummy2      : 6;
  unsigned int spu0_intr10 : 1;
  unsigned int spu1_intr10 : 1;
  unsigned int dummy3      : 6;
  unsigned int spu0_intr11 : 1;
  unsigned int spu1_intr11 : 1;
  unsigned int dummy4      : 6;
} reg_iop_sw_mpu_rw_ack_intr_grp2;
#define REG_RD_ADDR_iop_sw_mpu_rw_ack_intr_grp2 132
#define REG_WR_ADDR_iop_sw_mpu_rw_ack_intr_grp2 132

/* Register r_intr_grp2, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr8      : 1;
  unsigned int spu1_intr8      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr9      : 1;
  unsigned int spu1_intr9      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr10     : 1;
  unsigned int spu1_intr10     : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr11     : 1;
  unsigned int spu1_intr11     : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_intr_grp2;
#define REG_RD_ADDR_iop_sw_mpu_r_intr_grp2 136

/* Register r_masked_intr_grp2, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr8      : 1;
  unsigned int spu1_intr8      : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr9      : 1;
  unsigned int spu1_intr9      : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr10     : 1;
  unsigned int spu1_intr10     : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr11     : 1;
  unsigned int spu1_intr11     : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_masked_intr_grp2;
#define REG_RD_ADDR_iop_sw_mpu_r_masked_intr_grp2 140

/* Register rw_intr_grp3_mask, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr12     : 1;
  unsigned int spu1_intr12     : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr13     : 1;
  unsigned int spu1_intr13     : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr14     : 1;
  unsigned int spu1_intr14     : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr15     : 1;
  unsigned int spu1_intr15     : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_rw_intr_grp3_mask;
#define REG_RD_ADDR_iop_sw_mpu_rw_intr_grp3_mask 144
#define REG_WR_ADDR_iop_sw_mpu_rw_intr_grp3_mask 144

/* Register rw_ack_intr_grp3, scope iop_sw_mpu, type rw */
typedef struct {
  unsigned int spu0_intr12 : 1;
  unsigned int spu1_intr12 : 1;
  unsigned int dummy1      : 6;
  unsigned int spu0_intr13 : 1;
  unsigned int spu1_intr13 : 1;
  unsigned int dummy2      : 6;
  unsigned int spu0_intr14 : 1;
  unsigned int spu1_intr14 : 1;
  unsigned int dummy3      : 6;
  unsigned int spu0_intr15 : 1;
  unsigned int spu1_intr15 : 1;
  unsigned int dummy4      : 6;
} reg_iop_sw_mpu_rw_ack_intr_grp3;
#define REG_RD_ADDR_iop_sw_mpu_rw_ack_intr_grp3 148
#define REG_WR_ADDR_iop_sw_mpu_rw_ack_intr_grp3 148

/* Register r_intr_grp3, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr12     : 1;
  unsigned int spu1_intr12     : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr13     : 1;
  unsigned int spu1_intr13     : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr14     : 1;
  unsigned int spu1_intr14     : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr15     : 1;
  unsigned int spu1_intr15     : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_intr_grp3;
#define REG_RD_ADDR_iop_sw_mpu_r_intr_grp3 152

/* Register r_masked_intr_grp3, scope iop_sw_mpu, type r */
typedef struct {
  unsigned int spu0_intr12     : 1;
  unsigned int spu1_intr12     : 1;
  unsigned int trigger_grp0    : 1;
  unsigned int trigger_grp7    : 1;
  unsigned int timer_grp0      : 1;
  unsigned int fifo_in1        : 1;
  unsigned int fifo_in1_extra  : 1;
  unsigned int dmc_out0        : 1;
  unsigned int spu0_intr13     : 1;
  unsigned int spu1_intr13     : 1;
  unsigned int trigger_grp1    : 1;
  unsigned int trigger_grp4    : 1;
  unsigned int timer_grp1      : 1;
  unsigned int fifo_out0       : 1;
  unsigned int fifo_out0_extra : 1;
  unsigned int dmc_in0         : 1;
  unsigned int spu0_intr14     : 1;
  unsigned int spu1_intr14     : 1;
  unsigned int trigger_grp2    : 1;
  unsigned int trigger_grp5    : 1;
  unsigned int timer_grp2      : 1;
  unsigned int fifo_in0        : 1;
  unsigned int fifo_in0_extra  : 1;
  unsigned int dmc_out1        : 1;
  unsigned int spu0_intr15     : 1;
  unsigned int spu1_intr15     : 1;
  unsigned int trigger_grp3    : 1;
  unsigned int trigger_grp6    : 1;
  unsigned int timer_grp3      : 1;
  unsigned int fifo_out1       : 1;
  unsigned int fifo_out1_extra : 1;
  unsigned int dmc_in1         : 1;
} reg_iop_sw_mpu_r_masked_intr_grp3;
#define REG_RD_ADDR_iop_sw_mpu_r_masked_intr_grp3 156


/* Constants */
enum {
  regk_iop_sw_mpu_copy                     = 0x00000000,
  regk_iop_sw_mpu_cpu                      = 0x00000000,
  regk_iop_sw_mpu_mpu                      = 0x00000001,
  regk_iop_sw_mpu_no                       = 0x00000000,
  regk_iop_sw_mpu_nop                      = 0x00000000,
  regk_iop_sw_mpu_rd                       = 0x00000002,
  regk_iop_sw_mpu_reg_copy                 = 0x00000001,
  regk_iop_sw_mpu_rw_bus0_clr_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_bus0_oe_clr_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_bus0_oe_set_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_bus0_set_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_bus1_clr_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_bus1_oe_clr_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_bus1_oe_set_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_bus1_set_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_gio_clr_mask_default  = 0x00000000,
  regk_iop_sw_mpu_rw_gio_oe_clr_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_gio_oe_set_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_gio_set_mask_default  = 0x00000000,
  regk_iop_sw_mpu_rw_intr_grp0_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_intr_grp1_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_intr_grp2_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_intr_grp3_mask_default = 0x00000000,
  regk_iop_sw_mpu_rw_sw_cfg_owner_default  = 0x00000000,
  regk_iop_sw_mpu_set                      = 0x00000001,
  regk_iop_sw_mpu_spu0                     = 0x00000002,
  regk_iop_sw_mpu_spu1                     = 0x00000003,
  regk_iop_sw_mpu_wr                       = 0x00000003,
  regk_iop_sw_mpu_yes                      = 0x00000001
};
#endif /* __iop_sw_mpu_defs_h */
/*
 * Copyright (C) 2004-2006 Atmel Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef __ASM_AVR32_CACHEFLUSH_H
#define __ASM_AVR32_CACHEFLUSH_H

/* Keep includes the same across arches.  */
#include <linux/mm.h>

#define CACHE_OP_ICACHE_INVALIDATE	0x01
#define CACHE_OP_DCACHE_INVALIDATE	0x0b
#define CACHE_OP_DCACHE_CLEAN		0x0c
#define CACHE_OP_DCACHE_CLEAN_INVAL	0x0d

/*
 * Invalidate any cacheline containing virtual address vaddr without
 * writing anything back to memory.
 *
 * Note that this function may corrupt unrelated data structures when
 * applied on buffers that are not cacheline aligned in both ends.
 */
static inline void invalidate_dcache_line(void *vaddr)
{
	asm volatile("cache %0[0], %1"
		     :
		     : "r"(vaddr), "n"(CACHE_OP_DCACHE_INVALIDATE)
		     : "memory");
}

/*
 * Make sure any cacheline containing virtual address vaddr is written
 * to memory.
 */
static inline void clean_dcache_line(void *vaddr)
{
	asm volatile("cache %0[0], %1"
		     :
		     : "r"(vaddr), "n"(CACHE_OP_DCACHE_CLEAN)
		     : "memory");
}

/*
 * Make sure any cacheline containing virtual address vaddr is written
 * to memory and then invalidate it.
 */
static inline void flush_dcache_line(void *vaddr)
{
	asm volatile("cache %0[0], %1"
		     :
		     : "r"(vaddr), "n"(CACHE_OP_DCACHE_CLEAN_INVAL)
		     : "memory");
}

/*
 * Invalidate any instruction cacheline containing virtual address
 * vaddr.
 */
static inline void invalidate_icache_line(void *vaddr)
{
	asm volatile("cache %0[0], %1"
		     :
		     : "r"(vaddr), "n"(CACHE_OP_ICACHE_INVALIDATE)
		     : "memory");
}

/*
 * Applies the above functions on all lines that are touched by the
 * specified virtual address range.
 */
void invalidate_dcache_region(void *start, size_t len);
void clean_dcache_region(void *start, size_t len);
void flush_dcache_region(void *start, size_t len);
void invalidate_icache_region(void *start, size_t len);

/*
 * Make sure any pending writes are completed before continuing.
 */
#define flush_write_buffer() asm volatile("sync 0" : : : "memory")

/*
 * The following functions are called when a virtual mapping changes.
 * We do not need to flush anything in this case.
 */
#define flush_cache_all()			do { } while (0)
#define flush_cache_mm(mm)			do { } while (0)
#define flush_cache_dup_mm(mm)			do { } while (0)
#define flush_cache_range(vma, start, end)	do { } while (0)
#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
#define flush_cache_vmap(start, end)		do { } while (0)
#define flush_cache_vunmap(start, end)		do { } while (0)

/*
 * I think we need to implement this one to be able to reliably
 * execute pages from RAMDISK. However, if we implement the
 * flush_dcache_*() functions, it might not be needed anymore.
 *
 * #define flush_icache_page(vma, page)		do { } while (0)
 */
extern void flush_icache_page(struct vm_area_struct *vma, struct page *page);

/*
 * These are (I think) related to D-cache aliasing.  We might need to
 * do something here, but only for certain configurations.  No such
 * configurations exist at this time.
 */
#define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 0
#define flush_dcache_page(page)			do { } while (0)
#define flush_dcache_mmap_lock(page)		do { } while (0)
#define flush_dcache_mmap_unlock(page)		do { } while (0)

/*
 * These are for I/D cache coherency. In this case, we do need to
 * flush with all configurations.
 */
extern void flush_icache_range(unsigned long start, unsigned long end);

extern void copy_to_user_page(struct vm_area_struct *vma, struct page *page,
		unsigned long vaddr, void *dst, const void *src,
		unsigned long len);

static inline void copy_from_user_page(struct vm_area_struct *vma,
		struct page *page, unsigned long vaddr, void *dst,
		const void *src, unsigned long len)
{
	memcpy(dst, src, len);
}

#endif /* __ASM_AVR32_CACHEFLUSH_H */
/*
 * Common power driver for PDAs and phones with one or two external
 * power supplies (AC/USB) connected to main and backup batteries,
 * and optional builtin charger.
 *
 * Copyright  2007 Anton Vorontsov <cbou@mail.ru>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __PDA_POWER_H__
#define __PDA_POWER_H__

#define PDA_POWER_CHARGE_AC  (1 << 0)
#define PDA_POWER_CHARGE_USB (1 << 1)

struct device;

struct pda_power_pdata {
	int (*init)(struct device *dev);
	int (*is_ac_online)(void);
	int (*is_usb_online)(void);
	void (*set_charge)(int flags);
	void (*exit)(struct device *dev);
	int (*suspend)(pm_message_t state);
	int (*resume)(void);

	char **supplied_to;
	size_t num_supplicants;

	unsigned int wait_for_status; /* msecs, default is 500 */
	unsigned int wait_for_charger; /* msecs, default is 500 */
	unsigned int polling_interval; /* msecs, default is 2000 */

	unsigned long ac_max_uA; /* current to draw when on AC */
};

#endif /* __PDA_POWER_H__ */
/*
 * Copyright (C) 2006-2007 PA Semi, Inc
 *
 * Driver for the PA Semi PWRficient onchip 1G/10G Ethernet MACs
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/pci.h>
#include <linux/slab.h>
#include <linux/interrupt.h>
#include <linux/dmaengine.h>
#include <linux/delay.h>
#include <linux/netdevice.h>
#include <linux/of_mdio.h>
#include <linux/etherdevice.h>
#include <asm/dma-mapping.h>
#include <linux/in.h>
#include <linux/skbuff.h>

#include <linux/ip.h>
#include <linux/tcp.h>
#include <net/checksum.h>
#include <linux/inet_lro.h>

#include <asm/irq.h>
#include <asm/firmware.h>
#include <asm/pasemi_dma.h>

#include "pasemi_mac.h"

/* We have our own align, since ppc64 in general has it at 0 because
 * of design flaws in some of the server bridge chips. However, for
 * PWRficient doing the unaligned copies is more expensive than doing
 * unaligned DMA, so make sure the data is aligned instead.
 */
#define LOCAL_SKB_ALIGN	2

/* TODO list
 *
 * - Multicast support
 * - Large MTU support
 * - SW LRO
 * - Multiqueue RX/TX
 */

#define LRO_MAX_AGGR 64

#define PE_MIN_MTU	64
#define PE_MAX_MTU	9000
#define PE_DEF_MTU	ETH_DATA_LEN

#define DEFAULT_MSG_ENABLE	  \
	(NETIF_MSG_DRV		| \
	 NETIF_MSG_PROBE	| \
	 NETIF_MSG_LINK		| \
	 NETIF_MSG_TIMER	| \
	 NETIF_MSG_IFDOWN	| \
	 NETIF_MSG_IFUP		| \
	 NETIF_MSG_RX_ERR	| \
	 NETIF_MSG_TX_ERR)

MODULE_LICENSE("GPL");
MODULE_AUTHOR ("Olof Johansson <olof@lixom.net>");
MODULE_DESCRIPTION("PA Semi PWRficient Ethernet driver");

static int debug = -1;	/* -1 == use DEFAULT_MSG_ENABLE as value */
module_param(debug, int, 0);
MODULE_PARM_DESC(debug, "PA Semi MAC bitmapped debugging message enable value");

extern const struct ethtool_ops pasemi_mac_ethtool_ops;

static int translation_enabled(void)
{
#if defined(CONFIG_PPC_PASEMI_IOMMU_DMA_FORCE)
	return 1;
#else
	return firmware_has_feature(FW_FEATURE_LPAR);
#endif
}

static void write_iob_reg(unsigned int reg, unsigned int val)
{
	pasemi_write_iob_reg(reg, val);
}

static unsigned int read_mac_reg(const struct pasemi_mac *mac, unsigned int reg)
{
	return pasemi_read_mac_reg(mac->dma_if, reg);
}

static void write_mac_reg(const struct pasemi_mac *mac, unsigned int reg,
			  unsigned int val)
{
	pasemi_write_mac_reg(mac->dma_if, reg, val);
}

static unsigned int read_dma_reg(unsigned int reg)
{
	return pasemi_read_dma_reg(reg);
}

static void write_dma_reg(unsigned int reg, unsigned int val)
{
	pasemi_write_dma_reg(reg, val);
}

static struct pasemi_mac_rxring *rx_ring(const struct pasemi_mac *mac)
{
	return mac->rx;
}

static struct pasemi_mac_txring *tx_ring(const struct pasemi_mac *mac)
{
	return mac->tx;
}

static inline void prefetch_skb(const struct sk_buff *skb)
{
	const void *d = skb;

	prefetch(d);
	prefetch(d+64);
	prefetch(d+128);
	prefetch(d+192);
}

static int mac_to_intf(struct pasemi_mac *mac)
{
	struct pci_dev *pdev = mac->pdev;
	u32 tmp;
	int nintf, off, i, j;
	int devfn = pdev->devfn;

	tmp = read_dma_reg(PAS_DMA_CAP_IFI);
	nintf = (tmp & PAS_DMA_CAP_IFI_NIN_M) >> PAS_DMA_CAP_IFI_NIN_S;
	off = (tmp & PAS_DMA_CAP_IFI_IOFF_M) >> PAS_DMA_CAP_IFI_IOFF_S;

	/* IOFF contains the offset to the registers containing the
	 * DMA interface-to-MAC-pci-id mappings, and NIN contains number
	 * of total interfaces. Each register contains 4 devfns.
	 * Just do a linear search until we find the devfn of the MAC
	 * we're trying to look up.
	 */

	for (i = 0; i < (nintf+3)/4; i++) {
		tmp = read_dma_reg(off+4*i);
		for (j = 0; j < 4; j++) {
			if (((tmp >> (8*j)) & 0xff) == devfn)
				return i*4 + j;
		}
	}
	return -1;
}

static void pasemi_mac_intf_disable(struct pasemi_mac *mac)
{
	unsigned int flags;

	flags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);
	flags &= ~PAS_MAC_CFG_PCFG_PE;
	write_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);
}

static void pasemi_mac_intf_enable(struct pasemi_mac *mac)
{
	unsigned int flags;

	flags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);
	flags |= PAS_MAC_CFG_PCFG_PE;
	write_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);
}

static int pasemi_get_mac_addr(struct pasemi_mac *mac)
{
	struct pci_dev *pdev = mac->pdev;
	struct device_node *dn = pci_device_to_OF_node(pdev);
	int len;
	const u8 *maddr;
	u8 addr[6];

	if (!dn) {
		dev_dbg(&pdev->dev,
			  "No device node for mac, not configuring\n");
		return -ENOENT;
	}

	maddr = of_get_property(dn, "local-mac-address", &len);

	if (maddr && len == 6) {
		memcpy(mac->mac_addr, maddr, 6);
		return 0;
	}

	/* Some old versions of firmware mistakenly uses mac-address
	 * (and as a string) instead of a byte array in local-mac-address.
	 */

	if (maddr == NULL)
		maddr = of_get_property(dn, "mac-address", NULL);

	if (maddr == NULL) {
		dev_warn(&pdev->dev,
			 "no mac address in device tree, not configuring\n");
		return -ENOENT;
	}

	if (sscanf(maddr, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &addr[0],
		   &addr[1], &addr[2], &addr[3], &addr[4], &addr[5]) != 6) {
		dev_warn(&pdev->dev,
			 "can't parse mac address, not configuring\n");
		return -EINVAL;
	}

	memcpy(mac->mac_addr, addr, 6);

	return 0;
}

static int pasemi_mac_set_mac_addr(struct net_device *dev, void *p)
{
	struct pasemi_mac *mac = netdev_priv(dev);
	struct sockaddr *addr = p;
	unsigned int adr0, adr1;

	if (!is_valid_ether_addr(addr->sa_data))
		return -EINVAL;

	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);

	adr0 = dev->dev_addr[2] << 24 |
	       dev->dev_addr[3] << 16 |
	       dev->dev_addr[4] << 8 |
	       dev->dev_addr[5];
	adr1 = read_mac_reg(mac, PAS_MAC_CFG_ADR1);
	adr1 &= ~0xffff;
	adr1 |= dev->dev_addr[0] << 8 | dev->dev_addr[1];

	pasemi_mac_intf_disable(mac);
	write_mac_reg(mac, PAS_MAC_CFG_ADR0, adr0);
	write_mac_reg(mac, PAS_MAC_CFG_ADR1, adr1);
	pasemi_mac_intf_enable(mac);

	return 0;
}

static int get_skb_hdr(struct sk_buff *skb, void **iphdr,
		       void **tcph, u64 *hdr_flags, void *data)
{
	u64 macrx = (u64) data;
	unsigned int ip_len;
	struct iphdr *iph;

	/* IPv4 header checksum failed */
	if ((macrx & XCT_MACRX_HTY_M) != XCT_MACRX_HTY_IPV4_OK)
		return -1;

	/* non tcp packet */
	skb_reset_network_header(skb);
	iph = ip_hdr(skb);
	if (iph->protocol != IPPROTO_TCP)
		return -1;

	ip_len = ip_hdrlen(skb);
	skb_set_transport_header(skb, ip_len);
	*tcph = tcp_hdr(skb);

	/* check if ip header and tcp header are complete */
	if (ntohs(iph->tot_len) < ip_len + tcp_hdrlen(skb))
		return -1;

	*hdr_flags = LRO_IPV4 | LRO_TCP;
	*iphdr = iph;

	return 0;
}

static int pasemi_mac_unmap_tx_skb(struct pasemi_mac *mac,
				    const int nfrags,
				    struct sk_buff *skb,
				    const dma_addr_t *dmas)
{
	int f;
	struct pci_dev *pdev = mac->dma_pdev;

	pci_unmap_single(pdev, dmas[0], skb_headlen(skb), PCI_DMA_TODEVICE);

	for (f = 0; f < nfrags; f++) {
		skb_frag_t *frag = &skb_shinfo(skb)->frags[f];

		pci_unmap_page(pdev, dmas[f+1], frag->size, PCI_DMA_TODEVICE);
	}
	dev_kfree_skb_irq(skb);

	/* Freed descriptor slot + main SKB ptr + nfrags additional ptrs,
	 * aligned up to a power of 2
	 */
	return (nfrags + 3) & ~1;
}

static struct pasemi_mac_csring *pasemi_mac_setup_csring(struct pasemi_mac *mac)
{
	struct pasemi_mac_csring *ring;
	u32 val;
	unsigned int cfg;
	int chno;

	ring = pasemi_dma_alloc_chan(TXCHAN, sizeof(struct pasemi_mac_csring),
				       offsetof(struct pasemi_mac_csring, chan));

	if (!ring) {
		dev_err(&mac->pdev->dev, "Can't allocate checksum channel\n");
		goto out_chan;
	}

	chno = ring->chan.chno;

	ring->size = CS_RING_SIZE;
	ring->next_to_fill = 0;

	/* Allocate descriptors */
	if (pasemi_dma_alloc_ring(&ring->chan, CS_RING_SIZE))
		goto out_ring_desc;

	write_dma_reg(PAS_DMA_TXCHAN_BASEL(chno),
		      PAS_DMA_TXCHAN_BASEL_BRBL(ring->chan.ring_dma));
	val = PAS_DMA_TXCHAN_BASEU_BRBH(ring->chan.ring_dma >> 32);
	val |= PAS_DMA_TXCHAN_BASEU_SIZ(CS_RING_SIZE >> 3);

	write_dma_reg(PAS_DMA_TXCHAN_BASEU(chno), val);

	ring->events[0] = pasemi_dma_alloc_flag();
	ring->events[1] = pasemi_dma_alloc_flag();
	if (ring->events[0] < 0 || ring->events[1] < 0)
		goto out_flags;

	pasemi_dma_clear_flag(ring->events[0]);
	pasemi_dma_clear_flag(ring->events[1]);

	ring->fun = pasemi_dma_alloc_fun();
	if (ring->fun < 0)
		goto out_fun;

	cfg = PAS_DMA_TXCHAN_CFG_TY_FUNC | PAS_DMA_TXCHAN_CFG_UP |
	      PAS_DMA_TXCHAN_CFG_TATTR(ring->fun) |
	      PAS_DMA_TXCHAN_CFG_LPSQ | PAS_DMA_TXCHAN_CFG_LPDQ;

	if (translation_enabled())
		cfg |= PAS_DMA_TXCHAN_CFG_TRD | PAS_DMA_TXCHAN_CFG_TRR;

	write_dma_reg(PAS_DMA_TXCHAN_CFG(chno), cfg);

	/* enable channel */
	pasemi_dma_start_chan(&ring->chan, PAS_DMA_TXCHAN_TCMDSTA_SZ |
					   PAS_DMA_TXCHAN_TCMDSTA_DB |
					   PAS_DMA_TXCHAN_TCMDSTA_DE |
					   PAS_DMA_TXCHAN_TCMDSTA_DA);

	return ring;

out_fun:
out_flags:
	if (ring->events[0] >= 0)
		pasemi_dma_free_flag(ring->events[0]);
	if (ring->events[1] >= 0)
		pasemi_dma_free_flag(ring->events[1]);
	pasemi_dma_free_ring(&ring->chan);
out_ring_desc:
	pasemi_dma_free_chan(&ring->chan);
out_chan:

	return NULL;
}

static void pasemi_mac_setup_csrings(struct pasemi_mac *mac)
{
	int i;
	mac->cs[0] = pasemi_mac_setup_csring(mac);
	if (mac->type == MAC_TYPE_XAUI)
		mac->cs[1] = pasemi_mac_setup_csring(mac);
	else
		mac->cs[1] = 0;

	for (i = 0; i < MAX_CS; i++)
		if (mac->cs[i])
			mac->num_cs++;
}

static void pasemi_mac_free_csring(struct pasemi_mac_csring *csring)
{
	pasemi_dma_stop_chan(&csring->chan);
	pasemi_dma_free_flag(csring->events[0]);
	pasemi_dma_free_flag(csring->events[1]);
	pasemi_dma_free_ring(&csring->chan);
	pasemi_dma_free_chan(&csring->chan);
	pasemi_dma_free_fun(csring->fun);
}

static int pasemi_mac_setup_rx_resources(const struct net_device *dev)
{
	struct pasemi_mac_rxring *ring;
	struct pasemi_mac *mac = netdev_priv(dev);
	int chno;
	unsigned int cfg;

	ring = pasemi_dma_alloc_chan(RXCHAN, sizeof(struct pasemi_mac_rxring),
				     offsetof(struct pasemi_mac_rxring, chan));

	if (!ring) {
		dev_err(&mac->pdev->dev, "Can't allocate RX channel\n");
		goto out_chan;
	}
	chno = ring->chan.chno;

	spin_lock_init(&ring->lock);

	ring->size = RX_RING_SIZE;
	ring->ring_info = kzalloc(sizeof(struct pasemi_mac_buffer) *
				  RX_RING_SIZE, GFP_KERNEL);

	if (!ring->ring_info)
		goto out_ring_info;

	/* Allocate descriptors */
	if (pasemi_dma_alloc_ring(&ring->chan, RX_RING_SIZE))
		goto out_ring_desc;

	ring->buffers = dma_alloc_coherent(&mac->dma_pdev->dev,
					   RX_RING_SIZE * sizeof(u64),
					   &ring->buf_dma, GFP_KERNEL);
	if (!ring->buffers)
		goto out_ring_desc;

	memset(ring->buffers, 0, RX_RING_SIZE * sizeof(u64));

	write_dma_reg(PAS_DMA_RXCHAN_BASEL(chno),
		      PAS_DMA_RXCHAN_BASEL_BRBL(ring->chan.ring_dma));

	write_dma_reg(PAS_DMA_RXCHAN_BASEU(chno),
		      PAS_DMA_RXCHAN_BASEU_BRBH(ring->chan.ring_dma >> 32) |
		      PAS_DMA_RXCHAN_BASEU_SIZ(RX_RING_SIZE >> 3));

	cfg = PAS_DMA_RXCHAN_CFG_HBU(2);

	if (translation_enabled())
		cfg |= PAS_DMA_RXCHAN_CFG_CTR;

	write_dma_reg(PAS_DMA_RXCHAN_CFG(chno), cfg);

	write_dma_reg(PAS_DMA_RXINT_BASEL(mac->dma_if),
		      PAS_DMA_RXINT_BASEL_BRBL(ring->buf_dma));

	write_dma_reg(PAS_DMA_RXINT_BASEU(mac->dma_if),
		      PAS_DMA_RXINT_BASEU_BRBH(ring->buf_dma >> 32) |
		      PAS_DMA_RXINT_BASEU_SIZ(RX_RING_SIZE >> 3));

	cfg = PAS_DMA_RXINT_CFG_DHL(2) | PAS_DMA_RXINT_CFG_L2 |
	      PAS_DMA_RXINT_CFG_LW | PAS_DMA_RXINT_CFG_RBP |
	      PAS_DMA_RXINT_CFG_HEN;

	if (translation_enabled())
		cfg |= PAS_DMA_RXINT_CFG_ITRR | PAS_DMA_RXINT_CFG_ITR;

	write_dma_reg(PAS_DMA_RXINT_CFG(mac->dma_if), cfg);

	ring->next_to_fill = 0;
	ring->next_to_clean = 0;
	ring->mac = mac;
	mac->rx = ring;

	return 0;

out_ring_desc:
	kfree(ring->ring_info);
out_ring_info:
	pasemi_dma_free_chan(&ring->chan);
out_chan:
	return -ENOMEM;
}

static struct pasemi_mac_txring *
pasemi_mac_setup_tx_resources(const struct net_device *dev)
{
	struct pasemi_mac *mac = netdev_priv(dev);
	u32 val;
	struct pasemi_mac_txring *ring;
	unsigned int cfg;
	int chno;

	ring = pasemi_dma_alloc_chan(TXCHAN, sizeof(struct pasemi_mac_txring),
				     offsetof(struct pasemi_mac_txring, chan));

	if (!ring) {
		dev_err(&mac->pdev->dev, "Can't allocate TX channel\n");
		goto out_chan;
	}

	chno = ring->chan.chno;

	spin_lock_init(&ring->lock);

	ring->size = TX_RING_SIZE;
	ring->ring_info = kzalloc(sizeof(struct pasemi_mac_buffer) *
				  TX_RING_SIZE, GFP_KERNEL);
	if (!ring->ring_info)
		goto out_ring_info;

	/* Allocate descriptors */
	if (pasemi_dma_alloc_ring(&ring->chan, TX_RING_SIZE))
		goto out_ring_desc;

	write_dma_reg(PAS_DMA_TXCHAN_BASEL(chno),
		      PAS_DMA_TXCHAN_BASEL_BRBL(ring->chan.ring_dma));
	val = PAS_DMA_TXCHAN_BASEU_BRBH(ring->chan.ring_dma >> 32);
	val |= PAS_DMA_TXCHAN_BASEU_SIZ(TX_RING_SIZE >> 3);

	write_dma_reg(PAS_DMA_TXCHAN_BASEU(chno), val);

	cfg = PAS_DMA_TXCHAN_CFG_TY_IFACE |
	      PAS_DMA_TXCHAN_CFG_TATTR(mac->dma_if) |
	      PAS_DMA_TXCHAN_CFG_UP |
	      PAS_DMA_TXCHAN_CFG_WT(4);

	if (translation_enabled())
		cfg |= PAS_DMA_TXCHAN_CFG_TRD | PAS_DMA_TXCHAN_CFG_TRR;

	write_dma_reg(PAS_DMA_TXCHAN_CFG(chno), cfg);

	ring->next_to_fill = 0;
	ring->next_to_clean = 0;
	ring->mac = mac;

	return ring;

out_ring_desc:
	kfree(ring->ring_info);
out_ring_info:
	pasemi_dma_free_chan(&ring->chan);
out_chan:
	return NULL;
}

static void pasemi_mac_free_tx_resources(struct pasemi_mac *mac)
{
	struct pasemi_mac_txring *txring = tx_ring(mac);
	unsigned int i, j;
	struct pasemi_mac_buffer *info;
	dma_addr_t dmas[MAX_SKB_FRAGS+1];
	int freed, nfrags;
	int start, limit;

	start = txring->next_to_clean;
	limit = txring->next_to_fill;

	/* Compensate for when fill has wrapped and clean has not */
	if (start > limit)
		limit += TX_RING_SIZE;

	for (i = start; i < limit; i += freed) {
		info = &txring->ring_info[(i+1) & (TX_RING_SIZE-1)];
		if (info->dma && info->skb) {
			nfrags = skb_shinfo(info->skb)->nr_frags;
			for (j = 0; j <= nfrags; j++)
				dmas[j] = txring->ring_info[(i+1+j) &
						(TX_RING_SIZE-1)].dma;
			freed = pasemi_mac_unmap_tx_skb(mac, nfrags,
							info->skb, dmas);
		} else
			freed = 2;
	}

	kfree(txring->ring_info);
	pasemi_dma_free_chan(&txring->chan);

}

static void pasemi_mac_free_rx_buffers(struct pasemi_mac *mac)
{
	struct pasemi_mac_rxring *rx = rx_ring(mac);
	unsigned int i;
	struct pasemi_mac_buffer *info;

	for (i = 0; i < RX_RING_SIZE; i++) {
		info = &RX_DESC_INFO(rx, i);
		if (info->skb && info->dma) {
			pci_unmap_single(mac->dma_pdev,
					 info->dma,
					 info->skb->len,
					 PCI_DMA_FROMDEVICE);
			dev_kfree_skb_any(info->skb);
		}
		info->dma = 0;
		info->skb = NULL;
	}

	for (i = 0; i < RX_RING_SIZE; i++)
		RX_BUFF(rx, i) = 0;
}

static void pasemi_mac_free_rx_resources(struct pasemi_mac *mac)
{
	pasemi_mac_free_rx_buffers(mac);

	dma_free_coherent(&mac->dma_pdev->dev, RX_RING_SIZE * sizeof(u64),
			  rx_ring(mac)->buffers, rx_ring(mac)->buf_dma);

	kfree(rx_ring(mac)->ring_info);
	pasemi_dma_free_chan(&rx_ring(mac)->chan);
	mac->rx = NULL;
}

static void pasemi_mac_replenish_rx_ring(const struct net_device *dev,
					 const int limit)
{
	const struct pasemi_mac *mac = netdev_priv(dev);
	struct pasemi_mac_rxring *rx = rx_ring(mac);
	int fill, count;

	if (limit <= 0)
		return;

	fill = rx_ring(mac)->next_to_fill;
	for (count = 0; count < limit; count++) {
		struct pasemi_mac_buffer *info = &RX_DESC_INFO(rx, fill);
		u64 *buff = &RX_BUFF(rx, fill);
		struct sk_buff *skb;
		dma_addr_t dma;

		/* Entry in use? */
		WARN_ON(*buff);

		skb = dev_alloc_skb(mac->bufsz);
		skb_reserve(skb, LOCAL_SKB_ALIGN);

		if (unlikely(!skb))
			break;

		dma = pci_map_single(mac->dma_pdev, skb->data,
				     mac->bufsz - LOCAL_SKB_ALIGN,
				     PCI_DMA_FROMDEVICE);

		if (unlikely(pci_dma_mapping_error(mac->dma_pdev, dma))) {
			dev_kfree_skb_irq(info->skb);
			break;
		}

		info->skb = skb;
		info->dma = dma;
		*buff = XCT_RXB_LEN(mac->bufsz) | XCT_RXB_ADDR(dma);
		fill++;
	}

	wmb();

	write_dma_reg(PAS_DMA_RXINT_INCR(mac->dma_if), count);

	rx_ring(mac)->next_to_fill = (rx_ring(mac)->next_to_fill + count) &
				(RX_RING_SIZE - 1);
}

static void pasemi_mac_restart_rx_intr(const struct pasemi_mac *mac)
{
	struct pasemi_mac_rxring *rx = rx_ring(mac);
	unsigned int reg, pcnt;
	/* Re-enable packet count interrupts: finally
	 * ack the packet count interrupt we got in rx_intr.
	 */

	pcnt = *rx->chan.status & PAS_STATUS_PCNT_M;

	reg = PAS_IOB_DMA_RXCH_RESET_PCNT(pcnt) | PAS_IOB_DMA_RXCH_RESET_PINTC;

	if (*rx->chan.status & PAS_STATUS_TIMER)
		reg |= PAS_IOB_DMA_RXCH_RESET_TINTC;

	write_iob_reg(PAS_IOB_DMA_RXCH_RESET(mac->rx->chan.chno), reg);
}

static void pasemi_mac_restart_tx_intr(const struct pasemi_mac *mac)
{
	unsigned int reg, pcnt;

	/* Re-enable packet count interrupts */
	pcnt = *tx_ring(mac)->chan.status & PAS_STATUS_PCNT_M;

	reg = PAS_IOB_DMA_TXCH_RESET_PCNT(pcnt) | PAS_IOB_DMA_TXCH_RESET_PINTC;

	write_iob_reg(PAS_IOB_DMA_TXCH_RESET(tx_ring(mac)->chan.chno), reg);
}


static inline void pasemi_mac_rx_error(const struct pasemi_mac *mac,
				       const u64 macrx)
{
	unsigned int rcmdsta, ccmdsta;
	struct pasemi_dmachan *chan = &rx_ring(mac)->chan;

	if (!netif_msg_rx_err(mac))
		return;

	rcmdsta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));
	ccmdsta = read_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(chan->chno));

	printk(KERN_ERR "pasemi_mac: rx error. macrx %016llx, rx status %llx\n",
		macrx, *chan->status);

	printk(KERN_ERR "pasemi_mac: rcmdsta %08x ccmdsta %08x\n",
		rcmdsta, ccmdsta);
}

static inline void pasemi_mac_tx_error(const struct pasemi_mac *mac,
				       const u64 mactx)
{
	unsigned int cmdsta;
	struct pasemi_dmachan *chan = &tx_ring(mac)->chan;

	if (!netif_msg_tx_err(mac))
		return;

	cmdsta = read_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(chan->chno));

	printk(KERN_ERR "pasemi_mac: tx error. mactx 0x%016llx, "\
		"tx status 0x%016llx\n", mactx, *chan->status);

	printk(KERN_ERR "pasemi_mac: tcmdsta 0x%08x\n", cmdsta);
}

static int pasemi_mac_clean_rx(struct pasemi_mac_rxring *rx,
			       const int limit)
{
	const struct pasemi_dmachan *chan = &rx->chan;
	struct pasemi_mac *mac = rx->mac;
	struct pci_dev *pdev = mac->dma_pdev;
	unsigned int n;
	int count, buf_index, tot_bytes, packets;
	struct pasemi_mac_buffer *info;
	struct sk_buff *skb;
	unsigned int len;
	u64 macrx, eval;
	dma_addr_t dma;

	tot_bytes = 0;
	packets = 0;

	spin_lock(&rx->lock);

	n = rx->next_to_clean;

	prefetch(&RX_DESC(rx, n));

	for (count = 0; count < limit; count++) {
		macrx = RX_DESC(rx, n);
		prefetch(&RX_DESC(rx, n+4));

		if ((macrx & XCT_MACRX_E) ||
		    (*chan->status & PAS_STATUS_ERROR))
			pasemi_mac_rx_error(mac, macrx);

		if (!(macrx & XCT_MACRX_O))
			break;

		info = NULL;

		BUG_ON(!(macrx & XCT_MACRX_RR_8BRES));

		eval = (RX_DESC(rx, n+1) & XCT_RXRES_8B_EVAL_M) >>
			XCT_RXRES_8B_EVAL_S;
		buf_index = eval-1;

		dma = (RX_DESC(rx, n+2) & XCT_PTR_ADDR_M);
		info = &RX_DESC_INFO(rx, buf_index);

		skb = info->skb;

		prefetch_skb(skb);

		len = (macrx & XCT_MACRX_LLEN_M) >> XCT_MACRX_LLEN_S;

		pci_unmap_single(pdev, dma, mac->bufsz - LOCAL_SKB_ALIGN,
				 PCI_DMA_FROMDEVICE);

		if (macrx & XCT_MACRX_CRC) {
			/* CRC error flagged */
			mac->netdev->stats.rx_errors++;
			mac->netdev->stats.rx_crc_errors++;
			/* No need to free skb, it'll be reused */
			goto next;
		}

		info->skb = NULL;
		info->dma = 0;

		if (likely((macrx & XCT_MACRX_HTY_M) == XCT_MACRX_HTY_IPV4_OK)) {
			skb->ip_summed = CHECKSUM_UNNECESSARY;
			skb->csum = (macrx & XCT_MACRX_CSUM_M) >>
					   XCT_MACRX_CSUM_S;
		} else
			skb->ip_summed = CHECKSUM_NONE;

		packets++;
		tot_bytes += len;

		/* Don't include CRC */
		skb_put(skb, len-4);

		skb->protocol = eth_type_trans(skb, mac->netdev);
		lro_receive_skb(&mac->lro_mgr, skb, (void *)macrx);

next:
		RX_DESC(rx, n) = 0;
		RX_DESC(rx, n+1) = 0;

		/* Need to zero it out since hardware doesn't, since the
		 * replenish loop uses it to tell when it's done.
		 */
		RX_BUFF(rx, buf_index) = 0;

		n += 4;
	}

	if (n > RX_RING_SIZE) {
		/* Errata 5971 workaround: L2 target of headers */
		write_iob_reg(PAS_IOB_COM_PKTHDRCNT, 0);
		n &= (RX_RING_SIZE-1);
	}

	rx_ring(mac)->next_to_clean = n;

	lro_flush_all(&mac->lro_mgr);

	/* Increase is in number of 16-byte entries, and since each descriptor
	 * with an 8BRES takes up 3x8 bytes (padded to 4x8), increase with
	 * count*2.
	 */
	write_dma_reg(PAS_DMA_RXCHAN_INCR(mac->rx->chan.chno), count << 1);

	pasemi_mac_replenish_rx_ring(mac->netdev, count);

	mac->netdev->stats.rx_bytes += tot_bytes;
	mac->netdev->stats.rx_packets += packets;

	spin_unlock(&rx_ring(mac)->lock);

	return count;
}

/* Can't make this too large or we blow the kernel stack limits */
#define TX_CLEAN_BATCHSIZE (128/MAX_SKB_FRAGS)

static int pasemi_mac_clean_tx(struct pasemi_mac_txring *txring)
{
	struct pasemi_dmachan *chan = &txring->chan;
	struct pasemi_mac *mac = txring->mac;
	int i, j;
	unsigned int start, descr_count, buf_count, batch_limit;
	unsigned int ring_limit;
	unsigned int total_count;
	unsigned long flags;
	struct sk_buff *skbs[TX_CLEAN_BATCHSIZE];
	dma_addr_t dmas[TX_CLEAN_BATCHSIZE][MAX_SKB_FRAGS+1];
	int nf[TX_CLEAN_BATCHSIZE];
	int nr_frags;

	total_count = 0;
	batch_limit = TX_CLEAN_BATCHSIZE;
restart:
	spin_lock_irqsave(&txring->lock, flags);

	start = txring->next_to_clean;
	ring_limit = txring->next_to_fill;

	prefetch(&TX_DESC_INFO(txring, start+1).skb);

	/* Compensate for when fill has wrapped but clean has not */
	if (start > ring_limit)
		ring_limit += TX_RING_SIZE;

	buf_count = 0;
	descr_count = 0;

	for (i = start;
	     descr_count < batch_limit && i < ring_limit;
	     i += buf_count) {
		u64 mactx = TX_DESC(txring, i);
		struct sk_buff *skb;

		if ((mactx  & XCT_MACTX_E) ||
		    (*chan->status & PAS_STATUS_ERROR))
			pasemi_mac_tx_error(mac, mactx);

		/* Skip over control descriptors */
		if (!(mactx & XCT_MACTX_LLEN_M)) {
			TX_DESC(txring, i) = 0;
			TX_DESC(txring, i+1) = 0;
			buf_count = 2;
			continue;
		}

		skb = TX_DESC_INFO(txring, i+1).skb;
		nr_frags = TX_DESC_INFO(txring, i).dma;

		if (unlikely(mactx & XCT_MACTX_O))
			/* Not yet transmitted */
			break;

		buf_count = 2 + nr_frags;
		/* Since we always fill with an even number of entries, make
		 * sure we skip any unused one at the end as well.
		 */
		if (buf_count & 1)
			buf_count++;

		for (j = 0; j <= nr_frags; j++)
			dmas[descr_count][j] = TX_DESC_INFO(txring, i+1+j).dma;

		skbs[descr_count] = skb;
		nf[descr_count] = nr_frags;

		TX_DESC(txring, i) = 0;
		TX_DESC(txring, i+1) = 0;

		descr_count++;
	}
	txring->next_to_clean = i & (TX_RING_SIZE-1);

	spin_unlock_irqrestore(&txring->lock, flags);
	netif_wake_queue(mac->netdev);

	for (i = 0; i < descr_count; i++)
		pasemi_mac_unmap_tx_skb(mac, nf[i], skbs[i], dmas[i]);

	total_count += descr_count;

	/* If the batch was full, try to clean more */
	if (descr_count == batch_limit)
		goto restart;

	return total_count;
}


static irqreturn_t pasemi_mac_rx_intr(int irq, void *data)
{
	const struct pasemi_mac_rxring *rxring = data;
	struct pasemi_mac *mac = rxring->mac;
	const struct pasemi_dmachan *chan = &rxring->chan;
	unsigned int reg;

	if (!(*chan->status & PAS_STATUS_CAUSE_M))
		return IRQ_NONE;

	/* Don't reset packet count so it won't fire again but clear
	 * all others.
	 */

	reg = 0;
	if (*chan->status & PAS_STATUS_SOFT)
		reg |= PAS_IOB_DMA_RXCH_RESET_SINTC;
	if (*chan->status & PAS_STATUS_ERROR)
		reg |= PAS_IOB_DMA_RXCH_RESET_DINTC;

	napi_schedule(&mac->napi);

	write_iob_reg(PAS_IOB_DMA_RXCH_RESET(chan->chno), reg);

	return IRQ_HANDLED;
}

#define TX_CLEAN_INTERVAL HZ

static void pasemi_mac_tx_timer(unsigned long data)
{
	struct pasemi_mac_txring *txring = (struct pasemi_mac_txring *)data;
	struct pasemi_mac *mac = txring->mac;

	pasemi_mac_clean_tx(txring);

	mod_timer(&txring->clean_timer, jiffies + TX_CLEAN_INTERVAL);

	pasemi_mac_restart_tx_intr(mac);
}

static irqreturn_t pasemi_mac_tx_intr(int irq, void *data)
{
	struct pasemi_mac_txring *txring = data;
	const struct pasemi_dmachan *chan = &txring->chan;
	struct pasemi_mac *mac = txring->mac;
	unsigned int reg;

	if (!(*chan->status & PAS_STATUS_CAUSE_M))
		return IRQ_NONE;

	reg = 0;

	if (*chan->status & PAS_STATUS_SOFT)
		reg |= PAS_IOB_DMA_TXCH_RESET_SINTC;
	if (*chan->status & PAS_STATUS_ERROR)
		reg |= PAS_IOB_DMA_TXCH_RESET_DINTC;

	mod_timer(&txring->clean_timer, jiffies + (TX_CLEAN_INTERVAL)*2);

	napi_schedule(&mac->napi);

	if (reg)
		write_iob_reg(PAS_IOB_DMA_TXCH_RESET(chan->chno), reg);

	return IRQ_HANDLED;
}

static void pasemi_adjust_link(struct net_device *dev)
{
	struct pasemi_mac *mac = netdev_priv(dev);
	int msg;
	unsigned int flags;
	unsigned int new_flags;

	if (!mac->phydev->link) {
		/* If no link, MAC speed settings don't matter. Just report
		 * link down and return.
		 */
		if (mac->link && netif_msg_link(mac))
			printk(KERN_INFO "%s: Link is down.\n", dev->name);

		netif_carrier_off(dev);
		pasemi_mac_intf_disable(mac);
		mac->link = 0;

		return;
	} else {
		pasemi_mac_intf_enable(mac);
		netif_carrier_on(dev);
	}

	flags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);
	new_flags = flags & ~(PAS_MAC_CFG_PCFG_HD | PAS_MAC_CFG_PCFG_SPD_M |
			      PAS_MAC_CFG_PCFG_TSR_M);

	if (!mac->phydev->duplex)
		new_flags |= PAS_MAC_CFG_PCFG_HD;

	switch (mac->phydev->speed) {
	case 1000:
		new_flags |= PAS_MAC_CFG_PCFG_SPD_1G |
			     PAS_MAC_CFG_PCFG_TSR_1G;
		break;
	case 100:
		new_flags |= PAS_MAC_CFG_PCFG_SPD_100M |
			     PAS_MAC_CFG_PCFG_TSR_100M;
		break;
	case 10:
		new_flags |= PAS_MAC_CFG_PCFG_SPD_10M |
			     PAS_MAC_CFG_PCFG_TSR_10M;
		break;
	default:
		printk("Unsupported speed %d\n", mac->phydev->speed);
	}

	/* Print on link or speed/duplex change */
	msg = mac->link != mac->phydev->link || flags != new_flags;

	mac->duplex = mac->phydev->duplex;
	mac->speed = mac->phydev->speed;
	mac->link = mac->phydev->link;

	if (new_flags != flags)
		write_mac_reg(mac, PAS_MAC_CFG_PCFG, new_flags);

	if (msg && netif_msg_link(mac))
		printk(KERN_INFO "%s: Link is up at %d Mbps, %s duplex.\n",
		       dev->name, mac->speed, mac->duplex ? "full" : "half");
}

static int pasemi_mac_phy_init(struct net_device *dev)
{
	struct pasemi_mac *mac = netdev_priv(dev);
	struct device_node *dn, *phy_dn;
	struct phy_device *phydev;

	dn = pci_device_to_OF_node(mac->pdev);
	phy_dn = of_parse_phandle(dn, "phy-handle", 0);
	of_node_put(phy_dn);

	mac->link = 0;
	mac->speed = 0;
	mac->duplex = -1;

	phydev = of_phy_connect(dev, phy_dn, &pasemi_adjust_link, 0,
				PHY_INTERFACE_MODE_SGMII);

	if (IS_ERR(phydev)) {
		printk(KERN_ERR "%s: Could not attach to phy\n", dev->name);
		return PTR_ERR(phydev);
	}

	mac->phydev = phydev;

	return 0;
}


static int pasemi_mac_open(struct net_device *dev)
{
	struct pasemi_mac *mac = netdev_priv(dev);
	unsigned int flags;
	int i, ret;

	flags = PAS_MAC_CFG_TXP_FCE | PAS_MAC_CFG_TXP_FPC(3) |
		PAS_MAC_CFG_TXP_SL(3) | PAS_MAC_CFG_TXP_COB(0xf) |
		PAS_MAC_CFG_TXP_TIFT(8) | PAS_MAC_CFG_TXP_TIFG(12);

	write_mac_reg(mac, PAS_MAC_CFG_TXP, flags);

	ret = pasemi_mac_setup_rx_resources(dev);
	if (ret)
		goto out_rx_resources;

	mac->tx = pasemi_mac_setup_tx_resources(dev);

	if (!mac->tx)
		goto out_tx_ring;

	/* We might already have allocated rings in case mtu was changed
	 * before interface was brought up.
	 */
	if (dev->mtu > 1500 && !mac->num_cs) {
		pasemi_mac_setup_csrings(mac);
		if (!mac->num_cs)
			goto out_tx_ring;
	}

	/* Zero out rmon counters */
	for (i = 0; i < 32; i++)
		write_mac_reg(mac, PAS_MAC_RMON(i), 0);

	/* 0x3ff with 33MHz clock is about 31us */
	write_iob_reg(PAS_IOB_DMA_COM_TIMEOUTCFG,
		      PAS_IOB_DMA_COM_TIMEOUTCFG_TCNT(0x3ff));

	write_iob_reg(PAS_IOB_DMA_RXCH_CFG(mac->rx->chan.chno),
		      PAS_IOB_DMA_RXCH_CFG_CNTTH(256));

	write_iob_reg(PAS_IOB_DMA_TXCH_CFG(mac->tx->chan.chno),
		      PAS_IOB_DMA_TXCH_CFG_CNTTH(32));

	write_mac_reg(mac, PAS_MAC_IPC_CHNL,
		      PAS_MAC_IPC_CHNL_DCHNO(mac->rx->chan.chno) |
		      PAS_MAC_IPC_CHNL_BCH(mac->rx->chan.chno));

	/* enable rx if */
	write_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if),
		      PAS_DMA_RXINT_RCMDSTA_EN |
		      PAS_DMA_RXINT_RCMDSTA_DROPS_M |
		      PAS_DMA_RXINT_RCMDSTA_BP |
		      PAS_DMA_RXINT_RCMDSTA_OO |
		      PAS_DMA_RXINT_RCMDSTA_BT);

	/* enable rx channel */
	pasemi_dma_start_chan(&rx_ring(mac)->chan, PAS_DMA_RXCHAN_CCMDSTA_DU |
						   PAS_DMA_RXCHAN_CCMDSTA_OD |
						   PAS_DMA_RXCHAN_CCMDSTA_FD |
						   PAS_DMA_RXCHAN_CCMDSTA_DT);

	/* enable tx channel */
	pasemi_dma_start_chan(&tx_ring(mac)->chan, PAS_DMA_TXCHAN_TCMDSTA_SZ |
						   PAS_DMA_TXCHAN_TCMDSTA_DB |
						   PAS_DMA_TXCHAN_TCMDSTA_DE |
						   PAS_DMA_TXCHAN_TCMDSTA_DA);

	pasemi_mac_replenish_rx_ring(dev, RX_RING_SIZE);

	write_dma_reg(PAS_DMA_RXCHAN_INCR(rx_ring(mac)->chan.chno),
		      RX_RING_SIZE>>1);

	/* Clear out any residual packet count state from firmware */
	pasemi_mac_restart_rx_intr(mac);
	pasemi_mac_restart_tx_intr(mac);

	flags = PAS_MAC_CFG_PCFG_S1 | PAS_MAC_CFG_PCFG_PR | PAS_MAC_CFG_PCFG_CE;

	if (mac->type == MAC_TYPE_GMAC)
		flags |= PAS_MAC_CFG_PCFG_TSR_1G | PAS_MAC_CFG_PCFG_SPD_1G;
	else
		flags |= PAS_MAC_CFG_PCFG_TSR_10G | PAS_MAC_CFG_PCFG_SPD_10G;

	/* Enable interface in MAC */
	write_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);

	ret = pasemi_mac_phy_init(dev);
	if (ret) {
		/* Since we won't get link notification, just enable RX */
		pasemi_mac_intf_enable(mac);
		if (mac->type == MAC_TYPE_GMAC) {
			/* Warn for missing PHY on SGMII (1Gig) ports */
			dev_warn(&mac->pdev->dev,
				 "PHY init failed: %d.\n", ret);
			dev_warn(&mac->pdev->dev,
				 "Defaulting to 1Gbit full duplex\n");
		}
	}

	netif_start_queue(dev);
	napi_enable(&mac->napi);

	snprintf(mac->tx_irq_name, sizeof(mac->tx_irq_name), "%s tx",
		 dev->name);

	ret = request_irq(mac->tx->chan.irq, pasemi_mac_tx_intr, IRQF_DISABLED,
			  mac->tx_irq_name, mac->tx);
	if (ret) {
		dev_err(&mac->pdev->dev, "request_irq of irq %d failed: %d\n",
			mac->tx->chan.irq, ret);
		goto out_tx_int;
	}

	snprintf(mac->rx_irq_name, sizeof(mac->rx_irq_name), "%s rx",
		 dev->name);

	ret = request_irq(mac->rx->chan.irq, pasemi_mac_rx_intr, IRQF_DISABLED,
			  mac->rx_irq_name, mac->rx);
	if (ret) {
		dev_err(&mac->pdev->dev, "request_irq of irq %d failed: %d\n",
			mac->rx->chan.irq, ret);
		goto out_rx_int;
	}

	if (mac->phydev)
		phy_start(mac->phydev);

	init_timer(&mac->tx->clean_timer);
	mac->tx->clean_timer.function = pasemi_mac_tx_timer;
	mac->tx->clean_timer.data = (unsigned long)mac->tx;
	mac->tx->clean_timer.expires = jiffies+HZ;
	add_timer(&mac->tx->clean_timer);

	return 0;

out_rx_int:
	free_irq(mac->tx->chan.irq, mac->tx);
out_tx_int:
	napi_disable(&mac->napi);
	netif_stop_queue(dev);
out_tx_ring:
	if (mac->tx)
		pasemi_mac_free_tx_resources(mac);
	pasemi_mac_free_rx_resources(mac);
out_rx_resources:

	return ret;
}

#define MAX_RETRIES 5000

static void pasemi_mac_pause_txchan(struct pasemi_mac *mac)
{
	unsigned int sta, retries;
	int txch = tx_ring(mac)->chan.chno;

	write_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch),
		      PAS_DMA_TXCHAN_TCMDSTA_ST);

	for (retries = 0; retries < MAX_RETRIES; retries++) {
		sta = read_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch));
		if (!(sta & PAS_DMA_TXCHAN_TCMDSTA_ACT))
			break;
		cond_resched();
	}

	if (sta & PAS_DMA_TXCHAN_TCMDSTA_ACT)
		dev_err(&mac->dma_pdev->dev,
			"Failed to stop tx channel, tcmdsta %08x\n", sta);

	write_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch), 0);
}

static void pasemi_mac_pause_rxchan(struct pasemi_mac *mac)
{
	unsigned int sta, retries;
	int rxch = rx_ring(mac)->chan.chno;

	write_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch),
		      PAS_DMA_RXCHAN_CCMDSTA_ST);
	for (retries = 0; retries < MAX_RETRIES; retries++) {
		sta = read_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch));
		if (!(sta & PAS_DMA_RXCHAN_CCMDSTA_ACT))
			break;
		cond_resched();
	}

	if (sta & PAS_DMA_RXCHAN_CCMDSTA_ACT)
		dev_err(&mac->dma_pdev->dev,
			"Failed to stop rx channel, ccmdsta 08%x\n", sta);
	write_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch), 0);
}

static void pasemi_mac_pause_rxint(struct pasemi_mac *mac)
{
	unsigned int sta, retries;

	write_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if),
		      PAS_DMA_RXINT_RCMDSTA_ST);
	for (retries = 0; retries < MAX_RETRIES; retries++) {
		sta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));
		if (!(sta & PAS_DMA_RXINT_RCMDSTA_ACT))
			break;
		cond_resched();
	}

	if (sta & PAS_DMA_RXINT_RCMDSTA_ACT)
		dev_err(&mac->dma_pdev->dev,
			"Failed to stop rx interface, rcmdsta %08x\n", sta);
	write_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if), 0);
}

static int pasemi_mac_close(struct net_device *dev)
{
	struct pasemi_mac *mac = netdev_priv(dev);
	unsigned int sta;
	int rxch, txch, i;

	rxch = rx_ring(mac)->chan.chno;
	txch = tx_ring(mac)->chan.chno;

	if (mac->phydev) {
		phy_stop(mac->phydev);
		phy_disconnect(mac->phydev);
	}

	del_timer_sync(&mac->tx->clean_timer);

	netif_stop_queue(dev);
	napi_disable(&mac->napi);

	sta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));
	if (sta & (PAS_DMA_RXINT_RCMDSTA_BP |
		      PAS_DMA_RXINT_RCMDSTA_OO |
		      PAS_DMA_RXINT_RCMDSTA_BT))
		printk(KERN_DEBUG "pasemi_mac: rcmdsta error: 0x%08x\n", sta);

	sta = read_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch));
	if (sta & (PAS_DMA_RXCHAN_CCMDSTA_DU |
		     PAS_DMA_RXCHAN_CCMDSTA_OD |
		     PAS_DMA_RXCHAN_CCMDSTA_FD |
		     PAS_DMA_RXCHAN_CCMDSTA_DT))
		printk(KERN_DEBUG "pasemi_mac: ccmdsta error: 0x%08x\n", sta);

	sta = read_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch));
	if (sta & (PAS_DMA_TXCHAN_TCMDSTA_SZ | PAS_DMA_TXCHAN_TCMDSTA_DB |
		      PAS_DMA_TXCHAN_TCMDSTA_DE | PAS_DMA_TXCHAN_TCMDSTA_DA))
		printk(KERN_DEBUG "pasemi_mac: tcmdsta error: 0x%08x\n", sta);

	/* Clean out any pending buffers */
	pasemi_mac_clean_tx(tx_ring(mac));
	pasemi_mac_clean_rx(rx_ring(mac), RX_RING_SIZE);

	pasemi_mac_pause_txchan(mac);
	pasemi_mac_pause_rxint(mac);
	pasemi_mac_pause_rxchan(mac);
	pasemi_mac_intf_disable(mac);

	free_irq(mac->tx->chan.irq, mac->tx);
	free_irq(mac->rx->chan.irq, mac->rx);

	for (i = 0; i < mac->num_cs; i++) {
		pasemi_mac_free_csring(mac->cs[i]);
		mac->cs[i] = NULL;
	}

	mac->num_cs = 0;

	/* Free resources */
	pasemi_mac_free_rx_resources(mac);
	pasemi_mac_free_tx_resources(mac);

	return 0;
}

static void pasemi_mac_queue_csdesc(const struct sk_buff *skb,
				    const dma_addr_t *map,
				    const unsigned int *map_size,
				    struct pasemi_mac_txring *txring,
				    struct pasemi_mac_csring *csring)
{
	u64 fund;
	dma_addr_t cs_dest;
	const int nh_off = skb_network_offset(skb);
	const int nh_len = skb_network_header_len(skb);
	const int nfrags = skb_shinfo(skb)->nr_frags;
	int cs_size, i, fill, hdr, cpyhdr, evt;
	dma_addr_t csdma;

	fund = XCT_FUN_ST | XCT_FUN_RR_8BRES |
	       XCT_FUN_O | XCT_FUN_FUN(csring->fun) |
	       XCT_FUN_CRM_SIG | XCT_FUN_LLEN(skb->len - nh_off) |
	       XCT_FUN_SHL(nh_len >> 2) | XCT_FUN_SE;

	switch (ip_hdr(skb)->protocol) {
	case IPPROTO_TCP:
		fund |= XCT_FUN_SIG_TCP4;
		/* TCP checksum is 16 bytes into the header */
		cs_dest = map[0] + skb_transport_offset(skb) + 16;
		break;
	case IPPROTO_UDP:
		fund |= XCT_FUN_SIG_UDP4;
		/* UDP checksum is 6 bytes into the header */
		cs_dest = map[0] + skb_transport_offset(skb) + 6;
		break;
	default:
		BUG();
	}

	/* Do the checksum offloaded */
	fill = csring->next_to_fill;
	hdr = fill;

	CS_DESC(csring, fill++) = fund;
	/* Room for 8BRES. Checksum result is really 2 bytes into it */
	csdma = csring->chan.ring_dma + (fill & (CS_RING_SIZE-1)) * 8 + 2;
	CS_DESC(csring, fill++) = 0;

	CS_DESC(csring, fill) = XCT_PTR_LEN(map_size[0]-nh_off) | XCT_PTR_ADDR(map[0]+nh_off);
	for (i = 1; i <= nfrags; i++)
		CS_DESC(csring, fill+i) = XCT_PTR_LEN(map_size[i]) | XCT_PTR_ADDR(map[i]);

	fill += i;
	if (fill & 1)
		fill++;

	/* Copy the result into the TCP packet */
	cpyhdr = fill;
	CS_DESC(csring, fill++) = XCT_FUN_O | XCT_FUN_FUN(csring->fun) |
				  XCT_FUN_LLEN(2) | XCT_FUN_SE;
	CS_DESC(csring, fill++) = XCT_PTR_LEN(2) | XCT_PTR_ADDR(cs_dest) | XCT_PTR_T;
	CS_DESC(csring, fill++) = XCT_PTR_LEN(2) | XCT_PTR_ADDR(csdma);
	fill++;

	evt = !csring->last_event;
	csring->last_event = evt;

	/* Event handshaking with MAC TX */
	CS_DESC(csring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |
				  CTRL_CMD_ETYPE_SET | CTRL_CMD_REG(csring->events[evt]);
	CS_DESC(csring, fill++) = 0;
	CS_DESC(csring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |
				  CTRL_CMD_ETYPE_WCLR | CTRL_CMD_REG(csring->events[!evt]);
	CS_DESC(csring, fill++) = 0;
	csring->next_to_fill = fill & (CS_RING_SIZE-1);

	cs_size = fill - hdr;
	write_dma_reg(PAS_DMA_TXCHAN_INCR(csring->chan.chno), (cs_size) >> 1);

	/* TX-side event handshaking */
	fill = txring->next_to_fill;
	TX_DESC(txring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |
				  CTRL_CMD_ETYPE_WSET | CTRL_CMD_REG(csring->events[evt]);
	TX_DESC(txring, fill++) = 0;
	TX_DESC(txring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |
				  CTRL_CMD_ETYPE_CLR | CTRL_CMD_REG(csring->events[!evt]);
	TX_DESC(txring, fill++) = 0;
	txring->next_to_fill = fill;

	write_dma_reg(PAS_DMA_TXCHAN_INCR(txring->chan.chno), 2);
}

static int pasemi_mac_start_tx(struct sk_buff *skb, struct net_device *dev)
{
	struct pasemi_mac * const mac = netdev_priv(dev);
	struct pasemi_mac_txring * const txring = tx_ring(mac);
	struct pasemi_mac_csring *csring;
	u64 dflags = 0;
	u64 mactx;
	dma_addr_t map[MAX_SKB_FRAGS+1];
	unsigned int map_size[MAX_SKB_FRAGS+1];
	unsigned long flags;
	int i, nfrags;
	int fill;
	const int nh_off = skb_network_offset(skb);
	const int nh_len = skb_network_header_len(skb);

	prefetch(&txring->ring_info);

	dflags = XCT_MACTX_O | XCT_MACTX_ST | XCT_MACTX_CRC_PAD;

	nfrags = skb_shinfo(skb)->nr_frags;

	map[0] = pci_map_single(mac->dma_pdev, skb->data, skb_headlen(skb),
				PCI_DMA_TODEVICE);
	map_size[0] = skb_headlen(skb);
	if (pci_dma_mapping_error(mac->dma_pdev, map[0]))
		goto out_err_nolock;

	for (i = 0; i < nfrags; i++) {
		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];

		map[i+1] = pci_map_page(mac->dma_pdev, frag->page,
					frag->page_offset, frag->size,
					PCI_DMA_TODEVICE);
		map_size[i+1] = frag->size;
		if (pci_dma_mapping_error(mac->dma_pdev, map[i+1])) {
			nfrags = i;
			goto out_err_nolock;
		}
	}

	if (skb->ip_summed == CHECKSUM_PARTIAL && skb->len <= 1540) {
		switch (ip_hdr(skb)->protocol) {
		case IPPROTO_TCP:
			dflags |= XCT_MACTX_CSUM_TCP;
			dflags |= XCT_MACTX_IPH(nh_len >> 2);
			dflags |= XCT_MACTX_IPO(nh_off);
			break;
		case IPPROTO_UDP:
			dflags |= XCT_MACTX_CSUM_UDP;
			dflags |= XCT_MACTX_IPH(nh_len >> 2);
			dflags |= XCT_MACTX_IPO(nh_off);
			break;
		default:
			WARN_ON(1);
		}
	}

	mactx = dflags | XCT_MACTX_LLEN(skb->len);

	spin_lock_irqsave(&txring->lock, flags);

	/* Avoid stepping on the same cache line that the DMA controller
	 * is currently about to send, so leave at least 8 words available.
	 * Total free space needed is mactx + fragments + 8
	 */
	if (RING_AVAIL(txring) < nfrags + 14) {
		/* no room -- stop the queue and wait for tx intr */
		netif_stop_queue(dev);
		goto out_err;
	}

	/* Queue up checksum + event descriptors, if needed */
	if (mac->num_cs && skb->ip_summed == CHECKSUM_PARTIAL && skb->len > 1540) {
		csring = mac->cs[mac->last_cs];
		mac->last_cs = (mac->last_cs + 1) % mac->num_cs;

		pasemi_mac_queue_csdesc(skb, map, map_size, txring, csring);
	}

	fill = txring->next_to_fill;
	TX_DESC(txring, fill) = mactx;
	TX_DESC_INFO(txring, fill).dma = nfrags;
	fill++;
	TX_DESC_INFO(txring, fill).skb = skb;
	for (i = 0; i <= nfrags; i++) {
		TX_DESC(txring, fill+i) =
			XCT_PTR_LEN(map_size[i]) | XCT_PTR_ADDR(map[i]);
		TX_DESC_INFO(txring, fill+i).dma = map[i];
	}

	/* We have to add an even number of 8-byte entries to the ring
	 * even if the last one is unused. That means always an odd number
	 * of pointers + one mactx descriptor.
	 */
	if (nfrags & 1)
		nfrags++;

	txring->next_to_fill = (fill + nfrags + 1) & (TX_RING_SIZE-1);

	dev->stats.tx_packets++;
	dev->stats.tx_bytes += skb->len;

	spin_unlock_irqrestore(&txring->lock, flags);

	write_dma_reg(PAS_DMA_TXCHAN_INCR(txring->chan.chno), (nfrags+2) >> 1);

	return NETDEV_TX_OK;

out_err:
	spin_unlock_irqrestore(&txring->lock, flags);
out_err_nolock:
	while (nfrags--)
		pci_unmap_single(mac->dma_pdev, map[nfrags], map_size[nfrags],
				 PCI_DMA_TODEVICE);

	return NETDEV_TX_BUSY;
}

static void pasemi_mac_set_rx_mode(struct net_device *dev)
{
	const struct pasemi_mac *mac = netdev_priv(dev);
	unsigned int flags;

	flags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);

	/* Set promiscuous */
	if (dev->flags & IFF_PROMISC)
		flags |= PAS_MAC_CFG_PCFG_PR;
	else
		flags &= ~PAS_MAC_CFG_PCFG_PR;

	write_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);
}


static int pasemi_mac_poll(struct napi_struct *napi, int budget)
{
	struct pasemi_mac *mac = container_of(napi, struct pasemi_mac, napi);
	int pkts;

	pasemi_mac_clean_tx(tx_ring(mac));
	pkts = pasemi_mac_clean_rx(rx_ring(mac), budget);
	if (pkts < budget) {
		/* all done, no more packets present */
		napi_complete(napi);

		pasemi_mac_restart_rx_intr(mac);
		pasemi_mac_restart_tx_intr(mac);
	}
	return pkts;
}

#ifdef CONFIG_NET_POLL_CONTROLLER
/*
 * Polling 'interrupt' - used by things like netconsole to send skbs
 * without having to re-enable interrupts. It's not called while
 * the interrupt routine is executing.
 */
static void pasemi_mac_netpoll(struct net_device *dev)
{
	const struct pasemi_mac *mac = netdev_priv(dev);

	disable_irq(mac->tx->chan.irq);
	pasemi_mac_tx_intr(mac->tx->chan.irq, mac->tx);
	enable_irq(mac->tx->chan.irq);

	disable_irq(mac->rx->chan.irq);
	pasemi_mac_rx_intr(mac->rx->chan.irq, mac->rx);
	enable_irq(mac->rx->chan.irq);
}
#endif

static int pasemi_mac_change_mtu(struct net_device *dev, int new_mtu)
{
	struct pasemi_mac *mac = netdev_priv(dev);
	unsigned int reg;
	unsigned int rcmdsta = 0;
	int running;
	int ret = 0;

	if (new_mtu < PE_MIN_MTU || new_mtu > PE_MAX_MTU)
		return -EINVAL;

	running = netif_running(dev);

	if (running) {
		/* Need to stop the interface, clean out all already
		 * received buffers, free all unused buffers on the RX
		 * interface ring, then finally re-fill the rx ring with
		 * the new-size buffers and restart.
		 */

		napi_disable(&mac->napi);
		netif_tx_disable(dev);
		pasemi_mac_intf_disable(mac);

		rcmdsta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));
		pasemi_mac_pause_rxint(mac);
		pasemi_mac_clean_rx(rx_ring(mac), RX_RING_SIZE);
		pasemi_mac_free_rx_buffers(mac);

	}

	/* Setup checksum channels if large MTU and none already allocated */
	if (new_mtu > 1500 && !mac->num_cs) {
		pasemi_mac_setup_csrings(mac);
		if (!mac->num_cs) {
			ret = -ENOMEM;
			goto out;
		}
	}

	/* Change maxf, i.e. what size frames are accepted.
	 * Need room for ethernet header and CRC word
	 */
	reg = read_mac_reg(mac, PAS_MAC_CFG_MACCFG);
	reg &= ~PAS_MAC_CFG_MACCFG_MAXF_M;
	reg |= PAS_MAC_CFG_MACCFG_MAXF(new_mtu + ETH_HLEN + 4);
	write_mac_reg(mac, PAS_MAC_CFG_MACCFG, reg);

	dev->mtu = new_mtu;
	/* MTU + ETH_HLEN + VLAN_HLEN + 2 64B cachelines */
	mac->bufsz = new_mtu + ETH_HLEN + ETH_FCS_LEN + LOCAL_SKB_ALIGN + 128;

out:
	if (running) {
		write_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if),
			      rcmdsta | PAS_DMA_RXINT_RCMDSTA_EN);

		rx_ring(mac)->next_to_fill = 0;
		pasemi_mac_replenish_rx_ring(dev, RX_RING_SIZE-1);

		napi_enable(&mac->napi);
		netif_start_queue(dev);
		pasemi_mac_intf_enable(mac);
	}

	return ret;
}

static const struct net_device_ops pasemi_netdev_ops = {
	.ndo_open		= pasemi_mac_open,
	.ndo_stop		= pasemi_mac_close,
	.ndo_start_xmit		= pasemi_mac_start_tx,
	.ndo_set_multicast_list	= pasemi_mac_set_rx_mode,
	.ndo_set_mac_address	= pasemi_mac_set_mac_addr,
	.ndo_change_mtu		= pasemi_mac_change_mtu,
	.ndo_validate_addr	= eth_validate_addr,
#ifdef CONFIG_NET_POLL_CONTROLLER
	.ndo_poll_controller	= pasemi_mac_netpoll,
#endif
};

static int __devinit
pasemi_mac_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct net_device *dev;
	struct pasemi_mac *mac;
	int err, ret;

	err = pci_enable_device(pdev);
	if (err)
		return err;

	dev = alloc_etherdev(sizeof(struct pasemi_mac));
	if (dev == NULL) {
		dev_err(&pdev->dev,
			"pasemi_mac: Could not allocate ethernet device.\n");
		err = -ENOMEM;
		goto out_disable_device;
	}

	pci_set_drvdata(pdev, dev);
	SET_NETDEV_DEV(dev, &pdev->dev);

	mac = netdev_priv(dev);

	mac->pdev = pdev;
	mac->netdev = dev;

	netif_napi_add(dev, &mac->napi, pasemi_mac_poll, 64);

	dev->features = NETIF_F_IP_CSUM | NETIF_F_LLTX | NETIF_F_SG |
			NETIF_F_HIGHDMA | NETIF_F_GSO;

	mac->lro_mgr.max_aggr = LRO_MAX_AGGR;
	mac->lro_mgr.max_desc = MAX_LRO_DESCRIPTORS;
	mac->lro_mgr.lro_arr = mac->lro_desc;
	mac->lro_mgr.get_skb_header = get_skb_hdr;
	mac->lro_mgr.features = LRO_F_NAPI | LRO_F_EXTRACT_VLAN_ID;
	mac->lro_mgr.dev = mac->netdev;
	mac->lro_mgr.ip_summed = CHECKSUM_UNNECESSARY;
	mac->lro_mgr.ip_summed_aggr = CHECKSUM_UNNECESSARY;


	mac->dma_pdev = pci_get_device(PCI_VENDOR_ID_PASEMI, 0xa007, NULL);
	if (!mac->dma_pdev) {
		dev_err(&mac->pdev->dev, "Can't find DMA Controller\n");
		err = -ENODEV;
		goto out;
	}

	mac->iob_pdev = pci_get_device(PCI_VENDOR_ID_PASEMI, 0xa001, NULL);
	if (!mac->iob_pdev) {
		dev_err(&mac->pdev->dev, "Can't find I/O Bridge\n");
		err = -ENODEV;
		goto out;
	}

	/* get mac addr from device tree */
	if (pasemi_get_mac_addr(mac) || !is_valid_ether_addr(mac->mac_addr)) {
		err = -ENODEV;
		goto out;
	}
	memcpy(dev->dev_addr, mac->mac_addr, sizeof(mac->mac_addr));

	ret = mac_to_intf(mac);
	if (ret < 0) {
		dev_err(&mac->pdev->dev, "Can't map DMA interface\n");
		err = -ENODEV;
		goto out;
	}
	mac->dma_if = ret;

	switch (pdev->device) {
	case 0xa005:
		mac->type = MAC_TYPE_GMAC;
		break;
	case 0xa006:
		mac->type = MAC_TYPE_XAUI;
		break;
	default:
		err = -ENODEV;
		goto out;
	}

	dev->netdev_ops = &pasemi_netdev_ops;
	dev->mtu = PE_DEF_MTU;
	/* 1500 MTU + ETH_HLEN + VLAN_HLEN + 2 64B cachelines */
	mac->bufsz = dev->mtu + ETH_HLEN + ETH_FCS_LEN + LOCAL_SKB_ALIGN + 128;

	dev->ethtool_ops = &pasemi_mac_ethtool_ops;

	if (err)
		goto out;

	mac->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);

	/* Enable most messages by default */
	mac->msg_enable = (NETIF_MSG_IFUP << 1 ) - 1;

	err = register_netdev(dev);

	if (err) {
		dev_err(&mac->pdev->dev, "register_netdev failed with error %d\n",
			err);
		goto out;
	} else if netif_msg_probe(mac)
		printk(KERN_INFO "%s: PA Semi %s: intf %d, hw addr %pM\n",
		       dev->name, mac->type == MAC_TYPE_GMAC ? "GMAC" : "XAUI",
		       mac->dma_if, dev->dev_addr);

	return err;

out:
	if (mac->iob_pdev)
		pci_dev_put(mac->iob_pdev);
	if (mac->dma_pdev)
		pci_dev_put(mac->dma_pdev);

	free_netdev(dev);
out_disable_device:
	pci_disable_device(pdev);
	return err;

}

static void __devexit pasemi_mac_remove(struct pci_dev *pdev)
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct pasemi_mac *mac;

	if (!netdev)
		return;

	mac = netdev_priv(netdev);

	unregister_netdev(netdev);

	pci_disable_device(pdev);
	pci_dev_put(mac->dma_pdev);
	pci_dev_put(mac->iob_pdev);

	pasemi_dma_free_chan(&mac->tx->chan);
	pasemi_dma_free_chan(&mac->rx->chan);

	pci_set_drvdata(pdev, NULL);
	free_netdev(netdev);
}

static DEFINE_PCI_DEVICE_TABLE(pasemi_mac_pci_tbl) = {
	{ PCI_DEVICE(PCI_VENDOR_ID_PASEMI, 0xa005) },
	{ PCI_DEVICE(PCI_VENDOR_ID_PASEMI, 0xa006) },
	{ },
};

MODULE_DEVICE_TABLE(pci, pasemi_mac_pci_tbl);

static struct pci_driver pasemi_mac_driver = {
	.name		= "pasemi_mac",
	.id_table	= pasemi_mac_pci_tbl,
	.probe		= pasemi_mac_probe,
	.remove		= __devexit_p(pasemi_mac_remove),
};

static void __exit pasemi_mac_cleanup_module(void)
{
	pci_unregister_driver(&pasemi_mac_driver);
}

int pasemi_mac_init_module(void)
{
	int err;

	err = pasemi_dma_init();
	if (err)
		return err;

	return pci_register_driver(&pasemi_mac_driver);
}

module_init(pasemi_mac_init_module);
module_exit(pasemi_mac_cleanup_module);
/*
 * FLoating proportions
 *
 *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra <pzijlstr@redhat.com>
 *
 * This file contains the public data structure and API definitions.
 */

#ifndef _LINUX_PROPORTIONS_H
#define _LINUX_PROPORTIONS_H

#include <linux/percpu_counter.h>
#include <linux/spinlock.h>
#include <linux/mutex.h>

struct prop_global {
	/*
	 * The period over which we differentiate
	 *
	 *   period = 2^shift
	 */
	int shift;
	/*
	 * The total event counter aka 'time'.
	 *
	 * Treated as an unsigned long; the lower 'shift - 1' bits are the
	 * counter bits, the remaining upper bits the period counter.
	 */
	struct percpu_counter events;
};

/*
 * global proportion descriptor
 *
 * this is needed to consitently flip prop_global structures.
 */
struct prop_descriptor {
	int index;
	struct prop_global pg[2];
	struct mutex mutex;		/* serialize the prop_global switch */
};

int prop_descriptor_init(struct prop_descriptor *pd, int shift);
void prop_change_shift(struct prop_descriptor *pd, int new_shift);

/*
 * ----- PERCPU ------
 */

struct prop_local_percpu {
	/*
	 * the local events counter
	 */
	struct percpu_counter events;

	/*
	 * snapshot of the last seen global state
	 */
	int shift;
	unsigned long period;
	spinlock_t lock;		/* protect the snapshot state */
};

int prop_local_init_percpu(struct prop_local_percpu *pl);
void prop_local_destroy_percpu(struct prop_local_percpu *pl);
void __prop_inc_percpu(struct prop_descriptor *pd, struct prop_local_percpu *pl);
void prop_fraction_percpu(struct prop_descriptor *pd, struct prop_local_percpu *pl,
		long *numerator, long *denominator);

static inline
void prop_inc_percpu(struct prop_descriptor *pd, struct prop_local_percpu *pl)
{
	unsigned long flags;

	local_irq_save(flags);
	__prop_inc_percpu(pd, pl);
	local_irq_restore(flags);
}

/*
 * Limit the time part in order to ensure there are some bits left for the
 * cycle counter and fraction multiply.
 */
#define PROP_MAX_SHIFT (3*BITS_PER_LONG/4)

#define PROP_FRAC_SHIFT		(BITS_PER_LONG - PROP_MAX_SHIFT - 1)
#define PROP_FRAC_BASE		(1UL << PROP_FRAC_SHIFT)

void __prop_inc_percpu_max(struct prop_descriptor *pd,
			   struct prop_local_percpu *pl, long frac);


/*
 * ----- SINGLE ------
 */

struct prop_local_single {
	/*
	 * the local events counter
	 */
	unsigned long events;

	/*
	 * snapshot of the last seen global state
	 * and a lock protecting this state
	 */
	unsigned long period;
	int shift;
	spinlock_t lock;		/* protect the snapshot state */
};

#define INIT_PROP_LOCAL_SINGLE(name)			\
{	.lock = __SPIN_LOCK_UNLOCKED(name.lock),	\
}

int prop_local_init_single(struct prop_local_single *pl);
void prop_local_destroy_single(struct prop_local_single *pl);
void __prop_inc_single(struct prop_descriptor *pd, struct prop_local_single *pl);
void prop_fraction_single(struct prop_descriptor *pd, struct prop_local_single *pl,
		long *numerator, long *denominator);

static inline
void prop_inc_single(struct prop_descriptor *pd, struct prop_local_single *pl)
{
	unsigned long flags;

	local_irq_save(flags);
	__prop_inc_single(pd, pl);
	local_irq_restore(flags);
}

#endif /* _LINUX_PROPORTIONS_H */
cmd_drivers/net/phy/broadcom.o := gcc -Wp,-MD,drivers/net/phy/.broadcom.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(broadcom)"  -D"KBUILD_MODNAME=KBUILD_STR(broadcom)"  -c -o drivers/net/phy/.tmp_broadcom.o drivers/net/phy/broadcom.c

deps_drivers/net/phy/broadcom.o := \
  drivers/net/phy/broadcom.c \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/phy.h \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/ethtool.h \
  include/linux/rculist.h \
  include/linux/mii.h \
  include/linux/if.h \
  include/linux/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/socket.h \
  include/asm-generic/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sockios.h \
  include/asm-generic/sockios.h \
  include/linux/sockios.h \
  include/linux/uio.h \
  include/linux/hdlc/ioctl.h \
  include/linux/mod_devicetable.h \
  include/linux/brcmphy.h \

drivers/net/phy/broadcom.o: $(deps_drivers/net/phy/broadcom.o)

$(deps_drivers/net/phy/broadcom.o):
cmd_net/ipv4/netfilter/ipt_addrtype.ko := ld -r -m elf_x86_64 -T /usr/src/linux-2.6.36-gentoo-r5/scripts/module-common.lds --build-id  -o net/ipv4/netfilter/ipt_addrtype.ko net/ipv4/netfilter/ipt_addrtype.o net/ipv4/netfilter/ipt_addrtype.mod.o
/*
 * Copyright 2008-2009 Analog Devices Inc.
 *
 * Licensed under the ADI BSD license or the GPL-2 (or later)
 */

#ifndef _CDEF_BF514_H
#define _CDEF_BF514_H

/* include all Core registers and bit definitions */
#include "defBF514.h"

/* BF514 is BF512 + RSI */
#include "cdefBF512.h"

/* Removable Storage Interface Registers */

#define bfin_read_RSI_PWR_CTL()        bfin_read16(RSI_PWR_CONTROL)
#define bfin_write_RSI_PWR_CTL(val)    bfin_write16(RSI_PWR_CONTROL, val)
#define bfin_read_RSI_CLK_CTL()	       bfin_read16(RSI_CLK_CONTROL)
#define bfin_write_RSI_CLK_CTL(val)    bfin_write16(RSI_CLK_CONTROL, val)
#define bfin_read_RSI_ARGUMENT()       bfin_read32(RSI_ARGUMENT)
#define bfin_write_RSI_ARGUMENT(val)   bfin_write32(RSI_ARGUMENT, val)
#define bfin_read_RSI_COMMAND()        bfin_read16(RSI_COMMAND)
#define bfin_write_RSI_COMMAND(val)    bfin_write16(RSI_COMMAND, val)
#define bfin_read_RSI_RESP_CMD()       bfin_read16(RSI_RESP_CMD)
#define bfin_write_RSI_RESP_CMD(val)   bfin_write16(RSI_RESP_CMD, val)
#define bfin_read_RSI_RESPONSE0()      bfin_read32(RSI_RESPONSE0)
#define bfin_write_RSI_RESPONSE0(val)  bfin_write32(RSI_RESPONSE0, val)
#define bfin_read_RSI_RESPONSE1()      bfin_read32(RSI_RESPONSE1)
#define bfin_write_RSI_RESPONSE1(val)  bfin_write32(RSI_RESPONSE1, val)
#define bfin_read_RSI_RESPONSE2()      bfin_read32(RSI_RESPONSE2)
#define bfin_write_RSI_RESPONSE2(val)  bfin_write32(RSI_RESPONSE2, val)
#define bfin_read_RSI_RESPONSE3()      bfin_read32(RSI_RESPONSE3)
#define bfin_write_RSI_RESPONSE3(val)  bfin_write32(RSI_RESPONSE3, val)
#define bfin_read_RSI_DATA_TIMER()     bfin_read32(RSI_DATA_TIMER)
#define bfin_write_RSI_DATA_TIMER(val) bfin_write32(RSI_DATA_TIMER, val)
#define bfin_read_RSI_DATA_LGTH()      bfin_read16(RSI_DATA_LGTH)
#define bfin_write_RSI_DATA_LGTH(val)  bfin_write16(RSI_DATA_LGTH, val)
#define bfin_read_RSI_DATA_CTL()       bfin_read16(RSI_DATA_CONTROL)
#define bfin_write_RSI_DATA_CTL(val)   bfin_write16(RSI_DATA_CONTROL, val)
#define bfin_read_RSI_DATA_CNT()       bfin_read16(RSI_DATA_CNT)
#define bfin_write_RSI_DATA_CNT(val)   bfin_write16(RSI_DATA_CNT, val)
#define bfin_read_RSI_STATUS()         bfin_read32(RSI_STATUS)
#define bfin_write_RSI_STATUS(val)     bfin_write32(RSI_STATUS, val)
#define bfin_read_RSI_STATUS_CLR()     bfin_read16(RSI_STATUSCL)
#define bfin_write_RSI_STATUS_CLR(val) bfin_write16(RSI_STATUSCL, val)
#define bfin_read_RSI_MASK0()          bfin_read32(RSI_MASK0)
#define bfin_write_RSI_MASK0(val)      bfin_write32(RSI_MASK0, val)
#define bfin_read_RSI_MASK1()          bfin_read32(RSI_MASK1)
#define bfin_write_RSI_MASK1(val)      bfin_write32(RSI_MASK1, val)
#define bfin_read_RSI_FIFO_CNT()       bfin_read16(RSI_FIFO_CNT)
#define bfin_write_RSI_FIFO_CNT(val)   bfin_write16(RSI_FIFO_CNT, val)
#define bfin_read_RSI_CEATA_CTL()      bfin_read16(RSI_CEATA_CONTROL)
#define bfin_write_RSI_CEATA_CTL(val)  bfin_write16(RSI_CEATA_CONTROL, val)
#define bfin_read_RSI_FIFO()           bfin_read32(RSI_FIFO)
#define bfin_write_RSI_FIFO(val)       bfin_write32(RSI_FIFO, val)
#define bfin_read_RSI_E_STATUS()       bfin_read16(RSI_ESTAT)
#define bfin_write_RSI_E_STATUS(val)   bfin_write16(RSI_ESTAT, val)
#define bfin_read_RSI_E_MASK()         bfin_read16(RSI_EMASK)
#define bfin_write_RSI_E_MASK(val)     bfin_write16(RSI_EMASK, val)
#define bfin_read_RSI_CFG()            bfin_read16(RSI_CONFIG)
#define bfin_write_RSI_CFG(val)        bfin_write16(RSI_CONFIG, val)
#define bfin_read_RSI_RD_WAIT_EN()     bfin_read16(RSI_RD_WAIT_EN)
#define bfin_write_RSI_RD_WAIT_EN(val) bfin_write16(RSI_RD_WAIT_EN, val)
#define bfin_read_RSI_PID0()           bfin_read16(RSI_PID0)
#define bfin_write_RSI_PID0(val)       bfin_write16(RSI_PID0, val)
#define bfin_read_RSI_PID1()           bfin_read16(RSI_PID1)
#define bfin_write_RSI_PID1(val)       bfin_write16(RSI_PID1, val)
#define bfin_read_RSI_PID2()           bfin_read16(RSI_PID2)
#define bfin_write_RSI_PID2(val)       bfin_write16(RSI_PID2, val)
#define bfin_read_RSI_PID3()           bfin_read16(RSI_PID3)
#define bfin_write_RSI_PID3(val)       bfin_write16(RSI_PID3, val)
#define bfin_read_RSI_PID4()           bfin_read16(RSI_PID4)
#define bfin_write_RSI_PID4(val)       bfin_write16(RSI_PID4, val)
#define bfin_read_RSI_PID5()           bfin_read16(RSI_PID5)
#define bfin_write_RSI_PID5(val)       bfin_write16(RSI_PID5, val)
#define bfin_read_RSI_PID6()           bfin_read16(RSI_PID6)
#define bfin_write_RSI_PID6(val)       bfin_write16(RSI_PID6, val)
#define bfin_read_RSI_PID7()           bfin_read16(RSI_PID7)
#define bfin_write_RSI_PID7(val)       bfin_write16(RSI_PID7, val)

#endif /* _CDEF_BF514_H */
/*
 * DaVinci system defines
 *
 * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
 *
 * 2007 (c) MontaVista Software, Inc. This file is licensed under
 * the terms of the GNU General Public License version 2. This program
 * is licensed "as is" without any warranty of any kind, whether express
 * or implied.
 */
#ifndef __ASM_ARCH_SYSTEM_H
#define __ASM_ARCH_SYSTEM_H

#include <mach/common.h>

static inline void arch_idle(void)
{
	cpu_do_idle();
}

static inline void arch_reset(char mode, const char *cmd)
{
	if (davinci_soc_info.reset)
		davinci_soc_info.reset(davinci_soc_info.reset_device);
}

#endif /* __ASM_ARCH_SYSTEM_H */
/*
 * linux/drivers/serial/cpm_uart/cpm_uart_cpm2.h
 *
 * Driver for CPM (SCC/SMC) serial ports
 *
 * definitions for cpm2
 *
 */

#ifndef CPM_UART_CPM2_H
#define CPM_UART_CPM2_H

#include <asm/cpm2.h>

static inline void cpm_set_brg(int brg, int baud)
{
	cpm_setbrg(brg, baud);
}

static inline void cpm_set_scc_fcr(scc_uart_t __iomem *sup)
{
	out_8(&sup->scc_genscc.scc_rfcr, CPMFCR_GBL | CPMFCR_EB);
	out_8(&sup->scc_genscc.scc_tfcr, CPMFCR_GBL | CPMFCR_EB);
}

static inline void cpm_set_smc_fcr(smc_uart_t __iomem *up)
{
	out_8(&up->smc_rfcr, CPMFCR_GBL | CPMFCR_EB);
	out_8(&up->smc_tfcr, CPMFCR_GBL | CPMFCR_EB);
}

#define DPRAM_BASE	((u8 __iomem __force *)cpm_dpram_addr(0))

#endif
cmd_drivers/infiniband/core/ib_addr.mod.o := gcc -Wp,-MD,drivers/infiniband/core/.ib_addr.mod.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(ib_addr.mod)"  -D"KBUILD_MODNAME=KBUILD_STR(ib_addr)"  -DMODULE  -c -o drivers/infiniband/core/ib_addr.mod.o drivers/infiniband/core/ib_addr.mod.c

deps_drivers/infiniband/core/ib_addr.mod.o := \
  drivers/infiniband/core/ib_addr.mod.c \
    $(wildcard include/config/module/unload.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/vermagic.h \
  include/generated/utsrelease.h \

drivers/infiniband/core/ib_addr.mod.o: $(deps_drivers/infiniband/core/ib_addr.mod.o)

$(deps_drivers/infiniband/core/ib_addr.mod.o):
/*
 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
 *  Universal interface for Audio Codec '97
 *
 *  For more details look to AC '97 component specification revision 2.2
 *  by Intel Corporation (http://developer.intel.com).
 *
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 */

#include <linux/mutex.h>

#include <sound/core.h>
#include <sound/ac97_codec.h>
#include <sound/asoundef.h>
#include "ac97_local.h"
#include "ac97_id.h"

/*
 * proc interface
 */

static void snd_ac97_proc_read_functions(struct snd_ac97 *ac97, struct snd_info_buffer *buffer)
{
	int header = 0, function;
	unsigned short info, sense_info;
	static const char *function_names[12] = {
		"Master Out", "AUX Out", "Center/LFE Out", "SPDIF Out",
		"Phone In", "Mic 1", "Mic 2", "Line In", "CD In", "Video In",
		"Aux In", "Mono Out"
	};
	static const char *locations[8] = {
		"Rear I/O Panel", "Front Panel", "Motherboard", "Dock/External",
		"reserved", "reserved", "reserved", "NC/unused"
	};

	for (function = 0; function < 12; ++function) {
		snd_ac97_write(ac97, AC97_FUNC_SELECT, function << 1);
		info = snd_ac97_read(ac97, AC97_FUNC_INFO);
		if (!(info & 0x0001))
			continue;
		if (!header) {
			snd_iprintf(buffer, "\n                    Gain     Inverted  Buffer delay  Location\n");
			header = 1;
		}
		sense_info = snd_ac97_read(ac97, AC97_SENSE_INFO);
		snd_iprintf(buffer, "%-17s: %3d.%d dBV    %c      %2d/fs         %s\n",
			    function_names[function],
			    (info & 0x8000 ? -1 : 1) * ((info & 0x7000) >> 12) * 3 / 2,
			    ((info & 0x0800) >> 11) * 5,
			    info & 0x0400 ? 'X' : '-',
			    (info & 0x03e0) >> 5,
			    locations[sense_info >> 13]);
	}
}

static const char *snd_ac97_stereo_enhancements[] =
{
  /*   0 */ "No 3D Stereo Enhancement",
  /*   1 */ "Analog Devices Phat Stereo",
  /*   2 */ "Creative Stereo Enhancement",
  /*   3 */ "National Semi 3D Stereo Enhancement",
  /*   4 */ "YAMAHA Ymersion",
  /*   5 */ "BBE 3D Stereo Enhancement",
  /*   6 */ "Crystal Semi 3D Stereo Enhancement",
  /*   7 */ "Qsound QXpander",
  /*   8 */ "Spatializer 3D Stereo Enhancement",
  /*   9 */ "SRS 3D Stereo Enhancement",
  /*  10 */ "Platform Tech 3D Stereo Enhancement",
  /*  11 */ "AKM 3D Audio",
  /*  12 */ "Aureal Stereo Enhancement",
  /*  13 */ "Aztech 3D Enhancement",
  /*  14 */ "Binaura 3D Audio Enhancement",
  /*  15 */ "ESS Technology Stereo Enhancement",
  /*  16 */ "Harman International VMAx",
  /*  17 */ "Nvidea/IC Ensemble/KS Waves 3D Stereo Enhancement",
  /*  18 */ "Philips Incredible Sound",
  /*  19 */ "Texas Instruments 3D Stereo Enhancement",
  /*  20 */ "VLSI Technology 3D Stereo Enhancement",
  /*  21 */ "TriTech 3D Stereo Enhancement",
  /*  22 */ "Realtek 3D Stereo Enhancement",
  /*  23 */ "Samsung 3D Stereo Enhancement",
  /*  24 */ "Wolfson Microelectronics 3D Enhancement",
  /*  25 */ "Delta Integration 3D Enhancement",
  /*  26 */ "SigmaTel 3D Enhancement",
  /*  27 */ "IC Ensemble/KS Waves",
  /*  28 */ "Rockwell 3D Stereo Enhancement",
  /*  29 */ "Reserved 29",
  /*  30 */ "Reserved 30",
  /*  31 */ "Reserved 31"
};

static void snd_ac97_proc_read_main(struct snd_ac97 *ac97, struct snd_info_buffer *buffer, int subidx)
{
	char name[64];
	unsigned short val, tmp, ext, mext;
	static const char *spdif_slots[4] = { " SPDIF=3/4", " SPDIF=7/8", " SPDIF=6/9", " SPDIF=10/11" };
	static const char *spdif_rates[4] = { " Rate=44.1kHz", " Rate=res", " Rate=48kHz", " Rate=32kHz" };
	static const char *spdif_rates_cs4205[4] = { " Rate=48kHz", " Rate=44.1kHz", " Rate=res", " Rate=res" };
	static const char *double_rate_slots[4] = { "10/11", "7/8", "reserved", "reserved" };

	snd_ac97_get_name(NULL, ac97->id, name, 0);
	snd_iprintf(buffer, "%d-%d/%d: %s\n\n", ac97->addr, ac97->num, subidx, name);

	if ((ac97->scaps & AC97_SCAP_AUDIO) == 0)
		goto __modem;

        snd_iprintf(buffer, "PCI Subsys Vendor: 0x%04x\n",
	            ac97->subsystem_vendor);
        snd_iprintf(buffer, "PCI Subsys Device: 0x%04x\n\n",
                    ac97->subsystem_device);

	snd_iprintf(buffer, "Flags: %x\n", ac97->flags);

	if ((ac97->ext_id & AC97_EI_REV_MASK) >= AC97_EI_REV_23) {
		val = snd_ac97_read(ac97, AC97_INT_PAGING);
		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
				     AC97_PAGE_MASK, AC97_PAGE_1);
		tmp = snd_ac97_read(ac97, AC97_CODEC_CLASS_REV);
		snd_iprintf(buffer, "Revision         : 0x%02x\n", tmp & 0xff);
		snd_iprintf(buffer, "Compat. Class    : 0x%02x\n", (tmp >> 8) & 0x1f);
		snd_iprintf(buffer, "Subsys. Vendor ID: 0x%04x\n",
			    snd_ac97_read(ac97, AC97_PCI_SVID));
		snd_iprintf(buffer, "Subsys. ID       : 0x%04x\n\n",
			    snd_ac97_read(ac97, AC97_PCI_SID));
		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
				     AC97_PAGE_MASK, val & AC97_PAGE_MASK);
	}

	// val = snd_ac97_read(ac97, AC97_RESET);
	val = ac97->caps;
	snd_iprintf(buffer, "Capabilities     :%s%s%s%s%s%s\n",
	    	    val & AC97_BC_DEDICATED_MIC ? " -dedicated MIC PCM IN channel-" : "",
		    val & AC97_BC_RESERVED1 ? " -reserved1-" : "",
		    val & AC97_BC_BASS_TREBLE ? " -bass & treble-" : "",
		    val & AC97_BC_SIM_STEREO ? " -simulated stereo-" : "",
		    val & AC97_BC_HEADPHONE ? " -headphone out-" : "",
		    val & AC97_BC_LOUDNESS ? " -loudness-" : "");
	tmp = ac97->caps & AC97_BC_DAC_MASK;
	snd_iprintf(buffer, "DAC resolution   : %s%s%s%s\n",
		    tmp == AC97_BC_16BIT_DAC ? "16-bit" : "",
		    tmp == AC97_BC_18BIT_DAC ? "18-bit" : "",
		    tmp == AC97_BC_20BIT_DAC ? "20-bit" : "",
		    tmp == AC97_BC_DAC_MASK ? "???" : "");
	tmp = ac97->caps & AC97_BC_ADC_MASK;
	snd_iprintf(buffer, "ADC resolution   : %s%s%s%s\n",
		    tmp == AC97_BC_16BIT_ADC ? "16-bit" : "",
		    tmp == AC97_BC_18BIT_ADC ? "18-bit" : "",
		    tmp == AC97_BC_20BIT_ADC ? "20-bit" : "",
		    tmp == AC97_BC_ADC_MASK ? "???" : "");
	snd_iprintf(buffer, "3D enhancement   : %s\n",
		snd_ac97_stereo_enhancements[(val >> 10) & 0x1f]);
	snd_iprintf(buffer, "\nCurrent setup\n");
	val = snd_ac97_read(ac97, AC97_MIC);
	snd_iprintf(buffer, "Mic gain         : %s [%s]\n", val & 0x0040 ? "+20dB" : "+0dB", ac97->regs[AC97_MIC] & 0x0040 ? "+20dB" : "+0dB");
	val = snd_ac97_read(ac97, AC97_GENERAL_PURPOSE);
	snd_iprintf(buffer, "POP path         : %s 3D\n"
		    "Sim. stereo      : %s\n"
		    "3D enhancement   : %s\n"
		    "Loudness         : %s\n"
		    "Mono output      : %s\n"
		    "Mic select       : %s\n"
		    "ADC/DAC loopback : %s\n",
		    val & 0x8000 ? "post" : "pre",
		    val & 0x4000 ? "on" : "off",
		    val & 0x2000 ? "on" : "off",
		    val & 0x1000 ? "on" : "off",
		    val & 0x0200 ? "Mic" : "MIX",
		    val & 0x0100 ? "Mic2" : "Mic1",
		    val & 0x0080 ? "on" : "off");
	if (ac97->ext_id & AC97_EI_DRA)
		snd_iprintf(buffer, "Double rate slots: %s\n",
			    double_rate_slots[(val >> 10) & 3]);

	ext = snd_ac97_read(ac97, AC97_EXTENDED_ID);
	if (ext == 0)
		goto __modem;
		
	snd_iprintf(buffer, "Extended ID      : codec=%i rev=%i%s%s%s%s DSA=%i%s%s%s%s\n",
			(ext & AC97_EI_ADDR_MASK) >> AC97_EI_ADDR_SHIFT,
			(ext & AC97_EI_REV_MASK) >> AC97_EI_REV_SHIFT,
			ext & AC97_EI_AMAP ? " AMAP" : "",
			ext & AC97_EI_LDAC ? " LDAC" : "",
			ext & AC97_EI_SDAC ? " SDAC" : "",
			ext & AC97_EI_CDAC ? " CDAC" : "",
			(ext & AC97_EI_DACS_SLOT_MASK) >> AC97_EI_DACS_SLOT_SHIFT,
			ext & AC97_EI_VRM ? " VRM" : "",
			ext & AC97_EI_SPDIF ? " SPDIF" : "",
			ext & AC97_EI_DRA ? " DRA" : "",
			ext & AC97_EI_VRA ? " VRA" : "");
	val = snd_ac97_read(ac97, AC97_EXTENDED_STATUS);
	snd_iprintf(buffer, "Extended status  :%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
			val & AC97_EA_PRL ? " PRL" : "",
			val & AC97_EA_PRK ? " PRK" : "",
			val & AC97_EA_PRJ ? " PRJ" : "",
			val & AC97_EA_PRI ? " PRI" : "",
			val & AC97_EA_SPCV ? " SPCV" : "",
			val & AC97_EA_MDAC ? " MADC" : "",
			val & AC97_EA_LDAC ? " LDAC" : "",
			val & AC97_EA_SDAC ? " SDAC" : "",
			val & AC97_EA_CDAC ? " CDAC" : "",
			ext & AC97_EI_SPDIF ? spdif_slots[(val & AC97_EA_SPSA_SLOT_MASK) >> AC97_EA_SPSA_SLOT_SHIFT] : "",
			val & AC97_EA_VRM ? " VRM" : "",
			val & AC97_EA_SPDIF ? " SPDIF" : "",
			val & AC97_EA_DRA ? " DRA" : "",
			val & AC97_EA_VRA ? " VRA" : "");
	if (ext & AC97_EI_VRA) {	/* VRA */
		val = snd_ac97_read(ac97, AC97_PCM_FRONT_DAC_RATE);
		snd_iprintf(buffer, "PCM front DAC    : %iHz\n", val);
		if (ext & AC97_EI_SDAC) {
			val = snd_ac97_read(ac97, AC97_PCM_SURR_DAC_RATE);
			snd_iprintf(buffer, "PCM Surr DAC     : %iHz\n", val);
		}
		if (ext & AC97_EI_LDAC) {
			val = snd_ac97_read(ac97, AC97_PCM_LFE_DAC_RATE);
			snd_iprintf(buffer, "PCM LFE DAC      : %iHz\n", val);
		}
		val = snd_ac97_read(ac97, AC97_PCM_LR_ADC_RATE);
		snd_iprintf(buffer, "PCM ADC          : %iHz\n", val);
	}
	if (ext & AC97_EI_VRM) {
		val = snd_ac97_read(ac97, AC97_PCM_MIC_ADC_RATE);
		snd_iprintf(buffer, "PCM MIC ADC      : %iHz\n", val);
	}
	if ((ext & AC97_EI_SPDIF) || (ac97->flags & AC97_CS_SPDIF) ||
	    (ac97->id == AC97_ID_YMF743)) {
	        if (ac97->flags & AC97_CS_SPDIF)
			val = snd_ac97_read(ac97, AC97_CSR_SPDIF);
		else if (ac97->id == AC97_ID_YMF743) {
			val = snd_ac97_read(ac97, AC97_YMF7X3_DIT_CTRL);
			val = 0x2000 | (val & 0xff00) >> 4 | (val & 0x38) >> 2;
		} else
			val = snd_ac97_read(ac97, AC97_SPDIF);

		snd_iprintf(buffer, "SPDIF Control    :%s%s%s%s Category=0x%x Generation=%i%s%s%s\n",
			val & AC97_SC_PRO ? " PRO" : " Consumer",
			val & AC97_SC_NAUDIO ? " Non-audio" : " PCM",
			val & AC97_SC_COPY ? "" : " Copyright",
			val & AC97_SC_PRE ? " Preemph50/15" : "",
			(val & AC97_SC_CC_MASK) >> AC97_SC_CC_SHIFT,
			(val & AC97_SC_L) >> 11,
			(ac97->flags & AC97_CS_SPDIF) ?
			    spdif_rates_cs4205[(val & AC97_SC_SPSR_MASK) >> AC97_SC_SPSR_SHIFT] :
			    spdif_rates[(val & AC97_SC_SPSR_MASK) >> AC97_SC_SPSR_SHIFT],
			(ac97->flags & AC97_CS_SPDIF) ?
			    (val & AC97_SC_DRS ? " Validity" : "") :
			    (val & AC97_SC_DRS ? " DRS" : ""),
			(ac97->flags & AC97_CS_SPDIF) ?
			    (val & AC97_SC_V ? " Enabled" : "") :
			    (val & AC97_SC_V ? " Validity" : ""));
		/* ALC650 specific*/
		if ((ac97->id & 0xfffffff0) == 0x414c4720 &&
		    (snd_ac97_read(ac97, AC97_ALC650_CLOCK) & 0x01)) {
			val = snd_ac97_read(ac97, AC97_ALC650_SPDIF_INPUT_STATUS2);
			if (val & AC97_ALC650_CLOCK_LOCK) {
				val = snd_ac97_read(ac97, AC97_ALC650_SPDIF_INPUT_STATUS1);
				snd_iprintf(buffer, "SPDIF In Status  :%s%s%s%s Category=0x%x Generation=%i",
					    val & AC97_ALC650_PRO ? " PRO" : " Consumer",
					    val & AC97_ALC650_NAUDIO ? " Non-audio" : " PCM",
					    val & AC97_ALC650_COPY ? "" : " Copyright",
					    val & AC97_ALC650_PRE ? " Preemph50/15" : "",
					    (val & AC97_ALC650_CC_MASK) >> AC97_ALC650_CC_SHIFT,
					    (val & AC97_ALC650_L) >> 15);
				val = snd_ac97_read(ac97, AC97_ALC650_SPDIF_INPUT_STATUS2);
				snd_iprintf(buffer, "%s Accuracy=%i%s%s\n",
					    spdif_rates[(val & AC97_ALC650_SPSR_MASK) >> AC97_ALC650_SPSR_SHIFT],
					    (val & AC97_ALC650_CLOCK_ACCURACY) >> AC97_ALC650_CLOCK_SHIFT,
					    (val & AC97_ALC650_CLOCK_LOCK ? " Locked" : " Unlocked"),
					    (val & AC97_ALC650_V ? " Validity?" : ""));
			} else {
				snd_iprintf(buffer, "SPDIF In Status  : Not Locked\n");
			}
		}
	}
	if ((ac97->ext_id & AC97_EI_REV_MASK) >= AC97_EI_REV_23) {
		val = snd_ac97_read(ac97, AC97_INT_PAGING);
		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
				     AC97_PAGE_MASK, AC97_PAGE_1);
		snd_ac97_proc_read_functions(ac97, buffer);
		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
				     AC97_PAGE_MASK, val & AC97_PAGE_MASK);
	}


      __modem:
	mext = snd_ac97_read(ac97, AC97_EXTENDED_MID);
	if (mext == 0)
		return;
	
	snd_iprintf(buffer, "Extended modem ID: codec=%i%s%s%s%s%s\n",
			(mext & AC97_MEI_ADDR_MASK) >> AC97_MEI_ADDR_SHIFT,
			mext & AC97_MEI_CID2 ? " CID2" : "",
			mext & AC97_MEI_CID1 ? " CID1" : "",
			mext & AC97_MEI_HANDSET ? " HSET" : "",
			mext & AC97_MEI_LINE2 ? " LIN2" : "",
			mext & AC97_MEI_LINE1 ? " LIN1" : "");
	val = snd_ac97_read(ac97, AC97_EXTENDED_MSTATUS);
	snd_iprintf(buffer, "Modem status     :%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
			val & AC97_MEA_GPIO ? " GPIO" : "",
			val & AC97_MEA_MREF ? " MREF" : "",
			val & AC97_MEA_ADC1 ? " ADC1" : "",
			val & AC97_MEA_DAC1 ? " DAC1" : "",
			val & AC97_MEA_ADC2 ? " ADC2" : "",
			val & AC97_MEA_DAC2 ? " DAC2" : "",
			val & AC97_MEA_HADC ? " HADC" : "",
			val & AC97_MEA_HDAC ? " HDAC" : "",
			val & AC97_MEA_PRA ? " PRA(GPIO)" : "",
			val & AC97_MEA_PRB ? " PRB(res)" : "",
			val & AC97_MEA_PRC ? " PRC(ADC1)" : "",
			val & AC97_MEA_PRD ? " PRD(DAC1)" : "",
			val & AC97_MEA_PRE ? " PRE(ADC2)" : "",
			val & AC97_MEA_PRF ? " PRF(DAC2)" : "",
			val & AC97_MEA_PRG ? " PRG(HADC)" : "",
			val & AC97_MEA_PRH ? " PRH(HDAC)" : "");
	if (mext & AC97_MEI_LINE1) {
		val = snd_ac97_read(ac97, AC97_LINE1_RATE);
		snd_iprintf(buffer, "Line1 rate       : %iHz\n", val);
	}
	if (mext & AC97_MEI_LINE2) {
		val = snd_ac97_read(ac97, AC97_LINE2_RATE);
		snd_iprintf(buffer, "Line2 rate       : %iHz\n", val);
	}
	if (mext & AC97_MEI_HANDSET) {
		val = snd_ac97_read(ac97, AC97_HANDSET_RATE);
		snd_iprintf(buffer, "Headset rate     : %iHz\n", val);
	}
}

static void snd_ac97_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
{
	struct snd_ac97 *ac97 = entry->private_data;
	
	mutex_lock(&ac97->page_mutex);
	if ((ac97->id & 0xffffff40) == AC97_ID_AD1881) {	// Analog Devices AD1881/85/86
		int idx;
		for (idx = 0; idx < 3; idx++)
			if (ac97->spec.ad18xx.id[idx]) {
				/* select single codec */
				snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000,
						     ac97->spec.ad18xx.unchained[idx] | ac97->spec.ad18xx.chained[idx]);
				snd_ac97_proc_read_main(ac97, buffer, idx);
				snd_iprintf(buffer, "\n\n");
			}
		/* select all codecs */
		snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000, 0x7000);
		
		snd_iprintf(buffer, "\nAD18XX configuration\n");
		snd_iprintf(buffer, "Unchained        : 0x%04x,0x%04x,0x%04x\n",
			ac97->spec.ad18xx.unchained[0],
			ac97->spec.ad18xx.unchained[1],
			ac97->spec.ad18xx.unchained[2]);
		snd_iprintf(buffer, "Chained          : 0x%04x,0x%04x,0x%04x\n",
			ac97->spec.ad18xx.chained[0],
			ac97->spec.ad18xx.chained[1],
			ac97->spec.ad18xx.chained[2]);
	} else {
		snd_ac97_proc_read_main(ac97, buffer, 0);
	}
	mutex_unlock(&ac97->page_mutex);
}

#ifdef CONFIG_SND_DEBUG
/* direct register write for debugging */
static void snd_ac97_proc_regs_write(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
{
	struct snd_ac97 *ac97 = entry->private_data;
	char line[64];
	unsigned int reg, val;
	mutex_lock(&ac97->page_mutex);
	while (!snd_info_get_line(buffer, line, sizeof(line))) {
		if (sscanf(line, "%x %x", &reg, &val) != 2)
			continue;
		/* register must be even */
		if (reg < 0x80 && (reg & 1) == 0 && val <= 0xffff)
			snd_ac97_write_cache(ac97, reg, val);
	}
	mutex_unlock(&ac97->page_mutex);
}
#endif

static void snd_ac97_proc_regs_read_main(struct snd_ac97 *ac97, struct snd_info_buffer *buffer, int subidx)
{
	int reg, val;

	for (reg = 0; reg < 0x80; reg += 2) {
		val = snd_ac97_read(ac97, reg);
		snd_iprintf(buffer, "%i:%02x = %04x\n", subidx, reg, val);
	}
}

static void snd_ac97_proc_regs_read(struct snd_info_entry *entry, 
				    struct snd_info_buffer *buffer)
{
	struct snd_ac97 *ac97 = entry->private_data;

	mutex_lock(&ac97->page_mutex);
	if ((ac97->id & 0xffffff40) == AC97_ID_AD1881) {	// Analog Devices AD1881/85/86

		int idx;
		for (idx = 0; idx < 3; idx++)
			if (ac97->spec.ad18xx.id[idx]) {
				/* select single codec */
				snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000,
						     ac97->spec.ad18xx.unchained[idx] | ac97->spec.ad18xx.chained[idx]);
				snd_ac97_proc_regs_read_main(ac97, buffer, idx);
			}
		/* select all codecs */
		snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000, 0x7000);
	} else {
		snd_ac97_proc_regs_read_main(ac97, buffer, 0);
	}	
	mutex_unlock(&ac97->page_mutex);
}

void snd_ac97_proc_init(struct snd_ac97 * ac97)
{
	struct snd_info_entry *entry;
	char name[32];
	const char *prefix;

	if (ac97->bus->proc == NULL)
		return;
	prefix = ac97_is_audio(ac97) ? "ac97" : "mc97";
	sprintf(name, "%s#%d-%d", prefix, ac97->addr, ac97->num);
	if ((entry = snd_info_create_card_entry(ac97->bus->card, name, ac97->bus->proc)) != NULL) {
		snd_info_set_text_ops(entry, ac97, snd_ac97_proc_read);
		if (snd_info_register(entry) < 0) {
			snd_info_free_entry(entry);
			entry = NULL;
		}
	}
	ac97->proc = entry;
	sprintf(name, "%s#%d-%d+regs", prefix, ac97->addr, ac97->num);
	if ((entry = snd_info_create_card_entry(ac97->bus->card, name, ac97->bus->proc)) != NULL) {
		snd_info_set_text_ops(entry, ac97, snd_ac97_proc_regs_read);
#ifdef CONFIG_SND_DEBUG
		entry->mode |= S_IWUSR;
		entry->c.text.write = snd_ac97_proc_regs_write;
#endif
		if (snd_info_register(entry) < 0) {
			snd_info_free_entry(entry);
			entry = NULL;
		}
	}
	ac97->proc_regs = entry;
}

void snd_ac97_proc_done(struct snd_ac97 * ac97)
{
	snd_info_free_entry(ac97->proc_regs);
	ac97->proc_regs = NULL;
	snd_info_free_entry(ac97->proc);
	ac97->proc = NULL;
}

void snd_ac97_bus_proc_init(struct snd_ac97_bus * bus)
{
	struct snd_info_entry *entry;
	char name[32];

	sprintf(name, "codec97#%d", bus->num);
	if ((entry = snd_info_create_card_entry(bus->card, name, bus->card->proc_root)) != NULL) {
		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
		if (snd_info_register(entry) < 0) {
			snd_info_free_entry(entry);
			entry = NULL;
		}
	}
	bus->proc = entry;
}

void snd_ac97_bus_proc_done(struct snd_ac97_bus * bus)
{
	snd_info_free_entry(bus->proc);
	bus->proc = NULL;
}
#ifndef _S390_SEMBUF_H
#define _S390_SEMBUF_H

/* 
 * The semid64_ds structure for S/390 architecture.
 * Note extra padding because this structure is passed back and forth
 * between kernel and user space.
 *
 * Pad space is left for:
 * - 64-bit time_t to solve y2038 problem (for !__s390x__)
 * - 2 miscellaneous 32-bit values
 */

struct semid64_ds {
	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
	__kernel_time_t	sem_otime;		/* last semop time */
#ifndef __s390x__
	unsigned long	__unused1;
#endif /* ! __s390x__ */
	__kernel_time_t	sem_ctime;		/* last change time */
#ifndef __s390x__
	unsigned long	__unused2;
#endif /* ! __s390x__ */
	unsigned long	sem_nsems;		/* no. of semaphores in array */
	unsigned long	__unused3;
	unsigned long	__unused4;
};

#endif /* _S390_SEMBUF_H */
cmd_kernel/rtmutex.o := gcc -Wp,-MD,kernel/.rtmutex.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(rtmutex)"  -D"KBUILD_MODNAME=KBUILD_STR(rtmutex)"  -c -o kernel/.tmp_rtmutex.o kernel/rtmutex.c

deps_kernel/rtmutex.o := \
  kernel/rtmutex.c \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/spinlock.h \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
    $(wildcard include/config/debug/lock/alloc.h) \
  include/linux/typecheck.h \
  include/linux/preempt.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
    $(wildcard include/config/paravirt.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/init.h \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/virt/cpu/accounting.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  include/linux/capability.h \
  include/linux/rbtree.h \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/prio_tree.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  kernel/rtmutex_common.h \
    $(wildcard include/config/rt/mutex/tester.h) \
  kernel/rtmutex.h \

kernel/rtmutex.o: $(deps_kernel/rtmutex.o)

$(deps_kernel/rtmutex.o):
/*
 * arch/arm/mach-at91/at91sam9263_devices.c
 *
 *  Copyright (C) 2007 Atmel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 */
#include <asm/mach/arch.h>
#include <asm/mach/map.h>

#include <linux/dma-mapping.h>
#include <linux/platform_device.h>
#include <linux/i2c-gpio.h>

#include <linux/fb.h>
#include <video/atmel_lcdc.h>

#include <mach/board.h>
#include <mach/gpio.h>
#include <mach/at91sam9263.h>
#include <mach/at91sam9263_matrix.h>
#include <mach/at91sam9_smc.h>

#include "generic.h"


/* --------------------------------------------------------------------
 *  USB Host
 * -------------------------------------------------------------------- */

#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
static u64 ohci_dmamask = DMA_BIT_MASK(32);
static struct at91_usbh_data usbh_data;

static struct resource usbh_resources[] = {
	[0] = {
		.start	= AT91SAM9263_UHP_BASE,
		.end	= AT91SAM9263_UHP_BASE + SZ_1M - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_UHP,
		.end	= AT91SAM9263_ID_UHP,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91_usbh_device = {
	.name		= "at91_ohci",
	.id		= -1,
	.dev		= {
				.dma_mask		= &ohci_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &usbh_data,
	},
	.resource	= usbh_resources,
	.num_resources	= ARRAY_SIZE(usbh_resources),
};

void __init at91_add_device_usbh(struct at91_usbh_data *data)
{
	int i;

	if (!data)
		return;

	/* Enable VBus control for UHP ports */
	for (i = 0; i < data->ports; i++) {
		if (data->vbus_pin[i])
			at91_set_gpio_output(data->vbus_pin[i], 0);
	}

	usbh_data = *data;
	platform_device_register(&at91_usbh_device);
}
#else
void __init at91_add_device_usbh(struct at91_usbh_data *data) {}
#endif


/* --------------------------------------------------------------------
 *  USB Device (Gadget)
 * -------------------------------------------------------------------- */

#ifdef CONFIG_USB_GADGET_AT91
static struct at91_udc_data udc_data;

static struct resource udc_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_UDP,
		.end	= AT91SAM9263_BASE_UDP + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_UDP,
		.end	= AT91SAM9263_ID_UDP,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91_udc_device = {
	.name		= "at91_udc",
	.id		= -1,
	.dev		= {
				.platform_data		= &udc_data,
	},
	.resource	= udc_resources,
	.num_resources	= ARRAY_SIZE(udc_resources),
};

void __init at91_add_device_udc(struct at91_udc_data *data)
{
	if (!data)
		return;

	if (data->vbus_pin) {
		at91_set_gpio_input(data->vbus_pin, 0);
		at91_set_deglitch(data->vbus_pin, 1);
	}

	/* Pullup pin is handled internally by USB device peripheral */

	udc_data = *data;
	platform_device_register(&at91_udc_device);
}
#else
void __init at91_add_device_udc(struct at91_udc_data *data) {}
#endif


/* --------------------------------------------------------------------
 *  Ethernet
 * -------------------------------------------------------------------- */

#if defined(CONFIG_MACB) || defined(CONFIG_MACB_MODULE)
static u64 eth_dmamask = DMA_BIT_MASK(32);
static struct at91_eth_data eth_data;

static struct resource eth_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_EMAC,
		.end	= AT91SAM9263_BASE_EMAC + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_EMAC,
		.end	= AT91SAM9263_ID_EMAC,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_eth_device = {
	.name		= "macb",
	.id		= -1,
	.dev		= {
				.dma_mask		= &eth_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &eth_data,
	},
	.resource	= eth_resources,
	.num_resources	= ARRAY_SIZE(eth_resources),
};

void __init at91_add_device_eth(struct at91_eth_data *data)
{
	if (!data)
		return;

	if (data->phy_irq_pin) {
		at91_set_gpio_input(data->phy_irq_pin, 0);
		at91_set_deglitch(data->phy_irq_pin, 1);
	}

	/* Pins used for MII and RMII */
	at91_set_A_periph(AT91_PIN_PE21, 0);	/* ETXCK_EREFCK */
	at91_set_B_periph(AT91_PIN_PC25, 0);	/* ERXDV */
	at91_set_A_periph(AT91_PIN_PE25, 0);	/* ERX0 */
	at91_set_A_periph(AT91_PIN_PE26, 0);	/* ERX1 */
	at91_set_A_periph(AT91_PIN_PE27, 0);	/* ERXER */
	at91_set_A_periph(AT91_PIN_PE28, 0);	/* ETXEN */
	at91_set_A_periph(AT91_PIN_PE23, 0);	/* ETX0 */
	at91_set_A_periph(AT91_PIN_PE24, 0);	/* ETX1 */
	at91_set_A_periph(AT91_PIN_PE30, 0);	/* EMDIO */
	at91_set_A_periph(AT91_PIN_PE29, 0);	/* EMDC */

	if (!data->is_rmii) {
		at91_set_A_periph(AT91_PIN_PE22, 0);	/* ECRS */
		at91_set_B_periph(AT91_PIN_PC26, 0);	/* ECOL */
		at91_set_B_periph(AT91_PIN_PC22, 0);	/* ERX2 */
		at91_set_B_periph(AT91_PIN_PC23, 0);	/* ERX3 */
		at91_set_B_periph(AT91_PIN_PC27, 0);	/* ERXCK */
		at91_set_B_periph(AT91_PIN_PC20, 0);	/* ETX2 */
		at91_set_B_periph(AT91_PIN_PC21, 0);	/* ETX3 */
		at91_set_B_periph(AT91_PIN_PC24, 0);	/* ETXER */
	}

	eth_data = *data;
	platform_device_register(&at91sam9263_eth_device);
}
#else
void __init at91_add_device_eth(struct at91_eth_data *data) {}
#endif


/* --------------------------------------------------------------------
 *  MMC / SD
 * -------------------------------------------------------------------- */

#if defined(CONFIG_MMC_AT91) || defined(CONFIG_MMC_AT91_MODULE)
static u64 mmc_dmamask = DMA_BIT_MASK(32);
static struct at91_mmc_data mmc0_data, mmc1_data;

static struct resource mmc0_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_MCI0,
		.end	= AT91SAM9263_BASE_MCI0 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_MCI0,
		.end	= AT91SAM9263_ID_MCI0,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_mmc0_device = {
	.name		= "at91_mci",
	.id		= 0,
	.dev		= {
				.dma_mask		= &mmc_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &mmc0_data,
	},
	.resource	= mmc0_resources,
	.num_resources	= ARRAY_SIZE(mmc0_resources),
};

static struct resource mmc1_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_MCI1,
		.end	= AT91SAM9263_BASE_MCI1 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_MCI1,
		.end	= AT91SAM9263_ID_MCI1,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_mmc1_device = {
	.name		= "at91_mci",
	.id		= 1,
	.dev		= {
				.dma_mask		= &mmc_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &mmc1_data,
	},
	.resource	= mmc1_resources,
	.num_resources	= ARRAY_SIZE(mmc1_resources),
};

void __init at91_add_device_mmc(short mmc_id, struct at91_mmc_data *data)
{
	if (!data)
		return;

	/* input/irq */
	if (data->det_pin) {
		at91_set_gpio_input(data->det_pin, 1);
		at91_set_deglitch(data->det_pin, 1);
	}
	if (data->wp_pin)
		at91_set_gpio_input(data->wp_pin, 1);
	if (data->vcc_pin)
		at91_set_gpio_output(data->vcc_pin, 0);

	if (mmc_id == 0) {		/* MCI0 */
		/* CLK */
		at91_set_A_periph(AT91_PIN_PA12, 0);

		if (data->slot_b) {
			/* CMD */
			at91_set_A_periph(AT91_PIN_PA16, 1);

			/* DAT0, maybe DAT1..DAT3 */
			at91_set_A_periph(AT91_PIN_PA17, 1);
			if (data->wire4) {
				at91_set_A_periph(AT91_PIN_PA18, 1);
				at91_set_A_periph(AT91_PIN_PA19, 1);
				at91_set_A_periph(AT91_PIN_PA20, 1);
			}
		} else {
			/* CMD */
			at91_set_A_periph(AT91_PIN_PA1, 1);

			/* DAT0, maybe DAT1..DAT3 */
			at91_set_A_periph(AT91_PIN_PA0, 1);
			if (data->wire4) {
				at91_set_A_periph(AT91_PIN_PA3, 1);
				at91_set_A_periph(AT91_PIN_PA4, 1);
				at91_set_A_periph(AT91_PIN_PA5, 1);
			}
		}

		mmc0_data = *data;
		at91_clock_associate("mci0_clk", &at91sam9263_mmc0_device.dev, "mci_clk");
		platform_device_register(&at91sam9263_mmc0_device);
	} else {			/* MCI1 */
		/* CLK */
		at91_set_A_periph(AT91_PIN_PA6, 0);

		if (data->slot_b) {
			/* CMD */
			at91_set_A_periph(AT91_PIN_PA21, 1);

			/* DAT0, maybe DAT1..DAT3 */
			at91_set_A_periph(AT91_PIN_PA22, 1);
			if (data->wire4) {
				at91_set_A_periph(AT91_PIN_PA23, 1);
				at91_set_A_periph(AT91_PIN_PA24, 1);
				at91_set_A_periph(AT91_PIN_PA25, 1);
			}
		} else {
			/* CMD */
			at91_set_A_periph(AT91_PIN_PA7, 1);

			/* DAT0, maybe DAT1..DAT3 */
			at91_set_A_periph(AT91_PIN_PA8, 1);
			if (data->wire4) {
				at91_set_A_periph(AT91_PIN_PA9, 1);
				at91_set_A_periph(AT91_PIN_PA10, 1);
				at91_set_A_periph(AT91_PIN_PA11, 1);
			}
		}

		mmc1_data = *data;
		at91_clock_associate("mci1_clk", &at91sam9263_mmc1_device.dev, "mci_clk");
		platform_device_register(&at91sam9263_mmc1_device);
	}
}
#else
void __init at91_add_device_mmc(short mmc_id, struct at91_mmc_data *data) {}
#endif

/* --------------------------------------------------------------------
 *  Compact Flash (PCMCIA or IDE)
 * -------------------------------------------------------------------- */

#if defined(CONFIG_AT91_CF) || defined(CONFIG_AT91_CF_MODULE) || \
    defined(CONFIG_BLK_DEV_IDE_AT91) || defined(CONFIG_BLK_DEV_IDE_AT91_MODULE)

static struct at91_cf_data cf0_data;

static struct resource cf0_resources[] = {
	[0] = {
		.start	= AT91_CHIPSELECT_4,
		.end	= AT91_CHIPSELECT_4 + SZ_256M - 1,
		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8AND16BIT,
	}
};

static struct platform_device cf0_device = {
	.id		= 0,
	.dev		= {
				.platform_data	= &cf0_data,
	},
	.resource	= cf0_resources,
	.num_resources	= ARRAY_SIZE(cf0_resources),
};

static struct at91_cf_data cf1_data;

static struct resource cf1_resources[] = {
	[0] = {
		.start	= AT91_CHIPSELECT_5,
		.end	= AT91_CHIPSELECT_5 + SZ_256M - 1,
		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8AND16BIT,
	}
};

static struct platform_device cf1_device = {
	.id		= 1,
	.dev		= {
				.platform_data	= &cf1_data,
	},
	.resource	= cf1_resources,
	.num_resources	= ARRAY_SIZE(cf1_resources),
};

void __init at91_add_device_cf(struct at91_cf_data *data)
{
	unsigned long ebi0_csa;
	struct platform_device *pdev;

	if (!data)
		return;

	/*
	 * assign CS4 or CS5 to SMC with Compact Flash logic support,
	 * we assume SMC timings are configured by board code,
	 * except True IDE where timings are controlled by driver
	 */
	ebi0_csa = at91_sys_read(AT91_MATRIX_EBI0CSA);
	switch (data->chipselect) {
	case 4:
		at91_set_A_periph(AT91_PIN_PD6, 0);  /* EBI0_NCS4/CFCS0 */
		ebi0_csa |= AT91_MATRIX_EBI0_CS4A_SMC_CF1;
		cf0_data = *data;
		pdev = &cf0_device;
		break;
	case 5:
		at91_set_A_periph(AT91_PIN_PD7, 0);  /* EBI0_NCS5/CFCS1 */
		ebi0_csa |= AT91_MATRIX_EBI0_CS5A_SMC_CF2;
		cf1_data = *data;
		pdev = &cf1_device;
		break;
	default:
		printk(KERN_ERR "AT91 CF: bad chip-select requested (%u)\n",
		       data->chipselect);
		return;
	}
	at91_sys_write(AT91_MATRIX_EBI0CSA, ebi0_csa);

	if (data->det_pin) {
		at91_set_gpio_input(data->det_pin, 1);
		at91_set_deglitch(data->det_pin, 1);
	}

	if (data->irq_pin) {
		at91_set_gpio_input(data->irq_pin, 1);
		at91_set_deglitch(data->irq_pin, 1);
	}

	if (data->vcc_pin)
		/* initially off */
		at91_set_gpio_output(data->vcc_pin, 0);

	/* enable EBI controlled pins */
	at91_set_A_periph(AT91_PIN_PD5, 1);  /* NWAIT */
	at91_set_A_periph(AT91_PIN_PD8, 0);  /* CFCE1 */
	at91_set_A_periph(AT91_PIN_PD9, 0);  /* CFCE2 */
	at91_set_A_periph(AT91_PIN_PD14, 0); /* CFNRW */

	pdev->name = (data->flags & AT91_CF_TRUE_IDE) ? "at91_ide" : "at91_cf";
	platform_device_register(pdev);
}
#else
void __init at91_add_device_cf(struct at91_cf_data *data) {}
#endif

/* --------------------------------------------------------------------
 *  NAND / SmartMedia
 * -------------------------------------------------------------------- */

#if defined(CONFIG_MTD_NAND_ATMEL) || defined(CONFIG_MTD_NAND_ATMEL_MODULE)
static struct atmel_nand_data nand_data;

#define NAND_BASE	AT91_CHIPSELECT_3

static struct resource nand_resources[] = {
	[0] = {
		.start	= NAND_BASE,
		.end	= NAND_BASE + SZ_256M - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91_BASE_SYS + AT91_ECC0,
		.end	= AT91_BASE_SYS + AT91_ECC0 + SZ_512 - 1,
		.flags	= IORESOURCE_MEM,
	}
};

static struct platform_device at91sam9263_nand_device = {
	.name		= "atmel_nand",
	.id		= -1,
	.dev		= {
				.platform_data	= &nand_data,
	},
	.resource	= nand_resources,
	.num_resources	= ARRAY_SIZE(nand_resources),
};

void __init at91_add_device_nand(struct atmel_nand_data *data)
{
	unsigned long csa;

	if (!data)
		return;

	csa = at91_sys_read(AT91_MATRIX_EBI0CSA);
	at91_sys_write(AT91_MATRIX_EBI0CSA, csa | AT91_MATRIX_EBI0_CS3A_SMC_SMARTMEDIA);

	/* enable pin */
	if (data->enable_pin)
		at91_set_gpio_output(data->enable_pin, 1);

	/* ready/busy pin */
	if (data->rdy_pin)
		at91_set_gpio_input(data->rdy_pin, 1);

	/* card detect pin */
	if (data->det_pin)
		at91_set_gpio_input(data->det_pin, 1);

	nand_data = *data;
	platform_device_register(&at91sam9263_nand_device);
}
#else
void __init at91_add_device_nand(struct atmel_nand_data *data) {}
#endif


/* --------------------------------------------------------------------
 *  TWI (i2c)
 * -------------------------------------------------------------------- */

/*
 * Prefer the GPIO code since the TWI controller isn't robust
 * (gets overruns and underruns under load) and can only issue
 * repeated STARTs in one scenario (the driver doesn't yet handle them).
 */
#if defined(CONFIG_I2C_GPIO) || defined(CONFIG_I2C_GPIO_MODULE)

static struct i2c_gpio_platform_data pdata = {
	.sda_pin		= AT91_PIN_PB4,
	.sda_is_open_drain	= 1,
	.scl_pin		= AT91_PIN_PB5,
	.scl_is_open_drain	= 1,
	.udelay			= 2,		/* ~100 kHz */
};

static struct platform_device at91sam9263_twi_device = {
	.name			= "i2c-gpio",
	.id			= -1,
	.dev.platform_data	= &pdata,
};

void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices)
{
	at91_set_GPIO_periph(AT91_PIN_PB4, 1);		/* TWD (SDA) */
	at91_set_multi_drive(AT91_PIN_PB4, 1);

	at91_set_GPIO_periph(AT91_PIN_PB5, 1);		/* TWCK (SCL) */
	at91_set_multi_drive(AT91_PIN_PB5, 1);

	i2c_register_board_info(0, devices, nr_devices);
	platform_device_register(&at91sam9263_twi_device);
}

#elif defined(CONFIG_I2C_AT91) || defined(CONFIG_I2C_AT91_MODULE)

static struct resource twi_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_TWI,
		.end	= AT91SAM9263_BASE_TWI + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_TWI,
		.end	= AT91SAM9263_ID_TWI,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_twi_device = {
	.name		= "at91_i2c",
	.id		= -1,
	.resource	= twi_resources,
	.num_resources	= ARRAY_SIZE(twi_resources),
};

void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices)
{
	/* pins used for TWI interface */
	at91_set_A_periph(AT91_PIN_PB4, 0);		/* TWD */
	at91_set_multi_drive(AT91_PIN_PB4, 1);

	at91_set_A_periph(AT91_PIN_PB5, 0);		/* TWCK */
	at91_set_multi_drive(AT91_PIN_PB5, 1);

	i2c_register_board_info(0, devices, nr_devices);
	platform_device_register(&at91sam9263_twi_device);
}
#else
void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices) {}
#endif


/* --------------------------------------------------------------------
 *  SPI
 * -------------------------------------------------------------------- */

#if defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)
static u64 spi_dmamask = DMA_BIT_MASK(32);

static struct resource spi0_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_SPI0,
		.end	= AT91SAM9263_BASE_SPI0 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_SPI0,
		.end	= AT91SAM9263_ID_SPI0,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_spi0_device = {
	.name		= "atmel_spi",
	.id		= 0,
	.dev		= {
				.dma_mask		= &spi_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
	},
	.resource	= spi0_resources,
	.num_resources	= ARRAY_SIZE(spi0_resources),
};

static const unsigned spi0_standard_cs[4] = { AT91_PIN_PA5, AT91_PIN_PA3, AT91_PIN_PA4, AT91_PIN_PB11 };

static struct resource spi1_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_SPI1,
		.end	= AT91SAM9263_BASE_SPI1 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_SPI1,
		.end	= AT91SAM9263_ID_SPI1,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_spi1_device = {
	.name		= "atmel_spi",
	.id		= 1,
	.dev		= {
				.dma_mask		= &spi_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
	},
	.resource	= spi1_resources,
	.num_resources	= ARRAY_SIZE(spi1_resources),
};

static const unsigned spi1_standard_cs[4] = { AT91_PIN_PB15, AT91_PIN_PB16, AT91_PIN_PB17, AT91_PIN_PB18 };

void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices)
{
	int i;
	unsigned long cs_pin;
	short enable_spi0 = 0;
	short enable_spi1 = 0;

	/* Choose SPI chip-selects */
	for (i = 0; i < nr_devices; i++) {
		if (devices[i].controller_data)
			cs_pin = (unsigned long) devices[i].controller_data;
		else if (devices[i].bus_num == 0)
			cs_pin = spi0_standard_cs[devices[i].chip_select];
		else
			cs_pin = spi1_standard_cs[devices[i].chip_select];

		if (devices[i].bus_num == 0)
			enable_spi0 = 1;
		else
			enable_spi1 = 1;

		/* enable chip-select pin */
		at91_set_gpio_output(cs_pin, 1);

		/* pass chip-select pin to driver */
		devices[i].controller_data = (void *) cs_pin;
	}

	spi_register_board_info(devices, nr_devices);

	/* Configure SPI bus(es) */
	if (enable_spi0) {
		at91_set_B_periph(AT91_PIN_PA0, 0);	/* SPI0_MISO */
		at91_set_B_periph(AT91_PIN_PA1, 0);	/* SPI0_MOSI */
		at91_set_B_periph(AT91_PIN_PA2, 0);	/* SPI0_SPCK */

		at91_clock_associate("spi0_clk", &at91sam9263_spi0_device.dev, "spi_clk");
		platform_device_register(&at91sam9263_spi0_device);
	}
	if (enable_spi1) {
		at91_set_A_periph(AT91_PIN_PB12, 0);	/* SPI1_MISO */
		at91_set_A_periph(AT91_PIN_PB13, 0);	/* SPI1_MOSI */
		at91_set_A_periph(AT91_PIN_PB14, 0);	/* SPI1_SPCK */

		at91_clock_associate("spi1_clk", &at91sam9263_spi1_device.dev, "spi_clk");
		platform_device_register(&at91sam9263_spi1_device);
	}
}
#else
void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices) {}
#endif


/* --------------------------------------------------------------------
 *  AC97
 * -------------------------------------------------------------------- */

#if defined(CONFIG_SND_ATMEL_AC97C) || defined(CONFIG_SND_ATMEL_AC97C_MODULE)
static u64 ac97_dmamask = DMA_BIT_MASK(32);
static struct ac97c_platform_data ac97_data;

static struct resource ac97_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_AC97C,
		.end	= AT91SAM9263_BASE_AC97C + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_AC97C,
		.end	= AT91SAM9263_ID_AC97C,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_ac97_device = {
	.name		= "atmel_ac97c",
	.id		= 0,
	.dev		= {
				.dma_mask		= &ac97_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &ac97_data,
	},
	.resource	= ac97_resources,
	.num_resources	= ARRAY_SIZE(ac97_resources),
};

void __init at91_add_device_ac97(struct ac97c_platform_data *data)
{
	if (!data)
		return;

	at91_set_A_periph(AT91_PIN_PB0, 0);	/* AC97FS */
	at91_set_A_periph(AT91_PIN_PB1, 0);	/* AC97CK */
	at91_set_A_periph(AT91_PIN_PB2, 0);	/* AC97TX */
	at91_set_A_periph(AT91_PIN_PB3, 0);	/* AC97RX */

	/* reset */
	if (data->reset_pin)
		at91_set_gpio_output(data->reset_pin, 0);

	ac97_data = *data;
	platform_device_register(&at91sam9263_ac97_device);
}
#else
void __init at91_add_device_ac97(struct ac97c_platform_data *data) {}
#endif

/* --------------------------------------------------------------------
 *  CAN Controller
 * -------------------------------------------------------------------- */

#if defined(CONFIG_CAN_AT91) || defined(CONFIG_CAN_AT91_MODULE)
static struct resource can_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_CAN,
		.end	= AT91SAM9263_BASE_CAN + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_CAN,
		.end	= AT91SAM9263_ID_CAN,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_can_device = {
	.name		= "at91_can",
	.id		= -1,
	.resource	= can_resources,
	.num_resources	= ARRAY_SIZE(can_resources),
};

void __init at91_add_device_can(struct at91_can_data *data)
{
	at91_set_A_periph(AT91_PIN_PA13, 0);	/* CANTX */
	at91_set_A_periph(AT91_PIN_PA14, 0);	/* CANRX */
	at91sam9263_can_device.dev.platform_data = data;

	platform_device_register(&at91sam9263_can_device);
}
#else
void __init at91_add_device_can(struct at91_can_data *data) {}
#endif

/* --------------------------------------------------------------------
 *  LCD Controller
 * -------------------------------------------------------------------- */

#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
static u64 lcdc_dmamask = DMA_BIT_MASK(32);
static struct atmel_lcdfb_info lcdc_data;

static struct resource lcdc_resources[] = {
	[0] = {
		.start	= AT91SAM9263_LCDC_BASE,
		.end	= AT91SAM9263_LCDC_BASE + SZ_4K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_LCDC,
		.end	= AT91SAM9263_ID_LCDC,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91_lcdc_device = {
	.name		= "atmel_lcdfb",
	.id		= 0,
	.dev		= {
				.dma_mask		= &lcdc_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &lcdc_data,
	},
	.resource	= lcdc_resources,
	.num_resources	= ARRAY_SIZE(lcdc_resources),
};

void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data)
{
	if (!data)
		return;

	at91_set_A_periph(AT91_PIN_PC1, 0);	/* LCDHSYNC */
	at91_set_A_periph(AT91_PIN_PC2, 0);	/* LCDDOTCK */
	at91_set_A_periph(AT91_PIN_PC3, 0);	/* LCDDEN */
	at91_set_B_periph(AT91_PIN_PB9, 0);	/* LCDCC */
	at91_set_A_periph(AT91_PIN_PC6, 0);	/* LCDD2 */
	at91_set_A_periph(AT91_PIN_PC7, 0);	/* LCDD3 */
	at91_set_A_periph(AT91_PIN_PC8, 0);	/* LCDD4 */
	at91_set_A_periph(AT91_PIN_PC9, 0);	/* LCDD5 */
	at91_set_A_periph(AT91_PIN_PC10, 0);	/* LCDD6 */
	at91_set_A_periph(AT91_PIN_PC11, 0);	/* LCDD7 */
	at91_set_A_periph(AT91_PIN_PC14, 0);	/* LCDD10 */
	at91_set_A_periph(AT91_PIN_PC15, 0);	/* LCDD11 */
	at91_set_A_periph(AT91_PIN_PC16, 0);	/* LCDD12 */
	at91_set_B_periph(AT91_PIN_PC12, 0);	/* LCDD13 */
	at91_set_A_periph(AT91_PIN_PC18, 0);	/* LCDD14 */
	at91_set_A_periph(AT91_PIN_PC19, 0);	/* LCDD15 */
	at91_set_A_periph(AT91_PIN_PC22, 0);	/* LCDD18 */
	at91_set_A_periph(AT91_PIN_PC23, 0);	/* LCDD19 */
	at91_set_A_periph(AT91_PIN_PC24, 0);	/* LCDD20 */
	at91_set_B_periph(AT91_PIN_PC17, 0);	/* LCDD21 */
	at91_set_A_periph(AT91_PIN_PC26, 0);	/* LCDD22 */
	at91_set_A_periph(AT91_PIN_PC27, 0);	/* LCDD23 */

	lcdc_data = *data;
	platform_device_register(&at91_lcdc_device);
}
#else
void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data) {}
#endif


/* --------------------------------------------------------------------
 *  Image Sensor Interface
 * -------------------------------------------------------------------- */

#if defined(CONFIG_VIDEO_AT91_ISI) || defined(CONFIG_VIDEO_AT91_ISI_MODULE)

struct resource isi_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_ISI,
		.end	= AT91SAM9263_BASE_ISI + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_ISI,
		.end	= AT91SAM9263_ID_ISI,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_isi_device = {
	.name		= "at91_isi",
	.id		= -1,
	.resource	= isi_resources,
	.num_resources	= ARRAY_SIZE(isi_resources),
};

void __init at91_add_device_isi(void)
{
	at91_set_A_periph(AT91_PIN_PE0, 0);	/* ISI_D0 */
	at91_set_A_periph(AT91_PIN_PE1, 0);	/* ISI_D1 */
	at91_set_A_periph(AT91_PIN_PE2, 0);	/* ISI_D2 */
	at91_set_A_periph(AT91_PIN_PE3, 0);	/* ISI_D3 */
	at91_set_A_periph(AT91_PIN_PE4, 0);	/* ISI_D4 */
	at91_set_A_periph(AT91_PIN_PE5, 0);	/* ISI_D5 */
	at91_set_A_periph(AT91_PIN_PE6, 0);	/* ISI_D6 */
	at91_set_A_periph(AT91_PIN_PE7, 0);	/* ISI_D7 */
	at91_set_A_periph(AT91_PIN_PE8, 0);	/* ISI_PCK */
	at91_set_A_periph(AT91_PIN_PE9, 0);	/* ISI_HSYNC */
	at91_set_A_periph(AT91_PIN_PE10, 0);	/* ISI_VSYNC */
	at91_set_B_periph(AT91_PIN_PE11, 0);	/* ISI_MCK (PCK3) */
	at91_set_B_periph(AT91_PIN_PE12, 0);	/* ISI_PD8 */
	at91_set_B_periph(AT91_PIN_PE13, 0);	/* ISI_PD9 */
	at91_set_B_periph(AT91_PIN_PE14, 0);	/* ISI_PD10 */
	at91_set_B_periph(AT91_PIN_PE15, 0);	/* ISI_PD11 */
}
#else
void __init at91_add_device_isi(void) {}
#endif


/* --------------------------------------------------------------------
 *  Timer/Counter block
 * -------------------------------------------------------------------- */

#ifdef CONFIG_ATMEL_TCLIB

static struct resource tcb_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_TCB0,
		.end	= AT91SAM9263_BASE_TCB0 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_TCB,
		.end	= AT91SAM9263_ID_TCB,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_tcb_device = {
	.name		= "atmel_tcb",
	.id		= 0,
	.resource	= tcb_resources,
	.num_resources	= ARRAY_SIZE(tcb_resources),
};

static void __init at91_add_device_tc(void)
{
	/* this chip has one clock and irq for all three TC channels */
	at91_clock_associate("tcb_clk", &at91sam9263_tcb_device.dev, "t0_clk");
	platform_device_register(&at91sam9263_tcb_device);
}
#else
static void __init at91_add_device_tc(void) { }
#endif


/* --------------------------------------------------------------------
 *  RTT
 * -------------------------------------------------------------------- */

static struct resource rtt0_resources[] = {
	{
		.start	= AT91_BASE_SYS + AT91_RTT0,
		.end	= AT91_BASE_SYS + AT91_RTT0 + SZ_16 - 1,
		.flags	= IORESOURCE_MEM,
	}
};

static struct platform_device at91sam9263_rtt0_device = {
	.name		= "at91_rtt",
	.id		= 0,
	.resource	= rtt0_resources,
	.num_resources	= ARRAY_SIZE(rtt0_resources),
};

static struct resource rtt1_resources[] = {
	{
		.start	= AT91_BASE_SYS + AT91_RTT1,
		.end	= AT91_BASE_SYS + AT91_RTT1 + SZ_16 - 1,
		.flags	= IORESOURCE_MEM,
	}
};

static struct platform_device at91sam9263_rtt1_device = {
	.name		= "at91_rtt",
	.id		= 1,
	.resource	= rtt1_resources,
	.num_resources	= ARRAY_SIZE(rtt1_resources),
};

static void __init at91_add_device_rtt(void)
{
	platform_device_register(&at91sam9263_rtt0_device);
	platform_device_register(&at91sam9263_rtt1_device);
}


/* --------------------------------------------------------------------
 *  Watchdog
 * -------------------------------------------------------------------- */

#if defined(CONFIG_AT91SAM9X_WATCHDOG) || defined(CONFIG_AT91SAM9X_WATCHDOG_MODULE)
static struct platform_device at91sam9263_wdt_device = {
	.name		= "at91_wdt",
	.id		= -1,
	.num_resources	= 0,
};

static void __init at91_add_device_watchdog(void)
{
	platform_device_register(&at91sam9263_wdt_device);
}
#else
static void __init at91_add_device_watchdog(void) {}
#endif


/* --------------------------------------------------------------------
 *  PWM
 * --------------------------------------------------------------------*/

#if defined(CONFIG_ATMEL_PWM)
static u32 pwm_mask;

static struct resource pwm_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_PWMC,
		.end	= AT91SAM9263_BASE_PWMC + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_PWMC,
		.end	= AT91SAM9263_ID_PWMC,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_pwm0_device = {
	.name	= "atmel_pwm",
	.id	= -1,
	.dev	= {
		.platform_data		= &pwm_mask,
	},
	.resource	= pwm_resources,
	.num_resources	= ARRAY_SIZE(pwm_resources),
};

void __init at91_add_device_pwm(u32 mask)
{
	if (mask & (1 << AT91_PWM0))
		at91_set_B_periph(AT91_PIN_PB7, 1);	/* enable PWM0 */

	if (mask & (1 << AT91_PWM1))
		at91_set_B_periph(AT91_PIN_PB8, 1);	/* enable PWM1 */

	if (mask & (1 << AT91_PWM2))
		at91_set_B_periph(AT91_PIN_PC29, 1);	/* enable PWM2 */

	if (mask & (1 << AT91_PWM3))
		at91_set_B_periph(AT91_PIN_PB29, 1);	/* enable PWM3 */

	pwm_mask = mask;

	platform_device_register(&at91sam9263_pwm0_device);
}
#else
void __init at91_add_device_pwm(u32 mask) {}
#endif


/* --------------------------------------------------------------------
 *  SSC -- Synchronous Serial Controller
 * -------------------------------------------------------------------- */

#if defined(CONFIG_ATMEL_SSC) || defined(CONFIG_ATMEL_SSC_MODULE)
static u64 ssc0_dmamask = DMA_BIT_MASK(32);

static struct resource ssc0_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_SSC0,
		.end	= AT91SAM9263_BASE_SSC0 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_SSC0,
		.end	= AT91SAM9263_ID_SSC0,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_ssc0_device = {
	.name	= "ssc",
	.id	= 0,
	.dev	= {
		.dma_mask		= &ssc0_dmamask,
		.coherent_dma_mask	= DMA_BIT_MASK(32),
	},
	.resource	= ssc0_resources,
	.num_resources	= ARRAY_SIZE(ssc0_resources),
};

static inline void configure_ssc0_pins(unsigned pins)
{
	if (pins & ATMEL_SSC_TF)
		at91_set_B_periph(AT91_PIN_PB0, 1);
	if (pins & ATMEL_SSC_TK)
		at91_set_B_periph(AT91_PIN_PB1, 1);
	if (pins & ATMEL_SSC_TD)
		at91_set_B_periph(AT91_PIN_PB2, 1);
	if (pins & ATMEL_SSC_RD)
		at91_set_B_periph(AT91_PIN_PB3, 1);
	if (pins & ATMEL_SSC_RK)
		at91_set_B_periph(AT91_PIN_PB4, 1);
	if (pins & ATMEL_SSC_RF)
		at91_set_B_periph(AT91_PIN_PB5, 1);
}

static u64 ssc1_dmamask = DMA_BIT_MASK(32);

static struct resource ssc1_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_SSC1,
		.end	= AT91SAM9263_BASE_SSC1 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_SSC1,
		.end	= AT91SAM9263_ID_SSC1,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct platform_device at91sam9263_ssc1_device = {
	.name	= "ssc",
	.id	= 1,
	.dev	= {
		.dma_mask		= &ssc1_dmamask,
		.coherent_dma_mask	= DMA_BIT_MASK(32),
	},
	.resource	= ssc1_resources,
	.num_resources	= ARRAY_SIZE(ssc1_resources),
};

static inline void configure_ssc1_pins(unsigned pins)
{
	if (pins & ATMEL_SSC_TF)
		at91_set_A_periph(AT91_PIN_PB6, 1);
	if (pins & ATMEL_SSC_TK)
		at91_set_A_periph(AT91_PIN_PB7, 1);
	if (pins & ATMEL_SSC_TD)
		at91_set_A_periph(AT91_PIN_PB8, 1);
	if (pins & ATMEL_SSC_RD)
		at91_set_A_periph(AT91_PIN_PB9, 1);
	if (pins & ATMEL_SSC_RK)
		at91_set_A_periph(AT91_PIN_PB10, 1);
	if (pins & ATMEL_SSC_RF)
		at91_set_A_periph(AT91_PIN_PB11, 1);
}

/*
 * SSC controllers are accessed through library code, instead of any
 * kind of all-singing/all-dancing driver.  For example one could be
 * used by a particular I2S audio codec's driver, while another one
 * on the same system might be used by a custom data capture driver.
 */
void __init at91_add_device_ssc(unsigned id, unsigned pins)
{
	struct platform_device *pdev;

	/*
	 * NOTE: caller is responsible for passing information matching
	 * "pins" to whatever will be using each particular controller.
	 */
	switch (id) {
	case AT91SAM9263_ID_SSC0:
		pdev = &at91sam9263_ssc0_device;
		configure_ssc0_pins(pins);
		at91_clock_associate("ssc0_clk", &pdev->dev, "pclk");
		break;
	case AT91SAM9263_ID_SSC1:
		pdev = &at91sam9263_ssc1_device;
		configure_ssc1_pins(pins);
		at91_clock_associate("ssc1_clk", &pdev->dev, "pclk");
		break;
	default:
		return;
	}

	platform_device_register(pdev);
}

#else
void __init at91_add_device_ssc(unsigned id, unsigned pins) {}
#endif


/* --------------------------------------------------------------------
 *  UART
 * -------------------------------------------------------------------- */

#if defined(CONFIG_SERIAL_ATMEL)

static struct resource dbgu_resources[] = {
	[0] = {
		.start	= AT91_VA_BASE_SYS + AT91_DBGU,
		.end	= AT91_VA_BASE_SYS + AT91_DBGU + SZ_512 - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91_ID_SYS,
		.end	= AT91_ID_SYS,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct atmel_uart_data dbgu_data = {
	.use_dma_tx	= 0,
	.use_dma_rx	= 0,		/* DBGU not capable of receive DMA */
	.regs		= (void __iomem *)(AT91_VA_BASE_SYS + AT91_DBGU),
};

static u64 dbgu_dmamask = DMA_BIT_MASK(32);

static struct platform_device at91sam9263_dbgu_device = {
	.name		= "atmel_usart",
	.id		= 0,
	.dev		= {
				.dma_mask		= &dbgu_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &dbgu_data,
	},
	.resource	= dbgu_resources,
	.num_resources	= ARRAY_SIZE(dbgu_resources),
};

static inline void configure_dbgu_pins(void)
{
	at91_set_A_periph(AT91_PIN_PC30, 0);		/* DRXD */
	at91_set_A_periph(AT91_PIN_PC31, 1);		/* DTXD */
}

static struct resource uart0_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_US0,
		.end	= AT91SAM9263_BASE_US0 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_US0,
		.end	= AT91SAM9263_ID_US0,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct atmel_uart_data uart0_data = {
	.use_dma_tx	= 1,
	.use_dma_rx	= 1,
};

static u64 uart0_dmamask = DMA_BIT_MASK(32);

static struct platform_device at91sam9263_uart0_device = {
	.name		= "atmel_usart",
	.id		= 1,
	.dev		= {
				.dma_mask		= &uart0_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &uart0_data,
	},
	.resource	= uart0_resources,
	.num_resources	= ARRAY_SIZE(uart0_resources),
};

static inline void configure_usart0_pins(unsigned pins)
{
	at91_set_A_periph(AT91_PIN_PA26, 1);		/* TXD0 */
	at91_set_A_periph(AT91_PIN_PA27, 0);		/* RXD0 */

	if (pins & ATMEL_UART_RTS)
		at91_set_A_periph(AT91_PIN_PA28, 0);	/* RTS0 */
	if (pins & ATMEL_UART_CTS)
		at91_set_A_periph(AT91_PIN_PA29, 0);	/* CTS0 */
}

static struct resource uart1_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_US1,
		.end	= AT91SAM9263_BASE_US1 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_US1,
		.end	= AT91SAM9263_ID_US1,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct atmel_uart_data uart1_data = {
	.use_dma_tx	= 1,
	.use_dma_rx	= 1,
};

static u64 uart1_dmamask = DMA_BIT_MASK(32);

static struct platform_device at91sam9263_uart1_device = {
	.name		= "atmel_usart",
	.id		= 2,
	.dev		= {
				.dma_mask		= &uart1_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &uart1_data,
	},
	.resource	= uart1_resources,
	.num_resources	= ARRAY_SIZE(uart1_resources),
};

static inline void configure_usart1_pins(unsigned pins)
{
	at91_set_A_periph(AT91_PIN_PD0, 1);		/* TXD1 */
	at91_set_A_periph(AT91_PIN_PD1, 0);		/* RXD1 */

	if (pins & ATMEL_UART_RTS)
		at91_set_B_periph(AT91_PIN_PD7, 0);	/* RTS1 */
	if (pins & ATMEL_UART_CTS)
		at91_set_B_periph(AT91_PIN_PD8, 0);	/* CTS1 */
}

static struct resource uart2_resources[] = {
	[0] = {
		.start	= AT91SAM9263_BASE_US2,
		.end	= AT91SAM9263_BASE_US2 + SZ_16K - 1,
		.flags	= IORESOURCE_MEM,
	},
	[1] = {
		.start	= AT91SAM9263_ID_US2,
		.end	= AT91SAM9263_ID_US2,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct atmel_uart_data uart2_data = {
	.use_dma_tx	= 1,
	.use_dma_rx	= 1,
};

static u64 uart2_dmamask = DMA_BIT_MASK(32);

static struct platform_device at91sam9263_uart2_device = {
	.name		= "atmel_usart",
	.id		= 3,
	.dev		= {
				.dma_mask		= &uart2_dmamask,
				.coherent_dma_mask	= DMA_BIT_MASK(32),
				.platform_data		= &uart2_data,
	},
	.resource	= uart2_resources,
	.num_resources	= ARRAY_SIZE(uart2_resources),
};

static inline void configure_usart2_pins(unsigned pins)
{
	at91_set_A_periph(AT91_PIN_PD2, 1);		/* TXD2 */
	at91_set_A_periph(AT91_PIN_PD3, 0);		/* RXD2 */

	if (pins & ATMEL_UART_RTS)
		at91_set_B_periph(AT91_PIN_PD5, 0);	/* RTS2 */
	if (pins & ATMEL_UART_CTS)
		at91_set_B_periph(AT91_PIN_PD6, 0);	/* CTS2 */
}

static struct platform_device *__initdata at91_uarts[ATMEL_MAX_UART];	/* the UARTs to use */
struct platform_device *atmel_default_console_device;	/* the serial console device */

void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins)
{
	struct platform_device *pdev;

	switch (id) {
		case 0:		/* DBGU */
			pdev = &at91sam9263_dbgu_device;
			configure_dbgu_pins();
			at91_clock_associate("mck", &pdev->dev, "usart");
			break;
		case AT91SAM9263_ID_US0:
			pdev = &at91sam9263_uart0_device;
			configure_usart0_pins(pins);
			at91_clock_associate("usart0_clk", &pdev->dev, "usart");
			break;
		case AT91SAM9263_ID_US1:
			pdev = &at91sam9263_uart1_device;
			configure_usart1_pins(pins);
			at91_clock_associate("usart1_clk", &pdev->dev, "usart");
			break;
		case AT91SAM9263_ID_US2:
			pdev = &at91sam9263_uart2_device;
			configure_usart2_pins(pins);
			at91_clock_associate("usart2_clk", &pdev->dev, "usart");
			break;
		default:
			return;
	}
	pdev->id = portnr;		/* update to mapped ID */

	if (portnr < ATMEL_MAX_UART)
		at91_uarts[portnr] = pdev;
}

void __init at91_set_serial_console(unsigned portnr)
{
	if (portnr < ATMEL_MAX_UART)
		atmel_default_console_device = at91_uarts[portnr];
}

void __init at91_add_device_serial(void)
{
	int i;

	for (i = 0; i < ATMEL_MAX_UART; i++) {
		if (at91_uarts[i])
			platform_device_register(at91_uarts[i]);
	}

	if (!atmel_default_console_device)
		printk(KERN_INFO "AT91: No default serial console defined.\n");
}
#else
void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins) {}
void __init at91_set_serial_console(unsigned portnr) {}
void __init at91_add_device_serial(void) {}
#endif


/* -------------------------------------------------------------------- */
/*
 * These devices are always present and don't need any board-specific
 * setup.
 */
static int __init at91_add_standard_devices(void)
{
	at91_add_device_rtt();
	at91_add_device_watchdog();
	at91_add_device_tc();
	return 0;
}

arch_initcall(at91_add_standard_devices);
cmd_drivers/net/wireless/zd1201.o := gcc -Wp,-MD,drivers/net/wireless/.zd1201.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(zd1201)"  -D"KBUILD_MODNAME=KBUILD_STR(zd1201)"  -c -o drivers/net/wireless/.tmp_zd1201.o drivers/net/wireless/zd1201.c

deps_drivers/net/wireless/zd1201.o := \
  drivers/net/wireless/zd1201.c \
    $(wildcard include/config/pm.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/usb.h \
    $(wildcard include/config/usb/devicefs.h) \
    $(wildcard include/config/usb/mon.h) \
    $(wildcard include/config/usb/device/class.h) \
    $(wildcard include/config/usb/suspend.h) \
  include/linux/mod_devicetable.h \
  include/linux/usb/ch9.h \
    $(wildcard include/config/size.h) \
    $(wildcard include/config/att/one.h) \
    $(wildcard include/config/att/selfpower.h) \
    $(wildcard include/config/att/wakeup.h) \
    $(wildcard include/config/att/battery.h) \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/irqreturn.h \
  include/linux/irqnr.h \
  include/linux/hardirq.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  include/linux/capability.h \
  include/linux/rbtree.h \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/prio_tree.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/path.h \
  include/linux/pid.h \
  include/linux/proportions.h \
  include/linux/percpu_counter.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rculist.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/s390.h) \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/radix-tree.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/tr.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/net/dsa/tag/dsa.h) \
    $(wildcard include/config/net/dsa/tag/trailer.h) \
    $(wildcard include/config/netpoll/trap.h) \
  include/linux/if.h \
  include/linux/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/socket.h \
  include/asm-generic/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sockios.h \
  include/asm-generic/sockios.h \
  include/linux/sockios.h \
  include/linux/hdlc/ioctl.h \
  include/linux/if_ether.h \
  include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/dma.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
  include/linux/kmemcheck.h \
  include/linux/net.h \
  include/linux/random.h \
  include/linux/ratelimit.h \
  include/linux/textsearch.h \
  include/net/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum_64.h \
  include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/disable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  include/linux/dma-attrs.h \
  include/linux/bug.h \
  include/linux/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/scatterlist.h \
  include/asm-generic/scatterlist.h \
    $(wildcard include/config/need/sg/dma/length.h) \
  include/linux/mm.h \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/dma-mapping.h \
    $(wildcard include/config/isa.h) \
  include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swiotlb.h \
    $(wildcard include/config/swiotlb.h) \
  include/linux/swiotlb.h \
  include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  include/asm-generic/dma-mapping-common.h \
  include/linux/if_packet.h \
  include/linux/if_link.h \
  include/linux/netlink.h \
  include/linux/pm_qos_params.h \
  include/linux/miscdevice.h \
  include/linux/major.h \
  include/linux/ethtool.h \
  include/net/net_namespace.h \
    $(wildcard include/config/ipv6.h) \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/wext/core.h) \
    $(wildcard include/config/net.h) \
  include/net/netns/core.h \
  include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  include/net/snmp.h \
  include/linux/snmp.h \
  include/linux/u64_stats_sync.h \
  include/net/netns/unix.h \
  include/net/netns/packet.h \
  include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  include/net/inet_frag.h \
  include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  include/net/dst_ops.h \
  include/net/netns/dccp.h \
  include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  include/linux/netfilter.h \
    $(wildcard include/config/netfilter/debug.h) \
    $(wildcard include/config/nf/nat/needed.h) \
  include/linux/in.h \
  include/linux/in6.h \
  include/net/flow.h \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
  include/linux/magic.h \
  include/net/netns/conntrack.h \
  include/linux/list_nulls.h \
  include/net/netns/xfrm.h \
  include/linux/xfrm.h \
  include/linux/seq_file_net.h \
  include/linux/seq_file.h \
  include/net/dsa.h \
  include/linux/etherdevice.h \
    $(wildcard include/config/have/efficient/unaligned/access.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unaligned.h \
  include/linux/unaligned/access_ok.h \
  include/linux/unaligned/generic.h \
  include/linux/wireless.h \
  include/linux/compat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/compat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user32.h \
  include/linux/ieee80211.h \
  include/net/iw_handler.h \
    $(wildcard include/config/wext/priv.h) \
  include/linux/if_arp.h \
  include/linux/firmware.h \
    $(wildcard include/config/fw/loader.h) \
  drivers/net/wireless/zd1201.h \

drivers/net/wireless/zd1201.o: $(deps_drivers/net/wireless/zd1201.o)

$(deps_drivers/net/wireless/zd1201.o):
#include <linux/module.h>
#include <linux/vermagic.h>
#include <linux/compiler.h>

MODULE_INFO(vermagic, VERMAGIC_STRING);

struct module __this_module
__attribute__((section(".gnu.linkonce.this_module"))) = {
 .name = KBUILD_MODNAME,
 .init = init_module,
#ifdef CONFIG_MODULE_UNLOAD
 .exit = cleanup_module,
#endif
 .arch = MODULE_ARCH_INIT,
};

static const struct modversion_info ____versions[]
__used
__attribute__((section("__versions"))) = {
	{ 0x81b768be, "module_layout" },
	{ 0xa90c928a, "param_ops_int" },
	{ 0xbef0eb60, "__pci_register_driver" },
	{ 0x49ba74af, "i2c_add_adapter" },
	{ 0x9edbecae, "snprintf" },
	{ 0x9882c648, "dev_printk" },
	{ 0xb2e3a6da, "_dev_info" },
	{ 0xa68d84ce, "pci_bus_write_config_word" },
	{ 0x15816351, "pci_bus_write_config_byte" },
	{ 0xef80660a, "pci_bus_read_config_byte" },
	{ 0x238aafc, "pci_bus_read_config_word" },
	{ 0x90a1601f, "dmi_check_system" },
	{ 0xca7b7a8, "acpi_check_region" },
	{ 0x1fedf0f4, "__request_region" },
	{ 0xf9a482f9, "msleep" },
	{ 0x44ee4115, "dev_err" },
	{ 0xfbfc1afd, "dev_warn" },
	{ 0x735a0bd5, "native_io_delay" },
	{ 0x7c61340c, "__release_region" },
	{ 0xff7559e4, "ioport_resource" },
	{ 0x72c4884, "i2c_del_adapter" },
	{ 0x45fafed8, "pci_unregister_driver" },
};

static const char __module_depends[]
__used
__attribute__((section(".modinfo"))) =
"depends=";

MODULE_ALIAS("pci:v00008086d00007113sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00008086d0000719Bsv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001055d00009463sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001002d00004353sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001002d00004363sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001002d00004372sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001002d00004385sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001022d0000780Bsv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001166d00000200sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001166d00000201sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001166d00000203sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001166d00000205sv*sd*bc*sc*i*");
MODULE_ALIAS("pci:v00001166d00000408sv*sd*bc*sc*i*");
/*
 * arch/arm/mach-ns9xxx/time-ns9360.c
 *
 * Copyright (C) 2006,2007 by Digi International Inc.
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 */
#include <linux/jiffies.h>
#include <linux/interrupt.h>
#include <linux/irq.h>
#include <linux/stringify.h>
#include <linux/clocksource.h>
#include <linux/clockchips.h>

#include <mach/processor-ns9360.h>
#include <mach/regs-sys-ns9360.h>
#include <mach/irqs.h>
#include <mach/system.h>
#include "generic.h"

#define TIMER_CLOCKSOURCE 0
#define TIMER_CLOCKEVENT 1
static u32 latch;

static cycle_t ns9360_clocksource_read(struct clocksource *cs)
{
	return __raw_readl(SYS_TR(TIMER_CLOCKSOURCE));
}

static struct clocksource ns9360_clocksource = {
	.name	= "ns9360-timer" __stringify(TIMER_CLOCKSOURCE),
	.rating	= 300,
	.read	= ns9360_clocksource_read,
	.mask	= CLOCKSOURCE_MASK(32),
	.shift	= 20,
	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
};

static void ns9360_clockevent_setmode(enum clock_event_mode mode,
		struct clock_event_device *clk)
{
	u32 tc = __raw_readl(SYS_TC(TIMER_CLOCKEVENT));

	switch (mode) {
	case CLOCK_EVT_MODE_PERIODIC:
		__raw_writel(latch, SYS_TRC(TIMER_CLOCKEVENT));
		REGSET(tc, SYS_TCx, REN, EN);
		REGSET(tc, SYS_TCx, INTS, EN);
		REGSET(tc, SYS_TCx, TEN, EN);
		break;

	case CLOCK_EVT_MODE_ONESHOT:
		REGSET(tc, SYS_TCx, REN, DIS);
		REGSET(tc, SYS_TCx, INTS, EN);

		/* fall through */

	case CLOCK_EVT_MODE_UNUSED:
	case CLOCK_EVT_MODE_SHUTDOWN:
	case CLOCK_EVT_MODE_RESUME:
	default:
		REGSET(tc, SYS_TCx, TEN, DIS);
		break;
	}

	__raw_writel(tc, SYS_TC(TIMER_CLOCKEVENT));
}

static int ns9360_clockevent_setnextevent(unsigned long evt,
		struct clock_event_device *clk)
{
	u32 tc = __raw_readl(SYS_TC(TIMER_CLOCKEVENT));

	if (REGGET(tc, SYS_TCx, TEN)) {
		REGSET(tc, SYS_TCx, TEN, DIS);
		__raw_writel(tc, SYS_TC(TIMER_CLOCKEVENT));
	}

	REGSET(tc, SYS_TCx, TEN, EN);

	__raw_writel(evt, SYS_TRC(TIMER_CLOCKEVENT));

	__raw_writel(tc, SYS_TC(TIMER_CLOCKEVENT));

	return 0;
}

static struct clock_event_device ns9360_clockevent_device = {
	.name		= "ns9360-timer" __stringify(TIMER_CLOCKEVENT),
	.shift		= 20,
	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
	.set_mode	= ns9360_clockevent_setmode,
	.set_next_event	= ns9360_clockevent_setnextevent,
};

static irqreturn_t ns9360_clockevent_handler(int irq, void *dev_id)
{
	int timerno = irq - IRQ_NS9360_TIMER0;
	u32 tc;

	struct clock_event_device *evt = &ns9360_clockevent_device;

	/* clear irq */
	tc = __raw_readl(SYS_TC(timerno));
	if (REGGET(tc, SYS_TCx, REN) == SYS_TCx_REN_DIS) {
		REGSET(tc, SYS_TCx, TEN, DIS);
		__raw_writel(tc, SYS_TC(timerno));
	}
	REGSET(tc, SYS_TCx, INTC, SET);
	__raw_writel(tc, SYS_TC(timerno));
	REGSET(tc, SYS_TCx, INTC, UNSET);
	__raw_writel(tc, SYS_TC(timerno));

	evt->event_handler(evt);

	return IRQ_HANDLED;
}

static struct irqaction ns9360_clockevent_action = {
	.name		= "ns9360-timer" __stringify(TIMER_CLOCKEVENT),
	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
	.handler	= ns9360_clockevent_handler,
};

static void __init ns9360_timer_init(void)
{
	int tc;

	tc = __raw_readl(SYS_TC(TIMER_CLOCKSOURCE));
	if (REGGET(tc, SYS_TCx, TEN)) {
		REGSET(tc, SYS_TCx, TEN, DIS);
		__raw_writel(tc, SYS_TC(TIMER_CLOCKSOURCE));
	}

	__raw_writel(0, SYS_TRC(TIMER_CLOCKSOURCE));

	REGSET(tc, SYS_TCx, TEN, EN);
	REGSET(tc, SYS_TCx, TDBG, STOP);
	REGSET(tc, SYS_TCx, TLCS, CPU);
	REGSET(tc, SYS_TCx, TM, IEE);
	REGSET(tc, SYS_TCx, INTS, DIS);
	REGSET(tc, SYS_TCx, UDS, UP);
	REGSET(tc, SYS_TCx, TSZ, 32);
	REGSET(tc, SYS_TCx, REN, EN);

	__raw_writel(tc, SYS_TC(TIMER_CLOCKSOURCE));

	ns9360_clocksource.mult = clocksource_hz2mult(ns9360_cpuclock(),
			ns9360_clocksource.shift);

	clocksource_register(&ns9360_clocksource);

	latch = SH_DIV(ns9360_cpuclock(), HZ, 0);

	tc = __raw_readl(SYS_TC(TIMER_CLOCKEVENT));
	REGSET(tc, SYS_TCx, TEN, DIS);
	REGSET(tc, SYS_TCx, TDBG, STOP);
	REGSET(tc, SYS_TCx, TLCS, CPU);
	REGSET(tc, SYS_TCx, TM, IEE);
	REGSET(tc, SYS_TCx, INTS, DIS);
	REGSET(tc, SYS_TCx, UDS, DOWN);
	REGSET(tc, SYS_TCx, TSZ, 32);
	REGSET(tc, SYS_TCx, REN, EN);
	__raw_writel(tc, SYS_TC(TIMER_CLOCKEVENT));

	ns9360_clockevent_device.mult = div_sc(ns9360_cpuclock(),
			NSEC_PER_SEC, ns9360_clockevent_device.shift);
	ns9360_clockevent_device.max_delta_ns =
		clockevent_delta2ns(-1, &ns9360_clockevent_device);
	ns9360_clockevent_device.min_delta_ns =
		clockevent_delta2ns(1, &ns9360_clockevent_device);

	ns9360_clockevent_device.cpumask = cpumask_of(0);
	clockevents_register_device(&ns9360_clockevent_device);

	setup_irq(IRQ_NS9360_TIMER0 + TIMER_CLOCKEVENT,
			&ns9360_clockevent_action);
}

struct sys_timer ns9360_timer = {
	.init = ns9360_timer_init,
};
/* linux/drivers/char/scx200_gpio.c

   National Semiconductor SCx200 GPIO driver.  Allows a user space
   process to play with the GPIO pins.

   Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com> */

#include <linux/device.h>
#include <linux/fs.h>
#include <linux/module.h>
#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <asm/uaccess.h>
#include <asm/io.h>

#include <linux/types.h>
#include <linux/cdev.h>

#include <linux/scx200_gpio.h>
#include <linux/nsc_gpio.h>

#define DRVNAME "scx200_gpio"

static struct platform_device *pdev;

MODULE_AUTHOR("Christer Weinigel <wingel@nano-system.com>");
MODULE_DESCRIPTION("NatSemi/AMD SCx200 GPIO Pin Driver");
MODULE_LICENSE("GPL");

static int major = 0;		/* default to dynamic major */
module_param(major, int, 0);
MODULE_PARM_DESC(major, "Major device number");

#define MAX_PINS 32		/* 64 later, when known ok */

struct nsc_gpio_ops scx200_gpio_ops = {
	.owner		= THIS_MODULE,
	.gpio_config	= scx200_gpio_configure,
	.gpio_dump	= nsc_gpio_dump,
	.gpio_get	= scx200_gpio_get,
	.gpio_set	= scx200_gpio_set,
	.gpio_change	= scx200_gpio_change,
	.gpio_current	= scx200_gpio_current
};
EXPORT_SYMBOL_GPL(scx200_gpio_ops);

static int scx200_gpio_open(struct inode *inode, struct file *file)
{
	unsigned m = iminor(inode);
	file->private_data = &scx200_gpio_ops;

	if (m >= MAX_PINS)
		return -EINVAL;
	return nonseekable_open(inode, file);
}

static int scx200_gpio_release(struct inode *inode, struct file *file)
{
	return 0;
}

static const struct file_operations scx200_gpio_fileops = {
	.owner   = THIS_MODULE,
	.write   = nsc_gpio_write,
	.read    = nsc_gpio_read,
	.open    = scx200_gpio_open,
	.release = scx200_gpio_release,
};

static struct cdev scx200_gpio_cdev;  /* use 1 cdev for all pins */

static int __init scx200_gpio_init(void)
{
	int rc;
	dev_t devid;

	if (!scx200_gpio_present()) {
		printk(KERN_ERR DRVNAME ": no SCx200 gpio present\n");
		return -ENODEV;
	}

	/* support dev_dbg() with pdev->dev */
	pdev = platform_device_alloc(DRVNAME, 0);
	if (!pdev)
		return -ENOMEM;

	rc = platform_device_add(pdev);
	if (rc)
		goto undo_malloc;

	/* nsc_gpio uses dev_dbg(), so needs this */
	scx200_gpio_ops.dev = &pdev->dev;

	if (major) {
		devid = MKDEV(major, 0);
		rc = register_chrdev_region(devid, MAX_PINS, "scx200_gpio");
	} else {
		rc = alloc_chrdev_region(&devid, 0, MAX_PINS, "scx200_gpio");
		major = MAJOR(devid);
	}
	if (rc < 0) {
		dev_err(&pdev->dev, "SCx200 chrdev_region err: %d\n", rc);
		goto undo_platform_device_add;
	}

	cdev_init(&scx200_gpio_cdev, &scx200_gpio_fileops);
	cdev_add(&scx200_gpio_cdev, devid, MAX_PINS);

	return 0; /* succeed */

undo_platform_device_add:
	platform_device_del(pdev);
undo_malloc:
	platform_device_put(pdev);

	return rc;
}

static void __exit scx200_gpio_cleanup(void)
{
	cdev_del(&scx200_gpio_cdev);
	/* cdev_put(&scx200_gpio_cdev); */

	unregister_chrdev_region(MKDEV(major, 0), MAX_PINS);
	platform_device_unregister(pdev);
}

module_init(scx200_gpio_init);
module_exit(scx200_gpio_cleanup);
#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/scsi_device.h>
#include <linux/usb.h>
#include <linux/slab.h>

#include "usb.h"
#include "transport.h"
#include "protocol.h"
#include "scsiglue.h"
#include "sierra_ms.h"
#include "debug.h"

#define SWIMS_USB_REQUEST_SetSwocMode	0x0B
#define SWIMS_USB_REQUEST_GetSwocInfo	0x0A
#define SWIMS_USB_INDEX_SetMode		0x0000
#define SWIMS_SET_MODE_Modem		0x0001

#define TRU_NORMAL 			0x01
#define TRU_FORCE_MS 			0x02
#define TRU_FORCE_MODEM 		0x03

static unsigned int swi_tru_install = 1;
module_param(swi_tru_install, uint, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(swi_tru_install, "TRU-Install mode (1=Full Logic (def),"
		 " 2=Force CD-Rom, 3=Force Modem)");

struct swoc_info {
	__u8 rev;
	__u8 reserved[8];
	__u16 LinuxSKU;
	__u16 LinuxVer;
	__u8 reserved2[47];
} __attribute__((__packed__));

static bool containsFullLinuxPackage(struct swoc_info *swocInfo)
{
	if ((swocInfo->LinuxSKU >= 0x2100 && swocInfo->LinuxSKU <= 0x2FFF) ||
	   (swocInfo->LinuxSKU >= 0x7100 && swocInfo->LinuxSKU <= 0x7FFF))
		return true;
	else
		return false;
}

static int sierra_set_ms_mode(struct usb_device *udev, __u16 eSWocMode)
{
	int result;
	US_DEBUGP("SWIMS: %s", "DEVICE MODE SWITCH\n");
	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
			SWIMS_USB_REQUEST_SetSwocMode,	/* __u8 request      */
			USB_TYPE_VENDOR | USB_DIR_OUT,	/* __u8 request type */
			eSWocMode,			/* __u16 value       */
			0x0000,				/* __u16 index       */
			NULL,				/* void *data        */
			0,				/* __u16 size 	     */
			USB_CTRL_SET_TIMEOUT);		/* int timeout       */
	return result;
}


static int sierra_get_swoc_info(struct usb_device *udev,
				struct swoc_info *swocInfo)
{
	int result;

	US_DEBUGP("SWIMS: Attempting to get TRU-Install info.\n");

	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
			SWIMS_USB_REQUEST_GetSwocInfo,	/* __u8 request      */
			USB_TYPE_VENDOR | USB_DIR_IN,	/* __u8 request type */
			0,				/* __u16 value       */
			0,				/* __u16 index       */
			(void *) swocInfo,		/* void *data        */
			sizeof(struct swoc_info),	/* __u16 size 	     */
			USB_CTRL_SET_TIMEOUT);		/* int timeout 	     */

	swocInfo->LinuxSKU = le16_to_cpu(swocInfo->LinuxSKU);
	swocInfo->LinuxVer = le16_to_cpu(swocInfo->LinuxVer);
	return result;
}

static void debug_swoc(struct swoc_info *swocInfo)
{
	US_DEBUGP("SWIMS: SWoC Rev: %02d \n", swocInfo->rev);
	US_DEBUGP("SWIMS: Linux SKU: %04X \n", swocInfo->LinuxSKU);
	US_DEBUGP("SWIMS: Linux Version: %04X \n", swocInfo->LinuxVer);
}


static ssize_t show_truinst(struct device *dev, struct device_attribute *attr,
			char *buf)
{
	struct swoc_info *swocInfo;
	struct usb_interface *intf = to_usb_interface(dev);
	struct usb_device *udev = interface_to_usbdev(intf);
	int result;
	if (swi_tru_install == TRU_FORCE_MS) {
		result = snprintf(buf, PAGE_SIZE, "Forced Mass Storage\n");
	} else {
		swocInfo = kmalloc(sizeof(struct swoc_info), GFP_KERNEL);
		if (!swocInfo) {
			US_DEBUGP("SWIMS: Allocation failure\n");
			snprintf(buf, PAGE_SIZE, "Error\n");
			return -ENOMEM;
		}
		result = sierra_get_swoc_info(udev, swocInfo);
		if (result < 0) {
			US_DEBUGP("SWIMS: failed SWoC query\n");
			kfree(swocInfo);
			snprintf(buf, PAGE_SIZE, "Error\n");
			return -EIO;
		}
		debug_swoc(swocInfo);
		result = snprintf(buf, PAGE_SIZE,
			"REV=%02d SKU=%04X VER=%04X\n",
			swocInfo->rev,
			swocInfo->LinuxSKU,
			swocInfo->LinuxVer);
		kfree(swocInfo);
	}
	return result;
}
static DEVICE_ATTR(truinst, S_IRUGO, show_truinst, NULL);

int sierra_ms_init(struct us_data *us)
{
	int result, retries;
	signed long delay_t;
	struct swoc_info *swocInfo;
	struct usb_device *udev;
	struct Scsi_Host *sh;
	struct scsi_device *sd;

	delay_t = 2;
	retries = 3;
	result = 0;
	udev = us->pusb_dev;

	sh = us_to_host(us);
	sd = scsi_get_host_dev(sh);

	US_DEBUGP("SWIMS: sierra_ms_init called\n");

	/* Force Modem mode */
	if (swi_tru_install == TRU_FORCE_MODEM) {
		US_DEBUGP("SWIMS: %s", "Forcing Modem Mode\n");
		result = sierra_set_ms_mode(udev, SWIMS_SET_MODE_Modem);
		if (result < 0)
			US_DEBUGP("SWIMS: Failed to switch to modem mode.\n");
		return -EIO;
	}
	/* Force Mass Storage mode (keep CD-Rom) */
	else if (swi_tru_install == TRU_FORCE_MS) {
		US_DEBUGP("SWIMS: %s", "Forcing Mass Storage Mode\n");
		goto complete;
	}
	/* Normal TRU-Install Logic */
	else {
		US_DEBUGP("SWIMS: %s", "Normal SWoC Logic\n");

		swocInfo = kmalloc(sizeof(struct swoc_info),
				GFP_KERNEL);
		if (!swocInfo) {
			US_DEBUGP("SWIMS: %s", "Allocation failure\n");
			return -ENOMEM;
		}

		retries = 3;
		do {
			retries--;
			result = sierra_get_swoc_info(udev, swocInfo);
			if (result < 0) {
				US_DEBUGP("SWIMS: %s", "Failed SWoC query\n");
				schedule_timeout_uninterruptible(2*HZ);
			}
		} while (retries && result < 0);

		if (result < 0) {
			US_DEBUGP("SWIMS: %s",
				  "Completely failed SWoC query\n");
			kfree(swocInfo);
			return -EIO;
		}

		debug_swoc(swocInfo);

		/* If there is not Linux software on the TRU-Install device
		 * then switch to modem mode
		 */
		if (!containsFullLinuxPackage(swocInfo)) {
			US_DEBUGP("SWIMS: %s",
				"Switching to Modem Mode\n");
			result = sierra_set_ms_mode(udev,
				SWIMS_SET_MODE_Modem);
			if (result < 0)
				US_DEBUGP("SWIMS: Failed to switch modem\n");
			kfree(swocInfo);
			return -EIO;
		}
		kfree(swocInfo);
	}
complete:
	result = device_create_file(&us->pusb_intf->dev, &dev_attr_truinst);

	return 0;
}

/*
 * This file adds the header file glue so that the shared files
 * flatdevicetree.[ch] can compile and work in the powerpc bootwrapper.
 *
 * strncmp & strchr copied from <file:lib/string.c>
 * Copyright (C) 1991, 1992  Linus Torvalds
 *
 * Maintained by: Mark A. Greer <mgreer@mvista.com>
 */
#ifndef _PPC_BOOT_FLATDEVTREE_ENV_H_
#define _PPC_BOOT_FLATDEVTREE_ENV_H_

#include <stdarg.h>
#include <stddef.h>
#include "types.h"
#include "string.h"
#include "stdio.h"
#include "ops.h"

#define be16_to_cpu(x)		(x)
#define cpu_to_be16(x)		(x)
#define be32_to_cpu(x)		(x)
#define cpu_to_be32(x)		(x)
#define be64_to_cpu(x)		(x)
#define cpu_to_be64(x)		(x)

#endif /* _PPC_BOOT_FLATDEVTREE_ENV_H_ */
/*
 *
 *  Copyright (C) 2005 Mike Isely <isely@pobox.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include "pvrusb2-context.h"
#include "pvrusb2-io.h"
#include "pvrusb2-ioread.h"
#include "pvrusb2-hdw.h"
#include "pvrusb2-debug.h"
#include <linux/wait.h>
#include <linux/kthread.h>
#include <linux/errno.h>
#include <linux/string.h>
#include <linux/slab.h>

static struct pvr2_context *pvr2_context_exist_first;
static struct pvr2_context *pvr2_context_exist_last;
static struct pvr2_context *pvr2_context_notify_first;
static struct pvr2_context *pvr2_context_notify_last;
static DEFINE_MUTEX(pvr2_context_mutex);
static DECLARE_WAIT_QUEUE_HEAD(pvr2_context_sync_data);
static DECLARE_WAIT_QUEUE_HEAD(pvr2_context_cleanup_data);
static int pvr2_context_cleanup_flag;
static int pvr2_context_cleaned_flag;
static struct task_struct *pvr2_context_thread_ptr;


static void pvr2_context_set_notify(struct pvr2_context *mp, int fl)
{
	int signal_flag = 0;
	mutex_lock(&pvr2_context_mutex);
	if (fl) {
		if (!mp->notify_flag) {
			signal_flag = (pvr2_context_notify_first == NULL);
			mp->notify_prev = pvr2_context_notify_last;
			mp->notify_next = NULL;
			pvr2_context_notify_last = mp;
			if (mp->notify_prev) {
				mp->notify_prev->notify_next = mp;
			} else {
				pvr2_context_notify_first = mp;
			}
			mp->notify_flag = !0;
		}
	} else {
		if (mp->notify_flag) {
			mp->notify_flag = 0;
			if (mp->notify_next) {
				mp->notify_next->notify_prev = mp->notify_prev;
			} else {
				pvr2_context_notify_last = mp->notify_prev;
			}
			if (mp->notify_prev) {
				mp->notify_prev->notify_next = mp->notify_next;
			} else {
				pvr2_context_notify_first = mp->notify_next;
			}
		}
	}
	mutex_unlock(&pvr2_context_mutex);
	if (signal_flag) wake_up(&pvr2_context_sync_data);
}


static void pvr2_context_destroy(struct pvr2_context *mp)
{
	pvr2_trace(PVR2_TRACE_CTXT,"pvr2_context %p (destroy)",mp);
	if (mp->hdw) pvr2_hdw_destroy(mp->hdw);
	pvr2_context_set_notify(mp, 0);
	mutex_lock(&pvr2_context_mutex);
	if (mp->exist_next) {
		mp->exist_next->exist_prev = mp->exist_prev;
	} else {
		pvr2_context_exist_last = mp->exist_prev;
	}
	if (mp->exist_prev) {
		mp->exist_prev->exist_next = mp->exist_next;
	} else {
		pvr2_context_exist_first = mp->exist_next;
	}
	if (!pvr2_context_exist_first) {
		/* Trigger wakeup on control thread in case it is waiting
		   for an exit condition. */
		wake_up(&pvr2_context_sync_data);
	}
	mutex_unlock(&pvr2_context_mutex);
	kfree(mp);
}


static void pvr2_context_notify(struct pvr2_context *mp)
{
	pvr2_context_set_notify(mp,!0);
}


static void pvr2_context_check(struct pvr2_context *mp)
{
	struct pvr2_channel *ch1, *ch2;
	pvr2_trace(PVR2_TRACE_CTXT,
		   "pvr2_context %p (notify)", mp);
	if (!mp->initialized_flag && !mp->disconnect_flag) {
		mp->initialized_flag = !0;
		pvr2_trace(PVR2_TRACE_CTXT,
			   "pvr2_context %p (initialize)", mp);
		/* Finish hardware initialization */
		if (pvr2_hdw_initialize(mp->hdw,
					(void (*)(void *))pvr2_context_notify,
					mp)) {
			mp->video_stream.stream =
				pvr2_hdw_get_video_stream(mp->hdw);
			/* Trigger interface initialization.  By doing this
			   here initialization runs in our own safe and
			   cozy thread context. */
			if (mp->setup_func) mp->setup_func(mp);
		} else {
			pvr2_trace(PVR2_TRACE_CTXT,
				   "pvr2_context %p (thread skipping setup)",
				   mp);
			/* Even though initialization did not succeed,
			   we're still going to continue anyway.  We need
			   to do this in order to await the expected
			   disconnect (which we will detect in the normal
			   course of operation). */
		}
	}

	for (ch1 = mp->mc_first; ch1; ch1 = ch2) {
		ch2 = ch1->mc_next;
		if (ch1->check_func) ch1->check_func(ch1);
	}

	if (mp->disconnect_flag && !mp->mc_first) {
		/* Go away... */
		pvr2_context_destroy(mp);
		return;
	}
}


static int pvr2_context_shutok(void)
{
	return pvr2_context_cleanup_flag && (pvr2_context_exist_first == NULL);
}


static int pvr2_context_thread_func(void *foo)
{
	struct pvr2_context *mp;

	pvr2_trace(PVR2_TRACE_CTXT,"pvr2_context thread start");

	do {
		while ((mp = pvr2_context_notify_first) != NULL) {
			pvr2_context_set_notify(mp, 0);
			pvr2_context_check(mp);
		}
		wait_event_interruptible(
			pvr2_context_sync_data,
			((pvr2_context_notify_first != NULL) ||
			 pvr2_context_shutok()));
	} while (!pvr2_context_shutok());

	pvr2_context_cleaned_flag = !0;
	wake_up(&pvr2_context_cleanup_data);

	pvr2_trace(PVR2_TRACE_CTXT,"pvr2_context thread cleaned up");

	wait_event_interruptible(
		pvr2_context_sync_data,
		kthread_should_stop());

	pvr2_trace(PVR2_TRACE_CTXT,"pvr2_context thread end");

	return 0;
}


int pvr2_context_global_init(void)
{
	pvr2_context_thread_ptr = kthread_run(pvr2_context_thread_func,
					      NULL,
					      "pvrusb2-context");
	return (pvr2_context_thread_ptr ? 0 : -ENOMEM);
}


void pvr2_context_global_done(void)
{
	pvr2_context_cleanup_flag = !0;
	wake_up(&pvr2_context_sync_data);
	wait_event_interruptible(
		pvr2_context_cleanup_data,
		pvr2_context_cleaned_flag);
	kthread_stop(pvr2_context_thread_ptr);
}


struct pvr2_context *pvr2_context_create(
	struct usb_interface *intf,
	const struct usb_device_id *devid,
	void (*setup_func)(struct pvr2_context *))
{
	struct pvr2_context *mp = NULL;
	mp = kzalloc(sizeof(*mp),GFP_KERNEL);
	if (!mp) goto done;
	pvr2_trace(PVR2_TRACE_CTXT,"pvr2_context %p (create)",mp);
	mp->setup_func = setup_func;
	mutex_init(&mp->mutex);
	mutex_lock(&pvr2_context_mutex);
	mp->exist_prev = pvr2_context_exist_last;
	mp->exist_next = NULL;
	pvr2_context_exist_last = mp;
	if (mp->exist_prev) {
		mp->exist_prev->exist_next = mp;
	} else {
		pvr2_context_exist_first = mp;
	}
	mutex_unlock(&pvr2_context_mutex);
	mp->hdw = pvr2_hdw_create(intf,devid);
	if (!mp->hdw) {
		pvr2_context_destroy(mp);
		mp = NULL;
		goto done;
	}
	pvr2_context_set_notify(mp, !0);
 done:
	return mp;
}


static void pvr2_context_reset_input_limits(struct pvr2_context *mp)
{
	unsigned int tmsk,mmsk;
	struct pvr2_channel *cp;
	struct pvr2_hdw *hdw = mp->hdw;
	mmsk = pvr2_hdw_get_input_available(hdw);
	tmsk = mmsk;
	for (cp = mp->mc_first; cp; cp = cp->mc_next) {
		if (!cp->input_mask) continue;
		tmsk &= cp->input_mask;
	}
	pvr2_hdw_set_input_allowed(hdw,mmsk,tmsk);
	pvr2_hdw_commit_ctl(hdw);
}


static void pvr2_context_enter(struct pvr2_context *mp)
{
	mutex_lock(&mp->mutex);
}


static void pvr2_context_exit(struct pvr2_context *mp)
{
	int destroy_flag = 0;
	if (!(mp->mc_first || !mp->disconnect_flag)) {
		destroy_flag = !0;
	}
	mutex_unlock(&mp->mutex);
	if (destroy_flag) pvr2_context_notify(mp);
}


void pvr2_context_disconnect(struct pvr2_context *mp)
{
	pvr2_hdw_disconnect(mp->hdw);
	mp->disconnect_flag = !0;
	pvr2_context_notify(mp);
}


void pvr2_channel_init(struct pvr2_channel *cp,struct pvr2_context *mp)
{
	pvr2_context_enter(mp);
	cp->hdw = mp->hdw;
	cp->mc_head = mp;
	cp->mc_next = NULL;
	cp->mc_prev = mp->mc_last;
	if (mp->mc_last) {
		mp->mc_last->mc_next = cp;
	} else {
		mp->mc_first = cp;
	}
	mp->mc_last = cp;
	pvr2_context_exit(mp);
}


static void pvr2_channel_disclaim_stream(struct pvr2_channel *cp)
{
	if (!cp->stream) return;
	pvr2_stream_kill(cp->stream->stream);
	cp->stream->user = NULL;
	cp->stream = NULL;
}


void pvr2_channel_done(struct pvr2_channel *cp)
{
	struct pvr2_context *mp = cp->mc_head;
	pvr2_context_enter(mp);
	cp->input_mask = 0;
	pvr2_channel_disclaim_stream(cp);
	pvr2_context_reset_input_limits(mp);
	if (cp->mc_next) {
		cp->mc_next->mc_prev = cp->mc_prev;
	} else {
		mp->mc_last = cp->mc_prev;
	}
	if (cp->mc_prev) {
		cp->mc_prev->mc_next = cp->mc_next;
	} else {
		mp->mc_first = cp->mc_next;
	}
	cp->hdw = NULL;
	pvr2_context_exit(mp);
}


int pvr2_channel_limit_inputs(struct pvr2_channel *cp,unsigned int cmsk)
{
	unsigned int tmsk,mmsk;
	int ret = 0;
	struct pvr2_channel *p2;
	struct pvr2_hdw *hdw = cp->hdw;

	mmsk = pvr2_hdw_get_input_available(hdw);
	cmsk &= mmsk;
	if (cmsk == cp->input_mask) {
		/* No change; nothing to do */
		return 0;
	}

	pvr2_context_enter(cp->mc_head);
	do {
		if (!cmsk) {
			cp->input_mask = 0;
			pvr2_context_reset_input_limits(cp->mc_head);
			break;
		}
		tmsk = mmsk;
		for (p2 = cp->mc_head->mc_first; p2; p2 = p2->mc_next) {
			if (p2 == cp) continue;
			if (!p2->input_mask) continue;
			tmsk &= p2->input_mask;
		}
		if (!(tmsk & cmsk)) {
			ret = -EPERM;
			break;
		}
		tmsk &= cmsk;
		if ((ret = pvr2_hdw_set_input_allowed(hdw,mmsk,tmsk)) != 0) {
			/* Internal failure changing allowed list; probably
			   should not happen, but react if it does. */
			break;
		}
		cp->input_mask = cmsk;
		pvr2_hdw_commit_ctl(hdw);
	} while (0);
	pvr2_context_exit(cp->mc_head);
	return ret;
}


unsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp)
{
	return cp->input_mask;
}


int pvr2_channel_claim_stream(struct pvr2_channel *cp,
			      struct pvr2_context_stream *sp)
{
	int code = 0;
	pvr2_context_enter(cp->mc_head); do {
		if (sp == cp->stream) break;
		if (sp && sp->user) {
			code = -EBUSY;
			break;
		}
		pvr2_channel_disclaim_stream(cp);
		if (!sp) break;
		sp->user = cp;
		cp->stream = sp;
	} while (0); pvr2_context_exit(cp->mc_head);
	return code;
}


// This is the marker for the real beginning of a legitimate mpeg2 stream.
static char stream_sync_key[] = {
	0x00, 0x00, 0x01, 0xba,
};

struct pvr2_ioread *pvr2_channel_create_mpeg_stream(
	struct pvr2_context_stream *sp)
{
	struct pvr2_ioread *cp;
	cp = pvr2_ioread_create();
	if (!cp) return NULL;
	pvr2_ioread_setup(cp,sp->stream);
	pvr2_ioread_set_sync_key(cp,stream_sync_key,sizeof(stream_sync_key));
	return cp;
}


/*
  Stuff for Emacs to see, in order to encourage consistent editing style:
  *** Local Variables: ***
  *** mode: c ***
  *** fill-column: 75 ***
  *** tab-width: 8 ***
  *** c-basic-offset: 8 ***
  *** End: ***
  */
/*
 * RTC subsystem, proc interface
 *
 * Copyright (C) 2005-06 Tower Technologies
 * Author: Alessandro Zummo <a.zummo@towertech.it>
 *
 * based on arch/arm/common/rtctime.c
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

#include <linux/module.h>
#include <linux/rtc.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>

#include "rtc-core.h"


static int rtc_proc_show(struct seq_file *seq, void *offset)
{
	int err;
	struct rtc_device *rtc = seq->private;
	const struct rtc_class_ops *ops = rtc->ops;
	struct rtc_wkalrm alrm;
	struct rtc_time tm;

	err = rtc_read_time(rtc, &tm);
	if (err == 0) {
		seq_printf(seq,
			"rtc_time\t: %02d:%02d:%02d\n"
			"rtc_date\t: %04d-%02d-%02d\n",
			tm.tm_hour, tm.tm_min, tm.tm_sec,
			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);
	}

	err = rtc_read_alarm(rtc, &alrm);
	if (err == 0) {
		seq_printf(seq, "alrm_time\t: ");
		if ((unsigned int)alrm.time.tm_hour <= 24)
			seq_printf(seq, "%02d:", alrm.time.tm_hour);
		else
			seq_printf(seq, "**:");
		if ((unsigned int)alrm.time.tm_min <= 59)
			seq_printf(seq, "%02d:", alrm.time.tm_min);
		else
			seq_printf(seq, "**:");
		if ((unsigned int)alrm.time.tm_sec <= 59)
			seq_printf(seq, "%02d\n", alrm.time.tm_sec);
		else
			seq_printf(seq, "**\n");

		seq_printf(seq, "alrm_date\t: ");
		if ((unsigned int)alrm.time.tm_year <= 200)
			seq_printf(seq, "%04d-", alrm.time.tm_year + 1900);
		else
			seq_printf(seq, "****-");
		if ((unsigned int)alrm.time.tm_mon <= 11)
			seq_printf(seq, "%02d-", alrm.time.tm_mon + 1);
		else
			seq_printf(seq, "**-");
		if (alrm.time.tm_mday && (unsigned int)alrm.time.tm_mday <= 31)
			seq_printf(seq, "%02d\n", alrm.time.tm_mday);
		else
			seq_printf(seq, "**\n");
		seq_printf(seq, "alarm_IRQ\t: %s\n",
				alrm.enabled ? "yes" : "no");
		seq_printf(seq, "alrm_pending\t: %s\n",
				alrm.pending ? "yes" : "no");
	}

	seq_printf(seq, "24hr\t\t: yes\n");

	if (ops->proc)
		ops->proc(rtc->dev.parent, seq);

	return 0;
}

static int rtc_proc_open(struct inode *inode, struct file *file)
{
	struct rtc_device *rtc = PDE(inode)->data;

	if (!try_module_get(THIS_MODULE))
		return -ENODEV;

	return single_open(file, rtc_proc_show, rtc);
}

static int rtc_proc_release(struct inode *inode, struct file *file)
{
	int res = single_release(inode, file);
	module_put(THIS_MODULE);
	return res;
}

static const struct file_operations rtc_proc_fops = {
	.open		= rtc_proc_open,
	.read		= seq_read,
	.llseek		= seq_lseek,
	.release	= rtc_proc_release,
};

void rtc_proc_add_device(struct rtc_device *rtc)
{
	if (rtc->id == 0)
		proc_create_data("driver/rtc", 0, NULL, &rtc_proc_fops, rtc);
}

void rtc_proc_del_device(struct rtc_device *rtc)
{
	if (rtc->id == 0)
		remove_proc_entry("driver/rtc", NULL);
}
/*
 * security/tomoyo/common.h
 *
 * Header file for TOMOYO.
 *
 * Copyright (C) 2005-2010  NTT DATA CORPORATION
 */

#ifndef _SECURITY_TOMOYO_COMMON_H
#define _SECURITY_TOMOYO_COMMON_H

#include <linux/ctype.h>
#include <linux/string.h>
#include <linux/mm.h>
#include <linux/file.h>
#include <linux/kmod.h>
#include <linux/fs.h>
#include <linux/sched.h>
#include <linux/namei.h>
#include <linux/mount.h>
#include <linux/list.h>
#include <linux/cred.h>
#include <linux/poll.h>
struct linux_binprm;

/********** Constants definitions. **********/

/*
 * TOMOYO uses this hash only when appending a string into the string
 * table. Frequency of appending strings is very low. So we don't need
 * large (e.g. 64k) hash size. 256 will be sufficient.
 */
#define TOMOYO_HASH_BITS  8
#define TOMOYO_MAX_HASH (1u<<TOMOYO_HASH_BITS)

#define TOMOYO_EXEC_TMPSIZE     4096

/* Profile number is an integer between 0 and 255. */
#define TOMOYO_MAX_PROFILES 256

enum tomoyo_mode_index {
	TOMOYO_CONFIG_DISABLED,
	TOMOYO_CONFIG_LEARNING,
	TOMOYO_CONFIG_PERMISSIVE,
	TOMOYO_CONFIG_ENFORCING,
	TOMOYO_CONFIG_USE_DEFAULT = 255
};

enum tomoyo_policy_id {
	TOMOYO_ID_GROUP,
	TOMOYO_ID_PATH_GROUP,
	TOMOYO_ID_NUMBER_GROUP,
	TOMOYO_ID_TRANSITION_CONTROL,
	TOMOYO_ID_AGGREGATOR,
	TOMOYO_ID_GLOBALLY_READABLE,
	TOMOYO_ID_PATTERN,
	TOMOYO_ID_NO_REWRITE,
	TOMOYO_ID_MANAGER,
	TOMOYO_ID_NAME,
	TOMOYO_ID_ACL,
	TOMOYO_ID_DOMAIN,
	TOMOYO_MAX_POLICY
};

enum tomoyo_group_id {
	TOMOYO_PATH_GROUP,
	TOMOYO_NUMBER_GROUP,
	TOMOYO_MAX_GROUP
};

/* Keywords for ACLs. */
#define TOMOYO_KEYWORD_AGGREGATOR                "aggregator "
#define TOMOYO_KEYWORD_ALLOW_MOUNT               "allow_mount "
#define TOMOYO_KEYWORD_ALLOW_READ                "allow_read "
#define TOMOYO_KEYWORD_DELETE                    "delete "
#define TOMOYO_KEYWORD_DENY_REWRITE              "deny_rewrite "
#define TOMOYO_KEYWORD_FILE_PATTERN              "file_pattern "
#define TOMOYO_KEYWORD_INITIALIZE_DOMAIN         "initialize_domain "
#define TOMOYO_KEYWORD_KEEP_DOMAIN               "keep_domain "
#define TOMOYO_KEYWORD_NO_INITIALIZE_DOMAIN      "no_initialize_domain "
#define TOMOYO_KEYWORD_NO_KEEP_DOMAIN            "no_keep_domain "
#define TOMOYO_KEYWORD_PATH_GROUP                "path_group "
#define TOMOYO_KEYWORD_NUMBER_GROUP              "number_group "
#define TOMOYO_KEYWORD_SELECT                    "select "
#define TOMOYO_KEYWORD_USE_PROFILE               "use_profile "
#define TOMOYO_KEYWORD_IGNORE_GLOBAL_ALLOW_READ  "ignore_global_allow_read"
#define TOMOYO_KEYWORD_QUOTA_EXCEEDED            "quota_exceeded"
#define TOMOYO_KEYWORD_TRANSITION_FAILED         "transition_failed"
/* A domain definition starts with <kernel>. */
#define TOMOYO_ROOT_NAME                         "<kernel>"
#define TOMOYO_ROOT_NAME_LEN                     (sizeof(TOMOYO_ROOT_NAME) - 1)

/* Value type definition. */
#define TOMOYO_VALUE_TYPE_INVALID     0
#define TOMOYO_VALUE_TYPE_DECIMAL     1
#define TOMOYO_VALUE_TYPE_OCTAL       2
#define TOMOYO_VALUE_TYPE_HEXADECIMAL 3

enum tomoyo_transition_type {
	/* Do not change this order, */
	TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE,
	TOMOYO_TRANSITION_CONTROL_INITIALIZE,
	TOMOYO_TRANSITION_CONTROL_NO_KEEP,
	TOMOYO_TRANSITION_CONTROL_KEEP,
	TOMOYO_MAX_TRANSITION_TYPE
};

/* Index numbers for Access Controls. */
enum tomoyo_acl_entry_type_index {
	TOMOYO_TYPE_PATH_ACL,
	TOMOYO_TYPE_PATH2_ACL,
	TOMOYO_TYPE_PATH_NUMBER_ACL,
	TOMOYO_TYPE_MKDEV_ACL,
	TOMOYO_TYPE_MOUNT_ACL,
};

/* Index numbers for File Controls. */

/*
 * TOMOYO_TYPE_READ_WRITE is special. TOMOYO_TYPE_READ_WRITE is automatically
 * set if both TOMOYO_TYPE_READ and TOMOYO_TYPE_WRITE are set.
 * Both TOMOYO_TYPE_READ and TOMOYO_TYPE_WRITE are automatically set if
 * TOMOYO_TYPE_READ_WRITE is set.
 * TOMOYO_TYPE_READ_WRITE is automatically cleared if either TOMOYO_TYPE_READ
 * or TOMOYO_TYPE_WRITE is cleared.
 * Both TOMOYO_TYPE_READ and TOMOYO_TYPE_WRITE are automatically cleared if
 * TOMOYO_TYPE_READ_WRITE is cleared.
 */

enum tomoyo_path_acl_index {
	TOMOYO_TYPE_READ_WRITE,
	TOMOYO_TYPE_EXECUTE,
	TOMOYO_TYPE_READ,
	TOMOYO_TYPE_WRITE,
	TOMOYO_TYPE_UNLINK,
	TOMOYO_TYPE_RMDIR,
	TOMOYO_TYPE_TRUNCATE,
	TOMOYO_TYPE_SYMLINK,
	TOMOYO_TYPE_REWRITE,
	TOMOYO_TYPE_CHROOT,
	TOMOYO_TYPE_UMOUNT,
	TOMOYO_MAX_PATH_OPERATION
};

#define TOMOYO_RW_MASK ((1 << TOMOYO_TYPE_READ) | (1 << TOMOYO_TYPE_WRITE))

enum tomoyo_mkdev_acl_index {
	TOMOYO_TYPE_MKBLOCK,
	TOMOYO_TYPE_MKCHAR,
	TOMOYO_MAX_MKDEV_OPERATION
};

enum tomoyo_path2_acl_index {
	TOMOYO_TYPE_LINK,
	TOMOYO_TYPE_RENAME,
	TOMOYO_TYPE_PIVOT_ROOT,
	TOMOYO_MAX_PATH2_OPERATION
};

enum tomoyo_path_number_acl_index {
	TOMOYO_TYPE_CREATE,
	TOMOYO_TYPE_MKDIR,
	TOMOYO_TYPE_MKFIFO,
	TOMOYO_TYPE_MKSOCK,
	TOMOYO_TYPE_IOCTL,
	TOMOYO_TYPE_CHMOD,
	TOMOYO_TYPE_CHOWN,
	TOMOYO_TYPE_CHGRP,
	TOMOYO_MAX_PATH_NUMBER_OPERATION
};

enum tomoyo_securityfs_interface_index {
	TOMOYO_DOMAINPOLICY,
	TOMOYO_EXCEPTIONPOLICY,
	TOMOYO_DOMAIN_STATUS,
	TOMOYO_PROCESS_STATUS,
	TOMOYO_MEMINFO,
	TOMOYO_SELFDOMAIN,
	TOMOYO_VERSION,
	TOMOYO_PROFILE,
	TOMOYO_QUERY,
	TOMOYO_MANAGER
};

enum tomoyo_mac_index {
	TOMOYO_MAC_FILE_EXECUTE,
	TOMOYO_MAC_FILE_OPEN,
	TOMOYO_MAC_FILE_CREATE,
	TOMOYO_MAC_FILE_UNLINK,
	TOMOYO_MAC_FILE_MKDIR,
	TOMOYO_MAC_FILE_RMDIR,
	TOMOYO_MAC_FILE_MKFIFO,
	TOMOYO_MAC_FILE_MKSOCK,
	TOMOYO_MAC_FILE_TRUNCATE,
	TOMOYO_MAC_FILE_SYMLINK,
	TOMOYO_MAC_FILE_REWRITE,
	TOMOYO_MAC_FILE_MKBLOCK,
	TOMOYO_MAC_FILE_MKCHAR,
	TOMOYO_MAC_FILE_LINK,
	TOMOYO_MAC_FILE_RENAME,
	TOMOYO_MAC_FILE_CHMOD,
	TOMOYO_MAC_FILE_CHOWN,
	TOMOYO_MAC_FILE_CHGRP,
	TOMOYO_MAC_FILE_IOCTL,
	TOMOYO_MAC_FILE_CHROOT,
	TOMOYO_MAC_FILE_MOUNT,
	TOMOYO_MAC_FILE_UMOUNT,
	TOMOYO_MAC_FILE_PIVOT_ROOT,
	TOMOYO_MAX_MAC_INDEX
};

enum tomoyo_mac_category_index {
	TOMOYO_MAC_CATEGORY_FILE,
	TOMOYO_MAX_MAC_CATEGORY_INDEX
};

#define TOMOYO_RETRY_REQUEST 1 /* Retry this request. */

/********** Structure definitions. **********/

/*
 * tomoyo_acl_head is a structure which is used for holding elements not in
 * domain policy.
 * It has following fields.
 *
 *  (1) "list" which is linked to tomoyo_policy_list[] .
 *  (2) "is_deleted" is a bool which is true if marked as deleted, false
 *      otherwise.
 */
struct tomoyo_acl_head {
	struct list_head list;
	bool is_deleted;
} __packed;

/*
 * tomoyo_request_info is a structure which is used for holding
 *
 * (1) Domain information of current process.
 * (2) How many retries are made for this request.
 * (3) Profile number used for this request.
 * (4) Access control mode of the profile.
 */
struct tomoyo_request_info {
	struct tomoyo_domain_info *domain;
	/* For holding parameters. */
	union {
		struct {
			const struct tomoyo_path_info *filename;
			/* For using wildcards at tomoyo_find_next_domain(). */
			const struct tomoyo_path_info *matched_path;
			u8 operation;
		} path;
		struct {
			const struct tomoyo_path_info *filename1;
			const struct tomoyo_path_info *filename2;
			u8 operation;
		} path2;
		struct {
			const struct tomoyo_path_info *filename;
			unsigned int mode;
			unsigned int major;
			unsigned int minor;
			u8 operation;
		} mkdev;
		struct {
			const struct tomoyo_path_info *filename;
			unsigned long number;
			u8 operation;
		} path_number;
		struct {
			const struct tomoyo_path_info *type;
			const struct tomoyo_path_info *dir;
			const struct tomoyo_path_info *dev;
			unsigned long flags;
			int need_dev;
		} mount;
	} param;
	u8 param_type;
	bool granted;
	u8 retry;
	u8 profile;
	u8 mode; /* One of tomoyo_mode_index . */
	u8 type;
};

/*
 * tomoyo_path_info is a structure which is used for holding a string data
 * used by TOMOYO.
 * This structure has several fields for supporting pattern matching.
 *
 * (1) "name" is the '\0' terminated string data.
 * (2) "hash" is full_name_hash(name, strlen(name)).
 *     This allows tomoyo_pathcmp() to compare by hash before actually compare
 *     using strcmp().
 * (3) "const_len" is the length of the initial segment of "name" which
 *     consists entirely of non wildcard characters. In other words, the length
 *     which we can compare two strings using strncmp().
 * (4) "is_dir" is a bool which is true if "name" ends with "/",
 *     false otherwise.
 *     TOMOYO distinguishes directory and non-directory. A directory ends with
 *     "/" and non-directory does not end with "/".
 * (5) "is_patterned" is a bool which is true if "name" contains wildcard
 *     characters, false otherwise. This allows TOMOYO to use "hash" and
 *     strcmp() for string comparison if "is_patterned" is false.
 */
struct tomoyo_path_info {
	const char *name;
	u32 hash;          /* = full_name_hash(name, strlen(name)) */
	u16 const_len;     /* = tomoyo_const_part_length(name)     */
	bool is_dir;       /* = tomoyo_strendswith(name, "/")      */
	bool is_patterned; /* = tomoyo_path_contains_pattern(name) */
};

/*
 * tomoyo_name is a structure which is used for linking
 * "struct tomoyo_path_info" into tomoyo_name_list .
 */
struct tomoyo_name {
	struct list_head list;
	atomic_t users;
	struct tomoyo_path_info entry;
};

struct tomoyo_name_union {
	const struct tomoyo_path_info *filename;
	struct tomoyo_group *group;
	u8 is_group;
};

struct tomoyo_number_union {
	unsigned long values[2];
	struct tomoyo_group *group;
	u8 min_type;
	u8 max_type;
	u8 is_group;
};

/* Structure for "path_group"/"number_group" directive. */
struct tomoyo_group {
	struct list_head list;
	const struct tomoyo_path_info *group_name;
	struct list_head member_list;
	atomic_t users;
};

/* Structure for "path_group" directive. */
struct tomoyo_path_group {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *member_name;
};

/* Structure for "number_group" directive. */
struct tomoyo_number_group {
	struct tomoyo_acl_head head;
	struct tomoyo_number_union number;
};

/*
 * tomoyo_acl_info is a structure which is used for holding
 *
 *  (1) "list" which is linked to the ->acl_info_list of
 *      "struct tomoyo_domain_info"
 *  (2) "is_deleted" is a bool which is true if this domain is marked as
 *      "deleted", false otherwise.
 *  (3) "type" which tells type of the entry.
 *
 * Packing "struct tomoyo_acl_info" allows
 * "struct tomoyo_path_acl" to embed "u16" and "struct tomoyo_path2_acl"
 * "struct tomoyo_path_number_acl" "struct tomoyo_mkdev_acl" to embed
 * "u8" without enlarging their structure size.
 */
struct tomoyo_acl_info {
	struct list_head list;
	bool is_deleted;
	u8 type; /* = one of values in "enum tomoyo_acl_entry_type_index". */
} __packed;

/*
 * tomoyo_domain_info is a structure which is used for holding permissions
 * (e.g. "allow_read /lib/libc-2.5.so") given to each domain.
 * It has following fields.
 *
 *  (1) "list" which is linked to tomoyo_domain_list .
 *  (2) "acl_info_list" which is linked to "struct tomoyo_acl_info".
 *  (3) "domainname" which holds the name of the domain.
 *  (4) "profile" which remembers profile number assigned to this domain.
 *  (5) "is_deleted" is a bool which is true if this domain is marked as
 *      "deleted", false otherwise.
 *  (6) "quota_warned" is a bool which is used for suppressing warning message
 *      when learning mode learned too much entries.
 *  (7) "ignore_global_allow_read" is a bool which is true if this domain
 *      should ignore "allow_read" directive in exception policy.
 *  (8) "transition_failed" is a bool which is set to true when this domain was
 *      unable to create a new domain at tomoyo_find_next_domain() because the
 *      name of the domain to be created was too long or it could not allocate
 *      memory. If set to true, more than one process continued execve()
 *      without domain transition.
 *  (9) "users" is an atomic_t that holds how many "struct cred"->security
 *      are referring this "struct tomoyo_domain_info". If is_deleted == true
 *      and users == 0, this struct will be kfree()d upon next garbage
 *      collection.
 *
 * A domain's lifecycle is an analogy of files on / directory.
 * Multiple domains with the same domainname cannot be created (as with
 * creating files with the same filename fails with -EEXIST).
 * If a process reached a domain, that process can reside in that domain after
 * that domain is marked as "deleted" (as with a process can access an already
 * open()ed file after that file was unlink()ed).
 */
struct tomoyo_domain_info {
	struct list_head list;
	struct list_head acl_info_list;
	/* Name of this domain. Never NULL.          */
	const struct tomoyo_path_info *domainname;
	u8 profile;        /* Profile number to use. */
	bool is_deleted;   /* Delete flag.           */
	bool quota_warned; /* Quota warnning flag.   */
	bool ignore_global_allow_read; /* Ignore "allow_read" flag. */
	bool transition_failed; /* Domain transition failed flag. */
	atomic_t users; /* Number of referring credentials. */
};

/*
 * tomoyo_path_acl is a structure which is used for holding an
 * entry with one pathname operation (e.g. open(), mkdir()).
 * It has following fields.
 *
 *  (1) "head" which is a "struct tomoyo_acl_info".
 *  (2) "perm" which is a bitmask of permitted operations.
 *  (3) "name" is the pathname.
 *
 * Directives held by this structure are "allow_read/write", "allow_execute",
 * "allow_read", "allow_write", "allow_unlink", "allow_rmdir",
 * "allow_truncate", "allow_symlink", "allow_rewrite", "allow_chroot" and
 * "allow_unmount".
 */
struct tomoyo_path_acl {
	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_PATH_ACL */
	u16 perm;
	struct tomoyo_name_union name;
};

/*
 * tomoyo_path_number_acl is a structure which is used for holding an
 * entry with one pathname and one number operation.
 * It has following fields.
 *
 *  (1) "head" which is a "struct tomoyo_acl_info".
 *  (2) "perm" which is a bitmask of permitted operations.
 *  (3) "name" is the pathname.
 *  (4) "number" is the numeric value.
 *
 * Directives held by this structure are "allow_create", "allow_mkdir",
 * "allow_ioctl", "allow_mkfifo", "allow_mksock", "allow_chmod", "allow_chown"
 * and "allow_chgrp".
 *
 */
struct tomoyo_path_number_acl {
	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_PATH_NUMBER_ACL */
	u8 perm;
	struct tomoyo_name_union name;
	struct tomoyo_number_union number;
};

/*
 * tomoyo_mkdev_acl is a structure which is used for holding an
 * entry with one pathname and three numbers operation.
 * It has following fields.
 *
 *  (1) "head" which is a "struct tomoyo_acl_info".
 *  (2) "perm" which is a bitmask of permitted operations.
 *  (3) "mode" is the create mode.
 *  (4) "major" is the major number of device node.
 *  (5) "minor" is the minor number of device node.
 *
 * Directives held by this structure are "allow_mkchar", "allow_mkblock".
 *
 */
struct tomoyo_mkdev_acl {
	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_MKDEV_ACL */
	u8 perm;
	struct tomoyo_name_union name;
	struct tomoyo_number_union mode;
	struct tomoyo_number_union major;
	struct tomoyo_number_union minor;
};

/*
 * tomoyo_path2_acl is a structure which is used for holding an
 * entry with two pathnames operation (i.e. link(), rename() and pivot_root()).
 * It has following fields.
 *
 *  (1) "head" which is a "struct tomoyo_acl_info".
 *  (2) "perm" which is a bitmask of permitted operations.
 *  (3) "name1" is the source/old pathname.
 *  (4) "name2" is the destination/new pathname.
 *
 * Directives held by this structure are "allow_rename", "allow_link" and
 * "allow_pivot_root".
 */
struct tomoyo_path2_acl {
	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_PATH2_ACL */
	u8 perm;
	struct tomoyo_name_union name1;
	struct tomoyo_name_union name2;
};

/*
 * tomoyo_mount_acl is a structure which is used for holding an
 * entry for mount operation.
 * It has following fields.
 *
 *  (1) "head" which is a "struct tomoyo_acl_info".
 *  (2) "dev_name" is the device name.
 *  (3) "dir_name" is the mount point.
 *  (4) "fs_type" is the filesystem type.
 *  (5) "flags" is the mount flags.
 *
 * Directive held by this structure is "allow_mount".
 */
struct tomoyo_mount_acl {
	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_MOUNT_ACL */
	struct tomoyo_name_union dev_name;
	struct tomoyo_name_union dir_name;
	struct tomoyo_name_union fs_type;
	struct tomoyo_number_union flags;
};

#define TOMOYO_MAX_IO_READ_QUEUE 32

/*
 * Structure for reading/writing policy via /sys/kernel/security/tomoyo
 * interfaces.
 */
struct tomoyo_io_buffer {
	void (*read) (struct tomoyo_io_buffer *);
	int (*write) (struct tomoyo_io_buffer *);
	int (*poll) (struct file *file, poll_table *wait);
	/* Exclusive lock for this structure.   */
	struct mutex io_sem;
	/* Index returned by tomoyo_read_lock(). */
	int reader_idx;
	char __user *read_user_buf;
	int read_user_buf_avail;
	struct {
		struct list_head *domain;
		struct list_head *group;
		struct list_head *acl;
		int avail;
		int step;
		int query_index;
		u16 index;
		u8 bit;
		u8 w_pos;
		bool eof;
		bool print_this_domain_only;
		bool print_execute_only;
		const char *w[TOMOYO_MAX_IO_READ_QUEUE];
	} r;
	/* The position currently writing to.   */
	struct tomoyo_domain_info *write_var1;
	/* Buffer for reading.                  */
	char *read_buf;
	/* Size of read buffer.                 */
	int readbuf_size;
	/* Buffer for writing.                  */
	char *write_buf;
	/* Bytes available for writing.         */
	int write_avail;
	/* Size of write buffer.                */
	int writebuf_size;
	/* Type of this interface.              */
	u8 type;
};

/*
 * tomoyo_readable_file is a structure which is used for holding
 * "allow_read" entries.
 * It has following fields.
 *
 *  (1) "head" is "struct tomoyo_acl_head".
 *  (2) "filename" is a pathname which is allowed to open(O_RDONLY).
 */
struct tomoyo_readable_file {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *filename;
};

/*
 * tomoyo_no_pattern is a structure which is used for holding
 * "file_pattern" entries.
 * It has following fields.
 *
 *  (1) "head" is "struct tomoyo_acl_head".
 *  (2) "pattern" is a pathname pattern which is used for converting pathnames
 *      to pathname patterns during learning mode.
 */
struct tomoyo_no_pattern {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *pattern;
};

/*
 * tomoyo_no_rewrite is a structure which is used for holding
 * "deny_rewrite" entries.
 * It has following fields.
 *
 *  (1) "head" is "struct tomoyo_acl_head".
 *  (2) "pattern" is a pathname which is by default not permitted to modify
 *      already existing content.
 */
struct tomoyo_no_rewrite {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *pattern;
};

/*
 * tomoyo_transition_control is a structure which is used for holding
 * "initialize_domain"/"no_initialize_domain"/"keep_domain"/"no_keep_domain"
 * entries.
 * It has following fields.
 *
 *  (1) "head" is "struct tomoyo_acl_head".
 *  (2) "type" is type of this entry.
 *  (3) "is_last_name" is a bool which is true if "domainname" is "the last
 *      component of a domainname", false otherwise.
 *  (4) "domainname" which is "a domainname" or "the last component of a
 *      domainname".
 *  (5) "program" which is a program's pathname.
 */
struct tomoyo_transition_control {
	struct tomoyo_acl_head head;
	u8 type; /* One of values in "enum tomoyo_transition_type".  */
	/* True if the domainname is tomoyo_get_last_name(). */
	bool is_last_name;
	const struct tomoyo_path_info *domainname; /* Maybe NULL */
	const struct tomoyo_path_info *program;    /* Maybe NULL */
};

/*
 * tomoyo_aggregator is a structure which is used for holding
 * "aggregator" entries.
 * It has following fields.
 *
 *  (1) "head" is "struct tomoyo_acl_head".
 *  (2) "original_name" which is originally requested name.
 *  (3) "aggregated_name" which is name to rewrite.
 */
struct tomoyo_aggregator {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *original_name;
	const struct tomoyo_path_info *aggregated_name;
};

/*
 * tomoyo_manager is a structure which is used for holding list of
 * domainnames or programs which are permitted to modify configuration via
 * /sys/kernel/security/tomoyo/ interface.
 * It has following fields.
 *
 *  (1) "head" is "struct tomoyo_acl_head".
 *  (2) "is_domain" is a bool which is true if "manager" is a domainname, false
 *      otherwise.
 *  (3) "manager" is a domainname or a program's pathname.
 */
struct tomoyo_manager {
	struct tomoyo_acl_head head;
	bool is_domain;  /* True if manager is a domainname. */
	/* A path to program or a domainname. */
	const struct tomoyo_path_info *manager;
};

struct tomoyo_preference {
	unsigned int learning_max_entry;
	bool enforcing_verbose;
	bool learning_verbose;
	bool permissive_verbose;
};

struct tomoyo_profile {
	const struct tomoyo_path_info *comment;
	struct tomoyo_preference *learning;
	struct tomoyo_preference *permissive;
	struct tomoyo_preference *enforcing;
	struct tomoyo_preference preference;
	u8 default_config;
	u8 config[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX];
};

/********** Function prototypes. **********/

/* Check whether the given string starts with the given keyword. */
bool tomoyo_str_starts(char **src, const char *find);
/* Get tomoyo_realpath() of current process. */
const char *tomoyo_get_exe(void);
/* Format string. */
void tomoyo_normalize_line(unsigned char *buffer);
/* Print warning or error message on console. */
void tomoyo_warn_log(struct tomoyo_request_info *r, const char *fmt, ...)
     __attribute__ ((format(printf, 2, 3)));
/* Check all profiles currently assigned to domains are defined. */
void tomoyo_check_profile(void);
/* Open operation for /sys/kernel/security/tomoyo/ interface. */
int tomoyo_open_control(const u8 type, struct file *file);
/* Close /sys/kernel/security/tomoyo/ interface. */
int tomoyo_close_control(struct file *file);
/* Poll operation for /sys/kernel/security/tomoyo/ interface. */
int tomoyo_poll_control(struct file *file, poll_table *wait);
/* Read operation for /sys/kernel/security/tomoyo/ interface. */
int tomoyo_read_control(struct file *file, char __user *buffer,
			const int buffer_len);
/* Write operation for /sys/kernel/security/tomoyo/ interface. */
int tomoyo_write_control(struct file *file, const char __user *buffer,
			 const int buffer_len);
/* Check whether the domain has too many ACL entries to hold. */
bool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r);
/* Print out of memory warning message. */
void tomoyo_warn_oom(const char *function);
/* Check whether the given name matches the given name_union. */
const struct tomoyo_path_info *
tomoyo_compare_name_union(const struct tomoyo_path_info *name,
			  const struct tomoyo_name_union *ptr);
/* Check whether the given number matches the given number_union. */
bool tomoyo_compare_number_union(const unsigned long value,
				 const struct tomoyo_number_union *ptr);
int tomoyo_get_mode(const u8 profile, const u8 index);
void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt, ...)
	__attribute__ ((format(printf, 2, 3)));
/* Check whether the domainname is correct. */
bool tomoyo_correct_domain(const unsigned char *domainname);
/* Check whether the token is correct. */
bool tomoyo_correct_path(const char *filename);
bool tomoyo_correct_word(const char *string);
/* Check whether the token can be a domainname. */
bool tomoyo_domain_def(const unsigned char *buffer);
bool tomoyo_parse_name_union(const char *filename,
			     struct tomoyo_name_union *ptr);
/* Check whether the given filename matches the given path_group. */
const struct tomoyo_path_info *
tomoyo_path_matches_group(const struct tomoyo_path_info *pathname,
			  const struct tomoyo_group *group);
/* Check whether the given value matches the given number_group. */
bool tomoyo_number_matches_group(const unsigned long min,
				 const unsigned long max,
				 const struct tomoyo_group *group);
/* Check whether the given filename matches the given pattern. */
bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,
				 const struct tomoyo_path_info *pattern);

bool tomoyo_parse_number_union(char *data, struct tomoyo_number_union *num);
/* Tokenize a line. */
bool tomoyo_tokenize(char *buffer, char *w[], size_t size);
/* Write domain policy violation warning message to console? */
bool tomoyo_verbose_mode(const struct tomoyo_domain_info *domain);
/* Fill "struct tomoyo_request_info". */
int tomoyo_init_request_info(struct tomoyo_request_info *r,
			     struct tomoyo_domain_info *domain,
			     const u8 index);
/* Check permission for mount operation. */
int tomoyo_mount_permission(char *dev_name, struct path *path, char *type,
			    unsigned long flags, void *data_page);
/* Create "aggregator" entry in exception policy. */
int tomoyo_write_aggregator(char *data, const bool is_delete);
int tomoyo_write_transition_control(char *data, const bool is_delete,
				    const u8 type);
/*
 * Create "allow_read/write", "allow_execute", "allow_read", "allow_write",
 * "allow_create", "allow_unlink", "allow_mkdir", "allow_rmdir",
 * "allow_mkfifo", "allow_mksock", "allow_mkblock", "allow_mkchar",
 * "allow_truncate", "allow_symlink", "allow_rewrite", "allow_rename" and
 * "allow_link" entry in domain policy.
 */
int tomoyo_write_file(char *data, struct tomoyo_domain_info *domain,
		      const bool is_delete);
/* Create "allow_read" entry in exception policy. */
int tomoyo_write_globally_readable(char *data, const bool is_delete);
/* Create "allow_mount" entry in domain policy. */
int tomoyo_write_mount(char *data, struct tomoyo_domain_info *domain,
		       const bool is_delete);
/* Create "deny_rewrite" entry in exception policy. */
int tomoyo_write_no_rewrite(char *data, const bool is_delete);
/* Create "file_pattern" entry in exception policy. */
int tomoyo_write_pattern(char *data, const bool is_delete);
/* Create "path_group"/"number_group" entry in exception policy. */
int tomoyo_write_group(char *data, const bool is_delete, const u8 type);
int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)
     __attribute__ ((format(printf, 2, 3)));
/* Find a domain by the given name. */
struct tomoyo_domain_info *tomoyo_find_domain(const char *domainname);
/* Find or create a domain by the given name. */
struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,
						const u8 profile);
struct tomoyo_profile *tomoyo_profile(const u8 profile);
/*
 * Allocate memory for "struct tomoyo_path_group"/"struct tomoyo_number_group".
 */
struct tomoyo_group *tomoyo_get_group(const char *group_name, const u8 type);

/* Check mode for specified functionality. */
unsigned int tomoyo_check_flags(const struct tomoyo_domain_info *domain,
				const u8 index);
/* Fill in "struct tomoyo_path_info" members. */
void tomoyo_fill_path_info(struct tomoyo_path_info *ptr);
/* Run policy loader when /sbin/init starts. */
void tomoyo_load_policy(const char *filename);

void tomoyo_put_number_union(struct tomoyo_number_union *ptr);

/* Convert binary string to ascii string. */
char *tomoyo_encode(const char *str);

/*
 * Returns realpath(3) of the given pathname except that
 * ignores chroot'ed root and does not follow the final symlink.
 */
char *tomoyo_realpath_nofollow(const char *pathname);
/*
 * Returns realpath(3) of the given pathname except that
 * ignores chroot'ed root and the pathname is already solved.
 */
char *tomoyo_realpath_from_path(struct path *path);
/* Get patterned pathname. */
const char *tomoyo_pattern(const struct tomoyo_path_info *filename);

/* Check memory quota. */
bool tomoyo_memory_ok(void *ptr);
void *tomoyo_commit_ok(void *data, const unsigned int size);

/*
 * Keep the given name on the RAM.
 * The RAM is shared, so NEVER try to modify or kfree() the returned name.
 */
const struct tomoyo_path_info *tomoyo_get_name(const char *name);

/* Check for memory usage. */
void tomoyo_read_memory_counter(struct tomoyo_io_buffer *head);

/* Set memory quota. */
int tomoyo_write_memory_quota(struct tomoyo_io_buffer *head);

/* Initialize mm related code. */
void __init tomoyo_mm_init(void);
int tomoyo_path_permission(struct tomoyo_request_info *r, u8 operation,
			   const struct tomoyo_path_info *filename);
int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,
				 struct path *path, const int flag);
int tomoyo_path_number_perm(const u8 operation, struct path *path,
			    unsigned long number);
int tomoyo_mkdev_perm(const u8 operation, struct path *path,
		      const unsigned int mode, unsigned int dev);
int tomoyo_path_perm(const u8 operation, struct path *path);
int tomoyo_path2_perm(const u8 operation, struct path *path1,
		      struct path *path2);
int tomoyo_find_next_domain(struct linux_binprm *bprm);

void tomoyo_print_ulong(char *buffer, const int buffer_len,
			const unsigned long value, const u8 type);

/* Drop refcount on tomoyo_name_union. */
void tomoyo_put_name_union(struct tomoyo_name_union *ptr);

/* Run garbage collector. */
void tomoyo_run_gc(void);

void tomoyo_memory_free(void *ptr);

int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,
			 bool is_delete, struct tomoyo_domain_info *domain,
			 bool (*check_duplicate) (const struct tomoyo_acl_info
						  *,
						  const struct tomoyo_acl_info
						  *),
			 bool (*merge_duplicate) (struct tomoyo_acl_info *,
						  struct tomoyo_acl_info *,
						  const bool));
int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,
			 bool is_delete, struct list_head *list,
			 bool (*check_duplicate) (const struct tomoyo_acl_head
						  *,
						  const struct tomoyo_acl_head
						  *));
void tomoyo_check_acl(struct tomoyo_request_info *r,
		      bool (*check_entry) (struct tomoyo_request_info *,
					   const struct tomoyo_acl_info *));

/********** External variable definitions. **********/

/* Lock for GC. */
extern struct srcu_struct tomoyo_ss;

/* The list for "struct tomoyo_domain_info". */
extern struct list_head tomoyo_domain_list;

extern struct list_head tomoyo_policy_list[TOMOYO_MAX_POLICY];
extern struct list_head tomoyo_group_list[TOMOYO_MAX_GROUP];
extern struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];

/* Lock for protecting policy. */
extern struct mutex tomoyo_policy_lock;

/* Has /sbin/init started? */
extern bool tomoyo_policy_loaded;

/* The kernel's domain. */
extern struct tomoyo_domain_info tomoyo_kernel_domain;

extern const char *tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION];
extern const char *tomoyo_mkdev_keyword[TOMOYO_MAX_MKDEV_OPERATION];
extern const char *tomoyo_path2_keyword[TOMOYO_MAX_PATH2_OPERATION];
extern const char *tomoyo_path_number_keyword[TOMOYO_MAX_PATH_NUMBER_OPERATION];

extern unsigned int tomoyo_quota_for_query;
extern unsigned int tomoyo_query_memory_size;

/********** Inlined functions. **********/

static inline int tomoyo_read_lock(void)
{
	return srcu_read_lock(&tomoyo_ss);
}

static inline void tomoyo_read_unlock(int idx)
{
	srcu_read_unlock(&tomoyo_ss, idx);
}

/* strcmp() for "struct tomoyo_path_info" structure. */
static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,
				  const struct tomoyo_path_info *b)
{
	return a->hash != b->hash || strcmp(a->name, b->name);
}

/**
 * tomoyo_valid - Check whether the character is a valid char.
 *
 * @c: The character to check.
 *
 * Returns true if @c is a valid character, false otherwise.
 */
static inline bool tomoyo_valid(const unsigned char c)
{
	return c > ' ' && c < 127;
}

/**
 * tomoyo_invalid - Check whether the character is an invalid char.
 *
 * @c: The character to check.
 *
 * Returns true if @c is an invalid character, false otherwise.
 */
static inline bool tomoyo_invalid(const unsigned char c)
{
	return c && (c <= ' ' || c >= 127);
}

static inline void tomoyo_put_name(const struct tomoyo_path_info *name)
{
	if (name) {
		struct tomoyo_name *ptr =
			container_of(name, typeof(*ptr), entry);
		atomic_dec(&ptr->users);
	}
}

static inline void tomoyo_put_group(struct tomoyo_group *group)
{
	if (group)
		atomic_dec(&group->users);
}

static inline struct tomoyo_domain_info *tomoyo_domain(void)
{
	return current_cred()->security;
}

static inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct
							    *task)
{
	return task_cred_xxx(task, security);
}

static inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *p1,
					   const struct tomoyo_acl_info *p2)
{
	return p1->type == p2->type;
}

static inline bool tomoyo_same_name_union
(const struct tomoyo_name_union *p1, const struct tomoyo_name_union *p2)
{
	return p1->filename == p2->filename && p1->group == p2->group &&
		p1->is_group == p2->is_group;
}

static inline bool tomoyo_same_number_union
(const struct tomoyo_number_union *p1, const struct tomoyo_number_union *p2)
{
	return p1->values[0] == p2->values[0] && p1->values[1] == p2->values[1]
		&& p1->group == p2->group && p1->min_type == p2->min_type &&
		p1->max_type == p2->max_type && p1->is_group == p2->is_group;
}

/**
 * list_for_each_cookie - iterate over a list with cookie.
 * @pos:        the &struct list_head to use as a loop cursor.
 * @head:       the head for your list.
 */
#define list_for_each_cookie(pos, head)					\
	if (!pos)							\
		pos =  srcu_dereference((head)->next, &tomoyo_ss);	\
	for ( ; pos != (head); pos = srcu_dereference(pos->next, &tomoyo_ss))

#endif /* !defined(_SECURITY_TOMOYO_COMMON_H) */
#ifndef _ASM_SCORE_FUTEX_H
#define _ASM_SCORE_FUTEX_H

#include <asm-generic/futex.h>

#endif /* _ASM_SCORE_FUTEX_H */
 /*
  * Copyright (c) 1997-2000 LAN Media Corporation (LMC)
  * All rights reserved.  www.lanmedia.com
  * Generic HDLC port Copyright (C) 2008 Krzysztof Halasa <khc@pm.waw.pl>
  *
  * This code is written by:
  * Andrew Stanley-Jones (asj@cban.com)
  * Rob Braun (bbraun@vix.com),
  * Michael Graff (explorer@vix.com) and
  * Matt Thomas (matt@3am-software.com).
  *
  * With Help By:
  * David Boggs
  * Ron Crane
  * Alan Cox
  *
  * This software may be used and distributed according to the terms
  * of the GNU General Public License version 2, incorporated herein by reference.
  *
  * Driver for the LanMedia LMC5200, LMC5245, LMC1000, LMC1200 cards.
  *
  * To control link specific options lmcctl is required.
  * It can be obtained from ftp.lanmedia.com.
  *
  * Linux driver notes:
  * Linux uses the device struct lmc_private to pass private information
  * arround.
  *
  * The initialization portion of this driver (the lmc_reset() and the
  * lmc_dec_reset() functions, as well as the led controls and the
  * lmc_initcsrs() functions.
  *
  * The watchdog function runs every second and checks to see if
  * we still have link, and that the timing source is what we expected
  * it to be.  If link is lost, the interface is marked down, and
  * we no longer can transmit.
  *
  */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/string.h>
#include <linux/timer.h>
#include <linux/ptrace.h>
#include <linux/errno.h>
#include <linux/ioport.h>
#include <linux/slab.h>
#include <linux/interrupt.h>
#include <linux/pci.h>
#include <linux/delay.h>
#include <linux/hdlc.h>
#include <linux/init.h>
#include <linux/in.h>
#include <linux/if_arp.h>
#include <linux/netdevice.h>
#include <linux/etherdevice.h>
#include <linux/skbuff.h>
#include <linux/inet.h>
#include <linux/bitops.h>
#include <asm/processor.h>             /* Processor type for cache alignment. */
#include <asm/io.h>
#include <asm/dma.h>
#include <asm/uaccess.h>
//#include <asm/spinlock.h>

#define DRIVER_MAJOR_VERSION     1
#define DRIVER_MINOR_VERSION    34
#define DRIVER_SUB_VERSION       0

#define DRIVER_VERSION  ((DRIVER_MAJOR_VERSION << 8) + DRIVER_MINOR_VERSION)

#include "lmc.h"
#include "lmc_var.h"
#include "lmc_ioctl.h"
#include "lmc_debug.h"
#include "lmc_proto.h"

static int LMC_PKT_BUF_SZ = 1542;

static DEFINE_PCI_DEVICE_TABLE(lmc_pci_tbl) = {
	{ PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_TULIP_FAST,
	  PCI_VENDOR_ID_LMC, PCI_ANY_ID },
	{ PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_TULIP_FAST,
	  PCI_ANY_ID, PCI_VENDOR_ID_LMC },
	{ 0 }
};

MODULE_DEVICE_TABLE(pci, lmc_pci_tbl);
MODULE_LICENSE("GPL v2");


static netdev_tx_t lmc_start_xmit(struct sk_buff *skb,
					struct net_device *dev);
static int lmc_rx (struct net_device *dev);
static int lmc_open(struct net_device *dev);
static int lmc_close(struct net_device *dev);
static struct net_device_stats *lmc_get_stats(struct net_device *dev);
static irqreturn_t lmc_interrupt(int irq, void *dev_instance);
static void lmc_initcsrs(lmc_softc_t * const sc, lmc_csrptr_t csr_base, size_t csr_size);
static void lmc_softreset(lmc_softc_t * const);
static void lmc_running_reset(struct net_device *dev);
static int lmc_ifdown(struct net_device * const);
static void lmc_watchdog(unsigned long data);
static void lmc_reset(lmc_softc_t * const sc);
static void lmc_dec_reset(lmc_softc_t * const sc);
static void lmc_driver_timeout(struct net_device *dev);

/*
 * linux reserves 16 device specific IOCTLs.  We call them
 * LMCIOC* to control various bits of our world.
 */
int lmc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd) /*fold00*/
{
    lmc_softc_t *sc = dev_to_sc(dev);
    lmc_ctl_t ctl;
    int ret = -EOPNOTSUPP;
    u16 regVal;
    unsigned long flags;

    lmc_trace(dev, "lmc_ioctl in");

    /*
     * Most functions mess with the structure
     * Disable interrupts while we do the polling
     */

    switch (cmd) {
        /*
         * Return current driver state.  Since we keep this up
         * To date internally, just copy this out to the user.
         */
    case LMCIOCGINFO: /*fold01*/
	if (copy_to_user(ifr->ifr_data, &sc->ictl, sizeof(lmc_ctl_t)))
		ret = -EFAULT;
	else
		ret = 0;
        break;

    case LMCIOCSINFO: /*fold01*/
        if (!capable(CAP_NET_ADMIN)) {
            ret = -EPERM;
            break;
        }

        if(dev->flags & IFF_UP){
            ret = -EBUSY;
            break;
        }

	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(lmc_ctl_t))) {
		ret = -EFAULT;
		break;
	}

	spin_lock_irqsave(&sc->lmc_lock, flags);
        sc->lmc_media->set_status (sc, &ctl);

        if(ctl.crc_length != sc->ictl.crc_length) {
            sc->lmc_media->set_crc_length(sc, ctl.crc_length);
	    if (sc->ictl.crc_length == LMC_CTL_CRC_LENGTH_16)
		sc->TxDescriptControlInit |=  LMC_TDES_ADD_CRC_DISABLE;
	    else
		sc->TxDescriptControlInit &= ~LMC_TDES_ADD_CRC_DISABLE;
        }
	spin_unlock_irqrestore(&sc->lmc_lock, flags);

        ret = 0;
        break;

    case LMCIOCIFTYPE: /*fold01*/
        {
	    u16 old_type = sc->if_type;
	    u16	new_type;

	    if (!capable(CAP_NET_ADMIN)) {
		ret = -EPERM;
		break;
	    }

	    if (copy_from_user(&new_type, ifr->ifr_data, sizeof(u16))) {
		ret = -EFAULT;
		break;
	    }

            
	    if (new_type == old_type)
	    {
		ret = 0 ;
		break;				/* no change */
            }
            
	    spin_lock_irqsave(&sc->lmc_lock, flags);
            lmc_proto_close(sc);

            sc->if_type = new_type;
            lmc_proto_attach(sc);
	    ret = lmc_proto_open(sc);
	    spin_unlock_irqrestore(&sc->lmc_lock, flags);
	    break;
	}

    case LMCIOCGETXINFO: /*fold01*/
	spin_lock_irqsave(&sc->lmc_lock, flags);
        sc->lmc_xinfo.Magic0 = 0xBEEFCAFE;

        sc->lmc_xinfo.PciCardType = sc->lmc_cardtype;
        sc->lmc_xinfo.PciSlotNumber = 0;
        sc->lmc_xinfo.DriverMajorVersion = DRIVER_MAJOR_VERSION;
        sc->lmc_xinfo.DriverMinorVersion = DRIVER_MINOR_VERSION;
        sc->lmc_xinfo.DriverSubVersion = DRIVER_SUB_VERSION;
        sc->lmc_xinfo.XilinxRevisionNumber =
            lmc_mii_readreg (sc, 0, 3) & 0xf;
        sc->lmc_xinfo.MaxFrameSize = LMC_PKT_BUF_SZ;
        sc->lmc_xinfo.link_status = sc->lmc_media->get_link_status (sc);
        sc->lmc_xinfo.mii_reg16 = lmc_mii_readreg (sc, 0, 16);
	spin_unlock_irqrestore(&sc->lmc_lock, flags);

        sc->lmc_xinfo.Magic1 = 0xDEADBEEF;

        if (copy_to_user(ifr->ifr_data, &sc->lmc_xinfo,
			 sizeof(struct lmc_xinfo)))
		ret = -EFAULT;
	else
		ret = 0;

        break;

    case LMCIOCGETLMCSTATS:
	    spin_lock_irqsave(&sc->lmc_lock, flags);
	    if (sc->lmc_cardtype == LMC_CARDTYPE_T1) {
		    lmc_mii_writereg(sc, 0, 17, T1FRAMER_FERR_LSB);
		    sc->extra_stats.framingBitErrorCount +=
			    lmc_mii_readreg(sc, 0, 18) & 0xff;
		    lmc_mii_writereg(sc, 0, 17, T1FRAMER_FERR_MSB);
		    sc->extra_stats.framingBitErrorCount +=
			    (lmc_mii_readreg(sc, 0, 18) & 0xff) << 8;
		    lmc_mii_writereg(sc, 0, 17, T1FRAMER_LCV_LSB);
		    sc->extra_stats.lineCodeViolationCount +=
			    lmc_mii_readreg(sc, 0, 18) & 0xff;
		    lmc_mii_writereg(sc, 0, 17, T1FRAMER_LCV_MSB);
		    sc->extra_stats.lineCodeViolationCount +=
			    (lmc_mii_readreg(sc, 0, 18) & 0xff) << 8;
		    lmc_mii_writereg(sc, 0, 17, T1FRAMER_AERR);
		    regVal = lmc_mii_readreg(sc, 0, 18) & 0xff;

		    sc->extra_stats.lossOfFrameCount +=
			    (regVal & T1FRAMER_LOF_MASK) >> 4;
		    sc->extra_stats.changeOfFrameAlignmentCount +=
			    (regVal & T1FRAMER_COFA_MASK) >> 2;
		    sc->extra_stats.severelyErroredFrameCount +=
			    regVal & T1FRAMER_SEF_MASK;
	    }
	    spin_unlock_irqrestore(&sc->lmc_lock, flags);
	    if (copy_to_user(ifr->ifr_data, &sc->lmc_device->stats,
			     sizeof(sc->lmc_device->stats)) ||
		copy_to_user(ifr->ifr_data + sizeof(sc->lmc_device->stats),
			     &sc->extra_stats, sizeof(sc->extra_stats)))
		    ret = -EFAULT;
	    else
		    ret = 0;
	    break;

    case LMCIOCCLEARLMCSTATS:
	    if (!capable(CAP_NET_ADMIN)) {
		    ret = -EPERM;
		    break;
	    }

	    spin_lock_irqsave(&sc->lmc_lock, flags);
	    memset(&sc->lmc_device->stats, 0, sizeof(sc->lmc_device->stats));
	    memset(&sc->extra_stats, 0, sizeof(sc->extra_stats));
	    sc->extra_stats.check = STATCHECK;
	    sc->extra_stats.version_size = (DRIVER_VERSION << 16) +
		    sizeof(sc->lmc_device->stats) + sizeof(sc->extra_stats);
	    sc->extra_stats.lmc_cardtype = sc->lmc_cardtype;
	    spin_unlock_irqrestore(&sc->lmc_lock, flags);
	    ret = 0;
	    break;

    case LMCIOCSETCIRCUIT: /*fold01*/
        if (!capable(CAP_NET_ADMIN)){
            ret = -EPERM;
            break;
        }

        if(dev->flags & IFF_UP){
            ret = -EBUSY;
            break;
        }

	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(lmc_ctl_t))) {
		ret = -EFAULT;
		break;
	}
	spin_lock_irqsave(&sc->lmc_lock, flags);
        sc->lmc_media->set_circuit_type(sc, ctl.circuit_type);
        sc->ictl.circuit_type = ctl.circuit_type;
	spin_unlock_irqrestore(&sc->lmc_lock, flags);
        ret = 0;

        break;

    case LMCIOCRESET: /*fold01*/
        if (!capable(CAP_NET_ADMIN)){
            ret = -EPERM;
            break;
        }

	spin_lock_irqsave(&sc->lmc_lock, flags);
        /* Reset driver and bring back to current state */
        printk (" REG16 before reset +%04x\n", lmc_mii_readreg (sc, 0, 16));
        lmc_running_reset (dev);
        printk (" REG16 after reset +%04x\n", lmc_mii_readreg (sc, 0, 16));

        LMC_EVENT_LOG(LMC_EVENT_FORCEDRESET, LMC_CSR_READ (sc, csr_status), lmc_mii_readreg (sc, 0, 16));
	spin_unlock_irqrestore(&sc->lmc_lock, flags);

        ret = 0;
        break;

#ifdef DEBUG
    case LMCIOCDUMPEVENTLOG:
	if (copy_to_user(ifr->ifr_data, &lmcEventLogIndex, sizeof(u32))) {
		ret = -EFAULT;
		break;
	}
	if (copy_to_user(ifr->ifr_data + sizeof(u32), lmcEventLogBuf,
			 sizeof(lmcEventLogBuf)))
		ret = -EFAULT;
	else
		ret = 0;

        break;
#endif /* end ifdef _DBG_EVENTLOG */
    case LMCIOCT1CONTROL: /*fold01*/
        if (sc->lmc_cardtype != LMC_CARDTYPE_T1){
            ret = -EOPNOTSUPP;
            break;
        }
        break;
    case LMCIOCXILINX: /*fold01*/
        {
            struct lmc_xilinx_control xc; /*fold02*/

            if (!capable(CAP_NET_ADMIN)){
                ret = -EPERM;
                break;
            }

            /*
             * Stop the xwitter whlie we restart the hardware
             */
            netif_stop_queue(dev);

	    if (copy_from_user(&xc, ifr->ifr_data, sizeof(struct lmc_xilinx_control))) {
		ret = -EFAULT;
		break;
	    }
            switch(xc.command){
            case lmc_xilinx_reset: /*fold02*/
                {
                    u16 mii;
		    spin_lock_irqsave(&sc->lmc_lock, flags);
                    mii = lmc_mii_readreg (sc, 0, 16);

                    /*
                     * Make all of them 0 and make input
                     */
                    lmc_gpio_mkinput(sc, 0xff);

                    /*
                     * make the reset output
                     */
                    lmc_gpio_mkoutput(sc, LMC_GEP_RESET);

                    /*
                     * RESET low to force configuration.  This also forces
                     * the transmitter clock to be internal, but we expect to reset
                     * that later anyway.
                     */

                    sc->lmc_gpio &= ~LMC_GEP_RESET;
                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);


                    /*
                     * hold for more than 10 microseconds
                     */
                    udelay(50);

                    sc->lmc_gpio |= LMC_GEP_RESET;
                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);


                    /*
                     * stop driving Xilinx-related signals
                     */
                    lmc_gpio_mkinput(sc, 0xff);

                    /* Reset the frammer hardware */
                    sc->lmc_media->set_link_status (sc, 1);
                    sc->lmc_media->set_status (sc, NULL);
//                    lmc_softreset(sc);

                    {
                        int i;
                        for(i = 0; i < 5; i++){
                            lmc_led_on(sc, LMC_DS3_LED0);
                            mdelay(100);
                            lmc_led_off(sc, LMC_DS3_LED0);
                            lmc_led_on(sc, LMC_DS3_LED1);
                            mdelay(100);
                            lmc_led_off(sc, LMC_DS3_LED1);
                            lmc_led_on(sc, LMC_DS3_LED3);
                            mdelay(100);
                            lmc_led_off(sc, LMC_DS3_LED3);
                            lmc_led_on(sc, LMC_DS3_LED2);
                            mdelay(100);
                            lmc_led_off(sc, LMC_DS3_LED2);
                        }
                    }
		    spin_unlock_irqrestore(&sc->lmc_lock, flags);
                    
                    

                    ret = 0x0;

                }

                break;
            case lmc_xilinx_load_prom: /*fold02*/
                {
                    u16 mii;
                    int timeout = 500000;
		    spin_lock_irqsave(&sc->lmc_lock, flags);
                    mii = lmc_mii_readreg (sc, 0, 16);

                    /*
                     * Make all of them 0 and make input
                     */
                    lmc_gpio_mkinput(sc, 0xff);

                    /*
                     * make the reset output
                     */
                    lmc_gpio_mkoutput(sc,  LMC_GEP_DP | LMC_GEP_RESET);

                    /*
                     * RESET low to force configuration.  This also forces
                     * the transmitter clock to be internal, but we expect to reset
                     * that later anyway.
                     */

                    sc->lmc_gpio &= ~(LMC_GEP_RESET | LMC_GEP_DP);
                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);


                    /*
                     * hold for more than 10 microseconds
                     */
                    udelay(50);

                    sc->lmc_gpio |= LMC_GEP_DP | LMC_GEP_RESET;
                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

                    /*
                     * busy wait for the chip to reset
                     */
                    while( (LMC_CSR_READ(sc, csr_gp) & LMC_GEP_INIT) == 0 &&
                           (timeout-- > 0))
                        cpu_relax();


                    /*
                     * stop driving Xilinx-related signals
                     */
                    lmc_gpio_mkinput(sc, 0xff);
		    spin_unlock_irqrestore(&sc->lmc_lock, flags);

                    ret = 0x0;
                    

                    break;

                }

            case lmc_xilinx_load: /*fold02*/
                {
                    char *data;
                    int pos;
                    int timeout = 500000;

                    if (!xc.data) {
                            ret = -EINVAL;
                            break;
                    }

                    data = kmalloc(xc.len, GFP_KERNEL);
                    if (!data) {
                            printk(KERN_WARNING "%s: Failed to allocate memory for copy\n", dev->name);
                            ret = -ENOMEM;
                            break;
                    }
                    
                    if(copy_from_user(data, xc.data, xc.len))
                    {
                    	kfree(data);
                    	ret = -ENOMEM;
                    	break;
                    }

                    printk("%s: Starting load of data Len: %d at 0x%p == 0x%p\n", dev->name, xc.len, xc.data, data);

		    spin_lock_irqsave(&sc->lmc_lock, flags);
                    lmc_gpio_mkinput(sc, 0xff);

                    /*
                     * Clear the Xilinx and start prgramming from the DEC
                     */

                    /*
                     * Set ouput as:
                     * Reset: 0 (active)
                     * DP:    0 (active)
                     * Mode:  1
                     *
                     */
                    sc->lmc_gpio = 0x00;
                    sc->lmc_gpio &= ~LMC_GEP_DP;
                    sc->lmc_gpio &= ~LMC_GEP_RESET;
                    sc->lmc_gpio |=  LMC_GEP_MODE;
                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

                    lmc_gpio_mkoutput(sc, LMC_GEP_MODE | LMC_GEP_DP | LMC_GEP_RESET);

                    /*
                     * Wait at least 10 us 20 to be safe
                     */
                    udelay(50);

                    /*
                     * Clear reset and activate programming lines
                     * Reset: Input
                     * DP:    Input
                     * Clock: Output
                     * Data:  Output
                     * Mode:  Output
                     */
                    lmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);

                    /*
                     * Set LOAD, DATA, Clock to 1
                     */
                    sc->lmc_gpio = 0x00;
                    sc->lmc_gpio |= LMC_GEP_MODE;
                    sc->lmc_gpio |= LMC_GEP_DATA;
                    sc->lmc_gpio |= LMC_GEP_CLK;
                    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
                    
                    lmc_gpio_mkoutput(sc, LMC_GEP_DATA | LMC_GEP_CLK | LMC_GEP_MODE );

                    /*
                     * busy wait for the chip to reset
                     */
                    while( (LMC_CSR_READ(sc, csr_gp) & LMC_GEP_INIT) == 0 &&
                           (timeout-- > 0))
                        cpu_relax();

                    printk(KERN_DEBUG "%s: Waited %d for the Xilinx to clear it's memory\n", dev->name, 500000-timeout);

                    for(pos = 0; pos < xc.len; pos++){
                        switch(data[pos]){
                        case 0:
                            sc->lmc_gpio &= ~LMC_GEP_DATA; /* Data is 0 */
                            break;
                        case 1:
                            sc->lmc_gpio |= LMC_GEP_DATA; /* Data is 1 */
                            break;
                        default:
                            printk(KERN_WARNING "%s Bad data in xilinx programming data at %d, got %d wanted 0 or 1\n", dev->name, pos, data[pos]);
                            sc->lmc_gpio |= LMC_GEP_DATA; /* Assume it's 1 */
                        }
                        sc->lmc_gpio &= ~LMC_GEP_CLK; /* Clock to zero */
                        sc->lmc_gpio |= LMC_GEP_MODE;
                        LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
                        udelay(1);
                        
                        sc->lmc_gpio |= LMC_GEP_CLK; /* Put the clack back to one */
                        sc->lmc_gpio |= LMC_GEP_MODE;
                        LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
                        udelay(1);
                    }
                    if((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_INIT) == 0){
                        printk(KERN_WARNING "%s: Reprogramming FAILED. Needs to be reprogrammed. (corrupted data)\n", dev->name);
                    }
                    else if((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0){
                        printk(KERN_WARNING "%s: Reprogramming FAILED. Needs to be reprogrammed. (done)\n", dev->name);
                    }
                    else {
                        printk(KERN_DEBUG "%s: Done reprogramming Xilinx, %d bits, good luck!\n", dev->name, pos);
                    }

                    lmc_gpio_mkinput(sc, 0xff);
                    
                    sc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;
                    lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);

                    sc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;
                    lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
		    spin_unlock_irqrestore(&sc->lmc_lock, flags);

                    kfree(data);
                    
                    ret = 0;
                    
                    break;
                }
            default: /*fold02*/
                ret = -EBADE;
                break;
            }

            netif_wake_queue(dev);
            sc->lmc_txfull = 0;

        }
        break;
    default: /*fold01*/
        /* If we don't know what to do, give the protocol a shot. */
        ret = lmc_proto_ioctl (sc, ifr, cmd);
        break;
    }

    lmc_trace(dev, "lmc_ioctl out");

    return ret;
}


/* the watchdog process that cruises around */
static void lmc_watchdog (unsigned long data) /*fold00*/
{
    struct net_device *dev = (struct net_device *)data;
    lmc_softc_t *sc = dev_to_sc(dev);
    int link_status;
    u32 ticks;
    unsigned long flags;

    lmc_trace(dev, "lmc_watchdog in");

    spin_lock_irqsave(&sc->lmc_lock, flags);

    if(sc->check != 0xBEAFCAFE){
        printk("LMC: Corrupt net_device struct, breaking out\n");
	spin_unlock_irqrestore(&sc->lmc_lock, flags);
        return;
    }


    /* Make sure the tx jabber and rx watchdog are off,
     * and the transmit and receive processes are running.
     */

    LMC_CSR_WRITE (sc, csr_15, 0x00000011);
    sc->lmc_cmdmode |= TULIP_CMD_TXRUN | TULIP_CMD_RXRUN;
    LMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);

    if (sc->lmc_ok == 0)
        goto kick_timer;

    LMC_EVENT_LOG(LMC_EVENT_WATCHDOG, LMC_CSR_READ (sc, csr_status), lmc_mii_readreg (sc, 0, 16));

    /* --- begin time out check -----------------------------------
     * check for a transmit interrupt timeout
     * Has the packet xmt vs xmt serviced threshold been exceeded */
    if (sc->lmc_taint_tx == sc->lastlmc_taint_tx &&
	sc->lmc_device->stats.tx_packets > sc->lasttx_packets &&
	sc->tx_TimeoutInd == 0)
    {

        /* wait for the watchdog to come around again */
        sc->tx_TimeoutInd = 1;
    }
    else if (sc->lmc_taint_tx == sc->lastlmc_taint_tx &&
	     sc->lmc_device->stats.tx_packets > sc->lasttx_packets &&
	     sc->tx_TimeoutInd)
    {

        LMC_EVENT_LOG(LMC_EVENT_XMTINTTMO, LMC_CSR_READ (sc, csr_status), 0);

        sc->tx_TimeoutDisplay = 1;
	sc->extra_stats.tx_TimeoutCnt++;

        /* DEC chip is stuck, hit it with a RESET!!!! */
        lmc_running_reset (dev);


        /* look at receive & transmit process state to make sure they are running */
        LMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ (sc, csr_status), 0);

        /* look at: DSR - 02  for Reg 16
         *                  CTS - 08
         *                  DCD - 10
         *                  RI  - 20
         * for Reg 17
         */
        LMC_EVENT_LOG(LMC_EVENT_RESET2, lmc_mii_readreg (sc, 0, 16), lmc_mii_readreg (sc, 0, 17));

        /* reset the transmit timeout detection flag */
        sc->tx_TimeoutInd = 0;
        sc->lastlmc_taint_tx = sc->lmc_taint_tx;
	sc->lasttx_packets = sc->lmc_device->stats.tx_packets;
    } else {
        sc->tx_TimeoutInd = 0;
        sc->lastlmc_taint_tx = sc->lmc_taint_tx;
	sc->lasttx_packets = sc->lmc_device->stats.tx_packets;
    }

    /* --- end time out check ----------------------------------- */


    link_status = sc->lmc_media->get_link_status (sc);

    /*
     * hardware level link lost, but the interface is marked as up.
     * Mark it as down.
     */
    if ((link_status == 0) && (sc->last_link_status != 0)) {
        printk(KERN_WARNING "%s: hardware/physical link down\n", dev->name);
        sc->last_link_status = 0;
        /* lmc_reset (sc); Why reset??? The link can go down ok */

        /* Inform the world that link has been lost */
	netif_carrier_off(dev);
    }

    /*
     * hardware link is up, but the interface is marked as down.
     * Bring it back up again.
     */
     if (link_status != 0 && sc->last_link_status == 0) {
         printk(KERN_WARNING "%s: hardware/physical link up\n", dev->name);
         sc->last_link_status = 1;
         /* lmc_reset (sc); Again why reset??? */

	 netif_carrier_on(dev);
     }

    /* Call media specific watchdog functions */
    sc->lmc_media->watchdog(sc);

    /*
     * Poke the transmitter to make sure it
     * never stops, even if we run out of mem
     */
    LMC_CSR_WRITE(sc, csr_rxpoll, 0);

    /*
     * Check for code that failed
     * and try and fix it as appropriate
     */
    if(sc->failed_ring == 1){
        /*
         * Failed to setup the recv/xmit rin
         * Try again
         */
        sc->failed_ring = 0;
        lmc_softreset(sc);
    }
    if(sc->failed_recv_alloc == 1){
        /*
         * We failed to alloc mem in the
         * interrupt handler, go through the rings
         * and rebuild them
         */
        sc->failed_recv_alloc = 0;
        lmc_softreset(sc);
    }


    /*
     * remember the timer value
     */
kick_timer:

    ticks = LMC_CSR_READ (sc, csr_gp_timer);
    LMC_CSR_WRITE (sc, csr_gp_timer, 0xffffffffUL);
    sc->ictl.ticks = 0x0000ffff - (ticks & 0x0000ffff);

    /*
     * restart this timer.
     */
    sc->timer.expires = jiffies + (HZ);
    add_timer (&sc->timer);

    spin_unlock_irqrestore(&sc->lmc_lock, flags);

    lmc_trace(dev, "lmc_watchdog out");

}

static int lmc_attach(struct net_device *dev, unsigned short encoding,
		      unsigned short parity)
{
	if (encoding == ENCODING_NRZ && parity == PARITY_CRC16_PR1_CCITT)
		return 0;
	return -EINVAL;
}

static const struct net_device_ops lmc_ops = {
	.ndo_open       = lmc_open,
	.ndo_stop       = lmc_close,
	.ndo_change_mtu = hdlc_change_mtu,
	.ndo_start_xmit = hdlc_start_xmit,
	.ndo_do_ioctl   = lmc_ioctl,
	.ndo_tx_timeout = lmc_driver_timeout,
	.ndo_get_stats  = lmc_get_stats,
};

static int __devinit lmc_init_one(struct pci_dev *pdev,
				  const struct pci_device_id *ent)
{
	lmc_softc_t *sc;
	struct net_device *dev;
	u16 subdevice;
	u16 AdapModelNum;
	int err;
	static int cards_found;

	/* lmc_trace(dev, "lmc_init_one in"); */

	err = pci_enable_device(pdev);
	if (err) {
		printk(KERN_ERR "lmc: pci enable failed: %d\n", err);
		return err;
	}

	err = pci_request_regions(pdev, "lmc");
	if (err) {
		printk(KERN_ERR "lmc: pci_request_region failed\n");
		goto err_req_io;
	}

	/*
	 * Allocate our own device structure
	 */
	sc = kzalloc(sizeof(lmc_softc_t), GFP_KERNEL);
	if (!sc) {
		err = -ENOMEM;
		goto err_kzalloc;
	}

	dev = alloc_hdlcdev(sc);
	if (!dev) {
		printk(KERN_ERR "lmc:alloc_netdev for device failed\n");
		goto err_hdlcdev;
	}


	dev->type = ARPHRD_HDLC;
	dev_to_hdlc(dev)->xmit = lmc_start_xmit;
	dev_to_hdlc(dev)->attach = lmc_attach;
	dev->netdev_ops = &lmc_ops;
	dev->watchdog_timeo = HZ; /* 1 second */
	dev->tx_queue_len = 100;
	sc->lmc_device = dev;
	sc->name = dev->name;
	sc->if_type = LMC_PPP;
	sc->check = 0xBEAFCAFE;
	dev->base_addr = pci_resource_start(pdev, 0);
	dev->irq = pdev->irq;
	pci_set_drvdata(pdev, dev);
	SET_NETDEV_DEV(dev, &pdev->dev);

	/*
	 * This will get the protocol layer ready and do any 1 time init's
	 * Must have a valid sc and dev structure
	 */
	lmc_proto_attach(sc);

	/* Init the spin lock so can call it latter */

	spin_lock_init(&sc->lmc_lock);
	pci_set_master(pdev);

	printk(KERN_INFO "%s: detected at %lx, irq %d\n", dev->name,
	       dev->base_addr, dev->irq);

	err = register_hdlc_device(dev);
	if (err) {
		printk(KERN_ERR "%s: register_netdev failed.\n", dev->name);
		free_netdev(dev);
		goto err_hdlcdev;
	}

    sc->lmc_cardtype = LMC_CARDTYPE_UNKNOWN;
    sc->lmc_timing = LMC_CTL_CLOCK_SOURCE_EXT;

    /*
     *
     * Check either the subvendor or the subdevice, some systems reverse
     * the setting in the bois, seems to be version and arch dependent?
     * Fix the error, exchange the two values 
     */
    if ((subdevice = pdev->subsystem_device) == PCI_VENDOR_ID_LMC)
	    subdevice = pdev->subsystem_vendor;

    switch (subdevice) {
    case PCI_DEVICE_ID_LMC_HSSI:
	printk(KERN_INFO "%s: LMC HSSI\n", dev->name);
        sc->lmc_cardtype = LMC_CARDTYPE_HSSI;
        sc->lmc_media = &lmc_hssi_media;
        break;
    case PCI_DEVICE_ID_LMC_DS3:
	printk(KERN_INFO "%s: LMC DS3\n", dev->name);
        sc->lmc_cardtype = LMC_CARDTYPE_DS3;
        sc->lmc_media = &lmc_ds3_media;
        break;
    case PCI_DEVICE_ID_LMC_SSI:
	printk(KERN_INFO "%s: LMC SSI\n", dev->name);
        sc->lmc_cardtype = LMC_CARDTYPE_SSI;
        sc->lmc_media = &lmc_ssi_media;
        break;
    case PCI_DEVICE_ID_LMC_T1:
	printk(KERN_INFO "%s: LMC T1\n", dev->name);
        sc->lmc_cardtype = LMC_CARDTYPE_T1;
        sc->lmc_media = &lmc_t1_media;
        break;
    default:
	printk(KERN_WARNING "%s: LMC UNKNOWN CARD!\n", dev->name);
        break;
    }

    lmc_initcsrs (sc, dev->base_addr, 8);

    lmc_gpio_mkinput (sc, 0xff);
    sc->lmc_gpio = 0;		/* drive no signals yet */

    sc->lmc_media->defaults (sc);

    sc->lmc_media->set_link_status (sc, LMC_LINK_UP);

    /* verify that the PCI Sub System ID matches the Adapter Model number
     * from the MII register
     */
    AdapModelNum = (lmc_mii_readreg (sc, 0, 3) & 0x3f0) >> 4;

    if ((AdapModelNum != LMC_ADAP_T1 || /* detect LMC1200 */
	 subdevice != PCI_DEVICE_ID_LMC_T1) &&
	(AdapModelNum != LMC_ADAP_SSI || /* detect LMC1000 */
	 subdevice != PCI_DEVICE_ID_LMC_SSI) &&
	(AdapModelNum != LMC_ADAP_DS3 || /* detect LMC5245 */
	 subdevice != PCI_DEVICE_ID_LMC_DS3) &&
	(AdapModelNum != LMC_ADAP_HSSI || /* detect LMC5200 */
	 subdevice != PCI_DEVICE_ID_LMC_HSSI))
	    printk(KERN_WARNING "%s: Model number (%d) miscompare for PCI"
		   " Subsystem ID = 0x%04x\n",
		   dev->name, AdapModelNum, subdevice);

    /*
     * reset clock
     */
    LMC_CSR_WRITE (sc, csr_gp_timer, 0xFFFFFFFFUL);

    sc->board_idx = cards_found++;
    sc->extra_stats.check = STATCHECK;
    sc->extra_stats.version_size = (DRIVER_VERSION << 16) +
	    sizeof(sc->lmc_device->stats) + sizeof(sc->extra_stats);
    sc->extra_stats.lmc_cardtype = sc->lmc_cardtype;

    sc->lmc_ok = 0;
    sc->last_link_status = 0;

    lmc_trace(dev, "lmc_init_one out");
    return 0;

err_hdlcdev:
	pci_set_drvdata(pdev, NULL);
	kfree(sc);
err_kzalloc:
	pci_release_regions(pdev);
err_req_io:
	pci_disable_device(pdev);
	return err;
}

/*
 * Called from pci when removing module.
 */
static void __devexit lmc_remove_one(struct pci_dev *pdev)
{
	struct net_device *dev = pci_get_drvdata(pdev);

	if (dev) {
		printk(KERN_DEBUG "%s: removing...\n", dev->name);
		unregister_hdlc_device(dev);
		free_netdev(dev);
		pci_release_regions(pdev);
		pci_disable_device(pdev);
		pci_set_drvdata(pdev, NULL);
	}
}

/* After this is called, packets can be sent.
 * Does not initialize the addresses
 */
static int lmc_open(struct net_device *dev)
{
    lmc_softc_t *sc = dev_to_sc(dev);
    int err;

    lmc_trace(dev, "lmc_open in");

    lmc_led_on(sc, LMC_DS3_LED0);

    lmc_dec_reset(sc);
    lmc_reset(sc);

    LMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ(sc, csr_status), 0);
    LMC_EVENT_LOG(LMC_EVENT_RESET2, lmc_mii_readreg(sc, 0, 16),
		  lmc_mii_readreg(sc, 0, 17));

    if (sc->lmc_ok){
        lmc_trace(dev, "lmc_open lmc_ok out");
        return (0);
    }

    lmc_softreset (sc);

    /* Since we have to use PCI bus, this should work on x86,alpha,ppc */
    if (request_irq (dev->irq, lmc_interrupt, IRQF_SHARED, dev->name, dev)){
        printk(KERN_WARNING "%s: could not get irq: %d\n", dev->name, dev->irq);
        lmc_trace(dev, "lmc_open irq failed out");
        return -EAGAIN;
    }
    sc->got_irq = 1;

    /* Assert Terminal Active */
    sc->lmc_miireg16 |= LMC_MII16_LED_ALL;
    sc->lmc_media->set_link_status (sc, LMC_LINK_UP);

    /*
     * reset to last state.
     */
    sc->lmc_media->set_status (sc, NULL);

    /* setup default bits to be used in tulip_desc_t transmit descriptor
     * -baz */
    sc->TxDescriptControlInit = (
                                 LMC_TDES_INTERRUPT_ON_COMPLETION
                                 | LMC_TDES_FIRST_SEGMENT
                                 | LMC_TDES_LAST_SEGMENT
                                 | LMC_TDES_SECOND_ADDR_CHAINED
                                 | LMC_TDES_DISABLE_PADDING
                                );

    if (sc->ictl.crc_length == LMC_CTL_CRC_LENGTH_16) {
        /* disable 32 bit CRC generated by ASIC */
        sc->TxDescriptControlInit |= LMC_TDES_ADD_CRC_DISABLE;
    }
    sc->lmc_media->set_crc_length(sc, sc->ictl.crc_length);
    /* Acknoledge the Terminal Active and light LEDs */

    /* dev->flags |= IFF_UP; */

    if ((err = lmc_proto_open(sc)) != 0)
	    return err;

    netif_start_queue(dev);
    sc->extra_stats.tx_tbusy0++;

    /*
     * select what interrupts we want to get
     */
    sc->lmc_intrmask = 0;
    /* Should be using the default interrupt mask defined in the .h file. */
    sc->lmc_intrmask |= (TULIP_STS_NORMALINTR
                         | TULIP_STS_RXINTR
                         | TULIP_STS_TXINTR
                         | TULIP_STS_ABNRMLINTR
                         | TULIP_STS_SYSERROR
                         | TULIP_STS_TXSTOPPED
                         | TULIP_STS_TXUNDERFLOW
                         | TULIP_STS_RXSTOPPED
		         | TULIP_STS_RXNOBUF
                        );
    LMC_CSR_WRITE (sc, csr_intr, sc->lmc_intrmask);

    sc->lmc_cmdmode |= TULIP_CMD_TXRUN;
    sc->lmc_cmdmode |= TULIP_CMD_RXRUN;
    LMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);

    sc->lmc_ok = 1; /* Run watchdog */

    /*
     * Set the if up now - pfb
     */

    sc->last_link_status = 1;

    /*
     * Setup a timer for the watchdog on probe, and start it running.
     * Since lmc_ok == 0, it will be a NOP for now.
     */
    init_timer (&sc->timer);
    sc->timer.expires = jiffies + HZ;
    sc->timer.data = (unsigned long) dev;
    sc->timer.function = &lmc_watchdog;
    add_timer (&sc->timer);

    lmc_trace(dev, "lmc_open out");

    return (0);
}

/* Total reset to compensate for the AdTran DSU doing bad things
 *  under heavy load
 */

static void lmc_running_reset (struct net_device *dev) /*fold00*/
{
    lmc_softc_t *sc = dev_to_sc(dev);

    lmc_trace(dev, "lmc_runnig_reset in");

    /* stop interrupts */
    /* Clear the interrupt mask */
    LMC_CSR_WRITE (sc, csr_intr, 0x00000000);

    lmc_dec_reset (sc);
    lmc_reset (sc);
    lmc_softreset (sc);
    /* sc->lmc_miireg16 |= LMC_MII16_LED_ALL; */
    sc->lmc_media->set_link_status (sc, 1);
    sc->lmc_media->set_status (sc, NULL);

    netif_wake_queue(dev);

    sc->lmc_txfull = 0;
    sc->extra_stats.tx_tbusy0++;

    sc->lmc_intrmask = TULIP_DEFAULT_INTR_MASK;
    LMC_CSR_WRITE (sc, csr_intr, sc->lmc_intrmask);

    sc->lmc_cmdmode |= (TULIP_CMD_TXRUN | TULIP_CMD_RXRUN);
    LMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);

    lmc_trace(dev, "lmc_runnin_reset_out");
}


/* This is what is called when you ifconfig down a device.
 * This disables the timer for the watchdog and keepalives,
 * and disables the irq for dev.
 */
static int lmc_close(struct net_device *dev)
{
    /* not calling release_region() as we should */
    lmc_softc_t *sc = dev_to_sc(dev);

    lmc_trace(dev, "lmc_close in");

    sc->lmc_ok = 0;
    sc->lmc_media->set_link_status (sc, 0);
    del_timer (&sc->timer);
    lmc_proto_close(sc);
    lmc_ifdown (dev);

    lmc_trace(dev, "lmc_close out");

    return 0;
}

/* Ends the transfer of packets */
/* When the interface goes down, this is called */
static int lmc_ifdown (struct net_device *dev) /*fold00*/
{
    lmc_softc_t *sc = dev_to_sc(dev);
    u32 csr6;
    int i;

    lmc_trace(dev, "lmc_ifdown in");

    /* Don't let anything else go on right now */
    //    dev->start = 0;
    netif_stop_queue(dev);
    sc->extra_stats.tx_tbusy1++;

    /* stop interrupts */
    /* Clear the interrupt mask */
    LMC_CSR_WRITE (sc, csr_intr, 0x00000000);

    /* Stop Tx and Rx on the chip */
    csr6 = LMC_CSR_READ (sc, csr_command);
    csr6 &= ~LMC_DEC_ST;		/* Turn off the Transmission bit */
    csr6 &= ~LMC_DEC_SR;		/* Turn off the Receive bit */
    LMC_CSR_WRITE (sc, csr_command, csr6);

    sc->lmc_device->stats.rx_missed_errors +=
	    LMC_CSR_READ(sc, csr_missed_frames) & 0xffff;

    /* release the interrupt */
    if(sc->got_irq == 1){
        free_irq (dev->irq, dev);
        sc->got_irq = 0;
    }

    /* free skbuffs in the Rx queue */
    for (i = 0; i < LMC_RXDESCS; i++)
    {
        struct sk_buff *skb = sc->lmc_rxq[i];
        sc->lmc_rxq[i] = NULL;
        sc->lmc_rxring[i].status = 0;
        sc->lmc_rxring[i].length = 0;
        sc->lmc_rxring[i].buffer1 = 0xDEADBEEF;
        if (skb != NULL)
            dev_kfree_skb(skb);
        sc->lmc_rxq[i] = NULL;
    }

    for (i = 0; i < LMC_TXDESCS; i++)
    {
        if (sc->lmc_txq[i] != NULL)
            dev_kfree_skb(sc->lmc_txq[i]);
        sc->lmc_txq[i] = NULL;
    }

    lmc_led_off (sc, LMC_MII16_LED_ALL);

    netif_wake_queue(dev);
    sc->extra_stats.tx_tbusy0++;

    lmc_trace(dev, "lmc_ifdown out");

    return 0;
}

/* Interrupt handling routine.  This will take an incoming packet, or clean
 * up after a trasmit.
 */
static irqreturn_t lmc_interrupt (int irq, void *dev_instance) /*fold00*/
{
    struct net_device *dev = (struct net_device *) dev_instance;
    lmc_softc_t *sc = dev_to_sc(dev);
    u32 csr;
    int i;
    s32 stat;
    unsigned int badtx;
    u32 firstcsr;
    int max_work = LMC_RXDESCS;
    int handled = 0;

    lmc_trace(dev, "lmc_interrupt in");

    spin_lock(&sc->lmc_lock);

    /*
     * Read the csr to find what interrupts we have (if any)
     */
    csr = LMC_CSR_READ (sc, csr_status);

    /*
     * Make sure this is our interrupt
     */
    if ( ! (csr & sc->lmc_intrmask)) {
        goto lmc_int_fail_out;
    }

    firstcsr = csr;

    /* always go through this loop at least once */
    while (csr & sc->lmc_intrmask) {
	handled = 1;

        /*
         * Clear interrupt bits, we handle all case below
         */
        LMC_CSR_WRITE (sc, csr_status, csr);

        /*
         * One of
         *  - Transmit process timed out CSR5<1>
         *  - Transmit jabber timeout    CSR5<3>
         *  - Transmit underflow         CSR5<5>
         *  - Transmit Receiver buffer unavailable CSR5<7>
         *  - Receive process stopped    CSR5<8>
         *  - Receive watchdog timeout   CSR5<9>
         *  - Early transmit interrupt   CSR5<10>
         *
         * Is this really right? Should we do a running reset for jabber?
         * (being a WAN card and all)
         */
        if (csr & TULIP_STS_ABNRMLINTR){
            lmc_running_reset (dev);
            break;
        }
        
        if (csr & TULIP_STS_RXINTR){
            lmc_trace(dev, "rx interrupt");
            lmc_rx (dev);
            
        }
        if (csr & (TULIP_STS_TXINTR | TULIP_STS_TXNOBUF | TULIP_STS_TXSTOPPED)) {

	    int		n_compl = 0 ;
            /* reset the transmit timeout detection flag -baz */
	    sc->extra_stats.tx_NoCompleteCnt = 0;

            badtx = sc->lmc_taint_tx;
            i = badtx % LMC_TXDESCS;

            while ((badtx < sc->lmc_next_tx)) {
                stat = sc->lmc_txring[i].status;

                LMC_EVENT_LOG (LMC_EVENT_XMTINT, stat,
						 sc->lmc_txring[i].length);
                /*
                 * If bit 31 is 1 the tulip owns it break out of the loop
                 */
                if (stat & 0x80000000)
                    break;

		n_compl++ ;		/* i.e., have an empty slot in ring */
                /*
                 * If we have no skbuff or have cleared it
                 * Already continue to the next buffer
                 */
                if (sc->lmc_txq[i] == NULL)
                    continue;

		/*
		 * Check the total error summary to look for any errors
		 */
		if (stat & 0x8000) {
			sc->lmc_device->stats.tx_errors++;
			if (stat & 0x4104)
				sc->lmc_device->stats.tx_aborted_errors++;
			if (stat & 0x0C00)
				sc->lmc_device->stats.tx_carrier_errors++;
			if (stat & 0x0200)
				sc->lmc_device->stats.tx_window_errors++;
			if (stat & 0x0002)
				sc->lmc_device->stats.tx_fifo_errors++;
		} else {
			sc->lmc_device->stats.tx_bytes += sc->lmc_txring[i].length & 0x7ff;

			sc->lmc_device->stats.tx_packets++;
                }

                //                dev_kfree_skb(sc->lmc_txq[i]);
                dev_kfree_skb_irq(sc->lmc_txq[i]);
                sc->lmc_txq[i] = NULL;

                badtx++;
                i = badtx % LMC_TXDESCS;
            }

            if (sc->lmc_next_tx - badtx > LMC_TXDESCS)
            {
                printk ("%s: out of sync pointer\n", dev->name);
                badtx += LMC_TXDESCS;
            }
            LMC_EVENT_LOG(LMC_EVENT_TBUSY0, n_compl, 0);
            sc->lmc_txfull = 0;
            netif_wake_queue(dev);
	    sc->extra_stats.tx_tbusy0++;


#ifdef DEBUG
	    sc->extra_stats.dirtyTx = badtx;
	    sc->extra_stats.lmc_next_tx = sc->lmc_next_tx;
	    sc->extra_stats.lmc_txfull = sc->lmc_txfull;
#endif
            sc->lmc_taint_tx = badtx;

            /*
             * Why was there a break here???
             */
        }			/* end handle transmit interrupt */

        if (csr & TULIP_STS_SYSERROR) {
            u32 error;
            printk (KERN_WARNING "%s: system bus error csr: %#8.8x\n", dev->name, csr);
            error = csr>>23 & 0x7;
            switch(error){
            case 0x000:
                printk(KERN_WARNING "%s: Parity Fault (bad)\n", dev->name);
                break;
            case 0x001:
                printk(KERN_WARNING "%s: Master Abort (naughty)\n", dev->name);
                break;
            case 0x010:
                printk(KERN_WARNING "%s: Target Abort (not so naughty)\n", dev->name);
                break;
            default:
                printk(KERN_WARNING "%s: This bus error code was supposed to be reserved!\n", dev->name);
            }
            lmc_dec_reset (sc);
            lmc_reset (sc);
            LMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ (sc, csr_status), 0);
            LMC_EVENT_LOG(LMC_EVENT_RESET2,
                          lmc_mii_readreg (sc, 0, 16),
                          lmc_mii_readreg (sc, 0, 17));

        }

        
        if(max_work-- <= 0)
            break;
        
        /*
         * Get current csr status to make sure
         * we've cleared all interrupts
         */
        csr = LMC_CSR_READ (sc, csr_status);
    }				/* end interrupt loop */
    LMC_EVENT_LOG(LMC_EVENT_INT, firstcsr, csr);

lmc_int_fail_out:

    spin_unlock(&sc->lmc_lock);

    lmc_trace(dev, "lmc_interrupt out");
    return IRQ_RETVAL(handled);
}

static netdev_tx_t lmc_start_xmit(struct sk_buff *skb,
					struct net_device *dev)
{
    lmc_softc_t *sc = dev_to_sc(dev);
    u32 flag;
    int entry;
    unsigned long flags;

    lmc_trace(dev, "lmc_start_xmit in");

    spin_lock_irqsave(&sc->lmc_lock, flags);

    /* normal path, tbusy known to be zero */

    entry = sc->lmc_next_tx % LMC_TXDESCS;

    sc->lmc_txq[entry] = skb;
    sc->lmc_txring[entry].buffer1 = virt_to_bus (skb->data);

    LMC_CONSOLE_LOG("xmit", skb->data, skb->len);

#ifndef GCOM
    /* If the queue is less than half full, don't interrupt */
    if (sc->lmc_next_tx - sc->lmc_taint_tx < LMC_TXDESCS / 2)
    {
        /* Do not interrupt on completion of this packet */
        flag = 0x60000000;
        netif_wake_queue(dev);
    }
    else if (sc->lmc_next_tx - sc->lmc_taint_tx == LMC_TXDESCS / 2)
    {
        /* This generates an interrupt on completion of this packet */
        flag = 0xe0000000;
        netif_wake_queue(dev);
    }
    else if (sc->lmc_next_tx - sc->lmc_taint_tx < LMC_TXDESCS - 1)
    {
        /* Do not interrupt on completion of this packet */
        flag = 0x60000000;
        netif_wake_queue(dev);
    }
    else
    {
        /* This generates an interrupt on completion of this packet */
        flag = 0xe0000000;
        sc->lmc_txfull = 1;
        netif_stop_queue(dev);
    }
#else
    flag = LMC_TDES_INTERRUPT_ON_COMPLETION;

    if (sc->lmc_next_tx - sc->lmc_taint_tx >= LMC_TXDESCS - 1)
    {				/* ring full, go busy */
        sc->lmc_txfull = 1;
	netif_stop_queue(dev);
	sc->extra_stats.tx_tbusy1++;
        LMC_EVENT_LOG(LMC_EVENT_TBUSY1, entry, 0);
    }
#endif


    if (entry == LMC_TXDESCS - 1)	/* last descriptor in ring */
	flag |= LMC_TDES_END_OF_RING;	/* flag as such for Tulip */

    /* don't pad small packets either */
    flag = sc->lmc_txring[entry].length = (skb->len) | flag |
						sc->TxDescriptControlInit;

    /* set the transmit timeout flag to be checked in
     * the watchdog timer handler. -baz
     */

    sc->extra_stats.tx_NoCompleteCnt++;
    sc->lmc_next_tx++;

    /* give ownership to the chip */
    LMC_EVENT_LOG(LMC_EVENT_XMT, flag, entry);
    sc->lmc_txring[entry].status = 0x80000000;

    /* send now! */
    LMC_CSR_WRITE (sc, csr_txpoll, 0);

    spin_unlock_irqrestore(&sc->lmc_lock, flags);

    lmc_trace(dev, "lmc_start_xmit_out");
    return NETDEV_TX_OK;
}


static int lmc_rx(struct net_device *dev)
{
    lmc_softc_t *sc = dev_to_sc(dev);
    int i;
    int rx_work_limit = LMC_RXDESCS;
    unsigned int next_rx;
    int rxIntLoopCnt;		/* debug -baz */
    int localLengthErrCnt = 0;
    long stat;
    struct sk_buff *skb, *nsb;
    u16 len;

    lmc_trace(dev, "lmc_rx in");

    lmc_led_on(sc, LMC_DS3_LED3);

    rxIntLoopCnt = 0;		/* debug -baz */

    i = sc->lmc_next_rx % LMC_RXDESCS;
    next_rx = sc->lmc_next_rx;

    while (((stat = sc->lmc_rxring[i].status) & LMC_RDES_OWN_BIT) != DESC_OWNED_BY_DC21X4)
    {
        rxIntLoopCnt++;		/* debug -baz */
        len = ((stat & LMC_RDES_FRAME_LENGTH) >> RDES_FRAME_LENGTH_BIT_NUMBER);
        if ((stat & 0x0300) != 0x0300) {  /* Check first segment and last segment */
		if ((stat & 0x0000ffff) != 0x7fff) {
			/* Oversized frame */
			sc->lmc_device->stats.rx_length_errors++;
			goto skip_packet;
		}
	}

	if (stat & 0x00000008) { /* Catch a dribbling bit error */
		sc->lmc_device->stats.rx_errors++;
		sc->lmc_device->stats.rx_frame_errors++;
		goto skip_packet;
	}


	if (stat & 0x00000004) { /* Catch a CRC error by the Xilinx */
		sc->lmc_device->stats.rx_errors++;
		sc->lmc_device->stats.rx_crc_errors++;
		goto skip_packet;
	}

	if (len > LMC_PKT_BUF_SZ) {
		sc->lmc_device->stats.rx_length_errors++;
		localLengthErrCnt++;
		goto skip_packet;
	}

	if (len < sc->lmc_crcSize + 2) {
		sc->lmc_device->stats.rx_length_errors++;
		sc->extra_stats.rx_SmallPktCnt++;
		localLengthErrCnt++;
		goto skip_packet;
	}

        if(stat & 0x00004000){
            printk(KERN_WARNING "%s: Receiver descriptor error, receiver out of sync?\n", dev->name);
        }

        len -= sc->lmc_crcSize;

        skb = sc->lmc_rxq[i];

        /*
         * We ran out of memory at some point
         * just allocate an skb buff and continue.
         */
        
        if (!skb) {
            nsb = dev_alloc_skb (LMC_PKT_BUF_SZ + 2);
            if (nsb) {
                sc->lmc_rxq[i] = nsb;
                nsb->dev = dev;
                sc->lmc_rxring[i].buffer1 = virt_to_bus(skb_tail_pointer(nsb));
            }
            sc->failed_recv_alloc = 1;
            goto skip_packet;
        }
        
	sc->lmc_device->stats.rx_packets++;
	sc->lmc_device->stats.rx_bytes += len;

        LMC_CONSOLE_LOG("recv", skb->data, len);

        /*
         * I'm not sure of the sanity of this
         * Packets could be arriving at a constant
         * 44.210mbits/sec and we're going to copy
         * them into a new buffer??
         */
        
        if(len > (LMC_MTU - (LMC_MTU>>2))){ /* len > LMC_MTU * 0.75 */
            /*
             * If it's a large packet don't copy it just hand it up
             */
        give_it_anyways:

            sc->lmc_rxq[i] = NULL;
            sc->lmc_rxring[i].buffer1 = 0x0;

            skb_put (skb, len);
            skb->protocol = lmc_proto_type(sc, skb);
            skb_reset_mac_header(skb);
            /* skb_reset_network_header(skb); */
            skb->dev = dev;
            lmc_proto_netif(sc, skb);

            /*
             * This skb will be destroyed by the upper layers, make a new one
             */
            nsb = dev_alloc_skb (LMC_PKT_BUF_SZ + 2);
            if (nsb) {
                sc->lmc_rxq[i] = nsb;
                nsb->dev = dev;
                sc->lmc_rxring[i].buffer1 = virt_to_bus(skb_tail_pointer(nsb));
                /* Transferred to 21140 below */
            }
            else {
                /*
                 * We've run out of memory, stop trying to allocate
                 * memory and exit the interrupt handler
                 *
                 * The chip may run out of receivers and stop
                 * in which care we'll try to allocate the buffer
                 * again.  (once a second)
                 */
		sc->extra_stats.rx_BuffAllocErr++;
                LMC_EVENT_LOG(LMC_EVENT_RCVINT, stat, len);
                sc->failed_recv_alloc = 1;
                goto skip_out_of_mem;
            }
        }
        else {
            nsb = dev_alloc_skb(len);
            if(!nsb) {
                goto give_it_anyways;
            }
            skb_copy_from_linear_data(skb, skb_put(nsb, len), len);
            
            nsb->protocol = lmc_proto_type(sc, nsb);
            skb_reset_mac_header(nsb);
            /* skb_reset_network_header(nsb); */
            nsb->dev = dev;
            lmc_proto_netif(sc, nsb);
        }

    skip_packet:
        LMC_EVENT_LOG(LMC_EVENT_RCVINT, stat, len);
        sc->lmc_rxring[i].status = DESC_OWNED_BY_DC21X4;

        sc->lmc_next_rx++;
        i = sc->lmc_next_rx % LMC_RXDESCS;
        rx_work_limit--;
        if (rx_work_limit < 0)
            break;
    }

    /* detect condition for LMC1000 where DSU cable attaches and fills
     * descriptors with bogus packets
     *
    if (localLengthErrCnt > LMC_RXDESCS - 3) {
	sc->extra_stats.rx_BadPktSurgeCnt++;
	LMC_EVENT_LOG(LMC_EVENT_BADPKTSURGE, localLengthErrCnt,
		      sc->extra_stats.rx_BadPktSurgeCnt);
    } */

    /* save max count of receive descriptors serviced */
    if (rxIntLoopCnt > sc->extra_stats.rxIntLoopCnt)
	    sc->extra_stats.rxIntLoopCnt = rxIntLoopCnt; /* debug -baz */

#ifdef DEBUG
    if (rxIntLoopCnt == 0)
    {
        for (i = 0; i < LMC_RXDESCS; i++)
        {
            if ((sc->lmc_rxring[i].status & LMC_RDES_OWN_BIT)
                != DESC_OWNED_BY_DC21X4)
            {
                rxIntLoopCnt++;
            }
        }
        LMC_EVENT_LOG(LMC_EVENT_RCVEND, rxIntLoopCnt, 0);
    }
#endif


    lmc_led_off(sc, LMC_DS3_LED3);

skip_out_of_mem:

    lmc_trace(dev, "lmc_rx out");

    return 0;
}

static struct net_device_stats *lmc_get_stats(struct net_device *dev)
{
    lmc_softc_t *sc = dev_to_sc(dev);
    unsigned long flags;

    lmc_trace(dev, "lmc_get_stats in");

    spin_lock_irqsave(&sc->lmc_lock, flags);

    sc->lmc_device->stats.rx_missed_errors += LMC_CSR_READ(sc, csr_missed_frames) & 0xffff;

    spin_unlock_irqrestore(&sc->lmc_lock, flags);

    lmc_trace(dev, "lmc_get_stats out");

    return &sc->lmc_device->stats;
}

static struct pci_driver lmc_driver = {
	.name		= "lmc",
	.id_table	= lmc_pci_tbl,
	.probe		= lmc_init_one,
	.remove		= __devexit_p(lmc_remove_one),
};

static int __init init_lmc(void)
{
    return pci_register_driver(&lmc_driver);
}

static void __exit exit_lmc(void)
{
    pci_unregister_driver(&lmc_driver);
}

module_init(init_lmc);
module_exit(exit_lmc);

unsigned lmc_mii_readreg (lmc_softc_t * const sc, unsigned devaddr, unsigned regno) /*fold00*/
{
    int i;
    int command = (0xf6 << 10) | (devaddr << 5) | regno;
    int retval = 0;

    lmc_trace(sc->lmc_device, "lmc_mii_readreg in");

    LMC_MII_SYNC (sc);

    lmc_trace(sc->lmc_device, "lmc_mii_readreg: done sync");

    for (i = 15; i >= 0; i--)
    {
        int dataval = (command & (1 << i)) ? 0x20000 : 0;

        LMC_CSR_WRITE (sc, csr_9, dataval);
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
        LMC_CSR_WRITE (sc, csr_9, dataval | 0x10000);
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
    }

    lmc_trace(sc->lmc_device, "lmc_mii_readreg: done1");

    for (i = 19; i > 0; i--)
    {
        LMC_CSR_WRITE (sc, csr_9, 0x40000);
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
        retval = (retval << 1) | ((LMC_CSR_READ (sc, csr_9) & 0x80000) ? 1 : 0);
        LMC_CSR_WRITE (sc, csr_9, 0x40000 | 0x10000);
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
    }

    lmc_trace(sc->lmc_device, "lmc_mii_readreg out");

    return (retval >> 1) & 0xffff;
}

void lmc_mii_writereg (lmc_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data) /*fold00*/
{
    int i = 32;
    int command = (0x5002 << 16) | (devaddr << 23) | (regno << 18) | data;

    lmc_trace(sc->lmc_device, "lmc_mii_writereg in");

    LMC_MII_SYNC (sc);

    i = 31;
    while (i >= 0)
    {
        int datav;

        if (command & (1 << i))
            datav = 0x20000;
        else
            datav = 0x00000;

        LMC_CSR_WRITE (sc, csr_9, datav);
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
        LMC_CSR_WRITE (sc, csr_9, (datav | 0x10000));
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
        i--;
    }

    i = 2;
    while (i > 0)
    {
        LMC_CSR_WRITE (sc, csr_9, 0x40000);
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
        LMC_CSR_WRITE (sc, csr_9, 0x50000);
        lmc_delay ();
        /* __SLOW_DOWN_IO; */
        i--;
    }

    lmc_trace(sc->lmc_device, "lmc_mii_writereg out");
}

static void lmc_softreset (lmc_softc_t * const sc) /*fold00*/
{
    int i;

    lmc_trace(sc->lmc_device, "lmc_softreset in");

    /* Initialize the receive rings and buffers. */
    sc->lmc_txfull = 0;
    sc->lmc_next_rx = 0;
    sc->lmc_next_tx = 0;
    sc->lmc_taint_rx = 0;
    sc->lmc_taint_tx = 0;

    /*
     * Setup each one of the receiver buffers
     * allocate an skbuff for each one, setup the descriptor table
     * and point each buffer at the next one
     */

    for (i = 0; i < LMC_RXDESCS; i++)
    {
        struct sk_buff *skb;

        if (sc->lmc_rxq[i] == NULL)
        {
            skb = dev_alloc_skb (LMC_PKT_BUF_SZ + 2);
            if(skb == NULL){
                printk(KERN_WARNING "%s: Failed to allocate receiver ring, will try again\n", sc->name);
                sc->failed_ring = 1;
                break;
            }
            else{
                sc->lmc_rxq[i] = skb;
            }
        }
        else
        {
            skb = sc->lmc_rxq[i];
        }

        skb->dev = sc->lmc_device;

        /* owned by 21140 */
        sc->lmc_rxring[i].status = 0x80000000;

        /* used to be PKT_BUF_SZ now uses skb since we lose some to head room */
        sc->lmc_rxring[i].length = skb_tailroom(skb);

        /* use to be tail which is dumb since you're thinking why write
         * to the end of the packj,et but since there's nothing there tail == data
         */
        sc->lmc_rxring[i].buffer1 = virt_to_bus (skb->data);

        /* This is fair since the structure is static and we have the next address */
        sc->lmc_rxring[i].buffer2 = virt_to_bus (&sc->lmc_rxring[i + 1]);

    }

    /*
     * Sets end of ring
     */
    if (i != 0) {
        sc->lmc_rxring[i - 1].length |= 0x02000000; /* Set end of buffers flag */
        sc->lmc_rxring[i - 1].buffer2 = virt_to_bus(&sc->lmc_rxring[0]); /* Point back to the start */
    }
    LMC_CSR_WRITE (sc, csr_rxlist, virt_to_bus (sc->lmc_rxring)); /* write base address */

    /* Initialize the transmit rings and buffers */
    for (i = 0; i < LMC_TXDESCS; i++)
    {
        if (sc->lmc_txq[i] != NULL){		/* have buffer */
            dev_kfree_skb(sc->lmc_txq[i]);	/* free it */
	    sc->lmc_device->stats.tx_dropped++;	/* We just dropped a packet */
        }
        sc->lmc_txq[i] = NULL;
        sc->lmc_txring[i].status = 0x00000000;
        sc->lmc_txring[i].buffer2 = virt_to_bus (&sc->lmc_txring[i + 1]);
    }
    sc->lmc_txring[i - 1].buffer2 = virt_to_bus (&sc->lmc_txring[0]);
    LMC_CSR_WRITE (sc, csr_txlist, virt_to_bus (sc->lmc_txring));

    lmc_trace(sc->lmc_device, "lmc_softreset out");
}

void lmc_gpio_mkinput(lmc_softc_t * const sc, u32 bits) /*fold00*/
{
    lmc_trace(sc->lmc_device, "lmc_gpio_mkinput in");
    sc->lmc_gpio_io &= ~bits;
    LMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));
    lmc_trace(sc->lmc_device, "lmc_gpio_mkinput out");
}

void lmc_gpio_mkoutput(lmc_softc_t * const sc, u32 bits) /*fold00*/
{
    lmc_trace(sc->lmc_device, "lmc_gpio_mkoutput in");
    sc->lmc_gpio_io |= bits;
    LMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));
    lmc_trace(sc->lmc_device, "lmc_gpio_mkoutput out");
}

void lmc_led_on(lmc_softc_t * const sc, u32 led) /*fold00*/
{
    lmc_trace(sc->lmc_device, "lmc_led_on in");
    if((~sc->lmc_miireg16) & led){ /* Already on! */
        lmc_trace(sc->lmc_device, "lmc_led_on aon out");
        return;
    }
    
    sc->lmc_miireg16 &= ~led;
    lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
    lmc_trace(sc->lmc_device, "lmc_led_on out");
}

void lmc_led_off(lmc_softc_t * const sc, u32 led) /*fold00*/
{
    lmc_trace(sc->lmc_device, "lmc_led_off in");
    if(sc->lmc_miireg16 & led){ /* Already set don't do anything */
        lmc_trace(sc->lmc_device, "lmc_led_off aoff out");
        return;
    }
    
    sc->lmc_miireg16 |= led;
    lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
    lmc_trace(sc->lmc_device, "lmc_led_off out");
}

static void lmc_reset(lmc_softc_t * const sc) /*fold00*/
{
    lmc_trace(sc->lmc_device, "lmc_reset in");
    sc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;
    lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);

    sc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;
    lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);

    /*
     * make some of the GPIO pins be outputs
     */
    lmc_gpio_mkoutput(sc, LMC_GEP_RESET);

    /*
     * RESET low to force state reset.  This also forces
     * the transmitter clock to be internal, but we expect to reset
     * that later anyway.
     */
    sc->lmc_gpio &= ~(LMC_GEP_RESET);
    LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

    /*
     * hold for more than 10 microseconds
     */
    udelay(50);

    /*
     * stop driving Xilinx-related signals
     */
    lmc_gpio_mkinput(sc, LMC_GEP_RESET);

    /*
     * Call media specific init routine
     */
    sc->lmc_media->init(sc);

    sc->extra_stats.resetCount++;
    lmc_trace(sc->lmc_device, "lmc_reset out");
}

static void lmc_dec_reset(lmc_softc_t * const sc) /*fold00*/
{
    u32 val;
    lmc_trace(sc->lmc_device, "lmc_dec_reset in");

    /*
     * disable all interrupts
     */
    sc->lmc_intrmask = 0;
    LMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);

    /*
     * Reset the chip with a software reset command.
     * Wait 10 microseconds (actually 50 PCI cycles but at
     * 33MHz that comes to two microseconds but wait a
     * bit longer anyways)
     */
    LMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    udelay(25);
#ifdef __sparc__
    sc->lmc_busmode = LMC_CSR_READ(sc, csr_busmode);
    sc->lmc_busmode = 0x00100000;
    sc->lmc_busmode &= ~TULIP_BUSMODE_SWRESET;
    LMC_CSR_WRITE(sc, csr_busmode, sc->lmc_busmode);
#endif
    sc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);

    /*
     * We want:
     *   no ethernet address in frames we write
     *   disable padding (txdesc, padding disable)
     *   ignore runt frames (rdes0 bit 15)
     *   no receiver watchdog or transmitter jabber timer
     *       (csr15 bit 0,14 == 1)
     *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)
     */

    sc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS
                         | TULIP_CMD_FULLDUPLEX
                         | TULIP_CMD_PASSBADPKT
                         | TULIP_CMD_NOHEARTBEAT
                         | TULIP_CMD_PORTSELECT
                         | TULIP_CMD_RECEIVEALL
                         | TULIP_CMD_MUSTBEONE
                       );
    sc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE
                          | TULIP_CMD_THRESHOLDCTL
                          | TULIP_CMD_STOREFWD
                          | TULIP_CMD_TXTHRSHLDCTL
                        );

    LMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);

    /*
     * disable receiver watchdog and transmit jabber
     */
    val = LMC_CSR_READ(sc, csr_sia_general);
    val |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);
    LMC_CSR_WRITE(sc, csr_sia_general, val);

    lmc_trace(sc->lmc_device, "lmc_dec_reset out");
}

static void lmc_initcsrs(lmc_softc_t * const sc, lmc_csrptr_t csr_base, /*fold00*/
                         size_t csr_size)
{
    lmc_trace(sc->lmc_device, "lmc_initcsrs in");
    sc->lmc_csrs.csr_busmode	        = csr_base +  0 * csr_size;
    sc->lmc_csrs.csr_txpoll		= csr_base +  1 * csr_size;
    sc->lmc_csrs.csr_rxpoll		= csr_base +  2 * csr_size;
    sc->lmc_csrs.csr_rxlist		= csr_base +  3 * csr_size;
    sc->lmc_csrs.csr_txlist		= csr_base +  4 * csr_size;
    sc->lmc_csrs.csr_status		= csr_base +  5 * csr_size;
    sc->lmc_csrs.csr_command	        = csr_base +  6 * csr_size;
    sc->lmc_csrs.csr_intr		= csr_base +  7 * csr_size;
    sc->lmc_csrs.csr_missed_frames	= csr_base +  8 * csr_size;
    sc->lmc_csrs.csr_9		        = csr_base +  9 * csr_size;
    sc->lmc_csrs.csr_10		        = csr_base + 10 * csr_size;
    sc->lmc_csrs.csr_11		        = csr_base + 11 * csr_size;
    sc->lmc_csrs.csr_12		        = csr_base + 12 * csr_size;
    sc->lmc_csrs.csr_13		        = csr_base + 13 * csr_size;
    sc->lmc_csrs.csr_14		        = csr_base + 14 * csr_size;
    sc->lmc_csrs.csr_15		        = csr_base + 15 * csr_size;
    lmc_trace(sc->lmc_device, "lmc_initcsrs out");
}

static void lmc_driver_timeout(struct net_device *dev)
{
    lmc_softc_t *sc = dev_to_sc(dev);
    u32 csr6;
    unsigned long flags;

    lmc_trace(dev, "lmc_driver_timeout in");

    spin_lock_irqsave(&sc->lmc_lock, flags);

    printk("%s: Xmitter busy|\n", dev->name);

    sc->extra_stats.tx_tbusy_calls++;
    if (jiffies - dev_trans_start(dev) < TX_TIMEOUT)
	    goto bug_out;

    /*
     * Chip seems to have locked up
     * Reset it
     * This whips out all our decriptor
     * table and starts from scartch
     */

    LMC_EVENT_LOG(LMC_EVENT_XMTPRCTMO,
                  LMC_CSR_READ (sc, csr_status),
		  sc->extra_stats.tx_ProcTimeout);

    lmc_running_reset (dev);

    LMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ (sc, csr_status), 0);
    LMC_EVENT_LOG(LMC_EVENT_RESET2,
                  lmc_mii_readreg (sc, 0, 16),
                  lmc_mii_readreg (sc, 0, 17));

    /* restart the tx processes */
    csr6 = LMC_CSR_READ (sc, csr_command);
    LMC_CSR_WRITE (sc, csr_command, csr6 | 0x0002);
    LMC_CSR_WRITE (sc, csr_command, csr6 | 0x2002);

    /* immediate transmit */
    LMC_CSR_WRITE (sc, csr_txpoll, 0);

    sc->lmc_device->stats.tx_errors++;
    sc->extra_stats.tx_ProcTimeout++; /* -baz */

    dev->trans_start = jiffies; /* prevent tx timeout */

bug_out:

    spin_unlock_irqrestore(&sc->lmc_lock, flags);

    lmc_trace(dev, "lmc_driver_timout out");


}
/*
 * tsi148.h
 *
 * Support for the Tundra TSI148 VME Bridge chip
 *
 * Author: Tom Armistead
 * Updated and maintained by Ajit Prem
 * Copyright 2004 Motorola Inc.
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 */

#ifndef TSI148_H
#define TSI148_H

#ifndef	PCI_VENDOR_ID_TUNDRA
#define	PCI_VENDOR_ID_TUNDRA 0x10e3
#endif

#ifndef	PCI_DEVICE_ID_TUNDRA_TSI148
#define	PCI_DEVICE_ID_TUNDRA_TSI148 0x148
#endif

/*
 *  Define the number of each that the Tsi148 supports.
 */
#define TSI148_MAX_MASTER		8	/* Max Master Windows */
#define TSI148_MAX_SLAVE		8	/* Max Slave Windows */
#define TSI148_MAX_DMA			2	/* Max DMA Controllers */
#define TSI148_MAX_MAILBOX		4	/* Max Mail Box registers */
#define TSI148_MAX_SEMAPHORE		8	/* Max Semaphores */

/* Structure used to hold driver specific information */
struct tsi148_driver {
	void *base;	/* Base Address of device registers */
	wait_queue_head_t dma_queue[2];
	wait_queue_head_t iack_queue;
	void (*lm_callback[4])(int);	/* Called in interrupt handler */
	void *crcsr_kernel;
	dma_addr_t crcsr_bus;
	struct vme_master_resource *flush_image;
	struct mutex vme_rmw;		/* Only one RMW cycle at a time */
	struct mutex vme_int;		/*
					 * Only one VME interrupt can be
					 * generated at a time, provide locking
					 */
};

/*
 * Layout of a DMAC Linked-List Descriptor
 *
 * Note: This structure is accessed via the chip and therefore must be
 *       correctly laid out - It must also be aligned on 64-bit boundaries.
 */
struct tsi148_dma_descriptor {
	u32 dsau;      /* Source Address */
	u32 dsal;
	u32 ddau;      /* Destination Address */
	u32 ddal;
	u32 dsat;      /* Source attributes */
	u32 ddat;      /* Destination attributes */
	u32 dnlau;     /* Next link address */
	u32 dnlal;
	u32 dcnt;      /* Byte count */
	u32 ddbs;      /* 2eSST Broadcast select */
};

struct tsi148_dma_entry {
	/*
	 * The descriptor needs to be aligned on a 64-bit boundary, we increase
	 * the chance of this by putting it first in the structure.
	 */
	struct tsi148_dma_descriptor descriptor;
	struct list_head list;
};

/*
 *  TSI148 ASIC register structure overlays and bit field definitions.
 *
 *      Note:   Tsi148 Register Group (CRG) consists of the following
 *              combination of registers:
 *                      PCFS    - PCI Configuration Space Registers
 *                      LCSR    - Local Control and Status Registers
 *                      GCSR    - Global Control and Status Registers
 *                      CR/CSR  - Subset of Configuration ROM /
 *                                Control and Status Registers
 */


/*
 *  Command/Status Registers (CRG + $004)
 */
#define TSI148_PCFS_ID			0x0
#define TSI148_PCFS_CSR			0x4
#define TSI148_PCFS_CLASS		0x8
#define TSI148_PCFS_MISC0		0xC
#define TSI148_PCFS_MBARL		0x10
#define TSI148_PCFS_MBARU		0x14

#define TSI148_PCFS_SUBID		0x28

#define TSI148_PCFS_CAPP		0x34

#define TSI148_PCFS_MISC1		0x3C

#define TSI148_PCFS_XCAPP		0x40
#define TSI148_PCFS_XSTAT		0x44

/*
 * LCSR definitions
 */

/*
 *    Outbound Translations
 */
#define TSI148_LCSR_OT0_OTSAU		0x100
#define TSI148_LCSR_OT0_OTSAL		0x104
#define TSI148_LCSR_OT0_OTEAU		0x108
#define TSI148_LCSR_OT0_OTEAL		0x10C
#define TSI148_LCSR_OT0_OTOFU		0x110
#define TSI148_LCSR_OT0_OTOFL		0x114
#define TSI148_LCSR_OT0_OTBS		0x118
#define TSI148_LCSR_OT0_OTAT		0x11C

#define TSI148_LCSR_OT1_OTSAU		0x120
#define TSI148_LCSR_OT1_OTSAL		0x124
#define TSI148_LCSR_OT1_OTEAU		0x128
#define TSI148_LCSR_OT1_OTEAL		0x12C
#define TSI148_LCSR_OT1_OTOFU		0x130
#define TSI148_LCSR_OT1_OTOFL		0x134
#define TSI148_LCSR_OT1_OTBS		0x138
#define TSI148_LCSR_OT1_OTAT		0x13C

#define TSI148_LCSR_OT2_OTSAU		0x140
#define TSI148_LCSR_OT2_OTSAL		0x144
#define TSI148_LCSR_OT2_OTEAU		0x148
#define TSI148_LCSR_OT2_OTEAL		0x14C
#define TSI148_LCSR_OT2_OTOFU		0x150
#define TSI148_LCSR_OT2_OTOFL		0x154
#define TSI148_LCSR_OT2_OTBS		0x158
#define TSI148_LCSR_OT2_OTAT		0x15C

#define TSI148_LCSR_OT3_OTSAU		0x160
#define TSI148_LCSR_OT3_OTSAL		0x164
#define TSI148_LCSR_OT3_OTEAU		0x168
#define TSI148_LCSR_OT3_OTEAL		0x16C
#define TSI148_LCSR_OT3_OTOFU		0x170
#define TSI148_LCSR_OT3_OTOFL		0x174
#define TSI148_LCSR_OT3_OTBS		0x178
#define TSI148_LCSR_OT3_OTAT		0x17C

#define TSI148_LCSR_OT4_OTSAU		0x180
#define TSI148_LCSR_OT4_OTSAL		0x184
#define TSI148_LCSR_OT4_OTEAU		0x188
#define TSI148_LCSR_OT4_OTEAL		0x18C
#define TSI148_LCSR_OT4_OTOFU		0x190
#define TSI148_LCSR_OT4_OTOFL		0x194
#define TSI148_LCSR_OT4_OTBS		0x198
#define TSI148_LCSR_OT4_OTAT		0x19C

#define TSI148_LCSR_OT5_OTSAU		0x1A0
#define TSI148_LCSR_OT5_OTSAL		0x1A4
#define TSI148_LCSR_OT5_OTEAU		0x1A8
#define TSI148_LCSR_OT5_OTEAL		0x1AC
#define TSI148_LCSR_OT5_OTOFU		0x1B0
#define TSI148_LCSR_OT5_OTOFL		0x1B4
#define TSI148_LCSR_OT5_OTBS		0x1B8
#define TSI148_LCSR_OT5_OTAT		0x1BC

#define TSI148_LCSR_OT6_OTSAU		0x1C0
#define TSI148_LCSR_OT6_OTSAL		0x1C4
#define TSI148_LCSR_OT6_OTEAU		0x1C8
#define TSI148_LCSR_OT6_OTEAL		0x1CC
#define TSI148_LCSR_OT6_OTOFU		0x1D0
#define TSI148_LCSR_OT6_OTOFL		0x1D4
#define TSI148_LCSR_OT6_OTBS		0x1D8
#define TSI148_LCSR_OT6_OTAT		0x1DC

#define TSI148_LCSR_OT7_OTSAU		0x1E0
#define TSI148_LCSR_OT7_OTSAL		0x1E4
#define TSI148_LCSR_OT7_OTEAU		0x1E8
#define TSI148_LCSR_OT7_OTEAL		0x1EC
#define TSI148_LCSR_OT7_OTOFU		0x1F0
#define TSI148_LCSR_OT7_OTOFL		0x1F4
#define TSI148_LCSR_OT7_OTBS		0x1F8
#define TSI148_LCSR_OT7_OTAT		0x1FC

#define TSI148_LCSR_OT0		0x100
#define TSI148_LCSR_OT1		0x120
#define TSI148_LCSR_OT2		0x140
#define TSI148_LCSR_OT3		0x160
#define TSI148_LCSR_OT4		0x180
#define TSI148_LCSR_OT5		0x1A0
#define TSI148_LCSR_OT6		0x1C0
#define TSI148_LCSR_OT7		0x1E0

static const int TSI148_LCSR_OT[8] = { TSI148_LCSR_OT0, TSI148_LCSR_OT1,
					 TSI148_LCSR_OT2, TSI148_LCSR_OT3,
					 TSI148_LCSR_OT4, TSI148_LCSR_OT5,
					 TSI148_LCSR_OT6, TSI148_LCSR_OT7 };

#define TSI148_LCSR_OFFSET_OTSAU	0x0
#define TSI148_LCSR_OFFSET_OTSAL	0x4
#define TSI148_LCSR_OFFSET_OTEAU	0x8
#define TSI148_LCSR_OFFSET_OTEAL	0xC
#define TSI148_LCSR_OFFSET_OTOFU	0x10
#define TSI148_LCSR_OFFSET_OTOFL	0x14
#define TSI148_LCSR_OFFSET_OTBS		0x18
#define TSI148_LCSR_OFFSET_OTAT		0x1C

/*
 * VMEbus interupt ack
 * offset  200
 */
#define TSI148_LCSR_VIACK1	0x204
#define TSI148_LCSR_VIACK2	0x208
#define TSI148_LCSR_VIACK3	0x20C
#define TSI148_LCSR_VIACK4	0x210
#define TSI148_LCSR_VIACK5	0x214
#define TSI148_LCSR_VIACK6	0x218
#define TSI148_LCSR_VIACK7	0x21C

static const int TSI148_LCSR_VIACK[8] = { 0, TSI148_LCSR_VIACK1,
				TSI148_LCSR_VIACK2, TSI148_LCSR_VIACK3,
				TSI148_LCSR_VIACK4, TSI148_LCSR_VIACK5,
				TSI148_LCSR_VIACK6, TSI148_LCSR_VIACK7 };

/*
 * RMW
 * offset    220
 */
#define TSI148_LCSR_RMWAU	0x220
#define TSI148_LCSR_RMWAL	0x224
#define TSI148_LCSR_RMWEN	0x228
#define TSI148_LCSR_RMWC	0x22C
#define TSI148_LCSR_RMWS	0x230

/*
 * VMEbus control
 * offset    234
 */
#define TSI148_LCSR_VMCTRL	0x234
#define TSI148_LCSR_VCTRL	0x238
#define TSI148_LCSR_VSTAT	0x23C

/*
 * PCI status
 * offset  240
 */
#define TSI148_LCSR_PSTAT	0x240

/*
 * VME filter.
 * offset  250
 */
#define TSI148_LCSR_VMEFL	0x250

	/*
	 * VME exception.
	 * offset  260
 */
#define TSI148_LCSR_VEAU	0x260
#define TSI148_LCSR_VEAL	0x264
#define TSI148_LCSR_VEAT	0x268

	/*
	 * PCI error
	 * offset  270
	 */
#define TSI148_LCSR_EDPAU	0x270
#define TSI148_LCSR_EDPAL	0x274
#define TSI148_LCSR_EDPXA	0x278
#define TSI148_LCSR_EDPXS	0x27C
#define TSI148_LCSR_EDPAT	0x280

	/*
	 * Inbound Translations
	 * offset  300
	 */
#define TSI148_LCSR_IT0_ITSAU		0x300
#define TSI148_LCSR_IT0_ITSAL		0x304
#define TSI148_LCSR_IT0_ITEAU		0x308
#define TSI148_LCSR_IT0_ITEAL		0x30C
#define TSI148_LCSR_IT0_ITOFU		0x310
#define TSI148_LCSR_IT0_ITOFL		0x314
#define TSI148_LCSR_IT0_ITAT		0x318

#define TSI148_LCSR_IT1_ITSAU		0x320
#define TSI148_LCSR_IT1_ITSAL		0x324
#define TSI148_LCSR_IT1_ITEAU		0x328
#define TSI148_LCSR_IT1_ITEAL		0x32C
#define TSI148_LCSR_IT1_ITOFU		0x330
#define TSI148_LCSR_IT1_ITOFL		0x334
#define TSI148_LCSR_IT1_ITAT		0x338

#define TSI148_LCSR_IT2_ITSAU		0x340
#define TSI148_LCSR_IT2_ITSAL		0x344
#define TSI148_LCSR_IT2_ITEAU		0x348
#define TSI148_LCSR_IT2_ITEAL		0x34C
#define TSI148_LCSR_IT2_ITOFU		0x350
#define TSI148_LCSR_IT2_ITOFL		0x354
#define TSI148_LCSR_IT2_ITAT		0x358

#define TSI148_LCSR_IT3_ITSAU		0x360
#define TSI148_LCSR_IT3_ITSAL		0x364
#define TSI148_LCSR_IT3_ITEAU		0x368
#define TSI148_LCSR_IT3_ITEAL		0x36C
#define TSI148_LCSR_IT3_ITOFU		0x370
#define TSI148_LCSR_IT3_ITOFL		0x374
#define TSI148_LCSR_IT3_ITAT		0x378

#define TSI148_LCSR_IT4_ITSAU		0x380
#define TSI148_LCSR_IT4_ITSAL		0x384
#define TSI148_LCSR_IT4_ITEAU		0x388
#define TSI148_LCSR_IT4_ITEAL		0x38C
#define TSI148_LCSR_IT4_ITOFU		0x390
#define TSI148_LCSR_IT4_ITOFL		0x394
#define TSI148_LCSR_IT4_ITAT		0x398

#define TSI148_LCSR_IT5_ITSAU		0x3A0
#define TSI148_LCSR_IT5_ITSAL		0x3A4
#define TSI148_LCSR_IT5_ITEAU		0x3A8
#define TSI148_LCSR_IT5_ITEAL		0x3AC
#define TSI148_LCSR_IT5_ITOFU		0x3B0
#define TSI148_LCSR_IT5_ITOFL		0x3B4
#define TSI148_LCSR_IT5_ITAT		0x3B8

#define TSI148_LCSR_IT6_ITSAU		0x3C0
#define TSI148_LCSR_IT6_ITSAL		0x3C4
#define TSI148_LCSR_IT6_ITEAU		0x3C8
#define TSI148_LCSR_IT6_ITEAL		0x3CC
#define TSI148_LCSR_IT6_ITOFU		0x3D0
#define TSI148_LCSR_IT6_ITOFL		0x3D4
#define TSI148_LCSR_IT6_ITAT		0x3D8

#define TSI148_LCSR_IT7_ITSAU		0x3E0
#define TSI148_LCSR_IT7_ITSAL		0x3E4
#define TSI148_LCSR_IT7_ITEAU		0x3E8
#define TSI148_LCSR_IT7_ITEAL		0x3EC
#define TSI148_LCSR_IT7_ITOFU		0x3F0
#define TSI148_LCSR_IT7_ITOFL		0x3F4
#define TSI148_LCSR_IT7_ITAT		0x3F8


#define TSI148_LCSR_IT0		0x300
#define TSI148_LCSR_IT1		0x320
#define TSI148_LCSR_IT2		0x340
#define TSI148_LCSR_IT3		0x360
#define TSI148_LCSR_IT4		0x380
#define TSI148_LCSR_IT5		0x3A0
#define TSI148_LCSR_IT6		0x3C0
#define TSI148_LCSR_IT7		0x3E0

static const int TSI148_LCSR_IT[8] = { TSI148_LCSR_IT0, TSI148_LCSR_IT1,
					 TSI148_LCSR_IT2, TSI148_LCSR_IT3,
					 TSI148_LCSR_IT4, TSI148_LCSR_IT5,
					 TSI148_LCSR_IT6, TSI148_LCSR_IT7 };

#define TSI148_LCSR_OFFSET_ITSAU	0x0
#define TSI148_LCSR_OFFSET_ITSAL	0x4
#define TSI148_LCSR_OFFSET_ITEAU	0x8
#define TSI148_LCSR_OFFSET_ITEAL	0xC
#define TSI148_LCSR_OFFSET_ITOFU	0x10
#define TSI148_LCSR_OFFSET_ITOFL	0x14
#define TSI148_LCSR_OFFSET_ITAT		0x18

	/*
	 * Inbound Translation GCSR
	 * offset  400
	 */
#define TSI148_LCSR_GBAU	0x400
#define TSI148_LCSR_GBAL	0x404
#define TSI148_LCSR_GCSRAT	0x408

	/*
	 * Inbound Translation CRG
	 * offset  40C
	 */
#define TSI148_LCSR_CBAU	0x40C
#define TSI148_LCSR_CBAL	0x410
#define TSI148_LCSR_CSRAT	0x414

	/*
	 * Inbound Translation CR/CSR
	 *         CRG
	 * offset  418
	 */
#define TSI148_LCSR_CROU	0x418
#define TSI148_LCSR_CROL	0x41C
#define TSI148_LCSR_CRAT	0x420

	/*
	 * Inbound Translation Location Monitor
	 * offset  424
	 */
#define TSI148_LCSR_LMBAU	0x424
#define TSI148_LCSR_LMBAL	0x428
#define TSI148_LCSR_LMAT	0x42C

	/*
	 * VMEbus Interrupt Control.
	 * offset  430
	 */
#define TSI148_LCSR_BCU		0x430
#define TSI148_LCSR_BCL		0x434
#define TSI148_LCSR_BPGTR	0x438
#define TSI148_LCSR_BPCTR	0x43C
#define TSI148_LCSR_VICR	0x440

	/*
	 * Local Bus Interrupt Control.
	 * offset  448
	 */
#define TSI148_LCSR_INTEN	0x448
#define TSI148_LCSR_INTEO	0x44C
#define TSI148_LCSR_INTS	0x450
#define TSI148_LCSR_INTC	0x454
#define TSI148_LCSR_INTM1	0x458
#define TSI148_LCSR_INTM2	0x45C

	/*
	 * DMA Controllers
	 * offset 500
	 */
#define TSI148_LCSR_DCTL0	0x500
#define TSI148_LCSR_DSTA0	0x504
#define TSI148_LCSR_DCSAU0	0x508
#define TSI148_LCSR_DCSAL0	0x50C
#define TSI148_LCSR_DCDAU0	0x510
#define TSI148_LCSR_DCDAL0	0x514
#define TSI148_LCSR_DCLAU0	0x518
#define TSI148_LCSR_DCLAL0	0x51C
#define TSI148_LCSR_DSAU0	0x520
#define TSI148_LCSR_DSAL0	0x524
#define TSI148_LCSR_DDAU0	0x528
#define TSI148_LCSR_DDAL0	0x52C
#define TSI148_LCSR_DSAT0	0x530
#define TSI148_LCSR_DDAT0	0x534
#define TSI148_LCSR_DNLAU0	0x538
#define TSI148_LCSR_DNLAL0	0x53C
#define TSI148_LCSR_DCNT0	0x540
#define TSI148_LCSR_DDBS0	0x544

#define TSI148_LCSR_DCTL1	0x580
#define TSI148_LCSR_DSTA1	0x584
#define TSI148_LCSR_DCSAU1	0x588
#define TSI148_LCSR_DCSAL1	0x58C
#define TSI148_LCSR_DCDAU1	0x590
#define TSI148_LCSR_DCDAL1	0x594
#define TSI148_LCSR_DCLAU1	0x598
#define TSI148_LCSR_DCLAL1	0x59C
#define TSI148_LCSR_DSAU1	0x5A0
#define TSI148_LCSR_DSAL1	0x5A4
#define TSI148_LCSR_DDAU1	0x5A8
#define TSI148_LCSR_DDAL1	0x5AC
#define TSI148_LCSR_DSAT1	0x5B0
#define TSI148_LCSR_DDAT1	0x5B4
#define TSI148_LCSR_DNLAU1	0x5B8
#define TSI148_LCSR_DNLAL1	0x5BC
#define TSI148_LCSR_DCNT1	0x5C0
#define TSI148_LCSR_DDBS1	0x5C4

#define TSI148_LCSR_DMA0	0x500
#define TSI148_LCSR_DMA1	0x580


static const int TSI148_LCSR_DMA[TSI148_MAX_DMA] = { TSI148_LCSR_DMA0,
						TSI148_LCSR_DMA1 };

#define TSI148_LCSR_OFFSET_DCTL		0x0
#define TSI148_LCSR_OFFSET_DSTA		0x4
#define TSI148_LCSR_OFFSET_DCSAU	0x8
#define TSI148_LCSR_OFFSET_DCSAL	0xC
#define TSI148_LCSR_OFFSET_DCDAU	0x10
#define TSI148_LCSR_OFFSET_DCDAL	0x14
#define TSI148_LCSR_OFFSET_DCLAU	0x18
#define TSI148_LCSR_OFFSET_DCLAL	0x1C
#define TSI148_LCSR_OFFSET_DSAU		0x20
#define TSI148_LCSR_OFFSET_DSAL		0x24
#define TSI148_LCSR_OFFSET_DDAU		0x28
#define TSI148_LCSR_OFFSET_DDAL		0x2C
#define TSI148_LCSR_OFFSET_DSAT		0x30
#define TSI148_LCSR_OFFSET_DDAT		0x34
#define TSI148_LCSR_OFFSET_DNLAU	0x38
#define TSI148_LCSR_OFFSET_DNLAL	0x3C
#define TSI148_LCSR_OFFSET_DCNT		0x40
#define TSI148_LCSR_OFFSET_DDBS		0x44

	/*
	 * GCSR Register Group
	 */

	/*
	 *         GCSR    CRG
	 * offset   00     600 - DEVI/VENI
	 * offset   04     604 - CTRL/GA/REVID
	 * offset   08     608 - Semaphore3/2/1/0
	 * offset   0C     60C - Seamphore7/6/5/4
	 */
#define TSI148_GCSR_ID		0x600
#define TSI148_GCSR_CSR		0x604
#define TSI148_GCSR_SEMA0	0x608
#define TSI148_GCSR_SEMA1	0x60C

	/*
	 * Mail Box
	 *         GCSR    CRG
	 * offset   10     610 - Mailbox0
	 */
#define TSI148_GCSR_MBOX0	0x610
#define TSI148_GCSR_MBOX1	0x614
#define TSI148_GCSR_MBOX2	0x618
#define TSI148_GCSR_MBOX3	0x61C

static const int TSI148_GCSR_MBOX[4] = { TSI148_GCSR_MBOX0,
					TSI148_GCSR_MBOX1,
					TSI148_GCSR_MBOX2,
					TSI148_GCSR_MBOX3 };

	/*
	 * CR/CSR
	 */

	/*
	 *        CR/CSR   CRG
	 * offset  7FFF4   FF4 - CSRBCR
	 * offset  7FFF8   FF8 - CSRBSR
	 * offset  7FFFC   FFC - CBAR
	 */
#define TSI148_CSRBCR	0xFF4
#define TSI148_CSRBSR	0xFF8
#define TSI148_CBAR	0xFFC




	/*
	 *  TSI148 Register Bit Definitions
	 */

	/*
	 *  PFCS Register Set
	 */
#define TSI148_PCFS_CMMD_SERR          (1<<8)	/* SERR_L out pin ssys err */
#define TSI148_PCFS_CMMD_PERR          (1<<6)	/* PERR_L out pin  parity */
#define TSI148_PCFS_CMMD_MSTR          (1<<2)	/* PCI bus master */
#define TSI148_PCFS_CMMD_MEMSP         (1<<1)	/* PCI mem space access  */
#define TSI148_PCFS_CMMD_IOSP          (1<<0)	/* PCI I/O space enable */

#define TSI148_PCFS_STAT_RCPVE         (1<<15)	/* Detected Parity Error */
#define TSI148_PCFS_STAT_SIGSE         (1<<14)	/* Signalled System Error */
#define TSI148_PCFS_STAT_RCVMA         (1<<13)	/* Received Master Abort */
#define TSI148_PCFS_STAT_RCVTA         (1<<12)	/* Received Target Abort */
#define TSI148_PCFS_STAT_SIGTA         (1<<11)	/* Signalled Target Abort */
#define TSI148_PCFS_STAT_SELTIM        (3<<9)	/* DELSEL Timing */
#define TSI148_PCFS_STAT_DPAR          (1<<8)	/* Data Parity Err Reported */
#define TSI148_PCFS_STAT_FAST          (1<<7)	/* Fast back-to-back Cap */
#define TSI148_PCFS_STAT_P66M          (1<<5)	/* 66 MHz Capable */
#define TSI148_PCFS_STAT_CAPL          (1<<4)	/* Capab List - address $34 */

/*
 *  Revision ID/Class Code Registers   (CRG +$008)
 */
#define TSI148_PCFS_CLAS_M             (0xFF<<24)	/* Class ID */
#define TSI148_PCFS_SUBCLAS_M          (0xFF<<16)	/* Sub-Class ID */
#define TSI148_PCFS_PROGIF_M           (0xFF<<8)	/* Sub-Class ID */
#define TSI148_PCFS_REVID_M            (0xFF<<0)	/* Rev ID */

/*
 * Cache Line Size/ Master Latency Timer/ Header Type Registers (CRG + $00C)
 */
#define TSI148_PCFS_HEAD_M             (0xFF<<16)	/* Master Lat Timer */
#define TSI148_PCFS_MLAT_M             (0xFF<<8)	/* Master Lat Timer */
#define TSI148_PCFS_CLSZ_M             (0xFF<<0)	/* Cache Line Size */

/*
 *  Memory Base Address Lower Reg (CRG + $010)
 */
#define TSI148_PCFS_MBARL_BASEL_M      (0xFFFFF<<12) /* Base Addr Lower Mask */
#define TSI148_PCFS_MBARL_PRE          (1<<3)	/* Prefetch */
#define TSI148_PCFS_MBARL_MTYPE_M      (3<<1)	/* Memory Type Mask */
#define TSI148_PCFS_MBARL_IOMEM        (1<<0)	/* I/O Space Indicator */

/*
 *  Message Signaled Interrupt Capabilities Register (CRG + $040)
 */
#define TSI148_PCFS_MSICAP_64BAC       (1<<7)	/* 64-bit Address Capable */
#define TSI148_PCFS_MSICAP_MME_M       (7<<4)	/* Multiple Msg Enable Mask */
#define TSI148_PCFS_MSICAP_MMC_M       (7<<1)	/* Multiple Msg Capable Mask */
#define TSI148_PCFS_MSICAP_MSIEN       (1<<0)	/* Msg signaled INT Enable */

/*
 *  Message Address Lower Register (CRG +$044)
 */
#define TSI148_PCFS_MSIAL_M            (0x3FFFFFFF<<2)	/* Mask */

/*
 *  Message Data Register (CRG + 4C)
 */
#define TSI148_PCFS_MSIMD_M            (0xFFFF<<0)	/* Mask */

/*
 *  PCI-X Capabilities Register (CRG + $050)
 */
#define TSI148_PCFS_PCIXCAP_MOST_M     (7<<4)	/* Max outstanding Split Tran */
#define TSI148_PCFS_PCIXCAP_MMRBC_M    (3<<2)	/* Max Mem Read byte cnt */
#define TSI148_PCFS_PCIXCAP_ERO        (1<<1)	/* Enable Relaxed Ordering */
#define TSI148_PCFS_PCIXCAP_DPERE      (1<<0)	/* Data Parity Recover Enable */

/*
 *  PCI-X Status Register (CRG +$054)
 */
#define TSI148_PCFS_PCIXSTAT_RSCEM     (1<<29)	/* Recieved Split Comp Error */
#define TSI148_PCFS_PCIXSTAT_DMCRS_M   (7<<26)	/* max Cumulative Read Size */
#define TSI148_PCFS_PCIXSTAT_DMOST_M   (7<<23)	/* max outstanding Split Trans
						 */
#define TSI148_PCFS_PCIXSTAT_DMMRC_M   (3<<21)	/* max mem read byte count */
#define TSI148_PCFS_PCIXSTAT_DC        (1<<20)	/* Device Complexity */
#define TSI148_PCFS_PCIXSTAT_USC       (1<<19)	/* Unexpected Split comp */
#define TSI148_PCFS_PCIXSTAT_SCD       (1<<18)	/* Split completion discard */
#define TSI148_PCFS_PCIXSTAT_133C      (1<<17)	/* 133MHz capable */
#define TSI148_PCFS_PCIXSTAT_64D       (1<<16)	/* 64 bit device */
#define TSI148_PCFS_PCIXSTAT_BN_M      (0xFF<<8)	/* Bus number */
#define TSI148_PCFS_PCIXSTAT_DN_M      (0x1F<<3)	/* Device number */
#define TSI148_PCFS_PCIXSTAT_FN_M      (7<<0)	/* Function Number */

/*
 *  LCSR Registers
 */

/*
 *  Outbound Translation Starting Address Lower
 */
#define TSI148_LCSR_OTSAL_M            (0xFFFF<<16)	/* Mask */

/*
 *  Outbound Translation Ending Address Lower
 */
#define TSI148_LCSR_OTEAL_M            (0xFFFF<<16)	/* Mask */

/*
 *  Outbound Translation Offset Lower
 */
#define TSI148_LCSR_OTOFFL_M           (0xFFFF<<16)	/* Mask */

/*
 *  Outbound Translation 2eSST Broadcast Select
 */
#define TSI148_LCSR_OTBS_M             (0xFFFFF<<0)	/* Mask */

/*
 *  Outbound Translation Attribute
 */
#define TSI148_LCSR_OTAT_EN            (1<<31)	/* Window Enable */
#define TSI148_LCSR_OTAT_MRPFD         (1<<18)	/* Prefetch Disable */

#define TSI148_LCSR_OTAT_PFS_M         (3<<16)	/* Prefetch Size Mask */
#define TSI148_LCSR_OTAT_PFS_2         (0<<16)	/* 2 Cache Lines P Size */
#define TSI148_LCSR_OTAT_PFS_4         (1<<16)	/* 4 Cache Lines P Size */
#define TSI148_LCSR_OTAT_PFS_8         (2<<16)	/* 8 Cache Lines P Size */
#define TSI148_LCSR_OTAT_PFS_16        (3<<16)	/* 16 Cache Lines P Size */

#define TSI148_LCSR_OTAT_2eSSTM_M      (7<<11)	/* 2eSST Xfer Rate Mask */
#define TSI148_LCSR_OTAT_2eSSTM_160    (0<<11)	/* 160MB/s 2eSST Xfer Rate */
#define TSI148_LCSR_OTAT_2eSSTM_267    (1<<11)	/* 267MB/s 2eSST Xfer Rate */
#define TSI148_LCSR_OTAT_2eSSTM_320    (2<<11)	/* 320MB/s 2eSST Xfer Rate */

#define TSI148_LCSR_OTAT_TM_M          (7<<8)	/* Xfer Protocol Mask */
#define TSI148_LCSR_OTAT_TM_SCT        (0<<8)	/* SCT Xfer Protocol */
#define TSI148_LCSR_OTAT_TM_BLT        (1<<8)	/* BLT Xfer Protocol */
#define TSI148_LCSR_OTAT_TM_MBLT       (2<<8)	/* MBLT Xfer Protocol */
#define TSI148_LCSR_OTAT_TM_2eVME      (3<<8)	/* 2eVME Xfer Protocol */
#define TSI148_LCSR_OTAT_TM_2eSST      (4<<8)	/* 2eSST Xfer Protocol */
#define TSI148_LCSR_OTAT_TM_2eSSTB     (5<<8)	/* 2eSST Bcast Xfer Protocol */

#define TSI148_LCSR_OTAT_DBW_M         (3<<6)	/* Max Data Width */
#define TSI148_LCSR_OTAT_DBW_16        (0<<6)	/* 16-bit Data Width */
#define TSI148_LCSR_OTAT_DBW_32        (1<<6)	/* 32-bit Data Width */

#define TSI148_LCSR_OTAT_SUP           (1<<5)	/* Supervisory Access */
#define TSI148_LCSR_OTAT_PGM           (1<<4)	/* Program Access */

#define TSI148_LCSR_OTAT_AMODE_M       (0xf<<0)	/* Address Mode Mask */
#define TSI148_LCSR_OTAT_AMODE_A16     (0<<0)	/* A16 Address Space */
#define TSI148_LCSR_OTAT_AMODE_A24     (1<<0)	/* A24 Address Space */
#define TSI148_LCSR_OTAT_AMODE_A32     (2<<0)	/* A32 Address Space */
#define TSI148_LCSR_OTAT_AMODE_A64     (4<<0)	/* A32 Address Space */
#define TSI148_LCSR_OTAT_AMODE_CRCSR   (5<<0)	/* CR/CSR Address Space */
#define TSI148_LCSR_OTAT_AMODE_USER1   (8<<0)	/* User1 Address Space */
#define TSI148_LCSR_OTAT_AMODE_USER2   (9<<0)	/* User2 Address Space */
#define TSI148_LCSR_OTAT_AMODE_USER3   (10<<0)	/* User3 Address Space */
#define TSI148_LCSR_OTAT_AMODE_USER4   (11<<0)	/* User4 Address Space */

/*
 *  VME Master Control Register  CRG+$234
 */
#define TSI148_LCSR_VMCTRL_VSA         (1<<27)	/* VMEbus Stop Ack */
#define TSI148_LCSR_VMCTRL_VS          (1<<26)	/* VMEbus Stop */
#define TSI148_LCSR_VMCTRL_DHB         (1<<25)	/* Device Has Bus */
#define TSI148_LCSR_VMCTRL_DWB         (1<<24)	/* Device Wants Bus */

#define TSI148_LCSR_VMCTRL_RMWEN       (1<<20)	/* RMW Enable */

#define TSI148_LCSR_VMCTRL_ATO_M       (7<<16)	/* Master Access Time-out Mask
						 */
#define TSI148_LCSR_VMCTRL_ATO_32      (0<<16)	/* 32 us */
#define TSI148_LCSR_VMCTRL_ATO_128     (1<<16)	/* 128 us */
#define TSI148_LCSR_VMCTRL_ATO_512     (2<<16)	/* 512 us */
#define TSI148_LCSR_VMCTRL_ATO_2M      (3<<16)	/* 2 ms */
#define TSI148_LCSR_VMCTRL_ATO_8M      (4<<16)	/* 8 ms */
#define TSI148_LCSR_VMCTRL_ATO_32M     (5<<16)	/* 32 ms */
#define TSI148_LCSR_VMCTRL_ATO_128M    (6<<16)	/* 128 ms */
#define TSI148_LCSR_VMCTRL_ATO_DIS     (7<<16)	/* Disabled */

#define TSI148_LCSR_VMCTRL_VTOFF_M     (7<<12)	/* VMEbus Master Time off */
#define TSI148_LCSR_VMCTRL_VTOFF_0     (0<<12)	/* 0us */
#define TSI148_LCSR_VMCTRL_VTOFF_1     (1<<12)	/* 1us */
#define TSI148_LCSR_VMCTRL_VTOFF_2     (2<<12)	/* 2us */
#define TSI148_LCSR_VMCTRL_VTOFF_4     (3<<12)	/* 4us */
#define TSI148_LCSR_VMCTRL_VTOFF_8     (4<<12)	/* 8us */
#define TSI148_LCSR_VMCTRL_VTOFF_16    (5<<12)	/* 16us */
#define TSI148_LCSR_VMCTRL_VTOFF_32    (6<<12)	/* 32us */
#define TSI148_LCSR_VMCTRL_VTOFF_64    (7<<12)	/* 64us */

#define TSI148_LCSR_VMCTRL_VTON_M      (7<<8)	/* VMEbus Master Time On */
#define TSI148_LCSR_VMCTRL_VTON_4      (0<<8)	/* 8us */
#define TSI148_LCSR_VMCTRL_VTON_8      (1<<8)	/* 8us */
#define TSI148_LCSR_VMCTRL_VTON_16     (2<<8)	/* 16us */
#define TSI148_LCSR_VMCTRL_VTON_32     (3<<8)	/* 32us */
#define TSI148_LCSR_VMCTRL_VTON_64     (4<<8)	/* 64us */
#define TSI148_LCSR_VMCTRL_VTON_128    (5<<8)	/* 128us */
#define TSI148_LCSR_VMCTRL_VTON_256    (6<<8)	/* 256us */
#define TSI148_LCSR_VMCTRL_VTON_512    (7<<8)	/* 512us */

#define TSI148_LCSR_VMCTRL_VREL_M      (3<<3)	/* VMEbus Master Rel Mode Mask
						 */
#define TSI148_LCSR_VMCTRL_VREL_T_D    (0<<3)	/* Time on or Done */
#define TSI148_LCSR_VMCTRL_VREL_T_R_D  (1<<3)	/* Time on and REQ or Done */
#define TSI148_LCSR_VMCTRL_VREL_T_B_D  (2<<3)	/* Time on and BCLR or Done */
#define TSI148_LCSR_VMCTRL_VREL_T_D_R  (3<<3)	/* Time on or Done and REQ */

#define TSI148_LCSR_VMCTRL_VFAIR       (1<<2)	/* VMEbus Master Fair Mode */
#define TSI148_LCSR_VMCTRL_VREQL_M     (3<<0)	/* VMEbus Master Req Level Mask
						 */

/*
 *  VMEbus Control Register CRG+$238
 */
#define TSI148_LCSR_VCTRL_LRE          (1<<31)	/* Late Retry Enable */

#define TSI148_LCSR_VCTRL_DLT_M        (0xF<<24)	/* Deadlock Timer */
#define TSI148_LCSR_VCTRL_DLT_OFF      (0<<24)	/* Deadlock Timer Off */
#define TSI148_LCSR_VCTRL_DLT_16       (1<<24)	/* 16 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_32       (2<<24)	/* 32 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_64       (3<<24)	/* 64 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_128      (4<<24)	/* 128 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_256      (5<<24)	/* 256 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_512      (6<<24)	/* 512 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_1024     (7<<24)	/* 1024 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_2048     (8<<24)	/* 2048 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_4096     (9<<24)	/* 4096 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_8192     (0xA<<24)	/* 8192 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_16384    (0xB<<24)	/* 16384 VCLKS */
#define TSI148_LCSR_VCTRL_DLT_32768    (0xC<<24)	/* 32768 VCLKS */

#define TSI148_LCSR_VCTRL_NERBB        (1<<20)	/* No Early Release of Bus Busy
						 */

#define TSI148_LCSR_VCTRL_SRESET       (1<<17)	/* System Reset */
#define TSI148_LCSR_VCTRL_LRESET       (1<<16)	/* Local Reset */

#define TSI148_LCSR_VCTRL_SFAILAI      (1<<15)	/* SYSFAIL Auto Slot ID */
#define TSI148_LCSR_VCTRL_BID_M        (0x1F<<8)	/* Broadcast ID Mask */

#define TSI148_LCSR_VCTRL_ATOEN        (1<<7)	/* Arbiter Time-out Enable */
#define TSI148_LCSR_VCTRL_ROBIN        (1<<6)	/* VMEbus Round Robin */

#define TSI148_LCSR_VCTRL_GTO_M        (7<<0)	/* VMEbus Global Time-out Mask
						 */
#define TSI148_LCSR_VCTRL_GTO_8	      (0<<0)	/* 8 us */
#define TSI148_LCSR_VCTRL_GTO_16	      (1<<0)	/* 16 us */
#define TSI148_LCSR_VCTRL_GTO_32	      (2<<0)	/* 32 us */
#define TSI148_LCSR_VCTRL_GTO_64	      (3<<0)	/* 64 us */
#define TSI148_LCSR_VCTRL_GTO_128      (4<<0)	/* 128 us */
#define TSI148_LCSR_VCTRL_GTO_256      (5<<0)	/* 256 us */
#define TSI148_LCSR_VCTRL_GTO_512      (6<<0)	/* 512 us */
#define TSI148_LCSR_VCTRL_GTO_DIS      (7<<0)	/* Disabled */

/*
 *  VMEbus Status Register  CRG + $23C
 */
#define TSI148_LCSR_VSTAT_CPURST       (1<<15)	/* Clear power up reset */
#define TSI148_LCSR_VSTAT_BRDFL        (1<<14)	/* Board fail */
#define TSI148_LCSR_VSTAT_PURSTS       (1<<12)	/* Power up reset status */
#define TSI148_LCSR_VSTAT_BDFAILS      (1<<11)	/* Board Fail Status */
#define TSI148_LCSR_VSTAT_SYSFAILS     (1<<10)	/* System Fail Status */
#define TSI148_LCSR_VSTAT_ACFAILS      (1<<9)	/* AC fail status */
#define TSI148_LCSR_VSTAT_SCONS        (1<<8)	/* System Cont Status */
#define TSI148_LCSR_VSTAT_GAP          (1<<5)	/* Geographic Addr Parity */
#define TSI148_LCSR_VSTAT_GA_M         (0x1F<<0)  /* Geographic Addr Mask */

/*
 *  PCI Configuration Status Register CRG+$240
 */
#define TSI148_LCSR_PSTAT_REQ64S       (1<<6)	/* Request 64 status set */
#define TSI148_LCSR_PSTAT_M66ENS       (1<<5)	/* M66ENS 66Mhz enable */
#define TSI148_LCSR_PSTAT_FRAMES       (1<<4)	/* Frame Status */
#define TSI148_LCSR_PSTAT_IRDYS        (1<<3)	/* IRDY status */
#define TSI148_LCSR_PSTAT_DEVSELS      (1<<2)	/* DEVL status */
#define TSI148_LCSR_PSTAT_STOPS        (1<<1)	/* STOP status */
#define TSI148_LCSR_PSTAT_TRDYS        (1<<0)	/* TRDY status */

/*
 *  VMEbus Exception Attributes Register  CRG + $268
 */
#define TSI148_LCSR_VEAT_VES           (1<<31)	/* Status */
#define TSI148_LCSR_VEAT_VEOF          (1<<30)	/* Overflow */
#define TSI148_LCSR_VEAT_VESCL         (1<<29)	/* Status Clear */
#define TSI148_LCSR_VEAT_2EOT          (1<<21)	/* 2e Odd Termination */
#define TSI148_LCSR_VEAT_2EST          (1<<20)	/* 2e Slave terminated */
#define TSI148_LCSR_VEAT_BERR          (1<<19)	/* Bus Error */
#define TSI148_LCSR_VEAT_LWORD         (1<<18)	/* LWORD_ signal state */
#define TSI148_LCSR_VEAT_WRITE         (1<<17)	/* WRITE_ signal state */
#define TSI148_LCSR_VEAT_IACK          (1<<16)	/* IACK_ signal state */
#define TSI148_LCSR_VEAT_DS1           (1<<15)	/* DS1_ signal state */
#define TSI148_LCSR_VEAT_DS0           (1<<14)	/* DS0_ signal state */
#define TSI148_LCSR_VEAT_AM_M          (0x3F<<8)	/* Address Mode Mask */
#define TSI148_LCSR_VEAT_XAM_M         (0xFF<<0)	/* Master AMode Mask */


/*
 * VMEbus PCI Error Diagnostics PCI/X Attributes Register  CRG + $280
 */
#define TSI148_LCSR_EDPAT_EDPCL        (1<<29)

/*
 *  Inbound Translation Starting Address Lower
 */
#define TSI148_LCSR_ITSAL6432_M        (0xFFFF<<16)	/* Mask */
#define TSI148_LCSR_ITSAL24_M          (0x00FFF<<12)	/* Mask */
#define TSI148_LCSR_ITSAL16_M          (0x0000FFF<<4)	/* Mask */

/*
 *  Inbound Translation Ending Address Lower
 */
#define TSI148_LCSR_ITEAL6432_M        (0xFFFF<<16)	/* Mask */
#define TSI148_LCSR_ITEAL24_M          (0x00FFF<<12)	/* Mask */
#define TSI148_LCSR_ITEAL16_M          (0x0000FFF<<4)	/* Mask */

/*
 *  Inbound Translation Offset Lower
 */
#define TSI148_LCSR_ITOFFL6432_M       (0xFFFF<<16)	/* Mask */
#define TSI148_LCSR_ITOFFL24_M         (0xFFFFF<<12)	/* Mask */
#define TSI148_LCSR_ITOFFL16_M         (0xFFFFFFF<<4)	/* Mask */

/*
 *  Inbound Translation Attribute
 */
#define TSI148_LCSR_ITAT_EN            (1<<31)	/* Window Enable */
#define TSI148_LCSR_ITAT_TH            (1<<18)	/* Prefetch Threshold */

#define TSI148_LCSR_ITAT_VFS_M         (3<<16)	/* Virtual FIFO Size Mask */
#define TSI148_LCSR_ITAT_VFS_64        (0<<16)	/* 64 bytes Virtual FIFO Size */
#define TSI148_LCSR_ITAT_VFS_128       (1<<16)	/* 128 bytes Virtual FIFO Sz */
#define TSI148_LCSR_ITAT_VFS_256       (2<<16)	/* 256 bytes Virtual FIFO Sz */
#define TSI148_LCSR_ITAT_VFS_512       (3<<16)	/* 512 bytes Virtual FIFO Sz */

#define TSI148_LCSR_ITAT_2eSSTM_M      (7<<12)	/* 2eSST Xfer Rate Mask */
#define TSI148_LCSR_ITAT_2eSSTM_160    (0<<12)	/* 160MB/s 2eSST Xfer Rate */
#define TSI148_LCSR_ITAT_2eSSTM_267    (1<<12)	/* 267MB/s 2eSST Xfer Rate */
#define TSI148_LCSR_ITAT_2eSSTM_320    (2<<12)	/* 320MB/s 2eSST Xfer Rate */

#define TSI148_LCSR_ITAT_2eSSTB        (1<<11)	/* 2eSST Bcast Xfer Protocol */
#define TSI148_LCSR_ITAT_2eSST         (1<<10)	/* 2eSST Xfer Protocol */
#define TSI148_LCSR_ITAT_2eVME         (1<<9)	/* 2eVME Xfer Protocol */
#define TSI148_LCSR_ITAT_MBLT          (1<<8)	/* MBLT Xfer Protocol */
#define TSI148_LCSR_ITAT_BLT           (1<<7)	/* BLT Xfer Protocol */

#define TSI148_LCSR_ITAT_AS_M          (7<<4)	/* Address Space Mask */
#define TSI148_LCSR_ITAT_AS_A16        (0<<4)	/* A16 Address Space */
#define TSI148_LCSR_ITAT_AS_A24        (1<<4)	/* A24 Address Space */
#define TSI148_LCSR_ITAT_AS_A32        (2<<4)	/* A32 Address Space */
#define TSI148_LCSR_ITAT_AS_A64        (4<<4)	/* A64 Address Space */

#define TSI148_LCSR_ITAT_SUPR          (1<<3)	/* Supervisor Access */
#define TSI148_LCSR_ITAT_NPRIV         (1<<2)	/* Non-Priv (User) Access */
#define TSI148_LCSR_ITAT_PGM           (1<<1)	/* Program Access */
#define TSI148_LCSR_ITAT_DATA          (1<<0)	/* Data Access */

/*
 *  GCSR Base Address Lower Address  CRG +$404
 */
#define TSI148_LCSR_GBAL_M             (0x7FFFFFF<<5)	/* Mask */

/*
 *  GCSR Attribute Register CRG + $408
 */
#define TSI148_LCSR_GCSRAT_EN          (1<<7)	/* Enable access to GCSR */

#define TSI148_LCSR_GCSRAT_AS_M        (7<<4)	/* Address Space Mask */
#define TSI148_LCSR_GCSRAT_AS_A16       (0<<4)	/* Address Space 16 */
#define TSI148_LCSR_GCSRAT_AS_A24       (1<<4)	/* Address Space 24 */
#define TSI148_LCSR_GCSRAT_AS_A32       (2<<4)	/* Address Space 32 */
#define TSI148_LCSR_GCSRAT_AS_A64       (4<<4)	/* Address Space 64 */

#define TSI148_LCSR_GCSRAT_SUPR        (1<<3)	/* Sup set -GCSR decoder */
#define TSI148_LCSR_GCSRAT_NPRIV       (1<<2)	/* Non-Privliged set - CGSR */
#define TSI148_LCSR_GCSRAT_PGM         (1<<1)	/* Program set - GCSR decoder */
#define TSI148_LCSR_GCSRAT_DATA        (1<<0)	/* DATA set GCSR decoder */

/*
 *  CRG Base Address Lower Address  CRG + $410
 */
#define TSI148_LCSR_CBAL_M             (0xFFFFF<<12)

/*
 *  CRG Attribute Register  CRG + $414
 */
#define TSI148_LCSR_CRGAT_EN           (1<<7)	/* Enable PRG Access */

#define TSI148_LCSR_CRGAT_AS_M         (7<<4)	/* Address Space */
#define TSI148_LCSR_CRGAT_AS_A16       (0<<4)	/* Address Space 16 */
#define TSI148_LCSR_CRGAT_AS_A24       (1<<4)	/* Address Space 24 */
#define TSI148_LCSR_CRGAT_AS_A32       (2<<4)	/* Address Space 32 */
#define TSI148_LCSR_CRGAT_AS_A64       (4<<4)	/* Address Space 64 */

#define TSI148_LCSR_CRGAT_SUPR         (1<<3)	/* Supervisor Access */
#define TSI148_LCSR_CRGAT_NPRIV        (1<<2)	/* Non-Privliged(User) Access */
#define TSI148_LCSR_CRGAT_PGM          (1<<1)	/* Program Access */
#define TSI148_LCSR_CRGAT_DATA         (1<<0)	/* Data Access */

/*
 *  CR/CSR Offset Lower Register  CRG + $41C
 */
#define TSI148_LCSR_CROL_M             (0x1FFF<<19)	/* Mask */

/*
 *  CR/CSR Attribute register  CRG + $420
 */
#define TSI148_LCSR_CRAT_EN            (1<<7)	/* Enable access to CR/CSR */

/*
 *  Location Monitor base address lower register  CRG + $428
 */
#define TSI148_LCSR_LMBAL_M            (0x7FFFFFF<<5)	/* Mask */

/*
 *  Location Monitor Attribute Register  CRG + $42C
 */
#define TSI148_LCSR_LMAT_EN            (1<<7)	/* Enable Location Monitor */

#define TSI148_LCSR_LMAT_AS_M          (7<<4)	/* Address Space MASK  */
#define TSI148_LCSR_LMAT_AS_A16        (0<<4)	/* A16 */
#define TSI148_LCSR_LMAT_AS_A24        (1<<4)	/* A24 */
#define TSI148_LCSR_LMAT_AS_A32        (2<<4)	/* A32 */
#define TSI148_LCSR_LMAT_AS_A64        (4<<4)	/* A64 */

#define TSI148_LCSR_LMAT_SUPR          (1<<3)	/* Supervisor Access */
#define TSI148_LCSR_LMAT_NPRIV         (1<<2)	/* Non-Priv (User) Access */
#define TSI148_LCSR_LMAT_PGM           (1<<1)	/* Program Access */
#define TSI148_LCSR_LMAT_DATA          (1<<0)	/* Data Access  */

/*
 *  Broadcast Pulse Generator Timer Register  CRG + $438
 */
#define TSI148_LCSR_BPGTR_BPGT_M       (0xFFFF<<0)	/* Mask */

/*
 *  Broadcast Programmable Clock Timer Register  CRG + $43C
 */
#define TSI148_LCSR_BPCTR_BPCT_M       (0xFFFFFF<<0)	/* Mask */

/*
 *  VMEbus Interrupt Control Register           CRG + $43C
 */
#define TSI148_LCSR_VICR_CNTS_M        (3<<22)	/* Cntr Source MASK */
#define TSI148_LCSR_VICR_CNTS_DIS      (1<<22)	/* Cntr Disable */
#define TSI148_LCSR_VICR_CNTS_IRQ1     (2<<22)	/* IRQ1 to Cntr */
#define TSI148_LCSR_VICR_CNTS_IRQ2     (3<<22)	/* IRQ2 to Cntr */

#define TSI148_LCSR_VICR_EDGIS_M       (3<<20)	/* Edge interupt MASK */
#define TSI148_LCSR_VICR_EDGIS_DIS     (1<<20)	/* Edge interupt Disable */
#define TSI148_LCSR_VICR_EDGIS_IRQ1    (2<<20)	/* IRQ1 to Edge */
#define TSI148_LCSR_VICR_EDGIS_IRQ2    (3<<20)	/* IRQ2 to Edge */

#define TSI148_LCSR_VICR_IRQIF_M       (3<<18)	/* IRQ1* Function MASK */
#define TSI148_LCSR_VICR_IRQIF_NORM    (1<<18)	/* Normal */
#define TSI148_LCSR_VICR_IRQIF_PULSE   (2<<18)	/* Pulse Generator */
#define TSI148_LCSR_VICR_IRQIF_PROG    (3<<18)	/* Programmable Clock */
#define TSI148_LCSR_VICR_IRQIF_1U      (4<<18)	/* 1us Clock */

#define TSI148_LCSR_VICR_IRQ2F_M       (3<<16)	/* IRQ2* Function MASK */
#define TSI148_LCSR_VICR_IRQ2F_NORM    (1<<16)	/* Normal */
#define TSI148_LCSR_VICR_IRQ2F_PULSE   (2<<16)	/* Pulse Generator */
#define TSI148_LCSR_VICR_IRQ2F_PROG    (3<<16)	/* Programmable Clock */
#define TSI148_LCSR_VICR_IRQ2F_1U      (4<<16)	/* 1us Clock */

#define TSI148_LCSR_VICR_BIP           (1<<15)	/* Broadcast Interrupt Pulse */

#define TSI148_LCSR_VICR_IRQC          (1<<12)	/* VMEbus IRQ Clear */
#define TSI148_LCSR_VICR_IRQS          (1<<11)	/* VMEbus IRQ Status */

#define TSI148_LCSR_VICR_IRQL_M        (7<<8)	/* VMEbus SW IRQ Level Mask */
#define TSI148_LCSR_VICR_IRQL_1        (1<<8)	/* VMEbus SW IRQ Level 1 */
#define TSI148_LCSR_VICR_IRQL_2        (2<<8)	/* VMEbus SW IRQ Level 2 */
#define TSI148_LCSR_VICR_IRQL_3        (3<<8)	/* VMEbus SW IRQ Level 3 */
#define TSI148_LCSR_VICR_IRQL_4        (4<<8)	/* VMEbus SW IRQ Level 4 */
#define TSI148_LCSR_VICR_IRQL_5        (5<<8)	/* VMEbus SW IRQ Level 5 */
#define TSI148_LCSR_VICR_IRQL_6        (6<<8)	/* VMEbus SW IRQ Level 6 */
#define TSI148_LCSR_VICR_IRQL_7        (7<<8)	/* VMEbus SW IRQ Level 7 */

static const int TSI148_LCSR_VICR_IRQL[8] = { 0, TSI148_LCSR_VICR_IRQL_1,
			TSI148_LCSR_VICR_IRQL_2, TSI148_LCSR_VICR_IRQL_3,
			TSI148_LCSR_VICR_IRQL_4, TSI148_LCSR_VICR_IRQL_5,
			TSI148_LCSR_VICR_IRQL_6, TSI148_LCSR_VICR_IRQL_7 };

#define TSI148_LCSR_VICR_STID_M        (0xFF<<0)	/* Status/ID Mask */

/*
 *  Interrupt Enable Register   CRG + $440
 */
#define TSI148_LCSR_INTEN_DMA1EN       (1<<25)	/* DMAC 1 */
#define TSI148_LCSR_INTEN_DMA0EN       (1<<24)	/* DMAC 0 */
#define TSI148_LCSR_INTEN_LM3EN        (1<<23)	/* Location Monitor 3 */
#define TSI148_LCSR_INTEN_LM2EN        (1<<22)	/* Location Monitor 2 */
#define TSI148_LCSR_INTEN_LM1EN        (1<<21)	/* Location Monitor 1 */
#define TSI148_LCSR_INTEN_LM0EN        (1<<20)	/* Location Monitor 0 */
#define TSI148_LCSR_INTEN_MB3EN        (1<<19)	/* Mail Box 3 */
#define TSI148_LCSR_INTEN_MB2EN        (1<<18)	/* Mail Box 2 */
#define TSI148_LCSR_INTEN_MB1EN        (1<<17)	/* Mail Box 1 */
#define TSI148_LCSR_INTEN_MB0EN        (1<<16)	/* Mail Box 0 */
#define TSI148_LCSR_INTEN_PERREN       (1<<13)	/* PCI/X Error */
#define TSI148_LCSR_INTEN_VERREN       (1<<12)	/* VMEbus Error */
#define TSI148_LCSR_INTEN_VIEEN        (1<<11)	/* VMEbus IRQ Edge */
#define TSI148_LCSR_INTEN_IACKEN       (1<<10)	/* IACK */
#define TSI148_LCSR_INTEN_SYSFLEN      (1<<9)	/* System Fail */
#define TSI148_LCSR_INTEN_ACFLEN       (1<<8)	/* AC Fail */
#define TSI148_LCSR_INTEN_IRQ7EN       (1<<7)	/* IRQ7 */
#define TSI148_LCSR_INTEN_IRQ6EN       (1<<6)	/* IRQ6 */
#define TSI148_LCSR_INTEN_IRQ5EN       (1<<5)	/* IRQ5 */
#define TSI148_LCSR_INTEN_IRQ4EN       (1<<4)	/* IRQ4 */
#define TSI148_LCSR_INTEN_IRQ3EN       (1<<3)	/* IRQ3 */
#define TSI148_LCSR_INTEN_IRQ2EN       (1<<2)	/* IRQ2 */
#define TSI148_LCSR_INTEN_IRQ1EN       (1<<1)	/* IRQ1 */

static const int TSI148_LCSR_INTEN_LMEN[4] = { TSI148_LCSR_INTEN_LM0EN,
					TSI148_LCSR_INTEN_LM1EN,
					TSI148_LCSR_INTEN_LM2EN,
					TSI148_LCSR_INTEN_LM3EN };

static const int TSI148_LCSR_INTEN_IRQEN[7] = { TSI148_LCSR_INTEN_IRQ1EN,
					TSI148_LCSR_INTEN_IRQ2EN,
					TSI148_LCSR_INTEN_IRQ3EN,
					TSI148_LCSR_INTEN_IRQ4EN,
					TSI148_LCSR_INTEN_IRQ5EN,
					TSI148_LCSR_INTEN_IRQ6EN,
					TSI148_LCSR_INTEN_IRQ7EN };

/*
 *  Interrupt Enable Out Register CRG + $444
 */
#define TSI148_LCSR_INTEO_DMA1EO       (1<<25)	/* DMAC 1 */
#define TSI148_LCSR_INTEO_DMA0EO       (1<<24)	/* DMAC 0 */
#define TSI148_LCSR_INTEO_LM3EO        (1<<23)	/* Loc Monitor 3 */
#define TSI148_LCSR_INTEO_LM2EO        (1<<22)	/* Loc Monitor 2 */
#define TSI148_LCSR_INTEO_LM1EO        (1<<21)	/* Loc Monitor 1 */
#define TSI148_LCSR_INTEO_LM0EO        (1<<20)	/* Location Monitor 0 */
#define TSI148_LCSR_INTEO_MB3EO        (1<<19)	/* Mail Box 3 */
#define TSI148_LCSR_INTEO_MB2EO        (1<<18)	/* Mail Box 2 */
#define TSI148_LCSR_INTEO_MB1EO        (1<<17)	/* Mail Box 1 */
#define TSI148_LCSR_INTEO_MB0EO        (1<<16)	/* Mail Box 0 */
#define TSI148_LCSR_INTEO_PERREO       (1<<13)	/* PCI/X Error */
#define TSI148_LCSR_INTEO_VERREO       (1<<12)	/* VMEbus Error */
#define TSI148_LCSR_INTEO_VIEEO        (1<<11)	/* VMEbus IRQ Edge */
#define TSI148_LCSR_INTEO_IACKEO       (1<<10)	/* IACK */
#define TSI148_LCSR_INTEO_SYSFLEO      (1<<9)	/* System Fail */
#define TSI148_LCSR_INTEO_ACFLEO       (1<<8)	/* AC Fail */
#define TSI148_LCSR_INTEO_IRQ7EO       (1<<7)	/* IRQ7 */
#define TSI148_LCSR_INTEO_IRQ6EO       (1<<6)	/* IRQ6 */
#define TSI148_LCSR_INTEO_IRQ5EO       (1<<5)	/* IRQ5 */
#define TSI148_LCSR_INTEO_IRQ4EO       (1<<4)	/* IRQ4 */
#define TSI148_LCSR_INTEO_IRQ3EO       (1<<3)	/* IRQ3 */
#define TSI148_LCSR_INTEO_IRQ2EO       (1<<2)	/* IRQ2 */
#define TSI148_LCSR_INTEO_IRQ1EO       (1<<1)	/* IRQ1 */

static const int TSI148_LCSR_INTEO_LMEO[4] = { TSI148_LCSR_INTEO_LM0EO,
					TSI148_LCSR_INTEO_LM1EO,
					TSI148_LCSR_INTEO_LM2EO,
					TSI148_LCSR_INTEO_LM3EO };

static const int TSI148_LCSR_INTEO_IRQEO[7] = { TSI148_LCSR_INTEO_IRQ1EO,
					TSI148_LCSR_INTEO_IRQ2EO,
					TSI148_LCSR_INTEO_IRQ3EO,
					TSI148_LCSR_INTEO_IRQ4EO,
					TSI148_LCSR_INTEO_IRQ5EO,
					TSI148_LCSR_INTEO_IRQ6EO,
					TSI148_LCSR_INTEO_IRQ7EO };

/*
 *  Interrupt Status Register CRG + $448
 */
#define TSI148_LCSR_INTS_DMA1S         (1<<25)	/* DMA 1 */
#define TSI148_LCSR_INTS_DMA0S         (1<<24)	/* DMA 0 */
#define TSI148_LCSR_INTS_LM3S          (1<<23)	/* Location Monitor 3 */
#define TSI148_LCSR_INTS_LM2S          (1<<22)	/* Location Monitor 2 */
#define TSI148_LCSR_INTS_LM1S          (1<<21)	/* Location Monitor 1 */
#define TSI148_LCSR_INTS_LM0S          (1<<20)	/* Location Monitor 0 */
#define TSI148_LCSR_INTS_MB3S          (1<<19)	/* Mail Box 3 */
#define TSI148_LCSR_INTS_MB2S          (1<<18)	/* Mail Box 2 */
#define TSI148_LCSR_INTS_MB1S          (1<<17)	/* Mail Box 1 */
#define TSI148_LCSR_INTS_MB0S          (1<<16)	/* Mail Box 0 */
#define TSI148_LCSR_INTS_PERRS         (1<<13)	/* PCI/X Error */
#define TSI148_LCSR_INTS_VERRS         (1<<12)	/* VMEbus Error */
#define TSI148_LCSR_INTS_VIES          (1<<11)	/* VMEbus IRQ Edge */
#define TSI148_LCSR_INTS_IACKS         (1<<10)	/* IACK */
#define TSI148_LCSR_INTS_SYSFLS        (1<<9)	/* System Fail */
#define TSI148_LCSR_INTS_ACFLS         (1<<8)	/* AC Fail */
#define TSI148_LCSR_INTS_IRQ7S         (1<<7)	/* IRQ7 */
#define TSI148_LCSR_INTS_IRQ6S         (1<<6)	/* IRQ6 */
#define TSI148_LCSR_INTS_IRQ5S         (1<<5)	/* IRQ5 */
#define TSI148_LCSR_INTS_IRQ4S         (1<<4)	/* IRQ4 */
#define TSI148_LCSR_INTS_IRQ3S         (1<<3)	/* IRQ3 */
#define TSI148_LCSR_INTS_IRQ2S         (1<<2)	/* IRQ2 */
#define TSI148_LCSR_INTS_IRQ1S         (1<<1)	/* IRQ1 */

static const int TSI148_LCSR_INTS_LMS[4] = { TSI148_LCSR_INTS_LM0S,
					TSI148_LCSR_INTS_LM1S,
					TSI148_LCSR_INTS_LM2S,
					TSI148_LCSR_INTS_LM3S };

static const int TSI148_LCSR_INTS_MBS[4] = { TSI148_LCSR_INTS_MB0S,
					TSI148_LCSR_INTS_MB1S,
					TSI148_LCSR_INTS_MB2S,
					TSI148_LCSR_INTS_MB3S };

/*
 *  Interrupt Clear Register CRG + $44C
 */
#define TSI148_LCSR_INTC_DMA1C         (1<<25)	/* DMA 1 */
#define TSI148_LCSR_INTC_DMA0C         (1<<24)	/* DMA 0 */
#define TSI148_LCSR_INTC_LM3C          (1<<23)	/* Location Monitor 3 */
#define TSI148_LCSR_INTC_LM2C          (1<<22)	/* Location Monitor 2 */
#define TSI148_LCSR_INTC_LM1C          (1<<21)	/* Location Monitor 1 */
#define TSI148_LCSR_INTC_LM0C          (1<<20)	/* Location Monitor 0 */
#define TSI148_LCSR_INTC_MB3C          (1<<19)	/* Mail Box 3 */
#define TSI148_LCSR_INTC_MB2C          (1<<18)	/* Mail Box 2 */
#define TSI148_LCSR_INTC_MB1C          (1<<17)	/* Mail Box 1 */
#define TSI148_LCSR_INTC_MB0C          (1<<16)	/* Mail Box 0 */
#define TSI148_LCSR_INTC_PERRC         (1<<13)	/* VMEbus Error */
#define TSI148_LCSR_INTC_VERRC         (1<<12)	/* VMEbus Access Time-out */
#define TSI148_LCSR_INTC_VIEC          (1<<11)	/* VMEbus IRQ Edge */
#define TSI148_LCSR_INTC_IACKC         (1<<10)	/* IACK */
#define TSI148_LCSR_INTC_SYSFLC        (1<<9)	/* System Fail */
#define TSI148_LCSR_INTC_ACFLC         (1<<8)	/* AC Fail */

static const int TSI148_LCSR_INTC_LMC[4] = { TSI148_LCSR_INTC_LM0C,
					TSI148_LCSR_INTC_LM1C,
					TSI148_LCSR_INTC_LM2C,
					TSI148_LCSR_INTC_LM3C };

static const int TSI148_LCSR_INTC_MBC[4] = { TSI148_LCSR_INTC_MB0C,
					TSI148_LCSR_INTC_MB1C,
					TSI148_LCSR_INTC_MB2C,
					TSI148_LCSR_INTC_MB3C };

/*
 *  Interrupt Map Register 1 CRG + $458
 */
#define TSI148_LCSR_INTM1_DMA1M_M      (3<<18)	/* DMA 1 */
#define TSI148_LCSR_INTM1_DMA0M_M      (3<<16)	/* DMA 0 */
#define TSI148_LCSR_INTM1_LM3M_M       (3<<14)	/* Location Monitor 3 */
#define TSI148_LCSR_INTM1_LM2M_M       (3<<12)	/* Location Monitor 2 */
#define TSI148_LCSR_INTM1_LM1M_M       (3<<10)	/* Location Monitor 1 */
#define TSI148_LCSR_INTM1_LM0M_M       (3<<8)	/* Location Monitor 0 */
#define TSI148_LCSR_INTM1_MB3M_M       (3<<6)	/* Mail Box 3 */
#define TSI148_LCSR_INTM1_MB2M_M       (3<<4)	/* Mail Box 2 */
#define TSI148_LCSR_INTM1_MB1M_M       (3<<2)	/* Mail Box 1 */
#define TSI148_LCSR_INTM1_MB0M_M       (3<<0)	/* Mail Box 0 */

/*
 *  Interrupt Map Register 2 CRG + $45C
 */
#define TSI148_LCSR_INTM2_PERRM_M      (3<<26)	/* PCI Bus Error */
#define TSI148_LCSR_INTM2_VERRM_M      (3<<24)	/* VMEbus Error */
#define TSI148_LCSR_INTM2_VIEM_M       (3<<22)	/* VMEbus IRQ Edge */
#define TSI148_LCSR_INTM2_IACKM_M      (3<<20)	/* IACK */
#define TSI148_LCSR_INTM2_SYSFLM_M     (3<<18)	/* System Fail */
#define TSI148_LCSR_INTM2_ACFLM_M      (3<<16)	/* AC Fail */
#define TSI148_LCSR_INTM2_IRQ7M_M      (3<<14)	/* IRQ7 */
#define TSI148_LCSR_INTM2_IRQ6M_M      (3<<12)	/* IRQ6 */
#define TSI148_LCSR_INTM2_IRQ5M_M      (3<<10)	/* IRQ5 */
#define TSI148_LCSR_INTM2_IRQ4M_M      (3<<8)	/* IRQ4 */
#define TSI148_LCSR_INTM2_IRQ3M_M      (3<<6)	/* IRQ3 */
#define TSI148_LCSR_INTM2_IRQ2M_M      (3<<4)	/* IRQ2 */
#define TSI148_LCSR_INTM2_IRQ1M_M      (3<<2)	/* IRQ1 */

/*
 *  DMA Control (0-1) Registers CRG + $500
 */
#define TSI148_LCSR_DCTL_ABT           (1<<27)	/* Abort */
#define TSI148_LCSR_DCTL_PAU           (1<<26)	/* Pause */
#define TSI148_LCSR_DCTL_DGO           (1<<25)	/* DMA Go */

#define TSI148_LCSR_DCTL_MOD           (1<<23)	/* Mode */

#define TSI148_LCSR_DCTL_VBKS_M        (7<<12)	/* VMEbus block Size MASK */
#define TSI148_LCSR_DCTL_VBKS_32       (0<<12)	/* VMEbus block Size 32 */
#define TSI148_LCSR_DCTL_VBKS_64       (1<<12)	/* VMEbus block Size 64 */
#define TSI148_LCSR_DCTL_VBKS_128      (2<<12)	/* VMEbus block Size 128 */
#define TSI148_LCSR_DCTL_VBKS_256      (3<<12)	/* VMEbus block Size 256 */
#define TSI148_LCSR_DCTL_VBKS_512      (4<<12)	/* VMEbus block Size 512 */
#define TSI148_LCSR_DCTL_VBKS_1024     (5<<12)	/* VMEbus block Size 1024 */
#define TSI148_LCSR_DCTL_VBKS_2048     (6<<12)	/* VMEbus block Size 2048 */
#define TSI148_LCSR_DCTL_VBKS_4096     (7<<12)	/* VMEbus block Size 4096 */

#define TSI148_LCSR_DCTL_VBOT_M        (7<<8)	/* VMEbus back-off MASK */
#define TSI148_LCSR_DCTL_VBOT_0        (0<<8)	/* VMEbus back-off  0us */
#define TSI148_LCSR_DCTL_VBOT_1        (1<<8)	/* VMEbus back-off 1us */
#define TSI148_LCSR_DCTL_VBOT_2        (2<<8)	/* VMEbus back-off 2us */
#define TSI148_LCSR_DCTL_VBOT_4        (3<<8)	/* VMEbus back-off 4us */
#define TSI148_LCSR_DCTL_VBOT_8        (4<<8)	/* VMEbus back-off 8us */
#define TSI148_LCSR_DCTL_VBOT_16       (5<<8)	/* VMEbus back-off 16us */
#define TSI148_LCSR_DCTL_VBOT_32       (6<<8)	/* VMEbus back-off 32us */
#define TSI148_LCSR_DCTL_VBOT_64       (7<<8)	/* VMEbus back-off 64us */

#define TSI148_LCSR_DCTL_PBKS_M        (7<<4)	/* PCI block size MASK */
#define TSI148_LCSR_DCTL_PBKS_32       (0<<4)	/* PCI block size 32 bytes */
#define TSI148_LCSR_DCTL_PBKS_64       (1<<4)	/* PCI block size 64 bytes */
#define TSI148_LCSR_DCTL_PBKS_128      (2<<4)	/* PCI block size 128 bytes */
#define TSI148_LCSR_DCTL_PBKS_256      (3<<4)	/* PCI block size 256 bytes */
#define TSI148_LCSR_DCTL_PBKS_512      (4<<4)	/* PCI block size 512 bytes */
#define TSI148_LCSR_DCTL_PBKS_1024     (5<<4)	/* PCI block size 1024 bytes */
#define TSI148_LCSR_DCTL_PBKS_2048     (6<<4)	/* PCI block size 2048 bytes */
#define TSI148_LCSR_DCTL_PBKS_4096     (7<<4)	/* PCI block size 4096 bytes */

#define TSI148_LCSR_DCTL_PBOT_M        (7<<0)	/* PCI back off MASK */
#define TSI148_LCSR_DCTL_PBOT_0        (0<<0)	/* PCI back off 0us */
#define TSI148_LCSR_DCTL_PBOT_1        (1<<0)	/* PCI back off 1us */
#define TSI148_LCSR_DCTL_PBOT_2        (2<<0)	/* PCI back off 2us */
#define TSI148_LCSR_DCTL_PBOT_4        (3<<0)	/* PCI back off 3us */
#define TSI148_LCSR_DCTL_PBOT_8        (4<<0)	/* PCI back off 4us */
#define TSI148_LCSR_DCTL_PBOT_16       (5<<0)	/* PCI back off 8us */
#define TSI148_LCSR_DCTL_PBOT_32       (6<<0)	/* PCI back off 16us */
#define TSI148_LCSR_DCTL_PBOT_64       (7<<0)	/* PCI back off 32us */

/*
 *  DMA Status Registers (0-1)  CRG + $504
 */
#define TSI148_LCSR_DSTA_SMA           (1<<31)	/* PCI Signalled Master Abt */
#define TSI148_LCSR_DSTA_RTA           (1<<30)	/* PCI Received Target Abt */
#define TSI148_LCSR_DSTA_MRC           (1<<29)	/* PCI Max Retry Count */
#define TSI148_LCSR_DSTA_VBE           (1<<28)	/* VMEbus error */
#define TSI148_LCSR_DSTA_ABT           (1<<27)	/* Abort */
#define TSI148_LCSR_DSTA_PAU           (1<<26)	/* Pause */
#define TSI148_LCSR_DSTA_DON           (1<<25)	/* Done */
#define TSI148_LCSR_DSTA_BSY           (1<<24)	/* Busy */

/*
 *  DMA Current Link Address Lower (0-1)
 */
#define TSI148_LCSR_DCLAL_M            (0x3FFFFFF<<6)	/* Mask */

/*
 *  DMA Source Attribute (0-1) Reg
 */
#define TSI148_LCSR_DSAT_TYP_M         (3<<28)	/* Source Bus Type */
#define TSI148_LCSR_DSAT_TYP_PCI       (0<<28)	/* PCI Bus */
#define TSI148_LCSR_DSAT_TYP_VME       (1<<28)	/* VMEbus */
#define TSI148_LCSR_DSAT_TYP_PAT       (2<<28)	/* Data Pattern */

#define TSI148_LCSR_DSAT_PSZ           (1<<25)	/* Pattern Size */
#define TSI148_LCSR_DSAT_NIN           (1<<24)	/* No Increment */

#define TSI148_LCSR_DSAT_2eSSTM_M      (3<<11)	/* 2eSST Trans Rate Mask */
#define TSI148_LCSR_DSAT_2eSSTM_160    (0<<11)	/* 160 MB/s */
#define TSI148_LCSR_DSAT_2eSSTM_267    (1<<11)	/* 267 MB/s */
#define TSI148_LCSR_DSAT_2eSSTM_320    (2<<11)	/* 320 MB/s */

#define TSI148_LCSR_DSAT_TM_M          (7<<8)	/* Bus Transfer Protocol Mask */
#define TSI148_LCSR_DSAT_TM_SCT        (0<<8)	/* SCT */
#define TSI148_LCSR_DSAT_TM_BLT        (1<<8)	/* BLT */
#define TSI148_LCSR_DSAT_TM_MBLT       (2<<8)	/* MBLT */
#define TSI148_LCSR_DSAT_TM_2eVME      (3<<8)	/* 2eVME */
#define TSI148_LCSR_DSAT_TM_2eSST      (4<<8)	/* 2eSST */
#define TSI148_LCSR_DSAT_TM_2eSSTB     (5<<8)	/* 2eSST Broadcast */

#define TSI148_LCSR_DSAT_DBW_M         (3<<6)	/* Max Data Width MASK */
#define TSI148_LCSR_DSAT_DBW_16        (0<<6)	/* 16 Bits */
#define TSI148_LCSR_DSAT_DBW_32        (1<<6)	/* 32 Bits */

#define TSI148_LCSR_DSAT_SUP           (1<<5)	/* Supervisory Mode */
#define TSI148_LCSR_DSAT_PGM           (1<<4)	/* Program Mode */

#define TSI148_LCSR_DSAT_AMODE_M       (0xf<<0)	/* Address Space Mask */
#define TSI148_LCSR_DSAT_AMODE_A16     (0<<0)	/* A16 */
#define TSI148_LCSR_DSAT_AMODE_A24     (1<<0)	/* A24 */
#define TSI148_LCSR_DSAT_AMODE_A32     (2<<0)	/* A32 */
#define TSI148_LCSR_DSAT_AMODE_A64     (4<<0)	/* A64 */
#define TSI148_LCSR_DSAT_AMODE_CRCSR   (5<<0)	/* CR/CSR */
#define TSI148_LCSR_DSAT_AMODE_USER1   (8<<0)	/* User1 */
#define TSI148_LCSR_DSAT_AMODE_USER2   (9<<0)	/* User2 */
#define TSI148_LCSR_DSAT_AMODE_USER3   (0xa<<0)	/* User3 */
#define TSI148_LCSR_DSAT_AMODE_USER4   (0xb<<0)	/* User4 */

/*
 *  DMA Destination Attribute Registers (0-1)
 */
#define TSI148_LCSR_DDAT_TYP_PCI       (0<<28)	/* Destination PCI Bus  */
#define TSI148_LCSR_DDAT_TYP_VME       (1<<28)	/* Destination VMEbus */

#define TSI148_LCSR_DDAT_2eSSTM_M      (3<<11)	/* 2eSST Transfer Rate Mask */
#define TSI148_LCSR_DDAT_2eSSTM_160    (0<<11)	/* 160 MB/s */
#define TSI148_LCSR_DDAT_2eSSTM_267    (1<<11)	/* 267 MB/s */
#define TSI148_LCSR_DDAT_2eSSTM_320    (2<<11)	/* 320 MB/s */

#define TSI148_LCSR_DDAT_TM_M          (7<<8)	/* Bus Transfer Protocol Mask */
#define TSI148_LCSR_DDAT_TM_SCT        (0<<8)	/* SCT */
#define TSI148_LCSR_DDAT_TM_BLT        (1<<8)	/* BLT */
#define TSI148_LCSR_DDAT_TM_MBLT       (2<<8)	/* MBLT */
#define TSI148_LCSR_DDAT_TM_2eVME      (3<<8)	/* 2eVME */
#define TSI148_LCSR_DDAT_TM_2eSST      (4<<8)	/* 2eSST */
#define TSI148_LCSR_DDAT_TM_2eSSTB     (5<<8)	/* 2eSST Broadcast */

#define TSI148_LCSR_DDAT_DBW_M         (3<<6)	/* Max Data Width MASK */
#define TSI148_LCSR_DDAT_DBW_16        (0<<6)	/* 16 Bits */
#define TSI148_LCSR_DDAT_DBW_32        (1<<6)	/* 32 Bits */

#define TSI148_LCSR_DDAT_SUP           (1<<5)	/* Supervisory/User Access */
#define TSI148_LCSR_DDAT_PGM           (1<<4)	/* Program/Data Access */

#define TSI148_LCSR_DDAT_AMODE_M       (0xf<<0)	/* Address Space Mask */
#define TSI148_LCSR_DDAT_AMODE_A16      (0<<0)	/* A16 */
#define TSI148_LCSR_DDAT_AMODE_A24      (1<<0)	/* A24 */
#define TSI148_LCSR_DDAT_AMODE_A32      (2<<0)	/* A32 */
#define TSI148_LCSR_DDAT_AMODE_A64      (4<<0)	/* A64 */
#define TSI148_LCSR_DDAT_AMODE_CRCSR   (5<<0)	/* CRC/SR */
#define TSI148_LCSR_DDAT_AMODE_USER1   (8<<0)	/* User1 */
#define TSI148_LCSR_DDAT_AMODE_USER2   (9<<0)	/* User2 */
#define TSI148_LCSR_DDAT_AMODE_USER3   (0xa<<0)	/* User3 */
#define TSI148_LCSR_DDAT_AMODE_USER4   (0xb<<0)	/* User4 */

/*
 *  DMA Next Link Address Lower
 */
#define TSI148_LCSR_DNLAL_DNLAL_M      (0x3FFFFFF<<6)	/* Address Mask */
#define TSI148_LCSR_DNLAL_LLA          (1<<0)  /* Last Link Address Indicator */

/*
 *  DMA 2eSST Broadcast Select
 */
#define TSI148_LCSR_DBS_M              (0x1FFFFF<<0)	/* Mask */

/*
 *  GCSR Register Group
 */

/*
 *  GCSR Control and Status Register  CRG + $604
 */
#define TSI148_GCSR_GCTRL_LRST         (1<<15)	/* Local Reset */
#define TSI148_GCSR_GCTRL_SFAILEN      (1<<14)	/* System Fail enable */
#define TSI148_GCSR_GCTRL_BDFAILS      (1<<13)	/* Board Fail Status */
#define TSI148_GCSR_GCTRL_SCON         (1<<12)	/* System Copntroller */
#define TSI148_GCSR_GCTRL_MEN          (1<<11)	/* Module Enable (READY) */

#define TSI148_GCSR_GCTRL_LMI3S        (1<<7)	/* Loc Monitor 3 Int Status */
#define TSI148_GCSR_GCTRL_LMI2S        (1<<6)	/* Loc Monitor 2 Int Status */
#define TSI148_GCSR_GCTRL_LMI1S        (1<<5)	/* Loc Monitor 1 Int Status */
#define TSI148_GCSR_GCTRL_LMI0S        (1<<4)	/* Loc Monitor 0 Int Status */
#define TSI148_GCSR_GCTRL_MBI3S        (1<<3)	/* Mail box 3 Int Status */
#define TSI148_GCSR_GCTRL_MBI2S        (1<<2)	/* Mail box 2 Int Status */
#define TSI148_GCSR_GCTRL_MBI1S        (1<<1)	/* Mail box 1 Int Status */
#define TSI148_GCSR_GCTRL_MBI0S        (1<<0)	/* Mail box 0 Int Status */

#define TSI148_GCSR_GAP                (1<<5)	/* Geographic Addr Parity */
#define TSI148_GCSR_GA_M               (0x1F<<0)  /* Geographic Address Mask */

/*
 *  CR/CSR Register Group
 */

/*
 *  CR/CSR Bit Clear Register CRG + $FF4
 */
#define TSI148_CRCSR_CSRBCR_LRSTC      (1<<7)	/* Local Reset Clear */
#define TSI148_CRCSR_CSRBCR_SFAILC     (1<<6)	/* System Fail Enable Clear */
#define TSI148_CRCSR_CSRBCR_BDFAILS    (1<<5)	/* Board Fail Status */
#define TSI148_CRCSR_CSRBCR_MENC       (1<<4)	/* Module Enable Clear */
#define TSI148_CRCSR_CSRBCR_BERRSC     (1<<3)	/* Bus Error Status Clear */

/*
 *  CR/CSR Bit Set Register CRG+$FF8
 */
#define TSI148_CRCSR_CSRBSR_LISTS      (1<<7)	/* Local Reset Clear */
#define TSI148_CRCSR_CSRBSR_SFAILS     (1<<6)	/* System Fail Enable Clear */
#define TSI148_CRCSR_CSRBSR_BDFAILS    (1<<5)	/* Board Fail Status */
#define TSI148_CRCSR_CSRBSR_MENS       (1<<4)	/* Module Enable Clear */
#define TSI148_CRCSR_CSRBSR_BERRS      (1<<3)	/* Bus Error Status Clear */

/*
 *  CR/CSR Base Address Register CRG + FFC
 */
#define TSI148_CRCSR_CBAR_M            (0x1F<<3)	/* Mask */

#endif				/* TSI148_H */
/*
 *  PC Speaker beeper driver for Linux
 *
 *  Copyright (c) 2002 Vojtech Pavlik
 *  Copyright (c) 1992 Orest Zborowski
 *
 */

/*
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/input.h>
#include <linux/platform_device.h>
#include <linux/timex.h>
#include <asm/io.h>

MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
MODULE_DESCRIPTION("PC Speaker beeper driver");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:pcspkr");

#if defined(CONFIG_MIPS) || defined(CONFIG_X86)
/* Use the global PIT lock ! */
#include <asm/i8253.h>
#else
#include <asm/8253pit.h>
static DEFINE_RAW_SPINLOCK(i8253_lock);
#endif

static int pcspkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
{
	unsigned int count = 0;
	unsigned long flags;

	if (type != EV_SND)
		return -1;

	switch (code) {
		case SND_BELL: if (value) value = 1000;
		case SND_TONE: break;
		default: return -1;
	}

	if (value > 20 && value < 32767)
		count = PIT_TICK_RATE / value;

	raw_spin_lock_irqsave(&i8253_lock, flags);

	if (count) {
		/* set command for counter 2, 2 byte write */
		outb_p(0xB6, 0x43);
		/* select desired HZ */
		outb_p(count & 0xff, 0x42);
		outb((count >> 8) & 0xff, 0x42);
		/* enable counter 2 */
		outb_p(inb_p(0x61) | 3, 0x61);
	} else {
		/* disable counter 2 */
		outb(inb_p(0x61) & 0xFC, 0x61);
	}

	raw_spin_unlock_irqrestore(&i8253_lock, flags);

	return 0;
}

static int __devinit pcspkr_probe(struct platform_device *dev)
{
	struct input_dev *pcspkr_dev;
	int err;

	pcspkr_dev = input_allocate_device();
	if (!pcspkr_dev)
		return -ENOMEM;

	pcspkr_dev->name = "PC Speaker";
	pcspkr_dev->phys = "isa0061/input0";
	pcspkr_dev->id.bustype = BUS_ISA;
	pcspkr_dev->id.vendor = 0x001f;
	pcspkr_dev->id.product = 0x0001;
	pcspkr_dev->id.version = 0x0100;
	pcspkr_dev->dev.parent = &dev->dev;

	pcspkr_dev->evbit[0] = BIT_MASK(EV_SND);
	pcspkr_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);
	pcspkr_dev->event = pcspkr_event;

	err = input_register_device(pcspkr_dev);
	if (err) {
		input_free_device(pcspkr_dev);
		return err;
	}

	platform_set_drvdata(dev, pcspkr_dev);

	return 0;
}

static int __devexit pcspkr_remove(struct platform_device *dev)
{
	struct input_dev *pcspkr_dev = platform_get_drvdata(dev);

	input_unregister_device(pcspkr_dev);
	platform_set_drvdata(dev, NULL);
	/* turn off the speaker */
	pcspkr_event(NULL, EV_SND, SND_BELL, 0);

	return 0;
}

static int pcspkr_suspend(struct device *dev)
{
	pcspkr_event(NULL, EV_SND, SND_BELL, 0);

	return 0;
}

static void pcspkr_shutdown(struct platform_device *dev)
{
	/* turn off the speaker */
	pcspkr_event(NULL, EV_SND, SND_BELL, 0);
}

static const struct dev_pm_ops pcspkr_pm_ops = {
	.suspend = pcspkr_suspend,
};

static struct platform_driver pcspkr_platform_driver = {
	.driver		= {
		.name	= "pcspkr",
		.owner	= THIS_MODULE,
		.pm	= &pcspkr_pm_ops,
	},
	.probe		= pcspkr_probe,
	.remove		= __devexit_p(pcspkr_remove),
	.shutdown	= pcspkr_shutdown,
};


static int __init pcspkr_init(void)
{
	return platform_driver_register(&pcspkr_platform_driver);
}

static void __exit pcspkr_exit(void)
{
	platform_driver_unregister(&pcspkr_platform_driver);
}

module_init(pcspkr_init);
module_exit(pcspkr_exit);
cmd_drivers/input/touchscreen/touchright.mod.o := gcc -Wp,-MD,drivers/input/touchscreen/.touchright.mod.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(touchright.mod)"  -D"KBUILD_MODNAME=KBUILD_STR(touchright)"  -DMODULE  -c -o drivers/input/touchscreen/touchright.mod.o drivers/input/touchscreen/touchright.mod.c

deps_drivers/input/touchscreen/touchright.mod.o := \
  drivers/input/touchscreen/touchright.mod.c \
    $(wildcard include/config/module/unload.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/vermagic.h \
  include/generated/utsrelease.h \

drivers/input/touchscreen/touchright.mod.o: $(deps_drivers/input/touchscreen/touchright.mod.o)

$(deps_drivers/input/touchscreen/touchright.mod.o):
#ifndef _ASM_X86_USER_64_H
#define _ASM_X86_USER_64_H

#include <asm/types.h>
#include <asm/page.h>
/* Core file format: The core file is written in such a way that gdb
   can understand it and provide useful information to the user.
   There are quite a number of obstacles to being able to view the
   contents of the floating point registers, and until these are
   solved you will not be able to view the contents of them.
   Actually, you can read in the core file and look at the contents of
   the user struct to find out what the floating point registers
   contain.

   The actual file contents are as follows:
   UPAGE: 1 page consisting of a user struct that tells gdb what is present
   in the file.  Directly after this is a copy of the task_struct, which
   is currently not used by gdb, but it may come in useful at some point.
   All of the registers are stored as part of the upage.  The upage should
   always be only one page.
   DATA: The data area is stored.  We use current->end_text to
   current->brk to pick up all of the user variables, plus any memory
   that may have been malloced.  No attempt is made to determine if a page
   is demand-zero or if a page is totally unused, we just cover the entire
   range.  All of the addresses are rounded in such a way that an integral
   number of pages is written.
   STACK: We need the stack information in order to get a meaningful
   backtrace.  We need to write the data from (esp) to
   current->start_stack, so we round each of these off in order to be able
   to write an integer number of pages.
   The minimum core file size is 3 pages, or 12288 bytes.  */

/*
 * Pentium III FXSR, SSE support
 *	Gareth Hughes <gareth@valinux.com>, May 2000
 *
 * Provide support for the GDB 5.0+ PTRACE_{GET|SET}FPXREGS requests for
 * interacting with the FXSR-format floating point environment.  Floating
 * point data can be accessed in the regular format in the usual manner,
 * and both the standard and SIMD floating point data can be accessed via
 * the new ptrace requests.  In either case, changes to the FPU environment
 * will be reflected in the task's state as expected.
 *
 * x86-64 support by Andi Kleen.
 */

/* This matches the 64bit FXSAVE format as defined by AMD. It is the same
   as the 32bit format defined by Intel, except that the selector:offset pairs
   for data and eip are replaced with flat 64bit pointers. */
struct user_i387_struct {
	unsigned short	cwd;
	unsigned short	swd;
	unsigned short	twd;	/* Note this is not the same as
				   the 32bit/x87/FSAVE twd */
	unsigned short	fop;
	__u64	rip;
	__u64	rdp;
	__u32	mxcsr;
	__u32	mxcsr_mask;
	__u32	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg = 256 bytes */
	__u32	padding[24];
};

/*
 * Segment register layout in coredumps.
 */
struct user_regs_struct {
	unsigned long	r15;
	unsigned long	r14;
	unsigned long	r13;
	unsigned long	r12;
	unsigned long	bp;
	unsigned long	bx;
	unsigned long	r11;
	unsigned long	r10;
	unsigned long	r9;
	unsigned long	r8;
	unsigned long	ax;
	unsigned long	cx;
	unsigned long	dx;
	unsigned long	si;
	unsigned long	di;
	unsigned long	orig_ax;
	unsigned long	ip;
	unsigned long	cs;
	unsigned long	flags;
	unsigned long	sp;
	unsigned long	ss;
	unsigned long	fs_base;
	unsigned long	gs_base;
	unsigned long	ds;
	unsigned long	es;
	unsigned long	fs;
	unsigned long	gs;
};

/* When the kernel dumps core, it starts by dumping the user struct -
   this will be used by gdb to figure out where the data and stack segments
   are within the file, and what virtual addresses to use. */

struct user {
/* We start with the registers, to mimic the way that "memory" is returned
   from the ptrace(3,...) function.  */
  struct user_regs_struct regs;	/* Where the registers are actually stored */
/* ptrace does not yet supply these.  Someday.... */
  int u_fpvalid;		/* True if math co-processor being used. */
				/* for this mess. Not yet used. */
  int pad0;
  struct user_i387_struct i387;	/* Math Co-processor registers. */
/* The rest of this junk is to help gdb figure out what goes where */
  unsigned long int u_tsize;	/* Text segment size (pages). */
  unsigned long int u_dsize;	/* Data segment size (pages). */
  unsigned long int u_ssize;	/* Stack segment size (pages). */
  unsigned long start_code;     /* Starting virtual address of text. */
  unsigned long start_stack;	/* Starting virtual address of stack area.
				   This is actually the bottom of the stack,
				   the top of the stack is always found in the
				   esp register.  */
  long int signal;		/* Signal that caused the core dump. */
  int reserved;			/* No longer used */
  int pad1;
  unsigned long u_ar0;		/* Used by gdb to help find the values for */
				/* the registers. */
  struct user_i387_struct *u_fpstate;	/* Math Co-processor pointer. */
  unsigned long magic;		/* To uniquely identify a core file */
  char u_comm[32];		/* User command that was responsible */
  unsigned long u_debugreg[8];
  unsigned long error_code; /* CPU error code or 0 */
  unsigned long fault_address; /* CR3 or 0 */
};
#define NBPG PAGE_SIZE
#define UPAGES 1
#define HOST_TEXT_START_ADDR (u.start_code)
#define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)

#endif /* _ASM_X86_USER_64_H */
/*
  File: linux/posix_acl.h

  (C) 2002 Andreas Gruenbacher, <a.gruenbacher@computer.org>
*/


#ifndef __LINUX_POSIX_ACL_H
#define __LINUX_POSIX_ACL_H

#include <linux/slab.h>

#define ACL_UNDEFINED_ID	(-1)

/* a_type field in acl_user_posix_entry_t */
#define ACL_TYPE_ACCESS		(0x8000)
#define ACL_TYPE_DEFAULT	(0x4000)

/* e_tag entry in struct posix_acl_entry */
#define ACL_USER_OBJ		(0x01)
#define ACL_USER		(0x02)
#define ACL_GROUP_OBJ		(0x04)
#define ACL_GROUP		(0x08)
#define ACL_MASK		(0x10)
#define ACL_OTHER		(0x20)

/* permissions in the e_perm field */
#define ACL_READ		(0x04)
#define ACL_WRITE		(0x02)
#define ACL_EXECUTE		(0x01)
//#define ACL_ADD		(0x08)
//#define ACL_DELETE		(0x10)

struct posix_acl_entry {
	short			e_tag;
	unsigned short		e_perm;
	unsigned int		e_id;
};

struct posix_acl {
	atomic_t		a_refcount;
	unsigned int		a_count;
	struct posix_acl_entry	a_entries[0];
};

#define FOREACH_ACL_ENTRY(pa, acl, pe) \
	for(pa=(acl)->a_entries, pe=pa+(acl)->a_count; pa<pe; pa++)


/*
 * Duplicate an ACL handle.
 */
static inline struct posix_acl *
posix_acl_dup(struct posix_acl *acl)
{
	if (acl)
		atomic_inc(&acl->a_refcount);
	return acl;
}

/*
 * Free an ACL handle.
 */
static inline void
posix_acl_release(struct posix_acl *acl)
{
	if (acl && atomic_dec_and_test(&acl->a_refcount))
		kfree(acl);
}


/* posix_acl.c */

extern struct posix_acl *posix_acl_alloc(int, gfp_t);
extern struct posix_acl *posix_acl_clone(const struct posix_acl *, gfp_t);
extern int posix_acl_valid(const struct posix_acl *);
extern int posix_acl_permission(struct inode *, const struct posix_acl *, int);
extern struct posix_acl *posix_acl_from_mode(mode_t, gfp_t);
extern int posix_acl_equiv_mode(const struct posix_acl *, mode_t *);
extern int posix_acl_create_masq(struct posix_acl *, mode_t *);
extern int posix_acl_chmod_masq(struct posix_acl *, mode_t);

extern struct posix_acl *get_posix_acl(struct inode *, int);
extern int set_posix_acl(struct inode *, int, struct posix_acl *);

#ifdef CONFIG_FS_POSIX_ACL
static inline struct posix_acl *get_cached_acl(struct inode *inode, int type)
{
	struct posix_acl **p, *acl;
	switch (type) {
	case ACL_TYPE_ACCESS:
		p = &inode->i_acl;
		break;
	case ACL_TYPE_DEFAULT:
		p = &inode->i_default_acl;
		break;
	default:
		return ERR_PTR(-EINVAL);
	}
	acl = ACCESS_ONCE(*p);
	if (acl) {
		spin_lock(&inode->i_lock);
		acl = *p;
		if (acl != ACL_NOT_CACHED)
			acl = posix_acl_dup(acl);
		spin_unlock(&inode->i_lock);
	}
	return acl;
}

static inline void set_cached_acl(struct inode *inode,
				  int type,
				  struct posix_acl *acl)
{
	struct posix_acl *old = NULL;
	spin_lock(&inode->i_lock);
	switch (type) {
	case ACL_TYPE_ACCESS:
		old = inode->i_acl;
		inode->i_acl = posix_acl_dup(acl);
		break;
	case ACL_TYPE_DEFAULT:
		old = inode->i_default_acl;
		inode->i_default_acl = posix_acl_dup(acl);
		break;
	}
	spin_unlock(&inode->i_lock);
	if (old != ACL_NOT_CACHED)
		posix_acl_release(old);
}

static inline void forget_cached_acl(struct inode *inode, int type)
{
	struct posix_acl *old = NULL;
	spin_lock(&inode->i_lock);
	switch (type) {
	case ACL_TYPE_ACCESS:
		old = inode->i_acl;
		inode->i_acl = ACL_NOT_CACHED;
		break;
	case ACL_TYPE_DEFAULT:
		old = inode->i_default_acl;
		inode->i_default_acl = ACL_NOT_CACHED;
		break;
	}
	spin_unlock(&inode->i_lock);
	if (old != ACL_NOT_CACHED)
		posix_acl_release(old);
}

static inline void forget_all_cached_acls(struct inode *inode)
{
	struct posix_acl *old_access, *old_default;
	spin_lock(&inode->i_lock);
	old_access = inode->i_acl;
	old_default = inode->i_default_acl;
	inode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;
	spin_unlock(&inode->i_lock);
	if (old_access != ACL_NOT_CACHED)
		posix_acl_release(old_access);
	if (old_default != ACL_NOT_CACHED)
		posix_acl_release(old_default);
}
#endif

static inline void cache_no_acl(struct inode *inode)
{
#ifdef CONFIG_FS_POSIX_ACL
	inode->i_acl = NULL;
	inode->i_default_acl = NULL;
#endif
}

#endif  /* __LINUX_POSIX_ACL_H */
/*
 *  linux/sound/oss/dmasound/dmasound_q40.c
 *
 *  Q40 DMA Sound Driver
 *
 *  See linux/sound/oss/dmasound/dmasound_core.c for copyright and credits
 *  prior to 28/01/2001
 *
 *  28/01/2001 [0.1] Iain Sandoe
 *		     - added versioning
 *		     - put in and populated the hardware_afmts field.
 *             [0.2] - put in SNDCTL_DSP_GETCAPS value.
 *	       [0.3] - put in default hard/soft settings.
 */


#include <linux/module.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/soundcard.h>
#include <linux/interrupt.h>

#include <asm/uaccess.h>
#include <asm/q40ints.h>
#include <asm/q40_master.h>

#include "dmasound.h"

#define DMASOUND_Q40_REVISION 0
#define DMASOUND_Q40_EDITION 3

static int expand_bal;	/* Balance factor for expanding (not volume!) */
static int expand_data;	/* Data for expanding */


/*** Low level stuff *********************************************************/


static void *Q40Alloc(unsigned int size, gfp_t flags);
static void Q40Free(void *, unsigned int);
static int Q40IrqInit(void);
#ifdef MODULE
static void Q40IrqCleanUp(void);
#endif
static void Q40Silence(void);
static void Q40Init(void);
static int Q40SetFormat(int format);
static int Q40SetVolume(int volume);
static void Q40PlayNextFrame(int index);
static void Q40Play(void);
static irqreturn_t Q40StereoInterrupt(int irq, void *dummy);
static irqreturn_t Q40MonoInterrupt(int irq, void *dummy);
static void Q40Interrupt(void);


/*** Mid level stuff *********************************************************/



/* userCount, frameUsed, frameLeft == byte counts */
static ssize_t q40_ct_law(const u_char __user *userPtr, size_t userCount,
			   u_char frame[], ssize_t *frameUsed,
			   ssize_t frameLeft)
{
	char *table = dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8: dmasound_alaw2dma8;
	ssize_t count, used;
	u_char *p = (u_char *) &frame[*frameUsed];

	used = count = min_t(size_t, userCount, frameLeft);
	if (copy_from_user(p,userPtr,count))
	  return -EFAULT;
	while (count > 0) {
		*p = table[*p]+128;
		p++;
		count--;
	}
	*frameUsed += used ;
	return used;
}


static ssize_t q40_ct_s8(const u_char __user *userPtr, size_t userCount,
			  u_char frame[], ssize_t *frameUsed,
			  ssize_t frameLeft)
{
	ssize_t count, used;
	u_char *p = (u_char *) &frame[*frameUsed];

	used = count = min_t(size_t, userCount, frameLeft);
	if (copy_from_user(p,userPtr,count))
	  return -EFAULT;
	while (count > 0) {
		*p = *p + 128;
		p++;
		count--;
	}
	*frameUsed += used;
	return used;
}

static ssize_t q40_ct_u8(const u_char __user *userPtr, size_t userCount,
			  u_char frame[], ssize_t *frameUsed,
			  ssize_t frameLeft)
{
	ssize_t count, used;
	u_char *p = (u_char *) &frame[*frameUsed];

	used = count = min_t(size_t, userCount, frameLeft);
	if (copy_from_user(p,userPtr,count))
	  return -EFAULT;
	*frameUsed += used;
	return used;
}


/* a bit too complicated to optimise right now ..*/
static ssize_t q40_ctx_law(const u_char __user *userPtr, size_t userCount,
			    u_char frame[], ssize_t *frameUsed,
			    ssize_t frameLeft)
{
	unsigned char *table = (unsigned char *)
		(dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8: dmasound_alaw2dma8);
	unsigned int data = expand_data;
	u_char *p = (u_char *) &frame[*frameUsed];
	int bal = expand_bal;
	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
	int utotal, ftotal;

	ftotal = frameLeft;
	utotal = userCount;
	while (frameLeft) {
		u_char c;
		if (bal < 0) {
			if (userCount == 0)
				break;
			if (get_user(c, userPtr++))
				return -EFAULT;
			data = table[c];
			data += 0x80;
			userCount--;
			bal += hSpeed;
		}
		*p++ = data;
		frameLeft--;
		bal -= sSpeed;
	}
	expand_bal = bal;
	expand_data = data;
	*frameUsed += (ftotal - frameLeft);
	utotal -= userCount;
	return utotal;
}


static ssize_t q40_ctx_s8(const u_char __user *userPtr, size_t userCount,
			   u_char frame[], ssize_t *frameUsed,
			   ssize_t frameLeft)
{
	u_char *p = (u_char *) &frame[*frameUsed];
	unsigned int data = expand_data;
	int bal = expand_bal;
	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
	int utotal, ftotal;


	ftotal = frameLeft;
	utotal = userCount;
	while (frameLeft) {
		u_char c;
		if (bal < 0) {
			if (userCount == 0)
				break;
			if (get_user(c, userPtr++))
				return -EFAULT;
			data = c ;
			data += 0x80;
			userCount--;
			bal += hSpeed;
		}
		*p++ = data;
		frameLeft--;
		bal -= sSpeed;
	}
	expand_bal = bal;
	expand_data = data;
	*frameUsed += (ftotal - frameLeft);
	utotal -= userCount;
	return utotal;
}


static ssize_t q40_ctx_u8(const u_char __user *userPtr, size_t userCount,
			   u_char frame[], ssize_t *frameUsed,
			   ssize_t frameLeft)
{
	u_char *p = (u_char *) &frame[*frameUsed];
	unsigned int data = expand_data;
	int bal = expand_bal;
	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
	int utotal, ftotal;

	ftotal = frameLeft;
	utotal = userCount;
	while (frameLeft) {
		u_char c;
		if (bal < 0) {
			if (userCount == 0)
				break;
			if (get_user(c, userPtr++))
				return -EFAULT;
			data = c ;
			userCount--;
			bal += hSpeed;
		}
		*p++ = data;
		frameLeft--;
		bal -= sSpeed;
	}
	expand_bal = bal;
	expand_data = data;
	*frameUsed += (ftotal - frameLeft) ;
	utotal -= userCount;
	return utotal;
}

/* compressing versions */
static ssize_t q40_ctc_law(const u_char __user *userPtr, size_t userCount,
			    u_char frame[], ssize_t *frameUsed,
			    ssize_t frameLeft)
{
	unsigned char *table = (unsigned char *)
		(dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8: dmasound_alaw2dma8);
	unsigned int data = expand_data;
	u_char *p = (u_char *) &frame[*frameUsed];
	int bal = expand_bal;
	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
	int utotal, ftotal;
 
	ftotal = frameLeft;
	utotal = userCount;
	while (frameLeft) {
		u_char c;
		while(bal<0) {
			if (userCount == 0)
				goto lout;
			if (!(bal<(-hSpeed))) {
				if (get_user(c, userPtr))
					return -EFAULT;
				data = 0x80 + table[c];
			}
			userPtr++;
			userCount--;
			bal += hSpeed;
		}
		*p++ = data;
		frameLeft--;
		bal -= sSpeed;
	}
 lout:
	expand_bal = bal;
	expand_data = data;
	*frameUsed += (ftotal - frameLeft);
	utotal -= userCount;
	return utotal;
}


static ssize_t q40_ctc_s8(const u_char __user *userPtr, size_t userCount,
			   u_char frame[], ssize_t *frameUsed,
			   ssize_t frameLeft)
{
	u_char *p = (u_char *) &frame[*frameUsed];
	unsigned int data = expand_data;
	int bal = expand_bal;
	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
	int utotal, ftotal;

	ftotal = frameLeft;
	utotal = userCount;
	while (frameLeft) {
		u_char c;
		while (bal < 0) {
			if (userCount == 0)
				goto lout;
			if (!(bal<(-hSpeed))) {
				if (get_user(c, userPtr))
					return -EFAULT;
				data = c + 0x80;
			}
			userPtr++;
			userCount--;
			bal += hSpeed;
		}
		*p++ = data;
		frameLeft--;
		bal -= sSpeed;
	}
 lout:
	expand_bal = bal;
	expand_data = data;
	*frameUsed += (ftotal - frameLeft);
	utotal -= userCount;
	return utotal;
}


static ssize_t q40_ctc_u8(const u_char __user *userPtr, size_t userCount,
			   u_char frame[], ssize_t *frameUsed,
			   ssize_t frameLeft)
{
	u_char *p = (u_char *) &frame[*frameUsed];
	unsigned int data = expand_data;
	int bal = expand_bal;
	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
	int utotal, ftotal;

	ftotal = frameLeft;
	utotal = userCount;
	while (frameLeft) {
		u_char c;
		while (bal < 0) {
			if (userCount == 0)
				goto lout;
			if (!(bal<(-hSpeed))) {
				if (get_user(c, userPtr))
					return -EFAULT;
				data = c ;
			}
			userPtr++;
			userCount--;
			bal += hSpeed;
		}
		*p++ = data;
		frameLeft--;
		bal -= sSpeed;
	}
 lout:
	expand_bal = bal;
	expand_data = data;
	*frameUsed += (ftotal - frameLeft) ;
	utotal -= userCount;
	return utotal;
}


static TRANS transQ40Normal = {
	q40_ct_law, q40_ct_law, q40_ct_s8, q40_ct_u8, NULL, NULL, NULL, NULL
};

static TRANS transQ40Expanding = {
	q40_ctx_law, q40_ctx_law, q40_ctx_s8, q40_ctx_u8, NULL, NULL, NULL, NULL
};

static TRANS transQ40Compressing = {
	q40_ctc_law, q40_ctc_law, q40_ctc_s8, q40_ctc_u8, NULL, NULL, NULL, NULL
};


/*** Low level stuff *********************************************************/

static void *Q40Alloc(unsigned int size, gfp_t flags)
{
         return kmalloc(size, flags); /* change to vmalloc */
}

static void Q40Free(void *ptr, unsigned int size)
{
	kfree(ptr);
}

static int __init Q40IrqInit(void)
{
	/* Register interrupt handler. */
	if (request_irq(Q40_IRQ_SAMPLE, Q40StereoInterrupt, 0,
		    "DMA sound", Q40Interrupt))
		return 0;

	return(1);
}


#ifdef MODULE
static void Q40IrqCleanUp(void)
{
        master_outb(0,SAMPLE_ENABLE_REG);
	free_irq(Q40_IRQ_SAMPLE, Q40Interrupt);
}
#endif /* MODULE */


static void Q40Silence(void)
{
        master_outb(0,SAMPLE_ENABLE_REG);
	*DAC_LEFT=*DAC_RIGHT=127;
}

static char *q40_pp;
static unsigned int q40_sc;

static void Q40PlayNextFrame(int index)
{
	u_char *start;
	u_long size;
	u_char speed;
	int error;

	/* used by Q40Play() if all doubts whether there really is something
	 * to be played are already wiped out.
	 */
	start = write_sq.buffers[write_sq.front];
	size = (write_sq.count == index ? write_sq.rear_size : write_sq.block_size);

	q40_pp=start;
	q40_sc=size;

	write_sq.front = (write_sq.front+1) % write_sq.max_count;
	write_sq.active++;

	speed=(dmasound.hard.speed==10000 ? 0 : 1);

	master_outb( 0,SAMPLE_ENABLE_REG);
	free_irq(Q40_IRQ_SAMPLE, Q40Interrupt);
	if (dmasound.soft.stereo)
		error = request_irq(Q40_IRQ_SAMPLE, Q40StereoInterrupt, 0,
				    "Q40 sound", Q40Interrupt);
	  else
		error = request_irq(Q40_IRQ_SAMPLE, Q40MonoInterrupt, 0,
				    "Q40 sound", Q40Interrupt);
	if (error && printk_ratelimit())
		pr_err("Couldn't register sound interrupt\n");

	master_outb( speed, SAMPLE_RATE_REG);
	master_outb( 1,SAMPLE_CLEAR_REG);
	master_outb( 1,SAMPLE_ENABLE_REG);
}

static void Q40Play(void)
{
        unsigned long flags;

	if (write_sq.active || write_sq.count<=0 ) {
		/* There's already a frame loaded */
		return;
	}

	/* nothing in the queue */
	if (write_sq.count <= 1 && write_sq.rear_size < write_sq.block_size && !write_sq.syncing) {
	         /* hmmm, the only existing frame is not
		  * yet filled and we're not syncing?
		  */
	         return;
	}
	spin_lock_irqsave(&dmasound.lock, flags);
	Q40PlayNextFrame(1);
	spin_unlock_irqrestore(&dmasound.lock, flags);
}

static irqreturn_t Q40StereoInterrupt(int irq, void *dummy)
{
	spin_lock(&dmasound.lock);
        if (q40_sc>1){
            *DAC_LEFT=*q40_pp++;
	    *DAC_RIGHT=*q40_pp++;
	    q40_sc -=2;
	    master_outb(1,SAMPLE_CLEAR_REG);
	}else Q40Interrupt();
	spin_unlock(&dmasound.lock);
	return IRQ_HANDLED;
}
static irqreturn_t Q40MonoInterrupt(int irq, void *dummy)
{
	spin_lock(&dmasound.lock);
        if (q40_sc>0){
            *DAC_LEFT=*q40_pp;
	    *DAC_RIGHT=*q40_pp++;
	    q40_sc --;
	    master_outb(1,SAMPLE_CLEAR_REG);
	}else Q40Interrupt();
	spin_unlock(&dmasound.lock);
	return IRQ_HANDLED;
}
static void Q40Interrupt(void)
{
	if (!write_sq.active) {
	          /* playing was interrupted and sq_reset() has already cleared
		   * the sq variables, so better don't do anything here.
		   */
	           WAKE_UP(write_sq.sync_queue);
		   master_outb(0,SAMPLE_ENABLE_REG); /* better safe */
		   goto exit;
	} else write_sq.active=0;
	write_sq.count--;
	Q40Play();

	if (q40_sc<2)
	      { /* there was nothing to play, disable irq */
		master_outb(0,SAMPLE_ENABLE_REG);
		*DAC_LEFT=*DAC_RIGHT=127;
	      }
	WAKE_UP(write_sq.action_queue);

 exit:
	master_outb(1,SAMPLE_CLEAR_REG);
}


static void Q40Init(void)
{
	int i, idx;
	const int freq[] = {10000, 20000};

	/* search a frequency that fits into the allowed error range */

	idx = -1;
	for (i = 0; i < 2; i++)
		if ((100 * abs(dmasound.soft.speed - freq[i]) / freq[i]) <= catchRadius)
			idx = i;

	dmasound.hard = dmasound.soft;
	/*sound.hard.stereo=1;*/ /* no longer true */
	dmasound.hard.size=8;

	if (idx > -1) {
		dmasound.soft.speed = freq[idx];
		dmasound.trans_write = &transQ40Normal;
	} else
		dmasound.trans_write = &transQ40Expanding;

	Q40Silence();

	if (dmasound.hard.speed > 20200) {
		/* squeeze the sound, we do that */
		dmasound.hard.speed = 20000;
		dmasound.trans_write = &transQ40Compressing;
	} else if (dmasound.hard.speed > 10000) {
		dmasound.hard.speed = 20000;
	} else {
		dmasound.hard.speed = 10000;
	}
	expand_bal = -dmasound.soft.speed;
}


static int Q40SetFormat(int format)
{
	/* Q40 sound supports only 8bit modes */

	switch (format) {
	case AFMT_QUERY:
		return(dmasound.soft.format);
	case AFMT_MU_LAW:
	case AFMT_A_LAW:
	case AFMT_S8:
	case AFMT_U8:
		break;
	default:
		format = AFMT_S8;
	}

	dmasound.soft.format = format;
	dmasound.soft.size = 8;
	if (dmasound.minDev == SND_DEV_DSP) {
		dmasound.dsp.format = format;
		dmasound.dsp.size = 8;
	}
	Q40Init();

	return(format);
}

static int Q40SetVolume(int volume)
{
    return 0;
}


/*** Machine definitions *****************************************************/

static SETTINGS def_hard = {
	.format	= AFMT_U8,
	.stereo	= 0,
	.size	= 8,
	.speed	= 10000
} ;

static SETTINGS def_soft = {
	.format	= AFMT_U8,
	.stereo	= 0,
	.size	= 8,
	.speed	= 8000
} ;

static MACHINE machQ40 = {
	.name		= "Q40",
	.name2		= "Q40",
	.owner		= THIS_MODULE,
	.dma_alloc	= Q40Alloc,
	.dma_free	= Q40Free,
	.irqinit	= Q40IrqInit,
#ifdef MODULE
	.irqcleanup	= Q40IrqCleanUp,
#endif /* MODULE */
	.init		= Q40Init,
	.silence	= Q40Silence,
	.setFormat	= Q40SetFormat,
	.setVolume	= Q40SetVolume,
	.play		= Q40Play,
 	.min_dsp_speed	= 10000,
	.version	= ((DMASOUND_Q40_REVISION<<8) | DMASOUND_Q40_EDITION),
	.hardware_afmts	= AFMT_U8, /* h'ware-supported formats *only* here */
	.capabilities	= DSP_CAP_BATCH  /* As per SNDCTL_DSP_GETCAPS */
};


/*** Config & Setup **********************************************************/


static int __init dmasound_q40_init(void)
{
	if (MACH_IS_Q40) {
	    dmasound.mach = machQ40;
	    dmasound.mach.default_hard = def_hard ;
	    dmasound.mach.default_soft = def_soft ;
	    return dmasound_init();
	} else
	    return -ENODEV;
}

static void __exit dmasound_q40_cleanup(void)
{
	dmasound_deinit();
}

module_init(dmasound_q40_init);
module_exit(dmasound_q40_cleanup);

MODULE_DESCRIPTION("Q40/Q60 sound driver");
MODULE_LICENSE("GPL");
cmd_drivers/net/igb/igb.o := ld -m elf_x86_64   -r -o drivers/net/igb/igb.o drivers/net/igb/igb_main.o drivers/net/igb/igb_ethtool.o drivers/net/igb/e1000_82575.o drivers/net/igb/e1000_mac.o drivers/net/igb/e1000_nvm.o drivers/net/igb/e1000_phy.o drivers/net/igb/e1000_mbx.o 
/*********************************************************************
 *                
 * Filename:      irlan_event.h
 * Version:       
 * Description:   LAN access
 * Status:        Experimental.
 * Author:        Dag Brattli <dagb@cs.uit.no>
 * Created at:    Sun Aug 31 20:14:37 1997
 * Modified at:   Tue Feb  2 09:45:17 1999
 * Modified by:   Dag Brattli <dagb@cs.uit.no>
 * 
 *     Copyright (c) 1997 Dag Brattli <dagb@cs.uit.no>, All Rights Reserved.
 *     
 *     This program is free software; you can redistribute it and/or 
 *     modify it under the terms of the GNU General Public License as 
 *     published by the Free Software Foundation; either version 2 of 
 *     the License, or (at your option) any later version.
 *
 *     Neither Dag Brattli nor University of Troms admit liability nor
 *     provide warranty for any of this software. This material is 
 *     provided "AS-IS" and at no charge.
 *
 ********************************************************************/

#ifndef IRLAN_EVENT_H
#define IRLAN_EVENT_H

#include <linux/kernel.h>
#include <linux/skbuff.h>

#include <net/irda/irlan_common.h>

typedef enum {
	IRLAN_IDLE,
	IRLAN_QUERY,
	IRLAN_CONN, 
	IRLAN_INFO,
	IRLAN_MEDIA,
	IRLAN_OPEN,
	IRLAN_WAIT,
	IRLAN_ARB, 
	IRLAN_DATA,
	IRLAN_CLOSE,
	IRLAN_SYNC
} IRLAN_STATE;

typedef enum {
	IRLAN_DISCOVERY_INDICATION,
	IRLAN_IAS_PROVIDER_AVAIL,
	IRLAN_IAS_PROVIDER_NOT_AVAIL,
	IRLAN_LAP_DISCONNECT,
	IRLAN_LMP_DISCONNECT,
	IRLAN_CONNECT_COMPLETE,
	IRLAN_DATA_INDICATION,
	IRLAN_DATA_CONNECT_INDICATION,
	IRLAN_RETRY_CONNECT,

	IRLAN_CONNECT_INDICATION,
	IRLAN_GET_INFO_CMD,
	IRLAN_GET_MEDIA_CMD,
	IRLAN_OPEN_DATA_CMD,
	IRLAN_FILTER_CONFIG_CMD,

	IRLAN_CHECK_CON_ARB,
	IRLAN_PROVIDER_SIGNAL,

	IRLAN_WATCHDOG_TIMEOUT,
} IRLAN_EVENT;

extern char *irlan_state[];

void irlan_do_client_event(struct irlan_cb *self, IRLAN_EVENT event, 
			   struct sk_buff *skb);

void irlan_do_provider_event(struct irlan_cb *self, IRLAN_EVENT event, 
			     struct sk_buff *skb);

void irlan_next_client_state(struct irlan_cb *self, IRLAN_STATE state);
void irlan_next_provider_state(struct irlan_cb *self, IRLAN_STATE state);

#endif
/* sm501-regs.h
 *
 * Copyright 2006 Simtec Electronics
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Silicon Motion SM501 register definitions
*/

/* System Configuration area */
/* System config base */
#define SM501_SYS_CONFIG		(0x000000)

/* config 1 */
#define SM501_SYSTEM_CONTROL 		(0x000000)

#define SM501_SYSCTRL_PANEL_TRISTATE	(1<<0)
#define SM501_SYSCTRL_MEM_TRISTATE	(1<<1)
#define SM501_SYSCTRL_CRT_TRISTATE	(1<<2)

#define SM501_SYSCTRL_PCI_SLAVE_BURST_MASK (3<<4)
#define SM501_SYSCTRL_PCI_SLAVE_BURST_1	(0<<4)
#define SM501_SYSCTRL_PCI_SLAVE_BURST_2	(1<<4)
#define SM501_SYSCTRL_PCI_SLAVE_BURST_4	(2<<4)
#define SM501_SYSCTRL_PCI_SLAVE_BURST_8	(3<<4)

#define SM501_SYSCTRL_PCI_CLOCK_RUN_EN	(1<<6)
#define SM501_SYSCTRL_PCI_RETRY_DISABLE	(1<<7)
#define SM501_SYSCTRL_PCI_SUBSYS_LOCK	(1<<11)
#define SM501_SYSCTRL_PCI_BURST_READ_EN	(1<<15)

#define SM501_SYSCTRL_2D_ENGINE_STATUS	(1<<19)

/* miscellaneous control */

#define SM501_MISC_CONTROL		(0x000004)

#define SM501_MISC_BUS_SH		(0x0)
#define SM501_MISC_BUS_PCI		(0x1)
#define SM501_MISC_BUS_XSCALE		(0x2)
#define SM501_MISC_BUS_NEC		(0x6)
#define SM501_MISC_BUS_MASK		(0x7)

#define SM501_MISC_VR_62MB		(1<<3)
#define SM501_MISC_CDR_RESET		(1<<7)
#define SM501_MISC_USB_LB		(1<<8)
#define SM501_MISC_USB_SLAVE		(1<<9)
#define SM501_MISC_BL_1			(1<<10)
#define SM501_MISC_MC			(1<<11)
#define SM501_MISC_DAC_POWER		(1<<12)
#define SM501_MISC_IRQ_INVERT		(1<<16)
#define SM501_MISC_SH			(1<<17)

#define SM501_MISC_HOLD_EMPTY		(0<<18)
#define SM501_MISC_HOLD_8		(1<<18)
#define SM501_MISC_HOLD_16		(2<<18)
#define SM501_MISC_HOLD_24		(3<<18)
#define SM501_MISC_HOLD_32		(4<<18)
#define SM501_MISC_HOLD_MASK		(7<<18)

#define SM501_MISC_FREQ_12		(1<<24)
#define SM501_MISC_PNL_24BIT		(1<<25)
#define SM501_MISC_8051_LE		(1<<26)



#define SM501_GPIO31_0_CONTROL		(0x000008)
#define SM501_GPIO63_32_CONTROL		(0x00000C)
#define SM501_DRAM_CONTROL		(0x000010)

/* command list */
#define SM501_ARBTRTN_CONTROL		(0x000014)

/* command list */
#define SM501_COMMAND_LIST_STATUS	(0x000024)

/* interrupt debug */
#define SM501_RAW_IRQ_STATUS		(0x000028)
#define SM501_RAW_IRQ_CLEAR		(0x000028)
#define SM501_IRQ_STATUS		(0x00002C)
#define SM501_IRQ_MASK			(0x000030)
#define SM501_DEBUG_CONTROL		(0x000034)

/* power management */
#define SM501_POWERMODE_P2X_SRC		(1<<29)
#define SM501_POWERMODE_V2X_SRC		(1<<20)
#define SM501_POWERMODE_M_SRC		(1<<12)
#define SM501_POWERMODE_M1_SRC		(1<<4)

#define SM501_CURRENT_GATE		(0x000038)
#define SM501_CURRENT_CLOCK		(0x00003C)
#define SM501_POWER_MODE_0_GATE		(0x000040)
#define SM501_POWER_MODE_0_CLOCK	(0x000044)
#define SM501_POWER_MODE_1_GATE		(0x000048)
#define SM501_POWER_MODE_1_CLOCK	(0x00004C)
#define SM501_SLEEP_MODE_GATE		(0x000050)
#define SM501_POWER_MODE_CONTROL	(0x000054)

/* power gates for units within the 501 */
#define SM501_GATE_HOST			(0)
#define SM501_GATE_MEMORY		(1)
#define SM501_GATE_DISPLAY		(2)
#define SM501_GATE_2D_ENGINE		(3)
#define SM501_GATE_CSC			(4)
#define SM501_GATE_ZVPORT		(5)
#define SM501_GATE_GPIO			(6)
#define SM501_GATE_UART0		(7)
#define SM501_GATE_UART1		(8)
#define SM501_GATE_SSP			(10)
#define SM501_GATE_USB_HOST		(11)
#define SM501_GATE_USB_GADGET		(12)
#define SM501_GATE_UCONTROLLER		(17)
#define SM501_GATE_AC97			(18)

/* panel clock */
#define SM501_CLOCK_P2XCLK		(24)
/* crt clock */
#define SM501_CLOCK_V2XCLK		(16)
/* main clock */
#define SM501_CLOCK_MCLK		(8)
/* SDRAM controller clock */
#define SM501_CLOCK_M1XCLK		(0)

/* config 2 */
#define SM501_PCI_MASTER_BASE		(0x000058)
#define SM501_ENDIAN_CONTROL		(0x00005C)
#define SM501_DEVICEID			(0x000060)
/* 0x050100A0 */

#define SM501_DEVICEID_SM501		(0x05010000)
#define SM501_DEVICEID_IDMASK		(0xffff0000)
#define SM501_DEVICEID_REVMASK		(0x000000ff)

#define SM501_PLLCLOCK_COUNT		(0x000064)
#define SM501_MISC_TIMING		(0x000068)
#define SM501_CURRENT_SDRAM_CLOCK	(0x00006C)

#define SM501_PROGRAMMABLE_PLL_CONTROL	(0x000074)

/* GPIO base */
#define SM501_GPIO			(0x010000)
#define SM501_GPIO_DATA_LOW		(0x00)
#define SM501_GPIO_DATA_HIGH		(0x04)
#define SM501_GPIO_DDR_LOW		(0x08)
#define SM501_GPIO_DDR_HIGH		(0x0C)
#define SM501_GPIO_IRQ_SETUP		(0x10)
#define SM501_GPIO_IRQ_STATUS		(0x14)
#define SM501_GPIO_IRQ_RESET		(0x14)

/* I2C controller base */
#define SM501_I2C			(0x010040)
#define SM501_I2C_BYTE_COUNT		(0x00)
#define SM501_I2C_CONTROL		(0x01)
#define SM501_I2C_STATUS		(0x02)
#define SM501_I2C_RESET			(0x02)
#define SM501_I2C_SLAVE_ADDRESS		(0x03)
#define SM501_I2C_DATA			(0x04)

/* SSP base */
#define SM501_SSP			(0x020000)

/* Uart 0 base */
#define SM501_UART0			(0x030000)

/* Uart 1 base */
#define SM501_UART1			(0x030020)

/* USB host port base */
#define SM501_USB_HOST			(0x040000)

/* USB slave/gadget base */
#define SM501_USB_GADGET		(0x060000)

/* USB slave/gadget data port base */
#define SM501_USB_GADGET_DATA		(0x070000)

/* Display controller/video engine base */
#define SM501_DC			(0x080000)

/* common defines for the SM501 address registers */
#define SM501_ADDR_FLIP			(1<<31)
#define SM501_ADDR_EXT			(1<<27)
#define SM501_ADDR_CS1			(1<<26)
#define SM501_ADDR_MASK			(0x3f << 26)

#define SM501_FIFO_MASK			(0x3 << 16)
#define SM501_FIFO_1			(0x0 << 16)
#define SM501_FIFO_3			(0x1 << 16)
#define SM501_FIFO_7			(0x2 << 16)
#define SM501_FIFO_11			(0x3 << 16)

/* common registers for panel and the crt */
#define SM501_OFF_DC_H_TOT		(0x000)
#define SM501_OFF_DC_V_TOT		(0x008)
#define SM501_OFF_DC_H_SYNC		(0x004)
#define SM501_OFF_DC_V_SYNC		(0x00C)

#define SM501_DC_PANEL_CONTROL		(0x000)

#define SM501_DC_PANEL_CONTROL_FPEN	(1<<27)
#define SM501_DC_PANEL_CONTROL_BIAS	(1<<26)
#define SM501_DC_PANEL_CONTROL_DATA	(1<<25)
#define SM501_DC_PANEL_CONTROL_VDD	(1<<24)
#define SM501_DC_PANEL_CONTROL_DP	(1<<23)

#define SM501_DC_PANEL_CONTROL_TFT_888	(0<<21)
#define SM501_DC_PANEL_CONTROL_TFT_333	(1<<21)
#define SM501_DC_PANEL_CONTROL_TFT_444	(2<<21)

#define SM501_DC_PANEL_CONTROL_DE	(1<<20)

#define SM501_DC_PANEL_CONTROL_LCD_TFT	(0<<18)
#define SM501_DC_PANEL_CONTROL_LCD_STN8	(1<<18)
#define SM501_DC_PANEL_CONTROL_LCD_STN12 (2<<18)

#define SM501_DC_PANEL_CONTROL_CP	(1<<14)
#define SM501_DC_PANEL_CONTROL_VSP	(1<<13)
#define SM501_DC_PANEL_CONTROL_HSP	(1<<12)
#define SM501_DC_PANEL_CONTROL_CK	(1<<9)
#define SM501_DC_PANEL_CONTROL_TE	(1<<8)
#define SM501_DC_PANEL_CONTROL_VPD	(1<<7)
#define SM501_DC_PANEL_CONTROL_VP	(1<<6)
#define SM501_DC_PANEL_CONTROL_HPD	(1<<5)
#define SM501_DC_PANEL_CONTROL_HP	(1<<4)
#define SM501_DC_PANEL_CONTROL_GAMMA	(1<<3)
#define SM501_DC_PANEL_CONTROL_EN	(1<<2)

#define SM501_DC_PANEL_CONTROL_8BPP	(0<<0)
#define SM501_DC_PANEL_CONTROL_16BPP	(1<<0)
#define SM501_DC_PANEL_CONTROL_32BPP	(2<<0)


#define SM501_DC_PANEL_PANNING_CONTROL	(0x004)
#define SM501_DC_PANEL_COLOR_KEY	(0x008)
#define SM501_DC_PANEL_FB_ADDR		(0x00C)
#define SM501_DC_PANEL_FB_OFFSET	(0x010)
#define SM501_DC_PANEL_FB_WIDTH		(0x014)
#define SM501_DC_PANEL_FB_HEIGHT	(0x018)
#define SM501_DC_PANEL_TL_LOC		(0x01C)
#define SM501_DC_PANEL_BR_LOC		(0x020)
#define SM501_DC_PANEL_H_TOT		(0x024)
#define SM501_DC_PANEL_H_SYNC		(0x028)
#define SM501_DC_PANEL_V_TOT		(0x02C)
#define SM501_DC_PANEL_V_SYNC		(0x030)
#define SM501_DC_PANEL_CUR_LINE		(0x034)

#define SM501_DC_VIDEO_CONTROL		(0x040)
#define SM501_DC_VIDEO_FB0_ADDR		(0x044)
#define SM501_DC_VIDEO_FB_WIDTH		(0x048)
#define SM501_DC_VIDEO_FB0_LAST_ADDR	(0x04C)
#define SM501_DC_VIDEO_TL_LOC		(0x050)
#define SM501_DC_VIDEO_BR_LOC		(0x054)
#define SM501_DC_VIDEO_SCALE		(0x058)
#define SM501_DC_VIDEO_INIT_SCALE	(0x05C)
#define SM501_DC_VIDEO_YUV_CONSTANTS	(0x060)
#define SM501_DC_VIDEO_FB1_ADDR		(0x064)
#define SM501_DC_VIDEO_FB1_LAST_ADDR	(0x068)

#define SM501_DC_VIDEO_ALPHA_CONTROL	(0x080)
#define SM501_DC_VIDEO_ALPHA_FB_ADDR	(0x084)
#define SM501_DC_VIDEO_ALPHA_FB_OFFSET	(0x088)
#define SM501_DC_VIDEO_ALPHA_FB_LAST_ADDR	(0x08C)
#define SM501_DC_VIDEO_ALPHA_TL_LOC	(0x090)
#define SM501_DC_VIDEO_ALPHA_BR_LOC	(0x094)
#define SM501_DC_VIDEO_ALPHA_SCALE	(0x098)
#define SM501_DC_VIDEO_ALPHA_INIT_SCALE	(0x09C)
#define SM501_DC_VIDEO_ALPHA_CHROMA_KEY	(0x0A0)
#define SM501_DC_VIDEO_ALPHA_COLOR_LOOKUP	(0x0A4)

#define SM501_DC_PANEL_HWC_BASE		(0x0F0)
#define SM501_DC_PANEL_HWC_ADDR		(0x0F0)
#define SM501_DC_PANEL_HWC_LOC		(0x0F4)
#define SM501_DC_PANEL_HWC_COLOR_1_2	(0x0F8)
#define SM501_DC_PANEL_HWC_COLOR_3	(0x0FC)

#define SM501_HWC_EN			(1<<31)

#define SM501_OFF_HWC_ADDR		(0x00)
#define SM501_OFF_HWC_LOC		(0x04)
#define SM501_OFF_HWC_COLOR_1_2		(0x08)
#define SM501_OFF_HWC_COLOR_3		(0x0C)

#define SM501_DC_ALPHA_CONTROL		(0x100)
#define SM501_DC_ALPHA_FB_ADDR		(0x104)
#define SM501_DC_ALPHA_FB_OFFSET	(0x108)
#define SM501_DC_ALPHA_TL_LOC		(0x10C)
#define SM501_DC_ALPHA_BR_LOC		(0x110)
#define SM501_DC_ALPHA_CHROMA_KEY	(0x114)
#define SM501_DC_ALPHA_COLOR_LOOKUP	(0x118)

#define SM501_DC_CRT_CONTROL		(0x200)

#define SM501_DC_CRT_CONTROL_TVP	(1<<15)
#define SM501_DC_CRT_CONTROL_CP		(1<<14)
#define SM501_DC_CRT_CONTROL_VSP	(1<<13)
#define SM501_DC_CRT_CONTROL_HSP	(1<<12)
#define SM501_DC_CRT_CONTROL_VS		(1<<11)
#define SM501_DC_CRT_CONTROL_BLANK	(1<<10)
#define SM501_DC_CRT_CONTROL_SEL	(1<<9)
#define SM501_DC_CRT_CONTROL_TE		(1<<8)
#define SM501_DC_CRT_CONTROL_PIXEL_MASK (0xF << 4)
#define SM501_DC_CRT_CONTROL_GAMMA	(1<<3)
#define SM501_DC_CRT_CONTROL_ENABLE	(1<<2)

#define SM501_DC_CRT_CONTROL_8BPP	(0<<0)
#define SM501_DC_CRT_CONTROL_16BPP	(1<<0)
#define SM501_DC_CRT_CONTROL_32BPP	(2<<0)

#define SM501_DC_CRT_FB_ADDR		(0x204)
#define SM501_DC_CRT_FB_OFFSET		(0x208)
#define SM501_DC_CRT_H_TOT		(0x20C)
#define SM501_DC_CRT_H_SYNC		(0x210)
#define SM501_DC_CRT_V_TOT		(0x214)
#define SM501_DC_CRT_V_SYNC		(0x218)
#define SM501_DC_CRT_SIGNATURE_ANALYZER	(0x21C)
#define SM501_DC_CRT_CUR_LINE		(0x220)
#define SM501_DC_CRT_MONITOR_DETECT	(0x224)

#define SM501_DC_CRT_HWC_BASE		(0x230)
#define SM501_DC_CRT_HWC_ADDR		(0x230)
#define SM501_DC_CRT_HWC_LOC		(0x234)
#define SM501_DC_CRT_HWC_COLOR_1_2	(0x238)
#define SM501_DC_CRT_HWC_COLOR_3	(0x23C)

#define SM501_DC_PANEL_PALETTE		(0x400)

#define SM501_DC_VIDEO_PALETTE		(0x800)

#define SM501_DC_CRT_PALETTE		(0xC00)

/* Zoom Video port base */
#define SM501_ZVPORT			(0x090000)

/* AC97/I2S base */
#define SM501_AC97			(0x0A0000)

/* 8051 micro controller base */
#define SM501_UCONTROLLER		(0x0B0000)

/* 8051 micro controller SRAM base */
#define SM501_UCONTROLLER_SRAM		(0x0C0000)

/* DMA base */
#define SM501_DMA			(0x0D0000)

/* 2d engine base */
#define SM501_2D_ENGINE			(0x100000)
#define SM501_2D_SOURCE			(0x00)
#define SM501_2D_DESTINATION		(0x04)
#define SM501_2D_DIMENSION		(0x08)
#define SM501_2D_CONTROL		(0x0C)
#define SM501_2D_PITCH			(0x10)
#define SM501_2D_FOREGROUND		(0x14)
#define SM501_2D_BACKGROUND		(0x18)
#define SM501_2D_STRETCH		(0x1C)
#define SM501_2D_COLOR_COMPARE		(0x20)
#define SM501_2D_COLOR_COMPARE_MASK 	(0x24)
#define SM501_2D_MASK			(0x28)
#define SM501_2D_CLIP_TL		(0x2C)
#define SM501_2D_CLIP_BR		(0x30)
#define SM501_2D_MONO_PATTERN_LOW	(0x34)
#define SM501_2D_MONO_PATTERN_HIGH	(0x38)
#define SM501_2D_WINDOW_WIDTH		(0x3C)
#define SM501_2D_SOURCE_BASE		(0x40)
#define SM501_2D_DESTINATION_BASE	(0x44)
#define SM501_2D_ALPHA			(0x48)
#define SM501_2D_WRAP			(0x4C)
#define SM501_2D_STATUS			(0x50)

#define SM501_CSC_Y_SOURCE_BASE		(0xC8)
#define SM501_CSC_CONSTANTS		(0xCC)
#define SM501_CSC_Y_SOURCE_X		(0xD0)
#define SM501_CSC_Y_SOURCE_Y		(0xD4)
#define SM501_CSC_U_SOURCE_BASE		(0xD8)
#define SM501_CSC_V_SOURCE_BASE		(0xDC)
#define SM501_CSC_SOURCE_DIMENSION	(0xE0)
#define SM501_CSC_SOURCE_PITCH		(0xE4)
#define SM501_CSC_DESTINATION		(0xE8)
#define SM501_CSC_DESTINATION_DIMENSION	(0xEC)
#define SM501_CSC_DESTINATION_PITCH	(0xF0)
#define SM501_CSC_SCALE_FACTOR		(0xF4)
#define SM501_CSC_DESTINATION_BASE	(0xF8)
#define SM501_CSC_CONTROL		(0xFC)

/* 2d engine data port base */
#define SM501_2D_ENGINE_DATA		(0x110000)
cmd_arch/x86/kernel/reboot.o := gcc -Wp,-MD,arch/x86/kernel/.reboot.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(reboot)"  -D"KBUILD_MODNAME=KBUILD_STR(reboot)"  -c -o arch/x86/kernel/.tmp_reboot.o arch/x86/kernel/reboot.c

deps_arch/x86/kernel/reboot.o := \
  arch/x86/kernel/reboot.c \
    $(wildcard include/config/x86/32.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/apm.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/hpet/timer.h) \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/kexec.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/reboot.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/emergency-restart.h \
  include/linux/efi.h \
    $(wildcard include/config/efi/pcdp.h) \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
    $(wildcard include/config/mmu.h) \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/security.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/rculist.h \
  include/linux/path.h \
  include/linux/radix-tree.h \
  include/linux/prio_tree.h \
  include/linux/pid.h \
  include/linux/capability.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/percpu_counter.h \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/magic.h \
  include/linux/rtc.h \
    $(wildcard include/config/rtc/intf/dev/uie/emul.h) \
    $(wildcard include/config/rtc/hctosys.h) \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/irqreturn.h \
  include/linux/irqnr.h \
  include/linux/hardirq.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/mm/owner.h) \
  include/linux/rbtree.h \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/proportions.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
  include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  include/linux/sysctl.h \
  include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/uio.h \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/s390.h) \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/seq_file.h \
  include/linux/cdev.h \
  include/linux/poll.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/poll.h \
  include/asm-generic/poll.h \
  include/linux/dmi.h \
    $(wildcard include/config/dmi.h) \
  include/linux/mod_devicetable.h \
  include/linux/tboot.h \
  include/acpi/reboot.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ldt.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hpet.h \
    $(wildcard include/config/pci/msi.h) \
    $(wildcard include/config/hpet/emulate/rtc.h) \
  include/linux/msi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/proto.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/reboot_fixups.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/reboot.h \
  include/linux/kdebug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/kdebug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pci_x86.h \
    $(wildcard include/config/pci.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/virtext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vmx.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/svm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpu.h \
  include/linux/cpu.h \
    $(wildcard include/config/arch/cpu/probe/release.h) \
    $(wildcard include/config/pm/sleep/smp.h) \
  include/linux/sysdev.h \
  include/linux/node.h \
    $(wildcard include/config/memory/hotplug/sparse.h) \
    $(wildcard include/config/hugetlbfs.h) \

arch/x86/kernel/reboot.o: $(deps_arch/x86/kernel/reboot.o)

$(deps_arch/x86/kernel/reboot.o):
cmd_net/ipv4/netfilter/iptable_filter.mod.o := gcc -Wp,-MD,net/ipv4/netfilter/.iptable_filter.mod.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(iptable_filter.mod)"  -D"KBUILD_MODNAME=KBUILD_STR(iptable_filter)"  -DMODULE  -c -o net/ipv4/netfilter/iptable_filter.mod.o net/ipv4/netfilter/iptable_filter.mod.c

deps_net/ipv4/netfilter/iptable_filter.mod.o := \
  net/ipv4/netfilter/iptable_filter.mod.c \
    $(wildcard include/config/module/unload.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/vermagic.h \
  include/generated/utsrelease.h \

net/ipv4/netfilter/iptable_filter.mod.o: $(deps_net/ipv4/netfilter/iptable_filter.mod.o)

$(deps_net/ipv4/netfilter/iptable_filter.mod.o):
/*
 *  SCSI Transport Netlink Interface
 *    Used for the posting of outbound SCSI transport events
 *
 *  Copyright (C) 2006   James Smart, Emulex Corporation
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */
#ifndef SCSI_NETLINK_H
#define SCSI_NETLINK_H

#include <linux/netlink.h>


/*
 * This file intended to be included by both kernel and user space
 */

/* Single Netlink Message type to send all SCSI Transport messages */
#define SCSI_TRANSPORT_MSG		NLMSG_MIN_TYPE + 1

/* SCSI Transport Broadcast Groups */
	/* leaving groups 0 and 1 unassigned */
#define SCSI_NL_GRP_FC_EVENTS		(1<<2)		/* Group 2 */
#define SCSI_NL_GRP_CNT			3


/* SCSI_TRANSPORT_MSG event message header */
struct scsi_nl_hdr {
	uint8_t version;
	uint8_t transport;
	uint16_t magic;
	uint16_t msgtype;
	uint16_t msglen;
} __attribute__((aligned(sizeof(uint64_t))));

/* scsi_nl_hdr->version value */
#define SCSI_NL_VERSION				1

/* scsi_nl_hdr->magic value */
#define SCSI_NL_MAGIC				0xA1B2

/* scsi_nl_hdr->transport value */
#define SCSI_NL_TRANSPORT			0
#define SCSI_NL_TRANSPORT_FC			1
#define SCSI_NL_MAX_TRANSPORTS			2

/* Transport-based scsi_nl_hdr->msgtype values are defined in each transport */

/*
 * GENERIC SCSI scsi_nl_hdr->msgtype Values
 */
	/* kernel -> user */
#define SCSI_NL_SHOST_VENDOR			0x0001
	/* user -> kernel */
/* SCSI_NL_SHOST_VENDOR msgtype is kernel->user and user->kernel */


/*
 * Message Structures :
 */

/* macro to round up message lengths to 8byte boundary */
#define SCSI_NL_MSGALIGN(len)		(((len) + 7) & ~7)


/*
 * SCSI HOST Vendor Unique messages :
 *   SCSI_NL_SHOST_VENDOR
 *
 * Note: The Vendor Unique message payload will begin directly after
 * 	 this structure, with the length of the payload per vmsg_datalen.
 *
 * Note: When specifying vendor_id, be sure to read the Vendor Type and ID
 *   formatting requirements specified below
 */
struct scsi_nl_host_vendor_msg {
	struct scsi_nl_hdr snlh;		/* must be 1st element ! */
	uint64_t vendor_id;
	uint16_t host_no;
	uint16_t vmsg_datalen;
} __attribute__((aligned(sizeof(uint64_t))));


/*
 * Vendor ID:
 *   If transports post vendor-unique events, they must pass a well-known
 *   32-bit vendor identifier. This identifier consists of 8 bits indicating
 *   the "type" of identifier contained, and 24 bits of id data.
 *
 *   Identifiers for each type:
 *    PCI :  ID data is the 16 bit PCI Registered Vendor ID
 */
#define SCSI_NL_VID_TYPE_SHIFT		56
#define SCSI_NL_VID_TYPE_MASK		((__u64)0xFF << SCSI_NL_VID_TYPE_SHIFT)
#define SCSI_NL_VID_TYPE_PCI		((__u64)0x01 << SCSI_NL_VID_TYPE_SHIFT)
#define SCSI_NL_VID_ID_MASK		(~ SCSI_NL_VID_TYPE_MASK)


#define INIT_SCSI_NL_HDR(hdr, t, mtype, mlen)			\
	{							\
	(hdr)->version = SCSI_NL_VERSION;			\
	(hdr)->transport = t;					\
	(hdr)->magic = SCSI_NL_MAGIC;				\
	(hdr)->msgtype = mtype;					\
	(hdr)->msglen = mlen;					\
	}


#ifdef __KERNEL__

#include <scsi/scsi_host.h>

/* Exported Kernel Interfaces */
int scsi_nl_add_transport(u8 tport,
	 int (*msg_handler)(struct sk_buff *),
	void (*event_handler)(struct notifier_block *, unsigned long, void *));
void scsi_nl_remove_transport(u8 tport);

int scsi_nl_add_driver(u64 vendor_id, struct scsi_host_template *hostt,
	int (*nlmsg_handler)(struct Scsi_Host *shost, void *payload,
				 u32 len, u32 pid),
	void (*nlevt_handler)(struct notifier_block *nb,
				 unsigned long event, void *notify_ptr));
void scsi_nl_remove_driver(u64 vendor_id);

void scsi_nl_send_transport_msg(u32 pid, struct scsi_nl_hdr *hdr);
int scsi_nl_send_vendor_msg(u32 pid, unsigned short host_no, u64 vendor_id,
			 char *data_buf, u32 data_len);

#endif /* __KERNEL__ */

#endif /* SCSI_NETLINK_H */

#undef IRQ_DISABLE
#undef IRQ_ENABLE
#undef IRQ_ENTER
#undef IRQ_EXIT

#define IRQ_DISABLE		SOFTIRQ_DISABLE
#define IRQ_ENABLE		SOFTIRQ_ENABLE
#define IRQ_ENTER		SOFTIRQ_ENTER
#define IRQ_EXIT		SOFTIRQ_EXIT
/* nommu.c: mmu-less memory info files
 *
 * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
 * Written by David Howells (dhowells@redhat.com)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/errno.h>
#include <linux/time.h>
#include <linux/kernel.h>
#include <linux/string.h>
#include <linux/mman.h>
#include <linux/proc_fs.h>
#include <linux/mm.h>
#include <linux/mmzone.h>
#include <linux/pagemap.h>
#include <linux/swap.h>
#include <linux/smp.h>
#include <linux/seq_file.h>
#include <linux/hugetlb.h>
#include <linux/vmalloc.h>
#include <asm/uaccess.h>
#include <asm/pgtable.h>
#include <asm/tlb.h>
#include <asm/div64.h>
#include "internal.h"

/*
 * display a single region to a sequenced file
 */
static int nommu_region_show(struct seq_file *m, struct vm_region *region)
{
	unsigned long ino = 0;
	struct file *file;
	dev_t dev = 0;
	int flags, len;

	flags = region->vm_flags;
	file = region->vm_file;

	if (file) {
		struct inode *inode = region->vm_file->f_path.dentry->d_inode;
		dev = inode->i_sb->s_dev;
		ino = inode->i_ino;
	}

	seq_printf(m,
		   "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
		   region->vm_start,
		   region->vm_end,
		   flags & VM_READ ? 'r' : '-',
		   flags & VM_WRITE ? 'w' : '-',
		   flags & VM_EXEC ? 'x' : '-',
		   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',
		   ((loff_t)region->vm_pgoff) << PAGE_SHIFT,
		   MAJOR(dev), MINOR(dev), ino, &len);

	if (file) {
		len = 25 + sizeof(void *) * 6 - len;
		if (len < 1)
			len = 1;
		seq_printf(m, "%*c", len, ' ');
		seq_path(m, &file->f_path, "");
	}

	seq_putc(m, '\n');
	return 0;
}

/*
 * display a list of all the REGIONs the kernel knows about
 * - nommu kernels have a single flat list
 */
static int nommu_region_list_show(struct seq_file *m, void *_p)
{
	struct rb_node *p = _p;

	return nommu_region_show(m, rb_entry(p, struct vm_region, vm_rb));
}

static void *nommu_region_list_start(struct seq_file *m, loff_t *_pos)
{
	struct rb_node *p;
	loff_t pos = *_pos;

	down_read(&nommu_region_sem);

	for (p = rb_first(&nommu_region_tree); p; p = rb_next(p))
		if (pos-- == 0)
			return p;
	return NULL;
}

static void nommu_region_list_stop(struct seq_file *m, void *v)
{
	up_read(&nommu_region_sem);
}

static void *nommu_region_list_next(struct seq_file *m, void *v, loff_t *pos)
{
	(*pos)++;
	return rb_next((struct rb_node *) v);
}

static const struct seq_operations proc_nommu_region_list_seqop = {
	.start	= nommu_region_list_start,
	.next	= nommu_region_list_next,
	.stop	= nommu_region_list_stop,
	.show	= nommu_region_list_show
};

static int proc_nommu_region_list_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_nommu_region_list_seqop);
}

static const struct file_operations proc_nommu_region_list_operations = {
	.open    = proc_nommu_region_list_open,
	.read    = seq_read,
	.llseek  = seq_lseek,
	.release = seq_release,
};

static int __init proc_nommu_init(void)
{
	proc_create("maps", S_IRUGO, NULL, &proc_nommu_region_list_operations);
	return 0;
}

module_init(proc_nommu_init);
cmd_fs/nfs/super.o := gcc -Wp,-MD,fs/nfs/.super.o.d  -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include -I/usr/src/linux-2.6.36-gentoo-r5/arch/x86/include -Iinclude  -include include/generated/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -m64 -march=k8 -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack  -DMODULE  -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(super)"  -D"KBUILD_MODNAME=KBUILD_STR(nfs)"  -c -o fs/nfs/.tmp_super.o fs/nfs/super.c

deps_fs/nfs/super.o := \
  fs/nfs/super.c \
    $(wildcard include/config/nfs/v4.h) \
    $(wildcard include/config/nfs/fscache.h) \
    $(wildcard include/config/security/selinux.h) \
    $(wildcard include/config/nfs/v3.h) \
  include/linux/module.h \
    $(wildcard include/config/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/sysfs.h) \
  include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/types.h \
    $(wildcard include/config/x86/64.h) \
    $(wildcard include/config/highmem64g.h) \
  include/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/linux/posix_types.h \
  include/linux/stddef.h \
  include/linux/compiler.h \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
  include/linux/compiler-gcc4.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/x86/32.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/posix_types_64.h \
  include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  include/linux/prefetch.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor.h \
    $(wildcard include/config/x86/vsmp.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/paravirt.h) \
    $(wildcard include/config/m386.h) \
    $(wildcard include/config/m486.h) \
    $(wildcard include/config/x86/debugctlmsr.h) \
    $(wildcard include/config/cpu/sup/amd.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/processor-flags.h \
    $(wildcard include/config/vm86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vm86.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ptrace-abi.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/segment.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cache.h \
    $(wildcard include/config/x86/l1/cache/shift.h) \
    $(wildcard include/config/x86/internode/cache/shift.h) \
  include/linux/linkage.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/linkage.h \
    $(wildcard include/config/x86/alignment/16.h) \
  include/linux/stringify.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_types.h \
  include/linux/const.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64_types.h \
    $(wildcard include/config/physical/start.h) \
    $(wildcard include/config/physical/align.h) \
    $(wildcard include/config/flatmem.h) \
  include/linux/init.h \
    $(wildcard include/config/hotplug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/math_emu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sigcontext.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/current.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/percpu.h \
    $(wildcard include/config/x86/64/smp.h) \
  include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/spinlock/sleep.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/numa.h) \
  /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.4/include/stdarg.h \
  include/linux/bitops.h \
    $(wildcard include/config/generic/find/first/bit.h) \
    $(wildcard include/config/generic/find/last/bit.h) \
    $(wildcard include/config/generic/find/next/bit.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bitops.h \
    $(wildcard include/config/x86/cmov.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/alternative.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/x86/invlpg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/required-features.h \
    $(wildcard include/config/x86/minimum/cpu/family.h) \
    $(wildcard include/config/math/emulation.h) \
    $(wildcard include/config/x86/pae.h) \
    $(wildcard include/config/x86/cmpxchg64.h) \
    $(wildcard include/config/x86/use/3dnow.h) \
    $(wildcard include/config/x86/p6/nop.h) \
  include/asm-generic/bitops/sched.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/arch_hweight.h \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/ext2-non-atomic.h \
  include/asm-generic/bitops/le.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swab.h \
    $(wildcard include/config/x86/bswap.h) \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/minix.h \
  include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  include/linux/typecheck.h \
  include/linux/dynamic_debug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  include/asm-generic/bug.h \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
  include/asm-generic/percpu.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/system.h \
    $(wildcard include/config/ia32/emulation.h) \
    $(wildcard include/config/x86/32/lazy/gs.h) \
    $(wildcard include/config/x86/ppro/fence.h) \
    $(wildcard include/config/x86/oostore.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cmpxchg_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/nops.h \
    $(wildcard include/config/mk7.h) \
  include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irqflags.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/page_64.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  include/asm-generic/getorder.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/compat/vdso.h) \
    $(wildcard include/config/proc/fs.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msr-index.h \
  include/linux/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/errno.h \
  include/asm-generic/errno.h \
  include/asm-generic/errno-base.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  include/linux/bitmap.h \
  include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/string_64.h \
  include/linux/errno.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/desc_defs.h \
  include/linux/personality.h \
  include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  include/linux/math64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/div64.h \
  include/asm-generic/div64.h \
  include/linux/err.h \
  include/linux/stat.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/stat.h \
  include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  include/linux/seqlock.h \
  include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
  include/linux/preempt.h \
    $(wildcard include/config/preempt/notifiers.h) \
  include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/debug/stack/usage.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ftrace.h \
    $(wildcard include/config/function/tracer.h) \
    $(wildcard include/config/dynamic/ftrace.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/atomic64_64.h \
  include/asm-generic/atomic-long.h \
  include/linux/bottom_half.h \
  include/linux/spinlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock_types.h \
  include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/generic/hardirqs.h) \
    $(wildcard include/config/prove/rcu.h) \
  include/linux/rwlock_types.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/spinlock.h \
    $(wildcard include/config/paravirt/spinlocks.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwlock.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/paravirt.h \
  include/linux/rwlock.h \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/inline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  include/linux/kmod.h \
  include/linux/gfp.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/debug/vm.h) \
  include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/compaction.h) \
    $(wildcard include/config/arch/populates/node/map.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  include/linux/wait.h \
  include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  include/generated/bounds.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/memory/hotremove.h) \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/debug/mutexes.h) \
  include/linux/mutex-debug.h \
  include/linux/rwsem.h \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/rwsem.h \
  include/linux/srcu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sparsemem.h \
  include/linux/topology.h \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
  include/linux/smp.h \
    $(wildcard include/config/use/generic/smp/helpers.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/smp.h \
    $(wildcard include/config/x86/local/apic.h) \
    $(wildcard include/config/x86/io/apic.h) \
    $(wildcard include/config/x86/32/smp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/x86/numaq.h) \
    $(wildcard include/config/mca.h) \
    $(wildcard include/config/eisa.h) \
    $(wildcard include/config/x86/mpparse.h) \
    $(wildcard include/config/acpi.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mpspec_def.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/x86_init.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/bootparam.h \
  include/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/linux/edd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/e820.h \
    $(wildcard include/config/efi.h) \
    $(wildcard include/config/intel/txt.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/memtest.h) \
  include/linux/early_res.h \
  include/linux/range.h \
  include/linux/ioport.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/x86.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apic.h \
    $(wildcard include/config/x86/x2apic.h) \
  include/linux/delay.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/delay.h \
  include/linux/pm.h \
    $(wildcard include/config/pm/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/ops.h) \
  include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  include/linux/ktime.h \
    $(wildcard include/config/ktime/scalar.h) \
  include/linux/jiffies.h \
  include/linux/timex.h \
  include/linux/param.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/timex.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/tsc.h \
    $(wildcard include/config/x86/tsc.h) \
  include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  include/linux/completion.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/apicdef.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/provide/ohci1394/dma/init.h) \
    $(wildcard include/config/x86/visws/apic.h) \
    $(wildcard include/config/x86/f00f/bug.h) \
    $(wildcard include/config/x86/cyclone/timer.h) \
    $(wildcard include/config/pci/mmconfig.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/acpi.h \
    $(wildcard include/config/acpi/numa.h) \
  include/acpi/pdc_intel.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/numa_64.h \
    $(wildcard include/config/numa/emu.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/mmu.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vsyscall.h \
    $(wildcard include/config/generic/time.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io_apic.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/sparse/irq.h) \
  include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
  include/linux/pfn.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/topology.h \
    $(wildcard include/config/x86/ht.h) \
    $(wildcard include/config/x86/64/acpi/numa.h) \
  include/asm-generic/topology.h \
  include/linux/mmdebug.h \
    $(wildcard include/config/debug/virtual.h) \
  include/linux/elf.h \
  include/linux/elf-em.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/elf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/user_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/auxvec.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/vdso.h \
  include/linux/kobject.h \
  include/linux/sysfs.h \
  include/linux/kobject_ns.h \
  include/linux/kref.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ppc64.h) \
  include/linux/tracepoint.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/rcu/torture/test.h) \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
  include/linux/rcutree.h \
    $(wildcard include/config/no/hz.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/module.h \
    $(wildcard include/config/m586.h) \
    $(wildcard include/config/m586tsc.h) \
    $(wildcard include/config/m586mmx.h) \
    $(wildcard include/config/mcore2.h) \
    $(wildcard include/config/matom.h) \
    $(wildcard include/config/m686.h) \
    $(wildcard include/config/mpentiumii.h) \
    $(wildcard include/config/mpentiumiii.h) \
    $(wildcard include/config/mpentiumm.h) \
    $(wildcard include/config/mpentium4.h) \
    $(wildcard include/config/mk6.h) \
    $(wildcard include/config/mk8.h) \
    $(wildcard include/config/x86/elan.h) \
    $(wildcard include/config/mcrusoe.h) \
    $(wildcard include/config/mefficeon.h) \
    $(wildcard include/config/mwinchipc6.h) \
    $(wildcard include/config/mwinchip3d.h) \
    $(wildcard include/config/mcyrixiii.h) \
    $(wildcard include/config/mviac3/2.h) \
    $(wildcard include/config/mviac7.h) \
    $(wildcard include/config/mgeodegx1.h) \
    $(wildcard include/config/mgeode/lx.h) \
    $(wildcard include/config/4kstacks.h) \
  include/asm-generic/module.h \
  include/trace/events/module.h \
  include/trace/define_trace.h \
  include/linux/mm.h \
    $(wildcard include/config/sysctl.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/memory/failure.h) \
  include/linux/rbtree.h \
  include/linux/prio_tree.h \
  include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mm/owner.h) \
    $(wildcard include/config/mmu/notifier.h) \
  include/linux/auxvec.h \
  include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/pgtable_64_types.h \
  include/asm-generic/pgtable.h \
  include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/s390.h) \
  include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
  include/linux/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unistd_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/asm-offsets.h \
  include/generated/asm-offsets.h \
  include/linux/sunrpc/clnt.h \
    $(wildcard include/config/ipv6.h) \
  include/linux/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/socket.h \
  include/asm-generic/socket.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sockios.h \
  include/asm-generic/sockios.h \
  include/linux/sockios.h \
  include/linux/uio.h \
  include/linux/in.h \
  include/linux/in6.h \
  include/linux/sunrpc/msg_prot.h \
  include/linux/inet.h \
  include/linux/sunrpc/sched.h \
  include/linux/sunrpc/types.h \
  include/linux/sunrpc/debug.h \
  include/linux/sunrpc/xdr.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/unaligned.h \
  include/linux/unaligned/access_ok.h \
  include/linux/unaligned/generic.h \
  include/linux/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/scatterlist.h \
  include/asm-generic/scatterlist.h \
    $(wildcard include/config/need/sg/dma/length.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/io.h \
  include/asm-generic/iomap.h \
  include/linux/vmalloc.h \
  include/linux/sunrpc/xprt.h \
    $(wildcard include/config/nfs/v4/1.h) \
  include/linux/sunrpc/auth.h \
  include/linux/sunrpc/stats.h \
  include/linux/proc_fs.h \
    $(wildcard include/config/proc/devicetree.h) \
    $(wildcard include/config/proc/kcore.h) \
  include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
    $(wildcard include/config/debug/slab.h) \
    $(wildcard include/config/slab.h) \
  include/linux/slab_def.h \
  include/trace/events/kmem.h \
  include/trace/events/gfpflags.h \
  include/linux/kmalloc_sizes.h \
  include/linux/fs.h \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/security.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/debug/writecount.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  include/linux/limits.h \
  include/linux/blk_types.h \
    $(wildcard include/config/blk/dev/integrity.h) \
  include/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/rculist.h \
  include/linux/path.h \
  include/linux/radix-tree.h \
  include/linux/pid.h \
  include/linux/capability.h \
  include/linux/semaphore.h \
  include/linux/fiemap.h \
  include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  include/linux/percpu_counter.h \
  include/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/nfs_fs_i.h \
  include/linux/nfs.h \
  include/linux/fcntl.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/fcntl.h \
  include/asm-generic/fcntl.h \
  include/linux/magic.h \
  include/linux/sunrpc/timer.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/signal.h \
  include/asm-generic/signal-defs.h \
  include/net/ipv6.h \
  include/linux/ipv6.h \
    $(wildcard include/config/ipv6/privacy.h) \
    $(wildcard include/config/ipv6/router/pref.h) \
    $(wildcard include/config/ipv6/route/info.h) \
    $(wildcard include/config/ipv6/optimistic/dad.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mip6.h) \
    $(wildcard include/config/ipv6/subtrees.h) \
  include/linux/icmpv6.h \
  include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/dma.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
  include/linux/kmemcheck.h \
  include/linux/net.h \
  include/linux/random.h \
  include/linux/irqnr.h \
  include/linux/sysctl.h \
  include/linux/ratelimit.h \
  include/linux/textsearch.h \
  include/net/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/x86/wp/works/ok.h) \
    $(wildcard include/config/x86/intel/usercopy.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/uaccess_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/checksum_64.h \
  include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/disable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  include/linux/device.h \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/devtmpfs.h) \
  include/linux/klist.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/device.h \
    $(wildcard include/config/dmar.h) \
    $(wildcard include/config/amd/iommu.h) \
  include/linux/pm_wakeup.h \
    $(wildcard include/config/pm.h) \
  include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  include/linux/dma-attrs.h \
  include/linux/bug.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/dma-mapping.h \
    $(wildcard include/config/isa.h) \
  include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/swiotlb.h \
    $(wildcard include/config/swiotlb.h) \
  include/linux/swiotlb.h \
  include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  include/asm-generic/dma-mapping-common.h \
  include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
  include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/tr.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/net/dsa/tag/dsa.h) \
    $(wildcard include/config/net/dsa/tag/trailer.h) \
    $(wildcard include/config/netpoll/trap.h) \
  include/linux/if.h \
  include/linux/hdlc/ioctl.h \
  include/linux/if_ether.h \
  include/linux/if_packet.h \
  include/linux/if_link.h \
  include/linux/netlink.h \
  include/linux/pm_qos_params.h \
  include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  include/linux/miscdevice.h \
  include/linux/major.h \
  include/linux/ethtool.h \
  include/net/net_namespace.h \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/wext/core.h) \
    $(wildcard include/config/net.h) \
  include/net/netns/core.h \
  include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  include/net/snmp.h \
  include/linux/snmp.h \
  include/linux/u64_stats_sync.h \
  include/net/netns/unix.h \
  include/net/netns/packet.h \
  include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  include/net/inet_frag.h \
  include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  include/net/dst_ops.h \
  include/net/netns/dccp.h \
  include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  include/linux/netfilter.h \
    $(wildcard include/config/netfilter/debug.h) \
    $(wildcard include/config/nf/nat/needed.h) \
  include/net/flow.h \
  include/net/netns/conntrack.h \
  include/linux/list_nulls.h \
  include/net/netns/xfrm.h \
  include/linux/xfrm.h \
  include/linux/seq_file_net.h \
  include/linux/seq_file.h \
  include/net/dsa.h \
  include/linux/interrupt.h \
    $(wildcard include/config/generic/irq/probe.h) \
  include/linux/irqreturn.h \
  include/linux/hardirq.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  include/linux/smp_lock.h \
    $(wildcard include/config/lock/kernel.h) \
  include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/cgroup/sched.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cputime.h \
  include/asm-generic/cputime.h \
  include/linux/sem.h \
  include/linux/ipc.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ipcbuf.h \
  include/asm-generic/ipcbuf.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sembuf.h \
  include/linux/signal.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/siginfo.h \
  include/asm-generic/siginfo.h \
  include/linux/proportions.h \
  include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/seccomp_64.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/ia32_unistd.h \
  include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  include/linux/resource.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/resource.h \
  include/asm-generic/resource.h \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  include/linux/latencytop.h \
  include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
  include/linux/key.h \
  include/linux/selinux.h \
  include/linux/aio.h \
  include/linux/aio_abi.h \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/x86/thermal/vector.h) \
    $(wildcard include/config/x86/mce/threshold.h) \
  include/linux/irq.h \
    $(wildcard include/config/irq/per/cpu.h) \
    $(wildcard include/config/irq/release/method.h) \
    $(wildcard include/config/intr/remap.h) \
    $(wildcard include/config/generic/pending/irq.h) \
    $(wildcard include/config/numa/irq/desc.h) \
    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
    $(wildcard include/config/cpumasks/offstack.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/irq_regs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/hw_irq.h \
  include/linux/profile.h \
    $(wildcard include/config/profiling.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/sections.h \
    $(wildcard include/config/debug/rodata.h) \
  include/asm-generic/sections.h \
  include/linux/tcp.h \
    $(wildcard include/config/tcp/md5sig.h) \
  include/net/sock.h \
  include/linux/security.h \
    $(wildcard include/config/security/path.h) \
    $(wildcard include/config/security/network.h) \
    $(wildcard include/config/security/network/xfrm.h) \
    $(wildcard include/config/securityfs.h) \
  include/linux/fsnotify.h \
  include/linux/fsnotify_backend.h \
    $(wildcard include/config/fanotify.h) \
    $(wildcard include/config/fanotify/access/permissions.h) \
  include/linux/idr.h \
  include/linux/audit.h \
    $(wildcard include/config/change.h) \
  include/linux/binfmts.h \
  include/linux/shm.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/shmparam.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/shmbuf.h \
  include/asm-generic/shmbuf.h \
  include/linux/msg.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/msgbuf.h \
  include/asm-generic/msgbuf.h \
  include/linux/filter.h \
  include/linux/rculist_nulls.h \
  include/linux/poll.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/poll.h \
  include/asm-generic/poll.h \
  include/net/dst.h \
    $(wildcard include/config/net/cls/route.h) \
  include/linux/rtnetlink.h \
  include/linux/if_addr.h \
  include/linux/neighbour.h \
  include/net/neighbour.h \
  include/net/rtnetlink.h \
  include/net/netlink.h \
  include/net/inet_connection_sock.h \
  include/net/inet_sock.h \
  include/linux/jhash.h \
  include/net/request_sock.h \
  include/net/netns/hash.h \
  include/net/inet_timewait_sock.h \
  include/net/tcp_states.h \
  include/net/timewait_sock.h \
  include/linux/udp.h \
  include/net/if_inet6.h \
  include/net/ndisc.h \
  include/linux/sunrpc/metrics.h \
  include/linux/sunrpc/xprtsock.h \
  include/linux/sunrpc/xprtrdma.h \
  include/linux/nfs_fs.h \
    $(wildcard include/config/nfs/v3/acl.h) \
  include/linux/pagemap.h \
  include/linux/highmem.h \
    $(wildcard include/config/debug/highmem.h) \
  include/linux/uaccess.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/cacheflush.h \
    $(wildcard include/config/x86/pat.h) \
    $(wildcard include/config/debug/rodata/test.h) \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/kmap_types.h \
  include/asm-generic/kmap_types.h \
  include/linux/hugetlb_inline.h \
  include/linux/nfs2.h \
  include/linux/nfs3.h \
  include/linux/nfs4.h \
  include/linux/nfs_xdr.h \
  include/linux/nfsacl.h \
  include/linux/posix_acl.h \
  include/linux/nfs_fs_sb.h \
  include/linux/backing-dev.h \
    $(wildcard include/config/debug/fs.h) \
  include/linux/writeback.h \
  include/linux/mempool.h \
  include/linux/nfs_mount.h \
  include/linux/nfs4_mount.h \
  include/linux/lockd/bind.h \
    $(wildcard include/config/lockd/v4.h) \
  include/linux/lockd/nlm.h \
  include/linux/lockd/xdr.h \
  include/linux/lockd/xdr4.h \
  include/linux/mount.h \
  include/linux/mnt_namespace.h \
  include/linux/namei.h \
  include/linux/nfs_idmap.h \
  include/linux/vfs.h \
  include/linux/statfs.h \
  /usr/src/linux-2.6.36-gentoo-r5/arch/x86/include/asm/statfs.h \
  include/asm-generic/statfs.h \
  include/linux/parser.h \
  fs/nfs/nfs4_fs.h \
    $(wildcard include/config/nfs/v4/1.h) \
  fs/nfs/callback.h \
  fs/nfs/delegation.h \
  fs/nfs/iostat.h \
  include/linux/nfs_iostat.h \
  fs/nfs/internal.h \
  fs/nfs/fscache.h \
  include/linux/fscache.h \
    $(wildcard include/config/fscache.h) \
  include/linux/pagevec.h \

fs/nfs/super.o: $(deps_fs/nfs/super.o)

$(deps_fs/nfs/super.o):
/*
 * mgr.c
 *
 * DSP-BIOS Bridge driver support functions for TI OMAP processors.
 *
 * Implementation of Manager interface to the device object at the
 * driver level. This queries the NDB data base and retrieves the
 * data about Node and Processor.
 *
 * Copyright (C) 2005-2006 Texas Instruments, Inc.
 *
 * This package is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <linux/types.h>

/*  ----------------------------------- DSP/BIOS Bridge */
#include <dspbridge/dbdefs.h>

/*  ----------------------------------- Trace & Debug */
#include <dspbridge/dbc.h>

/*  ----------------------------------- OS Adaptation Layer */
#include <dspbridge/cfg.h>
#include <dspbridge/sync.h>

/*  ----------------------------------- Others */
#include <dspbridge/dbdcd.h>
#include <dspbridge/drv.h>
#include <dspbridge/dev.h>

/*  ----------------------------------- This */
#include <dspbridge/mgr.h>

/*  ----------------------------------- Defines, Data Structures, Typedefs */
#define ZLDLLNAME               ""

struct mgr_object {
	struct dcd_manager *hdcd_mgr;	/* Proc/Node data manager */
};

/*  ----------------------------------- Globals */
static u32 refs;

/*
 *  ========= mgr_create =========
 *  Purpose:
 *      MGR Object gets created only once during driver Loading.
 */
int mgr_create(struct mgr_object **mgr_obj,
		      struct cfg_devnode *dev_node_obj)
{
	int status = 0;
	struct mgr_object *pmgr_obj = NULL;

	DBC_REQUIRE(mgr_obj != NULL);
	DBC_REQUIRE(refs > 0);

	pmgr_obj = kzalloc(sizeof(struct mgr_object), GFP_KERNEL);
	if (pmgr_obj) {
		status = dcd_create_manager(ZLDLLNAME, &pmgr_obj->hdcd_mgr);
		if (!status) {
			/* If succeeded store the handle in the MGR Object */
			status = cfg_set_object((u32) pmgr_obj, REG_MGR_OBJECT);
			if (!status) {
				*mgr_obj = pmgr_obj;
			} else {
				dcd_destroy_manager(pmgr_obj->hdcd_mgr);
				kfree(pmgr_obj);
			}
		} else {
			/* failed to Create DCD Manager */
			kfree(pmgr_obj);
		}
	} else {
		status = -ENOMEM;
	}

	DBC_ENSURE(status || pmgr_obj);
	return status;
}

/*
 *  ========= mgr_destroy =========
 *     This function is invoked during bridge driver unloading.Frees MGR object.
 */
int mgr_destroy(struct mgr_object *hmgr_obj)
{
	int status = 0;
	struct mgr_object *pmgr_obj = (struct mgr_object *)hmgr_obj;

	DBC_REQUIRE(refs > 0);
	DBC_REQUIRE(hmgr_obj);

	/* Free resources */
	if (hmgr_obj->hdcd_mgr)
		dcd_destroy_manager(hmgr_obj->hdcd_mgr);

	kfree(pmgr_obj);
	/* Update the Registry with NULL for MGR Object */
	(void)cfg_set_object(0, REG_MGR_OBJECT);

	return status;
}

/*
 *  ======== mgr_enum_node_info ========
 *      Enumerate and get configuration information about nodes configured
 *      in the node database.
 */
int mgr_enum_node_info(u32 node_id, struct dsp_ndbprops *pndb_props,
			      u32 undb_props_size, u32 *pu_num_nodes)
{
	int status = 0;
	struct dsp_uuid node_uuid, temp_uuid;
	u32 temp_index = 0;
	u32 node_index = 0;
	struct dcd_genericobj gen_obj;
	struct mgr_object *pmgr_obj = NULL;

	DBC_REQUIRE(pndb_props != NULL);
	DBC_REQUIRE(pu_num_nodes != NULL);
	DBC_REQUIRE(undb_props_size >= sizeof(struct dsp_ndbprops));
	DBC_REQUIRE(refs > 0);

	*pu_num_nodes = 0;
	/* Get The Manager Object from the Registry */
	status = cfg_get_object((u32 *) &pmgr_obj, REG_MGR_OBJECT);
	if (status)
		goto func_cont;

	DBC_ASSERT(pmgr_obj);
	/* Forever loop till we hit failed or no more items in the
	 * Enumeration. We will exit the loop other than 0; */
	while (status == 0) {
		status = dcd_enumerate_object(temp_index++, DSP_DCDNODETYPE,
					      &temp_uuid);
		if (status == 0) {
			node_index++;
			if (node_id == (node_index - 1))
				node_uuid = temp_uuid;

		}
	}
	if (!status) {
		if (node_id > (node_index - 1)) {
			status = -EINVAL;
		} else {
			status = dcd_get_object_def(pmgr_obj->hdcd_mgr,
						    (struct dsp_uuid *)
						    &node_uuid, DSP_DCDNODETYPE,
						    &gen_obj);
			if (!status) {
				/* Get the Obj def */
				*pndb_props =
				    gen_obj.obj_data.node_obj.ndb_props;
				*pu_num_nodes = node_index;
			}
		}
	}

func_cont:
	DBC_ENSURE((!status && *pu_num_nodes > 0) ||
		   (status && *pu_num_nodes == 0));

	return status;
}

/*
 *  ======== mgr_enum_processor_info ========
 *      Enumerate and get configuration information about available
 *      DSP processors.
 */
int mgr_enum_processor_info(u32 processor_id,
				   struct dsp_processorinfo *
				   processor_info, u32 processor_info_size,
				   u8 *pu_num_procs)
{
	int status = 0;
	int status1 = 0;
	int status2 = 0;
	struct dsp_uuid temp_uuid;
	u32 temp_index = 0;
	u32 proc_index = 0;
	struct dcd_genericobj gen_obj;
	struct mgr_object *pmgr_obj = NULL;
	struct mgr_processorextinfo *ext_info;
	struct dev_object *hdev_obj;
	struct drv_object *hdrv_obj;
	u8 dev_type;
	struct cfg_devnode *dev_node;
	bool proc_detect = false;

	DBC_REQUIRE(processor_info != NULL);
	DBC_REQUIRE(pu_num_procs != NULL);
	DBC_REQUIRE(processor_info_size >= sizeof(struct dsp_processorinfo));
	DBC_REQUIRE(refs > 0);

	*pu_num_procs = 0;
	status = cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT);
	if (!status) {
		status = drv_get_dev_object(processor_id, hdrv_obj, &hdev_obj);
		if (!status) {
			status = dev_get_dev_type(hdev_obj, (u8 *) &dev_type);
			status = dev_get_dev_node(hdev_obj, &dev_node);
			if (dev_type != DSP_UNIT)
				status = -EPERM;

			if (!status)
				processor_info->processor_type = DSPTYPE64;
		}
	}
	if (status)
		goto func_end;

	/* Get The Manager Object from the Registry */
	if (cfg_get_object((u32 *) &pmgr_obj, REG_MGR_OBJECT)) {
		dev_dbg(bridge, "%s: Failed to get MGR Object\n", __func__);
		goto func_end;
	}
	DBC_ASSERT(pmgr_obj);
	/* Forever loop till we hit no more items in the
	 * Enumeration. We will exit the loop other than 0; */
	while (status1 == 0) {
		status1 = dcd_enumerate_object(temp_index++,
					       DSP_DCDPROCESSORTYPE,
					       &temp_uuid);
		if (status1 != 0)
			break;

		proc_index++;
		/* Get the Object properties to find the Device/Processor
		 * Type */
		if (proc_detect != false)
			continue;

		status2 = dcd_get_object_def(pmgr_obj->hdcd_mgr,
					     (struct dsp_uuid *)&temp_uuid,
					     DSP_DCDPROCESSORTYPE, &gen_obj);
		if (!status2) {
			/* Get the Obj def */
			if (processor_info_size <
			    sizeof(struct mgr_processorextinfo)) {
				*processor_info = gen_obj.obj_data.proc_info;
			} else {
				/* extended info */
				ext_info = (struct mgr_processorextinfo *)
				    processor_info;
				*ext_info = gen_obj.obj_data.ext_proc_obj;
			}
			dev_dbg(bridge, "%s: Got proctype  from DCD %x\n",
				__func__, processor_info->processor_type);
			/* See if we got the needed processor */
			if (dev_type == DSP_UNIT) {
				if (processor_info->processor_type ==
				    DSPPROCTYPE_C64)
					proc_detect = true;
			} else if (dev_type == IVA_UNIT) {
				if (processor_info->processor_type ==
				    IVAPROCTYPE_ARM7)
					proc_detect = true;
			}
			/* User applciatiuons aonly check for chip type, so
			 * this clumsy overwrite */
			processor_info->processor_type = DSPTYPE64;
		} else {
			dev_dbg(bridge, "%s: Failed to get DCD processor info "
				"%x\n", __func__, status2);
			status = -EPERM;
		}
	}
	*pu_num_procs = proc_index;
	if (proc_detect == false) {
		dev_dbg(bridge, "%s: Failed to get proc info from DCD, so use "
			"CFG registry\n", __func__);
		processor_info->processor_type = DSPTYPE64;
	}
func_end:
	return status;
}

/*
 *  ======== mgr_exit ========
 *      Decrement reference count, and free resources when reference count is
 *      0.
 */
void mgr_exit(void)
{
	DBC_REQUIRE(refs > 0);
	refs--;
	if (refs == 0)
		dcd_exit();

	DBC_ENSURE(refs >= 0);
}

/*
 *  ======== mgr_get_dcd_handle ========
 *      Retrieves the MGR handle. Accessor Function.
 */
int mgr_get_dcd_handle(struct mgr_object *mgr_handle,
			      u32 *dcd_handle)
{
	int status = -EPERM;
	struct mgr_object *pmgr_obj = (struct mgr_object *)mgr_handle;

	DBC_REQUIRE(refs > 0);
	DBC_REQUIRE(dcd_handle != NULL);

	*dcd_handle = (u32) NULL;
	if (pmgr_obj) {
		*dcd_handle = (u32) pmgr_obj->hdcd_mgr;
		status = 0;
	}
	DBC_ENSURE((!status && *dcd_handle != (u32) NULL) ||
		   (status && *dcd_handle == (u32) NULL));

	return status;
}

/*
 *  ======== mgr_init ========
 *      Initialize MGR's private state, keeping a reference count on each call.
 */
bool mgr_init(void)
{
	bool ret = true;
	bool init_dcd = false;

	DBC_REQUIRE(refs >= 0);

	if (refs == 0) {
		init_dcd = dcd_init();	/*  DCD Module */

		if (!init_dcd)
			ret = false;
	}

	if (ret)
		refs++;

	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));

	return ret;
}

/*
 *  ======== mgr_wait_for_bridge_events ========
 *      Block on any Bridge event(s)
 */
int mgr_wait_for_bridge_events(struct dsp_notification **anotifications,
				      u32 count, u32 *pu_index,
				      u32 utimeout)
{
	int status;
	struct sync_object *sync_events[MAX_EVENTS];
	u32 i;

	DBC_REQUIRE(count < MAX_EVENTS);

	for (i = 0; i < count; i++)
		sync_events[i] = anotifications[i]->handle;

	status = sync_wait_on_multiple_events(sync_events, count, utimeout,
					      pu_index);

	return status;

}
/*
 *  Silicon Labs C2 port Linux support
 *
 *  Copyright (c) 2007 Rodolfo Giometti <giometti@linux.it>
 *  Copyright (c) 2007 Eurotech S.p.A. <info@eurotech.it>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation
 */

#include <linux/device.h>
#include <linux/kmemcheck.h>

#define C2PORT_NAME_LEN			32

/*
 * C2 port basic structs
 */

/* Main struct */
struct c2port_ops;
struct c2port_device {
	kmemcheck_bitfield_begin(flags);
	unsigned int access:1;
	unsigned int flash_access:1;
	kmemcheck_bitfield_end(flags);

	int id;
	char name[C2PORT_NAME_LEN];
	struct c2port_ops *ops;
	struct mutex mutex;		/* prevent races during read/write */

	struct device *dev;

	void *private_data;
};

/* Basic operations */
struct c2port_ops {
	/* Flash layout */
	unsigned short block_size;	/* flash block size in bytes */
	unsigned short blocks_num;	/* flash blocks number */

	/* Enable or disable the access to C2 port */
	void (*access)(struct c2port_device *dev, int status);

	/* Set C2D data line as input/output */
	void (*c2d_dir)(struct c2port_device *dev, int dir);

	/* Read/write C2D data line */
	int (*c2d_get)(struct c2port_device *dev);
	void (*c2d_set)(struct c2port_device *dev, int status);

	/* Write C2CK clock line */
	void (*c2ck_set)(struct c2port_device *dev, int status);
};

/*
 * Exported functions
 */

#define to_class_dev(obj) container_of((obj), struct class_device, kobj)
#define to_c2port_device(obj) container_of((obj), struct c2port_device, class)

extern struct c2port_device *c2port_device_register(char *name,
					struct c2port_ops *ops, void *devdata);
extern void c2port_device_unregister(struct c2port_device *dev);
/*
 * linux/include/linux/netfilter/xt_IDLETIMER.h
 *
 * Header file for Xtables timer target module.
 *
 * Copyright (C) 2004, 2010 Nokia Corporation
 * Written by Timo Teras <ext-timo.teras@nokia.com>
 *
 * Converted to x_tables and forward-ported to 2.6.34
 * by Luciano Coelho <luciano.coelho@nokia.com>
 *
 * Contact: Luciano Coelho <luciano.coelho@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#ifndef _XT_IDLETIMER_H
#define _XT_IDLETIMER_H

#include <linux/types.h>

#define MAX_IDLETIMER_LABEL_SIZE 28

struct idletimer_tg_info {
	__u32 timeout;

	char label[MAX_IDLETIMER_LABEL_SIZE];

	/* for kernel module internal use only */
	struct idletimer_tg *timer __attribute__((aligned(8)));
};

#endif
